<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"destiny0118.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="SQL语句执行流程、索引(覆盖索引、联合索引、索引下推)、索引优化、索引失效">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL(1)：存储引擎、索引">
<meta property="og:url" content="https://destiny0118.github.io/2024/03/07/%E6%A1%86%E6%9E%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL(1)%EF%BC%9A%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%81%E7%B4%A2%E5%BC%95/index.html">
<meta property="og:site_name" content="我的个人博客">
<meta property="og:description" content="SQL语句执行流程、索引(覆盖索引、联合索引、索引下推)、索引优化、索引失效">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252156220.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252206970.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405132123653.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252225650.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404182021221.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403241636295.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405141106447.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252328222.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252334238.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404182127269.png">
<meta property="article:published_time" content="2024-03-06T16:00:00.000Z">
<meta property="article:modified_time" content="2024-05-29T13:33:55.383Z">
<meta property="article:author" content="Destiny">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252156220.png">


<link rel="canonical" href="https://destiny0118.github.io/2024/03/07/%E6%A1%86%E6%9E%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL(1)%EF%BC%9A%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%81%E7%B4%A2%E5%BC%95/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://destiny0118.github.io/2024/03/07/%E6%A1%86%E6%9E%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL(1)%EF%BC%9A%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%81%E7%B4%A2%E5%BC%95/","path":"2024/03/07/框架/数据库/MySQL(1)：存储引擎、索引/","title":"MySQL(1)：存储引擎、索引"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MySQL(1)：存储引擎、索引 | 我的个人博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">我的个人博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">What past is prolgue.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-项目"><a href="/categories/project/" rel="section"><i class="fa fa-tasks fa-fw"></i>项目</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="nav-text">1 字段类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="nav-text">2 MySQL基础架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">2.1 SQL语句执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-%E8%BF%9E%E6%8E%A5%E5%99%A8%EF%BC%88%E9%95%BF%E8%BF%9E%E6%8E%A5%E3%80%81%E7%9F%AD%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="nav-text">2.1.1 连接器（长连接、短连接）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="nav-text">2.1.2 查询缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-%E8%A7%A3%E6%9E%90SQL%E8%AF%AD%E5%8F%A5%EF%BC%88%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%89"><span class="nav-text">2.1.3 解析SQL语句（解析器）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4-%E6%89%A7%E8%A1%8CSQL"><span class="nav-text">2.1.4 执行SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-1-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%9A"><span class="nav-text">2.1.4.1 预处理器：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-2-%E4%BC%98%E5%8C%96%E5%99%A8%EF%BC%9A"><span class="nav-text">2.1.4.2 优化器：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-3-%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%9A%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BA%A4%E4%BA%92"><span class="nav-text">2.1.4.3 执行器：与存储引擎交互</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-MySQL%E4%B8%80%E8%A1%8C%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8"><span class="nav-text">2.2 MySQL一行记录存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-NULL%E5%80%BC%E5%88%97%E8%A1%A8%EF%BC%9A"><span class="nav-text">2.2.1 NULL值列表：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="nav-text">2.2.2 记录头信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE"><span class="nav-text">2.2.3 记录的真实数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-text">3 MySQL存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-MyISAM%E5%92%8CInnoDB"><span class="nav-text">3.1 MyISAM和InnoDB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-MyISAM-InnoDB"><span class="nav-text">3.2 存储引擎(MyISAM, InnoDB)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-MVCC%EF%BC%88%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="nav-text">4 MVCC（多版本并发控制）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E7%B4%A2%E5%BC%95"><span class="nav-text">5 索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">5.1 底层数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-AVL%E6%A0%91"><span class="nav-text">5.1.1 AVL树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-text">5.1.2 红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-B%E6%A0%91%E5%92%8CB-%E6%A0%91"><span class="nav-text">5.1.3 B树和B+树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B-%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95"><span class="nav-text">5.1.4 为什么选择B+树作为索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="nav-text">5.2 索引类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">5.2.1 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-1-B-Tree%E7%B4%A2%E5%BC%95"><span class="nav-text">5.2.1.1 B-Tree索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-2-%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="nav-text">5.2.1.2 哈希索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8"><span class="nav-text">5.2.2 物理存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-1-%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="nav-text">5.2.2.1 主键索引与二级索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-2-%E8%81%9A%E7%B0%87-%E9%9B%86-%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87-%E9%9B%86-%E7%B4%A2%E5%BC%95"><span class="nav-text">5.2.2.2 聚簇(集)索引与非聚簇(集)索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-text">5.2.3 覆盖索引与联合索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-4-%E5%86%97%E4%BD%99%E7%B4%A2%E5%BC%95%E5%92%8C%E9%87%8D%E5%A4%8D%E7%B4%A2%E5%BC%95"><span class="nav-text">5.2.4 冗余索引和重复索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-5-%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="nav-text">5.2.5 前缀索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-6-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%92%8C%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95"><span class="nav-text">5.2.6 联合索引和单列索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%88%E4%B8%89%E6%98%9F%E8%AF%84%E4%BB%B7%EF%BC%89"><span class="nav-text">5.3 索引的优点（三星评价）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D"><span class="nav-text">5.4 最左匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="nav-text">5.5 索引下推</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81-x2F-%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-text">5.6 什么时候需要 &#x2F; 不需要创建索引？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-1-1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%82%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-text">5.6.1.1 什么时候适用索引？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-1-2-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-text">5.6.1.2 什么时候不需要创建索引？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="nav-text">5.7 索引优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-1-NULL%E5%92%8C%E2%80%99%E2%80%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">5.7.1 NULL和’’的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-text">5.8 索引失效</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-8-1-%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%80%A0%E6%88%90%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-text">5.8.1 隐式类型转换造成索引失效</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-9-%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="nav-text">5.9 回表查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-10-Count"><span class="nav-text">5.10 Count</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="nav-text">6 执行计划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-type"><span class="nav-text">6.1 type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-extra"><span class="nav-text">6.2 extra</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96"><span class="nav-text">7 数据库优化</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Destiny</p>
  <div class="site-description" itemprop="description">凡是过去，皆为序章。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">124</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/destiny0118" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;destiny0118" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuyg163@163.com" title="E-Mail → mailto:yuyg163@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/19273732/destiny" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;19273732&#x2F;destiny" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/03/07/%E6%A1%86%E6%9E%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL(1)%EF%BC%9A%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%81%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="MySQL(1)：存储引擎、索引 | 我的个人博客">
      <meta itemprop="description" content="SQL语句执行流程、索引(覆盖索引、联合索引、索引下推)、索引优化、索引失效">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL(1)：存储引擎、索引<a href="https://github.com/destiny0118/Hexo/edit/master/Destiny/source/_posts/%E6%A1%86%E6%9E%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL(1)%EF%BC%9A%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%81%E7%B4%A2%E5%BC%95.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-07 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-07T00:00:00+08:00">2024-03-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-29 21:33:55" itemprop="dateModified" datetime="2024-05-29T21:33:55+08:00">2024-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">SQL语句执行流程、索引(覆盖索引、联合索引、索引下推)、索引优化、索引失效</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="1-字段类型"><a href="#1-字段类型" class="headerlink" title="1 字段类型"></a>1 字段类型</h1><p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252156220.png" alt="image.png|500"></p>
<h1 id="2-MySQL基础架构"><a href="#2-MySQL基础架构" class="headerlink" title="2 MySQL基础架构"></a>2 MySQL基础架构</h1><p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252206970.png" alt="image.png|500"><br>MySQL 可以简单分为 Server 层和存储引擎层这两层，MySQL 支持 InnoDB、MyISAM、Memory 等多种存储引擎。</p>
<ul>
<li>Server 层负责建立连接、分析和执行SQL。所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li>
<li>引擎层负责数据的存储和读取</li>
</ul>
<h2 id="2-1-SQL语句执行流程"><a href="#2-1-SQL语句执行流程" class="headerlink" title="2.1 SQL语句执行流程"></a>2.1 SQL语句执行流程</h2><h3 id="2-1-1-连接器（长连接、短连接）"><a href="#2-1-1-连接器（长连接、短连接）" class="headerlink" title="2.1.1 连接器（长连接、短连接）"></a>2.1.1 连接器（长连接、短连接）</h3><pre><code>- 与客户端进行 TCP 三次握手建立连接；
- 校验客户端的用户名和密码，如果用户名或密码不对，则会报错；
- 如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限
</code></pre>
<h3 id="2-1-2-查询缓存"><a href="#2-1-2-查询缓存" class="headerlink" title="2.1.2 查询缓存"></a>2.1.2 查询缓存</h3><h3 id="2-1-3-解析SQL语句（解析器）"><a href="#2-1-3-解析SQL语句（解析器）" class="headerlink" title="2.1.3 解析SQL语句（解析器）"></a>2.1.3 解析SQL语句（解析器）</h3><pre><code>- 词法分析
- 语法分析
</code></pre>
<h3 id="2-1-4-执行SQL"><a href="#2-1-4-执行SQL" class="headerlink" title="2.1.4 执行SQL"></a>2.1.4 执行SQL</h3><h4 id="2-1-4-1-预处理器："><a href="#2-1-4-1-预处理器：" class="headerlink" title="2.1.4.1 预处理器："></a>2.1.4.1 预处理器：</h4><ul>
<li>检查 SQL 查询语句中的表或者字段是否存在；</li>
<li>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</li>
</ul>
<h4 id="2-1-4-2-优化器："><a href="#2-1-4-2-优化器：" class="headerlink" title="2.1.4.2 优化器："></a>2.1.4.2 优化器：</h4><ul>
<li>优化器主要负责将 SQL 查询语句的执行方案确定下来，为SQL语句指定<strong>执行计划</strong>（选择某个索引，explain）</li>
</ul>
<h4 id="2-1-4-3-执行器：与存储引擎交互"><a href="#2-1-4-3-执行器：与存储引擎交互" class="headerlink" title="2.1.4.3 执行器：与存储引擎交互"></a>2.1.4.3 执行器：与存储引擎交互</h4><ul>
<li>主键索引查询</li>
<li>全表扫描</li>
<li>索引下推：索引下推能够减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</li>
</ul>
<p><a href="https://xiaolincoding.com/mysql/base/how_select.html#%E6%89%A7%E8%A1%8C%E5%99%A8">执行一条 select 语句，期间发生了什么？ | 小林coding (xiaolincoding.com)</a></p>
<h2 id="2-2-MySQL一行记录存储"><a href="#2-2-MySQL一行记录存储" class="headerlink" title="2.2 MySQL一行记录存储"></a>2.2 MySQL一行记录存储</h2><p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405132123653.png" alt="image.png"></p>
<h3 id="2-2-1-NULL值列表："><a href="#2-2-1-NULL值列表：" class="headerlink" title="2.2.1 NULL值列表："></a>2.2.1 NULL值列表：</h3><p>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。</p>
<h3 id="2-2-2-记录头信息"><a href="#2-2-2-记录头信息" class="headerlink" title="2.2.2 记录头信息"></a>2.2.2 记录头信息</h3><ul>
<li><code>delete_mask</code> ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li>
<li>next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li>
<li>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li>
</ul>
<h3 id="2-2-3-记录的真实数据"><a href="#2-2-3-记录的真实数据" class="headerlink" title="2.2.3 记录的真实数据"></a>2.2.3 记录的真实数据</h3><ul>
<li><p>row_id：如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。</p>
</li>
<li><p>trx_id：<code>事务id</code>，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</p>
</li>
<li><p>roll_pointer：这条记录<code>上一个版本的指针</code>。roll_pointer 是必需的，占用 7 个字节。</p>
</li>
</ul>
<blockquote>
<p>MySQL 的 NULL 值是怎么存放的？</p>
</blockquote>
<p>MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。</p>
<p>NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。</p>
<blockquote>
<p>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</p>
</blockquote>
<p>MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。</p>
<h1 id="3-MySQL存储引擎"><a href="#3-MySQL存储引擎" class="headerlink" title="3 MySQL存储引擎"></a>3 MySQL存储引擎</h1><h2 id="3-1-MyISAM和InnoDB"><a href="#3-1-MyISAM和InnoDB" class="headerlink" title="3.1 MyISAM和InnoDB"></a>3.1 MyISAM和InnoDB</h2><ul>
<li><strong>是否支持行级锁</strong>：MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li>
<li><strong>是否支持事务</strong>：MyISAM 不提供事务支持。</li>
<li>是否支持外键：MyISAM 不支持，而 InnoDB 支持。外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。</li>
<li><strong>是否支持数据库异常崩溃后的安全恢复</strong>：MyISAM 不支持，而 InnoDB 支持。使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</li>
<li><strong>是否支持 MVCC</strong>：MyISAM 不支持，而 InnoDB 支持。</li>
<li><strong>索引实现不一样</strong>：都使用B+Tree作为索引结构，InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</li>
<li>数据缓存策略和机制实现不同：InnoDB 使用缓冲池<code>（Buffer Pool）</code>缓存数据页和索引页，MyISAM 使用键缓存（Key Cache）仅缓存索引页而不缓存数据页。</li>
</ul>
<h2 id="3-2-存储引擎-MyISAM-InnoDB"><a href="#3-2-存储引擎-MyISAM-InnoDB" class="headerlink" title="3.2 存储引擎(MyISAM, InnoDB)"></a>3.2 存储引擎(MyISAM, InnoDB)</h2><ul>
<li>&#x3D;&#x3D;事务支持&#x3D;&#x3D;： InnoDB支持事务，具有提交、回滚和崩溃恢复能力，可以保护用户数据。它使用了一种称为“写前日志”（write-ahead logging，WAL）的技术，先写日志，再写数据，保证了事务的完整性。 MyISAM不支持事务，这意味着在MyISAM中进行的更改无法回滚，且如果发生崩溃，数据可能会损坏。</li>
<li>&#x3D;&#x3D;锁机制&#x3D;&#x3D;： InnoDB支持行级锁和表级锁，但默认使用行级锁。行级锁可以提高并发性能，因为它只锁定被访问的行，而不是整个表。 MyISAM只支持表级锁，这意味着当一个线程正在对一个表进行写操作时，其他线程无法对该表进行读或写操作。这可能会降低并发性能。</li>
<li>外键支持： InnoDB支持外键约束，这有助于维护数据的引用完整性和一致性。 MyISAM不支持外键约束。</li>
<li>&#x3D;&#x3D;数据存储和索引&#x3D;&#x3D;： InnoDB使用聚簇索引来组织数据，表数据和主键索引存储在一起。此外，InnoDB还支持全文索引和哈希索引。 MyISAM将数据和索引分开存储，数据文件（MYD）和索引文件（MYI）是分离的。MyISAM也支持全文索引，但不支持哈希索引。</li>
<li>数据恢复和备份： InnoDB提供了更好的数据恢复功能，如通过binlog进行点时间恢复（PITR）。此外，InnoDB还支持在线备份功能。 MyISAM的数据恢复相对较弱，通常依赖于物理备份和恢复。</li>
<li>&#x3D;&#x3D;性能&#x3D;&#x3D;： InnoDB在处理大量读写操作时通常表现更好，特别是在高并发环境下。这得益于其行级锁和事务支持。 MyISAM在处理只读查询时可能更快，特别是当数据量很大且内存充足时。然而，在写操作频繁的场景下，MyISAM的性能可能会下降。</li>
<li>存储空间： InnoDB的存储空间通常比MyISAM大，因为它需要额外的空间来存储事务日志、行级锁等信息。此外，InnoDB的数据文件大小是动态增长的。 MyISAM的存储空间相对较小，数据文件大小是固定的（可以通过配置修改）。但是，MyISAM不支持数据压缩功能。</li>
</ul>
<h1 id="4-MVCC（多版本并发控制）"><a href="#4-MVCC（多版本并发控制）" class="headerlink" title="4 MVCC（多版本并发控制）"></a>4 MVCC（多版本并发控制）</h1><p>多版本并发控制（MVCC，Multiversion Concurrency Control），是行级锁的变种，在很多情况下避免了加锁操作，因此开销更低。实现了非阻塞的读操作，写操作也只锁定必要的行。</p>
<p><strong>通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。</strong></p>
<p>MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，<br>每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据<br>可能是不一样的。</p>
<p>InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创<br>建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号<br>（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号<br>会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。<br><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252225650.png" alt="image.png"></p>
<p><strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p>
<p>MVCC 在 MySQL 中实现所依赖的手段主要是: &#x3D;&#x3D;隐藏字段、read view、undo log&#x3D;&#x3D;。</p>
<ul>
<li>undo log : undo log 用于记录某行数据的多个版本的数据。</li>
<li>read view 和 隐藏字段 : 用来判断当前版本数据的可见性。</li>
</ul>
<p><a href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html">InnoDB存储引擎对MVCC的实现 | JavaGuide</a></p>
<h1 id="5-索引"><a href="#5-索引" class="headerlink" title="5 索引"></a>5 索引</h1><blockquote>
<p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong><br>索引（MySQ中也叫做“键”）是存储引擎用于快速找到记录的一种数据结构</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404182021221.png" alt="image.png"></p>
<p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li>
<li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li>
</ul>
<h2 id="5-1-底层数据结构"><a href="#5-1-底层数据结构" class="headerlink" title="5.1 底层数据结构"></a>5.1 底层数据结构</h2><h3 id="5-1-1-AVL树"><a href="#5-1-1-AVL树" class="headerlink" title="5.1.1 AVL树"></a>5.1.1 AVL树</h3><blockquote>
<p>在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 <strong>磁盘 IO 是一项耗时的操作</strong></p>
</blockquote>
<h3 id="5-1-2-红黑树"><a href="#5-1-2-红黑树" class="headerlink" title="5.1.2 红黑树"></a>5.1.2 红黑树</h3><h3 id="5-1-3-B树和B-树"><a href="#5-1-3-B树和B-树" class="headerlink" title="5.1.3 B树和B+树"></a>5.1.3 B树和B+树</h3><ul>
<li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li>
<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
<li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li>
</ul>
<h3 id="5-1-4-为什么选择B-树作为索引"><a href="#5-1-4-为什么选择B-树作为索引" class="headerlink" title="5.1.4 为什么选择B+树作为索引"></a>5.1.4 为什么选择B+树作为索引</h3><ul>
<li>&#x3D;&#x3D;B+ 树的非叶子节点不存放实际的记录数据，仅存放索引&#x3D;&#x3D;，因此数据量相同的情况下，相比即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少。</li>
<li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在&#x3D;&#x3D;插入、删除的效率都更高&#x3D;&#x3D;，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li>
<li>B+ 树叶子节点之间用链表连接了起来，有利于<strong>范围查询</strong>，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。</li>
</ul>
<h2 id="5-2-索引类型"><a href="#5-2-索引类型" class="headerlink" title="5.2 索引类型"></a>5.2 索引类型</h2><ul>
<li>按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。</li>
<li>按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。</li>
<li>按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。</li>
<li>按「字段个数」分类：单列索引、联合索引。</li>
</ul>
<h3 id="5-2-1-数据结构"><a href="#5-2-1-数据结构" class="headerlink" title="5.2.1 数据结构"></a>5.2.1 数据结构</h3><h4 id="5-2-1-1-B-Tree索引"><a href="#5-2-1-1-B-Tree索引" class="headerlink" title="5.2.1.1 B-Tree索引"></a>5.2.1.1 B-Tree索引</h4><blockquote>
<p>B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403241636295.png" alt="image.png|500"></p>
<blockquote>
<p>MyISAM索引通过数据的物理位置引用被索引的行，B+Tree 叶节点的 data 域存放的是数据记录的地址（非聚簇索引），索引文件和数据文件分离<br>  InnoDB则根据主键引用被索引的行。其数据文件本身就是索引文件。 InnoDB 表数据文件本身就是主索引，辅助索引的 data 域存储相应记录主键的值而不是地址。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405141106447.png"></p>
<p><strong>可以使用B-Tree索引的查询类型</strong></p>
<ul>
<li>全值匹配：全值匹配指的是和索引中的所有列进行匹配</li>
<li>匹配最左前缀</li>
<li>匹配列前缀：也可以只匹配某一列的值的开头部分</li>
<li>匹配范围值</li>
<li>精确匹配某一列并范围匹配另外一列</li>
</ul>
<h4 id="5-2-1-2-哈希索引"><a href="#5-2-1-2-哈希索引" class="headerlink" title="5.2.1.2 哈希索引"></a>5.2.1.2 哈希索引</h4><blockquote>
<p>不支持顺序和范围查询</p>
</blockquote>
<h3 id="5-2-2-物理存储"><a href="#5-2-2-物理存储" class="headerlink" title="5.2.2 物理存储"></a>5.2.2 物理存储</h3><h4 id="5-2-2-1-主键索引与二级索引"><a href="#5-2-2-1-主键索引与二级索引" class="headerlink" title="5.2.2.1 主键索引与二级索引"></a>5.2.2.1 主键索引与二级索引</h4><p>主键索引：聚集索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚集索引的叶子节点<br>二级索引：叶子节点存放的是主键值，而不是实际数据。</p>
<p>在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是<strong>覆盖索引</strong>。</p>
<p>如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是<strong>回表</strong>。</p>
<h4 id="5-2-2-2-聚簇-集-索引与非聚簇-集-索引"><a href="#5-2-2-2-聚簇-集-索引与非聚簇-集-索引" class="headerlink" title="5.2.2.2 聚簇(集)索引与非聚簇(集)索引"></a>5.2.2.2 聚簇(集)索引与非聚簇(集)索引</h4><ul>
<li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li>
<li>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。<br><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252328222.png" alt="image.png|500"></li>
</ul>
<p>聚簇索引优缺点：</p>
<ul>
<li>二级索引访问需要两次索引查找，而不是一次。二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。InnoDB在移动行或者数据页分裂时无须更新二级索引中的这个“指针”。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252334238.png" alt="image.png|475"></p>
<h3 id="5-2-3-覆盖索引与联合索引"><a href="#5-2-3-覆盖索引与联合索引" class="headerlink" title="5.2.3 覆盖索引与联合索引"></a>5.2.3 覆盖索引与联合索引</h3><p>覆盖索引</p>
<ul>
<li>使用索引来直接获取列的数据，这样就不再需要读取数据行</li>
<li>如果一个<strong>索引包含（或者说覆盖）所有需要查询的字段的值</strong>，我们就称之为“覆盖索引”。</li>
</ul>
<p>联合索引</p>
<ul>
<li>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</li>
</ul>
<h3 id="5-2-4-冗余索引和重复索引"><a href="#5-2-4-冗余索引和重复索引" class="headerlink" title="5.2.4 冗余索引和重复索引"></a>5.2.4 冗余索引和重复索引</h3><p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引</p>
<h3 id="5-2-5-前缀索引"><a href="#5-2-5-前缀索引" class="headerlink" title="5.2.5 前缀索引"></a>5.2.5 前缀索引</h3><p>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p>
<h3 id="5-2-6-联合索引和单列索引"><a href="#5-2-6-联合索引和单列索引" class="headerlink" title="5.2.6 联合索引和单列索引"></a>5.2.6 联合索引和单列索引</h3><p>联合索引底层存储结构(和其他种类的索引的存储结构有什么区别?)</p>
<p>联合索引是数据库中一种常见的索引类型，它允许在多个列上创建索引，以提高查询性能。与单列索引相比，联合索引的底层存储结构有一些区别，主要体现在如何组织和存储索引数据的方式上。</p>
<ol>
<li><strong>存储数据的组织方式</strong>：    <ul>
<li>单列索引：单列索引只包含一个列的值和指向相应数据行的指针。通常，单列索引按照列值的大小顺序来组织存储数据。</li>
<li>联合索引：<strong>联合索引则包含多个列的值，以及指向相应数据行的指针</strong>。联合索引可以按照多个列值的组合来组织存储数据，这意味着可以根据多个列的值来定位数据行。</li>
</ul>
</li>
<li><strong>查询时的性能影响</strong>：<ul>
<li>单列索引：单列索引适合用于只涉及单个列的查询。当查询条件涉及到索引列时，数据库可以更快地定位到匹配的数据行。</li>
<li>联合索引：联合索引适合用于涉及多个列的查询。当查询涉及到联合索引中的多个列时，数据库可以利用索引中列值的组合来快速定位匹配的数据行。</li>
</ul>
</li>
<li><strong>索引维护的复杂性</strong>：<ul>
<li>单列索引：单列索引的维护相对简单，因为它只需要维护单个列的值和指针。</li>
<li>联合索引：联合索引的维护相对复杂一些，因为它需要考虑多个列值的组合。当表中的数据发生变化时，数据库需要确保联合索引中的多个列值的组合保持有序，这可能需要更多的资源和时间。</li>
</ul>
</li>
</ol>
<p>联合索引在适当的情况下可以提供更好的查询性能，特别是对于涉及到联合索引中列值的组合的查询。然而，需要注意的是，联合索引的创建和维护可能会带来一些额外的开销，并且需要根据具体的查询需求和数据模式来合理选择索引策略。</p>
<h2 id="5-3-索引的优点（三星评价）"><a href="#5-3-索引的优点（三星评价）" class="headerlink" title="5.3 索引的优点（三星评价）"></a>5.3 索引的优点（三星评价）</h2><p>索引将相关的记录放到一起则获得一星；<br>如果索引中的数据顺序和查找中的排列顺序一致则获得二星；<br>如果索引中的列包含了查询中需要的全部列则获得“三星”。</p>
<h2 id="5-4-最左匹配"><a href="#5-4-最左匹配" class="headerlink" title="5.4 最左匹配"></a>5.4 最左匹配</h2><p>查询只能使用索引的最左前缀，直到遇到第一个范围条件列。<br>最左前缀匹配原则指的是在使用联合索引时，MySQL 会&#x3D;&#x3D;根据索引中的字段顺序，从左到右依次匹配查询条件中的字段&#x3D;&#x3D;。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用索引来过滤数据，这样可以提高查询效率。</p>
<p>最左匹配原则会一直向右匹配，直到遇到范围查询（如 &gt;、&lt;）为止，范围查询的字段可以用到联合索引。对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN 以及&#x3D;&#x3D;前缀匹配 LIKE&#x3D;&#x3D; 的范围查询，不会停止匹配</p>
<p>当MySQL使用联合索引进行查询时，会从索引的最左边开始匹配查询条件，如果查询条件中包含了索引左边的列，那么MySQL才可能会使用这个索引来优化查询。如果查询条件没有包含左边的列或者左边的列出现一些范围查询（&gt;、&lt;、between等），即使其他列都在索引中，MySQL也可能不会使用这个索引。  </p>
<h2 id="5-5-索引下推"><a href="#5-5-索引下推" class="headerlink" title="5.5 索引下推"></a>5.5 索引下推</h2><p><strong>索引下推（Index Condition Pushdown，简称 ICP）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，执行部分 <code>WHERE</code>字句的判断条件，直接过滤掉不满足条件的记录，从而减少回表次数，提高查询效率。</p>
<p>将Server层筛选数据的工作，下推到引擎层处理。</p>
<p>在没有索引下推的情况下，MySQL会先从索引中获取所有可能满足条件的数据行的主键，然后根据这些主键检索完整的数据行(即回表)，最后再应用WHERE条件进行过滤。而有了索引下推，MySQL可以在扫描索引的同时，直接<strong>根据索引中的值来判断是否满足WHERE条件</strong>，从而避免不必要的回表操作。</p>
<p>对于联合索引(a,b)，在执行 <code>select * from table where a &gt; 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引。在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后：</p>
<ul>
<li>不使用索引下推：从ID&#x3D;2（主键值）回表，在主键索引中找出数据行，在对比b字段值</li>
<li>索引下推：<strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。（Using index condition）</li>
</ul>
<p>对于联合索引，在遇到范围查询时，后面的索引无法被用到。不使用索引下推，则根据主键值回表查询。但是可以根据索引包含的字段先做判断</p>
<h2 id="5-6-什么时候需要-x2F-不需要创建索引？"><a href="#5-6-什么时候需要-x2F-不需要创建索引？" class="headerlink" title="5.6 什么时候需要 &#x2F; 不需要创建索引？"></a>5.6 什么时候需要 &#x2F; 不需要创建索引？</h2><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p>
<ul>
<li>需要占用物理空间，数量越大，占用空间越大；</li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li>
<li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li>
</ul>
<p>所以，索引不是万能钥匙，它也是根据场景来使用的。</p>
<h4 id="5-6-1-1-什么时候适用索引？"><a href="#5-6-1-1-什么时候适用索引？" class="headerlink" title="5.6.1.1 什么时候适用索引？"></a>5.6.1.1 什么时候适用索引？</h4><ul>
<li>字段有<code>唯一性</code>限制的，比如商品编码；</li>
<li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li>
<li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li>
</ul>
<h4 id="5-6-1-2-什么时候不需要创建索引？"><a href="#5-6-1-2-什么时候不需要创建索引？" class="headerlink" title="5.6.1.2 什么时候不需要创建索引？"></a>5.6.1.2 什么时候不需要创建索引？</h4><ul>
<li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li>
<li><code>字段不具有区分度</code>，字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li>
<li>表数据太少的时候，不需要创建索引；</li>
<li><code>经常更新的字段</code>不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li>
</ul>
<h2 id="5-7-索引优化"><a href="#5-7-索引优化" class="headerlink" title="5.7 索引优化"></a>5.7 索引优化</h2><ul>
<li>前缀索引优化：使用字符串的前几个字符建立索引，减少索引字段大小</li>
<li>覆盖索引：要查询的字段，在叶子节点上都能找到对应的索引</li>
<li>主键索引最好是自增的：每次插入一条新记录，都是追加操作，不需要重新移动数据</li>
<li>索引最好设置为NOT NULL</li>
<li>防止索引失效，最左前缀匹配</li>
<li>选择合适的列进行索引，选择经常用于查询条件的列，避免对经常修改的列建立索引</li>
</ul>
<p><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</p>
<h3 id="5-7-1-NULL和’’的区别"><a href="#5-7-1-NULL和’’的区别" class="headerlink" title="5.7.1 NULL和’’的区别"></a>5.7.1 NULL和’’的区别</h3><ul>
<li><code>NULL</code> 代表一个不确定的值,就算是两个 <code>NULL</code>,它俩也不一定相等。例如，<code>SELECT NULL=NULL</code>的结果为 false，但是在我们使用<code>DISTINCT</code>,<code>GROUP BY</code>,<code>ORDER BY</code>时,<code>NULL</code>又被认为是相等的。</li>
<li><code>&#39;&#39;</code>的长度是 0，是不占用空间的，而<code>NULL</code> 是需要占用空间的。</li>
<li><code>NULL</code> 会影响聚合函数的结果。例如，<code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。 <code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*</code>(<code>COUNT(*)</code>)，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名(<code>COUNT(列名)</code>)，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li>
<li>查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULLl</code> 来判断，而不能使用 &#x3D;、!&#x3D;、 &lt;、&gt; 之类的比较运算符。而<code>&#39;&#39;</code>是可以使用这些比较运算符的。</li>
</ul>
<h2 id="5-8-索引失效"><a href="#5-8-索引失效" class="headerlink" title="5.8 索引失效"></a>5.8 索引失效</h2><ul>
<li>使用左或者左右<strong>模糊匹配</strong>的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li>
<li>在查询条件中<strong>对索引使用函数</strong>，即对索引列做了<code>计算、函数、类型转换操作</code>，这些情况下都会造成索引失效；</li>
<li>联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//对索引进行表达式计算</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> department <span class="keyword">where</span> dept_id+<span class="number">1</span>=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> department <span class="keyword">where</span> dept_id=<span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">//对索引使用函数</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> department <span class="keyword">where</span> LENGTH(dept_name)=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> department <span class="keyword">add</span> key idx_name_length ((LENGTH(dept_name)));</span><br></pre></td></tr></table></figure>

<h3 id="5-8-1-隐式类型转换造成索引失效"><a href="#5-8-1-隐式类型转换造成索引失效" class="headerlink" title="5.8.1 隐式类型转换造成索引失效"></a>5.8.1 隐式类型转换造成索引失效</h3><ul>
<li>当操作符<strong>左右两边的数据类型不一致</strong>时，会发生<strong>隐式转换</strong>。</li>
<li>当 where 查询操作符<strong>左边为数值类型</strong>时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。</li>
<li>当 where 查询操作符<strong>左边为字符类型</strong>时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。</li>
<li>字符串转换为数值类型时，非数字开头的字符串会转化为<code>0</code>，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。</li>
</ul>
<h2 id="5-9-回表查询"><a href="#5-9-回表查询" class="headerlink" title="5.9 回表查询"></a>5.9 回表查询</h2><p>回表查询是指在使用非聚集索引进行查询时，需要通过索引中的指针回到主键索引或者聚集索引中获取完整的数据行的过程。回表查询通常发生在以下场景中：</p>
<ol>
<li><p>需要查询的字段不在非聚集索引中：当查询的字段不在非聚集索引中时，数据库引擎无法直接从索引中获取完整的数据行，而是需要通过回表操作到主键索引或聚集索引中获取完整的数据行。</p>
</li>
<li><p>需要返回的数据超过了非聚集索引的覆盖索引能力：覆盖索引是指索引中包含了查询所需的所有字段，可以直接从索引中获取查询结果，而无需回表操作。但是，如果需要返回的数据超过了非聚集索引的覆盖索引能力，仍然需要进行回表查询。</p>
</li>
<li><p>使用了索引优化的查询：有些查询语句可能会使用到索引优化，例如使用了索引的覆盖扫描、索引合并等技术，这些优化可能会导致回表查询的发生。</p>
</li>
</ol>
<p>回表查询会增加额外的IO操作，因为需要通过指针再次访问主键索引或聚集索引。在一些对查询性能要求较高的场景中，可以考虑使用覆盖索引或者调整查询语句的优化方式，以减少回表查询的次数。</p>
<p>回表查询并非一定是性能问题，有时候回表查询是必要的，特别是在需要返回完整数据行的情况下。在设计数据库表和索引时，需要根据具体的业务需求和查询场景来选择合适的索引策略，以达到最佳的查询性能。</p>
<h2 id="5-10-Count"><a href="#5-10-Count" class="headerlink" title="5.10 Count"></a>5.10 Count</h2><p>count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。</p>
<p>所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。</p>
<p>再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。</p>
<p>如果参数是 (<code>COUNT(*)</code>)，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名(<code>COUNT(列名)</code>)，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</p>
<h1 id="6-执行计划"><a href="#6-执行计划" class="headerlink" title="6 执行计划"></a>6 执行计划</h1><ul>
<li>possible_keys 字段表示可能用到的索引；</li>
<li>key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；</li>
<li>key_len 表示索引的长度；</li>
<li>rows 表示扫描的数据行数。</li>
<li>type 表示&#x3D;&#x3D;数据扫描类型&#x3D;&#x3D;，我们需要重点看这个。</li>
</ul>
<h2 id="6-1-type"><a href="#6-1-type" class="headerlink" title="6.1 type"></a>6.1 type</h2><ul>
<li>All（全表扫描）；</li>
<li>index（全索引扫描）；</li>
<li>range（索引范围扫描）；</li>
<li>ref（非唯一索引扫描）；</li>
<li>eq_ref（唯一索引扫描）；</li>
<li>const（结果只有一条的主键或唯一索引扫描）。</li>
</ul>
<h2 id="6-2-extra"><a href="#6-2-extra" class="headerlink" title="6.2 extra"></a>6.2 extra</h2><ul>
<li>Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。</li>
<li>Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。</li>
<li>Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404182127269.png" alt="image.png"></p>
<h1 id="7-数据库优化"><a href="#7-数据库优化" class="headerlink" title="7 数据库优化"></a>7 数据库优化</h1><ol>
<li>索引优化</li>
<li>读写分离和分库分表</li>
<li>数据冷热分离</li>
<li>SQL 优化</li>
<li>深度分页优化</li>
<li>适当冗余数据</li>
<li>使用更高的硬件配置</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/mysql/" rel="tag"># MySQL</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/03/06/%E7%AE%97%E6%B3%95/%E6%A0%91%EF%BC%9A%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91/" rel="prev" title="树：平衡搜索树">
                  <i class="fa fa-chevron-left"></i> 树：平衡搜索树
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/03/17/%E6%A1%86%E6%9E%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis(1)%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%81%E7%BC%93%E5%AD%98/" rel="next" title="Redis(1)：数据结构、持久化、缓存">
                  Redis(1)：数据结构、持久化、缓存 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Destiny</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
