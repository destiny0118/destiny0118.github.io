<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"destiny0118.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 、 Queue。   List(对付顺序的好帮手): 存储的元素是有序的、可重复的。 Set(注重独一无二的性质): 存储的元素不可重复的。 Queue(实现排队功能的叫">
<meta property="og:type" content="article">
<meta property="og:title" content="我的个人博客">
<meta property="og:url" content="https://destiny0118.github.io/2024/03/04/Java/Java(3)%EF%BC%9A%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="我的个人博客">
<meta property="og:description" content="Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 、 Queue。   List(对付顺序的好帮手): 存储的元素是有序的、可重复的。 Set(注重独一无二的性质): 存储的元素不可重复的。 Queue(实现排队功能的叫">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405281131352.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404012148392.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404012149783.png">
<meta property="article:published_time" content="2024-03-04T02:11:52.436Z">
<meta property="article:modified_time" content="2024-06-12T09:30:10.982Z">
<meta property="article:author" content="Destiny">
<meta property="article:tag" content="算法，工具">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405281131352.png">


<link rel="canonical" href="https://destiny0118.github.io/2024/03/04/Java/Java(3)%EF%BC%9A%E9%9B%86%E5%90%88/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://destiny0118.github.io/2024/03/04/Java/Java(3)%EF%BC%9A%E9%9B%86%E5%90%88/","path":"2024/03/04/Java/Java(3)：集合/","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title> | 我的个人博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">我的个人博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">What past is prolgue.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-project"><a href="/categories/project/" rel="section"><i class="fa fa-tasks fa-fw"></i>项目</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">1 List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB"><span class="nav-text">1.1 ArrayList和LinkedList区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">2 Set</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Comparable%E5%92%8CComparator"><span class="nav-text">2.1 Comparable和Comparator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-Hashset%E3%80%81LinkedHashSet%E3%80%81TreeSet"><span class="nav-text">2.2 Hashset、LinkedHashSet、TreeSet</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">3 Map</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-HashMap%E5%92%8CTreeMap"><span class="nav-text">3.1 HashMap和TreeMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-HashMap"><span class="nav-text">3.2 HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-text">3.2.1 扩容机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-HashMap%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="nav-text">3.2.2 HashMap多线程导致死循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-text">3.2.3 HashMap为什么线程不安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-1-%E5%90%8C%E6%97%B6%E6%A3%80%E6%B5%8B%E5%88%B0%E6%A1%B6%E4%BD%8D%E7%BD%AE%E4%B8%BA%E7%A9%BA%EF%BC%8C%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="nav-text">3.2.3.1 同时检测到桶位置为空，插入元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-2-%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6put%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4size%E4%B8%8D%E6%AD%A3%E7%A1%AE"><span class="nav-text">3.2.3.2 多个线程同时put操作导致size不正确</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-text">3.2.4 底层实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-5-put%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E8%BF%87%E7%A8%8B"><span class="nav-text">3.2.5 put添加元素过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-6-%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E8%AE%A9HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">3.2.6 如何做到让HashMap线程安全</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-ConcurrentHashMap"><span class="nav-text">3.3 ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-JDK-1-7"><span class="nav-text">3.3.1 JDK 1.7</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-JDK-1-8"><span class="nav-text">3.3.2 JDK 1.8</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-JDK-1-7-%E5%92%8C-JDK-1-8-%E7%9A%84-ConcurrentHashMap-%E5%AE%9E%E7%8E%B0%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-text">3.3.3 JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">4 Atomic</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Destiny</p>
  <div class="site-description" itemprop="description">凡是过去，皆为序章。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">129</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/destiny0118" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;destiny0118" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuyg163@163.com" title="E-Mail → mailto:yuyg163@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/19273732/destiny" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;19273732&#x2F;destiny" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/03/04/Java/Java(3)%EF%BC%9A%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          <a href="https://github.com/destiny0118/Hexo/edit/master/Destiny/source/_posts/Java/Java(3)%EF%BC%9A%E9%9B%86%E5%90%88.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-04 10:11:52" itemprop="dateCreated datePublished" datetime="2024-03-04T10:11:52+08:00">2024-03-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-12 17:30:10" itemprop="dateModified" datetime="2024-06-12T17:30:10+08:00">2024-06-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 、 <code>Queue</code>。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405281131352.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2"><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
<li class="lvl-2"><code>Set</code>(注重独一无二的性质): 存储的元素不可重复的。</li>
<li class="lvl-2"><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li class="lvl-2"><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，“x” 代表 key，“y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<table>
<thead>
<tr>
<th>集合</th>
<th>实现</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>List</td>
<td>ArrayList</td>
<td></td>
</tr>
<tr>
<td></td>
<td>vector</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LinkedList</td>
<td></td>
</tr>
<tr>
<td>Set</td>
<td>HashSet</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LinkedHashSet</td>
<td></td>
</tr>
<tr>
<td></td>
<td>TreeSet</td>
<td></td>
</tr>
<tr>
<td>Map</td>
<td>HashMap</td>
<td>线程不安全，key、value都可为null</td>
</tr>
<tr>
<td></td>
<td>LinkedHashMap</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HashTable</td>
<td>线程安全</td>
</tr>
<tr>
<td></td>
<td>TreeMap</td>
<td></td>
</tr>
</tbody>
</table>
<p>Queue</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>PriorityQueue</p>
</li>
<li class="lvl-2">
<p>DelayQueue</p>
</li>
<li class="lvl-2">
<p>ArrayDeque</p>
</li>
</ul>
<p><code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。</p>
<h1>1 List</h1>
<h2 id="1-1-ArrayList和LinkedList区别">1.1 ArrayList和LinkedList区别</h2>
<ol>
<li class="lvl-3">
<p><strong>底层数据结构：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>ArrayList</code>使用<em>动态数组</em>实现。它的内部是一个数组，当数组容量不足时，会自动进行扩容。</li>
<li class="lvl-6"><code>LinkedList</code>使用<em>双向链表</em>实现。每个元素都包含一个指向前一个元素和一个指向后一个元素的引用。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>随机访问性能：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>ArrayList</code>支持快速的随机访问，因为它是基于数组的，可以通过索引直接访问元素。</li>
<li class="lvl-6"><code>LinkedList</code>在随机访问时性能较差，因为必须从链表的头部或尾部开始遍历，直到找到目标元素。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>插入和删除操作性能：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>ArrayList</code>在中间插入或删除元素时性能较差，因为需要移动数组中的元素。</li>
<li class="lvl-6"><code>LinkedList</code>在插入和删除元素时性能较好，因为只需要改变相邻元素的引用。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>空间复杂度：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>ArrayList</code>相对较省空间，因为它只需要存储元素值和数组容量。</li>
<li class="lvl-6"><code>LinkedList</code>相对较耗费空间，因为每个元素都需要额外的两个引用字段。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>迭代器性能：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>ArrayList</code>上的迭代器性能较好，因为它可以通过索引直接访问元素。</li>
<li class="lvl-6"><code>LinkedList</code>上的迭代器性能较差，因为必须沿着链表一个一个地移动。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>适用场景：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">如果需要频繁进行随机访问，使用<code>ArrayList</code>更为合适。</li>
<li class="lvl-6">如果需要频繁进行插入和删除操作，特别是在集合的中间位置，使用<code>LinkedList</code>更为合适。</li>
</ul>
</li>
</ol>
<h1>2 Set</h1>
<h2 id="2-1-Comparable和Comparator">2.1 Comparable和Comparator</h2>
<p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</p>
</li>
<li class="lvl-2">
<p><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</p>
</li>
</ul>
<h2 id="2-2-Hashset、LinkedHashSet、TreeSet">2.2 Hashset、LinkedHashSet、TreeSet</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</p>
</li>
<li class="lvl-2">
<p>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</p>
</li>
</ul>
<h1>3 Map</h1>
<h2 id="3-1-HashMap和TreeMap">3.1 HashMap和TreeMap</h2>
<p><strong>相比于<code>HashMap</code>来说， <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>
<h2 id="3-2-HashMap">3.2 HashMap</h2>
<h3 id="3-2-1-扩容机制">3.2.1 扩容机制</h3>
<ol>
<li class="lvl-3">
<p><strong>初始容量和负载因子：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>HashMap</code> 有一个初始容量和一个负载因子。初始容量是哈希表在创建时的容量，默认为 16。负载因子是一个在哈希表大小超过其容量乘以负载因子时，哈希表将进行扩容的阈值，默认为 0.75。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>扩容操作：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">当哈希表的元素个数达到了负载因子所定义的阈值，<code>HashMap</code> 将进行扩容操作。</li>
<li class="lvl-6">扩容操作包括创建一个新的哈希表，其容量为原容量的两倍，然后将所有元素重新分配到新的哈希表中。<br>
<a href="https://zhuanlan.zhihu.com/p/114363420">HashMap的扩容机制 - 知乎 (zhihu.com)</a><br>
<a href="https://blog.csdn.net/qq_49217297/article/details/126304736">HashMap实现原理， 扩容机制，面试题和总结_hashmap扩容机制面试-CSDN博客</a></li>
</ul>
</li>
</ol>
<h3 id="3-2-2-HashMap多线程导致死循环">3.2.2 HashMap多线程导致死循环</h3>
<p>当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，<code>头插法</code>可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。</p>
<p><a href="https://coolshell.cn/articles/9606.html">疫苗：Java HashMap的死循环 | 酷 壳 - CoolShell</a></p>
<h3 id="3-2-3-HashMap为什么线程不安全">3.2.3 HashMap为什么线程不安全</h3>
<p>多线程环境下，<code>HashMap</code> 扩容时会造成<code>死循环</code> 和<code>数据丢失</code>的问题。在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对<code>HashMap</code>的put操作会导致线程不安全，可能产生数据覆盖.</p>
<h4 id="3-2-3-1-同时检测到桶位置为空，插入元素">3.2.3.1 同时检测到桶位置为空，插入元素</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>两个线程同时进行put操作，并且存在哈希冲突</p>
</li>
<li class="lvl-2">
<p>由于线程首先都执行完了hash碰撞的判断，桶为空</p>
</li>
<li class="lvl-2">
<p>每个线程再向空桶中插入元素</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 判断是否出现 hash 碰撞</span></span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素（处理hash冲突）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-3-2-多个线程同时put操作导致size不正确">3.2.3.2 多个线程同时put操作导致size不正确</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>两个线程都先获取size，在++size</p>
</li>
<li class="lvl-2">
<p>添加两次元素，而size只增加1</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://zhuanlan.zhihu.com/p/484653028">基于JDK8的HashMap实现(万字详解) - 知乎 (zhihu.com)</a></p>
<h3 id="3-2-4-底层实现">3.2.4 底层实现</h3>
<p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<h3 id="3-2-5-put添加元素过程">3.2.5 put添加元素过程</h3>
<ol>
<li class="lvl-3">
<p><strong>计算哈希码（Hash Code）：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">当你向 <code>HashSet</code> 中添加一个元素时，首先会调用该元素的 <code>hashCode()</code> 方法，得到元素的哈希码。</li>
<li class="lvl-6">如果元素为 <code>null</code>，则它的哈希码为 0。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>映射到桶位置（Bucket Position）：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">哈希码经过一系列的变换和运算，被映射到哈希表中的一个桶位置（bucket position）。</li>
<li class="lvl-6">桶位置是一个数组索引，表示存储元素的位置。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>处理哈希冲突：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">哈希表可能存在冲突，即不同元素映射到相同的桶位置。为了解决冲突，<code>HashSet</code> 使用链表或红黑树（在JDK 8之后）来存储相同桶位置上的元素。</li>
<li class="lvl-6">如果桶位置上已经有一个元素，新元素会被添加到链表或红黑树的末尾。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>检查元素唯一性：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">在添加元素的过程中，<code>HashSet</code> 会通过调用元素的 <code>equals()</code> 方法来检查元素的唯一性。</li>
<li class="lvl-6">如果已经存在相同的元素（根据 <code>equals()</code> 判断），新元素不会被加入。</li>
</ul>
</li>
</ol>
<h3 id="3-2-6-如何做到让HashMap线程安全">3.2.6 如何做到让HashMap线程安全</h3>
<ol>
<li class="lvl-3">
<p><strong>使用<code>Collections.synchronizedMap</code>方法：</strong><br>
Map&lt;K, V&gt; synchronizedMap = Collections.synchronizedMap(new HashMap&lt;K, V&gt;());</p>
<p>这将返回一个线程安全的<code>Map</code>，它在每个方法上都使用同步机制来确保线程安全。但请注意，虽然这确保了每个方法的原子性，但在多个操作之间，仍然可能需要额外的同步。</p>
</li>
<li class="lvl-3">
<p><strong>使用<code>ConcurrentHashMap</code>：</strong> <code>ConcurrentHashMap</code>是Java提供的线程安全的<code>Map</code>实现。它使用分段锁机制，每个段相当于一个小的<code>HashMap</code>，不同的段之间互不影响，这样可以提高并发性能。</p>
<p>Map&lt;K, V&gt; concurrentMap = new ConcurrentHashMap&lt;K, V&gt;();</p>
</li>
</ol>
<h2 id="3-3-ConcurrentHashMap">3.3 ConcurrentHashMap</h2>
<h3 id="3-3-1-JDK-1-7">3.3.1 JDK 1.7</h3>
<blockquote>
<p>通过分段锁（Segmentation）实现线程安全。它将整个哈希表分成多个段（Segment），每个段都是一个小的哈希表，并且拥有自己的锁。这样，多个线程可以并发地访问不同的段，从而减少了锁的竞争，提高了并发性能。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404012148392.png" alt="image.png"></p>
<h3 id="3-3-2-JDK-1-8">3.3.2 JDK 1.8</h3>
<blockquote>
<p>使用了一种更细粒度的锁策略，结合CAS（Compare-and-Swap）无锁算法来实现线程安全。在JDK 1.8中，ConcurrentHashMap将整个哈希表看作一个整体，不再进行分段。而是通过Node数组+链表+红黑树的结构来存储数据，并使用Synchronized和CAS来协调并发访问。</p>
</blockquote>
<p>锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404012149783.png" alt="image.png"></p>
<h3 id="3-3-3-JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？">3.3.3 JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p>
</li>
<li class="lvl-2">
<p><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</p>
</li>
<li class="lvl-2">
<p><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</p>
</li>
</ul>
<p><a href="https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html#_4-get">ConcurrentHashMap 源码分析 | JavaGuide</a><br>
<a href="https://zhuanlan.zhihu.com/p/94976168">一文彻底搞懂CAS实现原理 &amp; 深入到CPU指令 - 知乎 (zhihu.com)</a><br>
<a href="https://javaguide.cn/java/collection/java-collection-questions-02.html#map-%E9%87%8D%E8%A6%81">Java集合常见面试题总结(下) | JavaGuide</a></p>
<h1>4 Atomic</h1>
<p><code>java.util.concurrent.atomic</code> 包提供了一组用于在多线程环境中进行原子操作的类。这些类通过使用硬件级别的原子性操作或者利用 <code>sun.misc.Unsafe</code> 提供的 CAS（Compare-And-Swap）操作来确保对变量的操作是原子的。这些类大多数都是基于原始数据类型的，例如 <code>int</code>、<code>long</code>，还有一些是引用类型。</p>
<p>以下是 <code>java.util.concurrent.atomic</code> 包中一些主要的类以及它们的用途：</p>
<ol>
<li class="lvl-3">
<p><strong>AtomicInteger：</strong> 用于对整数进行原子操作，支持原子的自增（<code>incrementAndGet()</code>）、自减（<code>decrementAndGet()</code>）等操作。</p>
</li>
<li class="lvl-3">
<p><strong>AtomicLong：</strong> 用于对长整型进行原子操作，同样支持原子的自增、自减等操作。</p>
</li>
<li class="lvl-3">
<p><strong>AtomicBoolean：</strong> 用于对布尔类型进行原子操作，支持原子的设置和获取操作。</p>
</li>
<li class="lvl-3">
<p><strong>AtomicReference：</strong> 用于对引用类型进行原子操作，支持原子的获取和设置引用对象。</p>
</li>
<li class="lvl-3">
<p><strong>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray：</strong> 用于对数组中的元素进行原子操作，提供了一些原子性的数组操作。</p>
</li>
<li class="lvl-3">
<p><strong>AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater：</strong> 用于对类的字段进行原子更新，允许在并发环境中对对象的字段进行原子性操作。</p>
</li>
</ol>
<p>这些原子类提供了一种比使用 <code>synchronized</code> 关键字更轻量级的线程安全机制，特别适用于一些简单的计数器、状态标志等场景。在需要进行原子操作而又不需要全局的锁的情况下，这些类可以提供更好的性能。</p>
<p>虽然这些类提供了原子性的操作，但并不是所有的操作都可以用原子方式完成，因此在使用时仍然需要注意保证原子性的操作是否符合预期。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/02/28/Java/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91(1)%EF%BC%9A%E5%B9%B6%E5%8F%91/" rel="prev" title="Java：并发">
                  <i class="fa fa-chevron-left"></i> Java：并发
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/03/05/Java/%E6%BA%90%E7%A0%81/Java%E5%B9%B6%E5%8F%91%EF%BC%9AThreadPoolExecutor/" rel="next" title="">
                   <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Destiny</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
