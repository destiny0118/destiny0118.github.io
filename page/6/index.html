<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"destiny0118.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="凡是过去，皆为序章。">
<meta property="og:type" content="website">
<meta property="og:title" content="我的个人博客">
<meta property="og:url" content="https://destiny0118.github.io/page/6/index.html">
<meta property="og:site_name" content="我的个人博客">
<meta property="og:description" content="凡是过去，皆为序章。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Destiny">
<meta property="article:tag" content="算法，工具">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://destiny0118.github.io/page/6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>我的个人博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">我的个人博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">What past is prolgue.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-project"><a href="/categories/project/" rel="section"><i class="fa fa-tasks fa-fw"></i>项目</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Destiny</p>
  <div class="site-description" itemprop="description">凡是过去，皆为序章。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/destiny0118" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;destiny0118" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuyg163@163.com" title="E-Mail → mailto:yuyg163@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/19273732/destiny" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;19273732&#x2F;destiny" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/04/08/%E6%A1%86%E6%9E%B6/JVM/JVM%20(2)%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/08/%E6%A1%86%E6%9E%B6/JVM/JVM%20(2)%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="post-title-link" itemprop="url">JVM (2)：垃圾回收</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-08 00:00:00" itemprop="dateCreated datePublished" datetime="2024-04-08T00:00:00+08:00">2024-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-18 19:59:21" itemprop="dateModified" datetime="2024-09-18T19:59:21+08:00">2024-09-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1. GC触发时机
2. 死亡对象判断方法
3. 垃圾收集算法
4. 垃圾收集器</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/08/%E6%A1%86%E6%9E%B6/JVM/JVM%20(2)%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/04/02/Java/Java(2)%EF%BC%9A%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/02/Java/Java(2)%EF%BC%9A%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-02 17:02:50" itemprop="dateCreated datePublished" datetime="2024-04-02T17:02:50+08:00">2024-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-25 11:01:00" itemprop="dateModified" datetime="2024-08-25T11:01:00+08:00">2024-08-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-序列化-反序列化"><a class="markdownIt-Anchor" href="#1-序列化-反序列化"></a> 1 序列化、反序列化</h1>
<p>序列化是将数据结构或对象转换成一种可存储或可传输格式的过程，通常涉及将数据转换成字节流或类似的格式，以便在不同平台和编程语言之间进行传输和交换。反序列化是将序列化后的数据重新还原成原始的数据结构或对象，从文件、网络数据或数据库中读取序列化的数据，并将其转换回原始形式，以便在程序中进行使用和操作。这两个概念在编程中与数据存储、传输和处理密切相关，为开发工作带来便利1</p>
<h1 id="2-异常"><a class="markdownIt-Anchor" href="#2-异常"></a> 2 异常</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405132023043.png" alt="image.png|500" /></p>
<h2 id="21-exception和error"><a class="markdownIt-Anchor" href="#21-exception和error"></a> 2.1 Exception和Error</h2>
<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>
<li><strong><code>Error</code></strong>：<code>Error</code> 属于程序无法处理的错误</li>
</ul>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p>
<ul>
<li><code>NullPointerException</code>(空指针错误)</li>
<li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li>
<li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类，s包含非数字字符，或者为null）</li>
<li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li>
<li><code>ClassCastException</code>（类型转换错误）</li>
<li><code>ArithmeticException</code>（算术错误）</li>
<li><code>SecurityException</code> （安全错误比如权限不够）</li>
<li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li>
</ul>
<h3 id="211-如何使用-try-with-resources-代替try-catch-finally"><a class="markdownIt-Anchor" href="#211-如何使用-try-with-resources-代替try-catch-finally"></a> 2.1.1 如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h3>
<pre class="highlight"><code class="java"><span class="hljs-comment">//读取文本文件的内容</span>
Scanner scanner = <span class="hljs-keyword">null</span>;
<span class="hljs-keyword">try</span> &#123;
    scanner = <span class="hljs-keyword">new</span> Scanner(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"D://read.txt"</span>));
    <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;
        System.out.println(scanner.nextLine());
    &#125;
&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;
    e.printStackTrace();
&#125; <span class="hljs-keyword">finally</span> &#123;
    <span class="hljs-keyword">if</span> (scanner != <span class="hljs-keyword">null</span>) &#123;
        scanner.close();
    &#125;
&#125;
</code></pre>
<p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>
<pre class="highlight"><code class="java"><span class="hljs-keyword">try</span> (Scanner scanner = <span class="hljs-keyword">new</span> Scanner(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"test.txt"</span>))) &#123;
    <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;
        System.out.println(scanner.nextLine());
    &#125;
&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException fnfe) &#123;
    fnfe.printStackTrace();
&#125;
</code></pre>
<h1 id="3-泛型"><a class="markdownIt-Anchor" href="#3-泛型"></a> 3 泛型</h1>
<blockquote>
<p>在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code></p>
</blockquote>
<p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-01 21:02:51" itemprop="dateCreated datePublished" datetime="2024-04-01T21:02:51+08:00">2024-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-25 10:41:05" itemprop="dateModified" datetime="2024-08-25T10:41:05+08:00">2024-08-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-linux运行级别"><a class="markdownIt-Anchor" href="#1-linux运行级别"></a> 1 Linux运行级别</h1>
<p>Linux系统有七个运行级别，分别用数字0-6表示。每个运行级别都会启动或停止不同的系统服务和进程，以满足不同的系统需求。</p>
<p>​1.我们可以使用 <strong>runlevel</strong> 命令，进行查看</p>
<p>2.我们可以使用 <strong>who -r</strong> 命令进行查看</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>运行等级</strong></td>
<td><strong>描述</strong></td>
<td><strong>命令参数</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>关机模式，系统默认运行级别不能设置为0，否则不能正常启动，一开机就自动关机</td>
<td><strong>shutdown.target</strong></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>单用户模式，root权限，用于系统维护，禁止远程登录，就像Windows下的安全模式</td>
<td><strong>emergency.target</strong></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>多用户模式，没有 NFS 网络支持</td>
<td><strong>rescure.target</strong></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>完整的多用户文本模式，有 NFS，登录后进入控制台命令模式</td>
<td><strong>multi-user.target</strong></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>系统未使用，保留一般不用</td>
<td><strong>无</strong></td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>图形化模式，登陆后进入图形 GUI 模式</td>
<td><strong>graphical.target</strong></td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>重启模式，默认运行级别不能设为6，否则不能设为6，否则不能正常启动，就会一直开机重启</td>
<td><strong>无</strong></td>
</tr>
</tbody>
</table>
<p>​</p>
<p>我们怎么查看系统在启动时默认的运行等级呢?</p>
<p>可以使用 <strong>systemctl get-default</strong> 命令进行查看<br />
 <strong>systemctl set-default multi-user.target</strong></p>
<p>要改变Linux的运行级别，可以使用以下方法：<br />
使用runlevel命令查看当前系统的运行级别。<br />
使用init命令切换运行级别。<br />
修改/etc/inittab文件中的运行级别。<br />
使用systemctl命令设置默认运行级别。<br />
使用systemctl命令立即切换到指定的运行级别。</p>
<h1 id="2-linux常用命令"><a class="markdownIt-Anchor" href="#2-linux常用命令"></a> 2 Linux常用命令</h1>
<ul>
<li>chmod：更改文件或目录的权限。</li>
<li>cat：查看文件内容</li>
<li>top：inux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况.该命令可以提供实时的对系统处理器的状态监视，它会显示系统中CPU最“敏感”的任务列表，并且可以按CPU使用、内存使用和执行时间对任务进行排序</li>
</ul>
<h2 id="21-grep"><a class="markdownIt-Anchor" href="#21-grep"></a> 2.1 grep</h2>
<blockquote>
<p>分析一行信息</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v</td>
<td>排除选项</td>
</tr>
<tr>
<td>grep -v ‘^$’ filename</td>
<td>^：行首，$：行尾，去掉空行</td>
</tr>
<tr>
<td>grep -v ‘<sup>#|</sup>$’ filename</td>
<td>^#：以#开头，去掉空行和以#开头的行</td>
</tr>
</tbody>
</table>
<h2 id="22-tar"><a class="markdownIt-Anchor" href="#22-tar"></a> 2.2 tar</h2>
<pre class="highlight"><code class="">压缩命令
tar：该命令用于将多个文件或目录打包成一个文件，也可以同时对其进行压缩。常用的参数有：
-c：创建新的压缩文件。
-v：显示详细的压缩过程。
-f：指定压缩文件的名称。
-z：使用gzip压缩算法进行压缩。
-j：使用bzip2压缩算法进行压缩。
-J：使用xz压缩算法进行压缩。

解压命令：
tar：该命令不仅可以用于压缩，也可以用于解压。解压时常用的参数有：
-x：从压缩文件中提取文件或目录。
-v：显示详细的解压过程。
-f：指定要解压的压缩文件名称。
-z：解压使用gzip压缩算法的文件。
-j：解压使用bzip2压缩算法的文件。
-J：解压使用xz压缩算法的文件。
例如，要解压doc.tar.gz到当前目录，可以使用命令tar -xzvf doc.tar.gz。
</code></pre>
<h2 id="23-top"><a class="markdownIt-Anchor" href="#23-top"></a> 2.3 top</h2>
<p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况</p>
<h2 id="24-ps"><a class="markdownIt-Anchor" href="#24-ps"></a> 2.4 ps</h2>
<p>ps命令用于报告当前系统的进程状态。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。</p>
<h2 id="25-free"><a class="markdownIt-Anchor" href="#25-free"></a> 2.5 free</h2>
<p>free命令可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。</p>
<p><a href="https://www.jianshu.com/p/4bca8fe8a878">面试官常考的 21 条 Linux 命令 - 简书 (jianshu.com)</a></p>
<h1 id="3-文件系统"><a class="markdownIt-Anchor" href="#3-文件系统"></a> 3 文件系统</h1>
<h2 id="31-linux相关文件的概念文件有哪些类型各自的作用是什么"><a class="markdownIt-Anchor" href="#31-linux相关文件的概念文件有哪些类型各自的作用是什么"></a> 3.1 Linux相关：文件的概念？文件有哪些类型？各自的作用是什么？</h2>
<p><strong>解析：</strong>： 文件类型很多，能回答几种常见的就行，例如普通文件，目录文件，块设备文件，套接字文件。 <strong>参考回答：</strong></p>
<blockquote>
<p>1.普通文件（-）：这是最常见的文件类型，包括纯文本文件、二进制文件、数据文件等。它们不包含文件系统的结构信息，只是用户所接触到的文件。例如，.c文件、可执行的二进制文件等都是普通文件。</p>
<p>2.目录文件（d）：目录文件是用于存放文件名及其相关信息的文件。它们可以包含下一级文件目录或普通文件，是内核组织文件系统的基本节点。通过目录文件，用户可以轻松地浏览和管理文件系统。</p>
<p>3.字符设备文件（c）：这类文件提供了对设备不带缓冲区的访问，每次访问长度可变。它们通常用于表示系统中的字符设备，如控制台、串口等。</p>
<p>4.块设备文件（b）：块设备文件提供对设备（如磁盘）带缓冲的访问，每次访问以固定的长度单位进行。它们用于表示系统中的块设备，如硬盘、U盘等。</p>
<p>5.FIFO（p）：FIFO文件也称为命名管道，用于进程间的通信。它们允许一个进程向另一个进程发送数据，而不需要通过中间的文件或网络连接。</p>
<p>6.套接字（s）：套接字文件用于进程间的网络通信。它们提供了一种在不同进程之间传输数据的方式，通常用于实现网络服务和客户端之间的通信。</p>
<p>7.链接文件（l）：链接文件是指向另一个文件的指针。它们可以分为硬链接和符号链接两种。硬链接指向文件的inode节点，而符号链接则指向另一个文件的路径名。通过链接文件，用户可以方便地访问其他文件或目录。</p>
<p>除了以上七种常见的文件类型外，Linux系统中还有其他一些特殊的文件类型，如特殊文件、门文件等，但这些类型在日常使用中相对较少见。</p>
</blockquote>
<p><strong>学习指引：</strong> <a href="https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fos%2F6_file_system%2Ffile_system.html%23%25E6%2596%2587%25E4%25BB%25B6%25E7%25B3%25BB%25E7%25BB%259F%25E7%259A%2584%25E5%259F%25BA%25E6%259C%25AC%25E7%25BB%2584%25E6%2588%2590">推荐学习：小林 coding|图解系统｜文件系统</a></p>
<h2 id="32-linux相关inode的作用inode包含哪些内容给出一个文件名linux是如何根据该文件名打开文件的文件名-inode-block文件的访问时间是如何记录的"><a class="markdownIt-Anchor" href="#32-linux相关inode的作用inode包含哪些内容给出一个文件名linux是如何根据该文件名打开文件的文件名-inode-block文件的访问时间是如何记录的"></a> 3.2 Linux相关：inode的作用？inode包含哪些内容？给出一个文件名，Linux是如何根据该文件名打开文件的？（文件名-&gt;inode-&gt;block）文件的访问时间是如何记录的？</h2>
<p><strong>解析：</strong>： 考察linux文件系统相关问题，比较细，推荐大家系统学习后理解掌握 <strong>参考回答：</strong></p>
<blockquote>
<p><strong>1.inode的作用？：</strong> inode，即索引节点，在Linux文件系统中用于存储文件或目录的元数据信息。它是文件系统的一个基本组成部分，允许系统通过inode号而非完整的文件路径快速访问到文件数据。</p>
<p><strong>2.inode包含哪些内容？：</strong> inode包含文件的元数据信息，如文件大小、文件所有者、文件权限、文件类型、文件的创建/访问/修改时间等。此外，inode还包含指向文件数据块的指针，这些指针指示了文件内容在磁盘上的实际存储位置。</p>
<p><mark><strong>3.给出一个文件名，Linux是如何根据该文件名打开文件的？</strong> <strong>（文件名-&gt;inode-&gt;block）</strong></mark>： 当给出一个文件名时，Linux首先会根据文件路径在目录结构中查找该文件对应的<mark>目录项</mark>。目录项中包含了文件的inode号。然后，系统会使用这个inode号在文件系统中找到对应的inode结构。一旦找到inode，系统就可以通过inode中的指针找到文件数据所在的磁盘块（block）。最后，系统将这些磁盘块加载到内存中，从而打开并访问文件。</p>
<p><strong>4.文件的访问时间是如何记录的</strong>？： 文件的访问时间是通过inode中的访问时间戳（atime）来记录的。每当文件被读取时，其inode中的atime就会被更新为当前时间。这个机制允许系统跟踪文件的访问历史，以便进行各种管理和维护操作。需要注意的是，为了优化性能，某些文件系统可能会延迟更新atime或仅在文件内容实际被读取时更新它。</p>
</blockquote>
<p><a href="https://www.nowcoder.com/discuss/590576768491216896?sourceSSR=users">阿里云 实习面经（已OC） 一面面经｜讲解_牛客网 (nowcoder.com)</a></p>
<h2 id="33-零拷贝是什么用来解决什么问题有哪些应用场景实现方式有哪些"><a class="markdownIt-Anchor" href="#33-零拷贝是什么用来解决什么问题有哪些应用场景实现方式有哪些"></a> 3.3 零拷贝是什么？用来解决什么问题？有哪些应用场景？实现方式有哪些？</h2>
<p><strong>解析：</strong>：</p>
<p><strong>参考回答：</strong></p>
<blockquote>
<p><strong>1.是什么？</strong>：零拷贝是一种IO操作优化技术，旨在减少数据在内核空间和用户空间之间的冗余拷贝，从而解放CPU、减少上下文切换并降低系统资源消耗。它主要用来解决传统IO操作中不必要的数据拷贝问题，提高数据传输效率。</p>
<p><strong>2.应用场景</strong>：零拷贝技术广泛应用于需要高性能数据传输的场景，如网络传输、文件传输、数据库操作等。在这些场景中，大量的数据需要在内核空间和用户空间之间传输，传统的IO操作会导致不必要的数据拷贝和性能损失。</p>
<p><strong>3.实现方式有哪些？</strong>：实现零拷贝的方式主要有mmap、sendfile、splice和tee等。其中，mmap通过内存映射将内核缓冲区与用户空间共享，避免了数据拷贝；sendfile直接将数据从内核缓冲区发送到网络缓冲区，减少了CPU拷贝；splice和tee则在内核空间内实现数据的传输和复制，避免了用户空间的参与。这些技术根据具体的应用场景和需求选择使用，可以有效地提高数据传输效率和系统性能。</p>
</blockquote>
<p><strong>学习指引：</strong> <a href="https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fos%2F8_network_system%2Fzero_copy.html">图解系统：什么是零拷贝？如何实现零拷贝？</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">数据库优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-26 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-26T00:00:00+08:00">2024-03-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-27 23:51:54" itemprop="dateModified" datetime="2024-08-27T23:51:54+08:00">2024-08-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1. 读写分离
2. 分库分表
3. 数据库查询优化</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/03/05/Java/%E6%BA%90%E7%A0%81/Java%E5%B9%B6%E5%8F%91%EF%BC%9AThreadPoolExecutor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/05/Java/%E6%BA%90%E7%A0%81/Java%E5%B9%B6%E5%8F%91%EF%BC%9AThreadPoolExecutor/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-03-05 20:42:29 / 修改时间：21:21:44" itemprop="dateCreated datePublished" datetime="2024-03-05T20:42:29+08:00">2024-03-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <pre class="highlight"><code class="java"><span class="hljs-comment">/**  
 * Executes the given task sometime in the future.  The task * may execute in a new thread or in an existing pooled thread. * * If the task cannot be submitted for execution, either because this * executor has been shutdown or because its capacity has been reached, * the task is handled by the current &#123;<span class="hljs-doctag">@code</span> RejectedExecutionHandler&#125;.  
 * * <span class="hljs-doctag">@param</span> command the task to execute  
 * <span class="hljs-doctag">@throws</span> RejectedExecutionException at discretion of  
 *         &#123;<span class="hljs-doctag">@code</span> RejectedExecutionHandler&#125;, if the task  
 *         cannot be accepted for execution * <span class="hljs-doctag">@throws</span> NullPointerException if &#123;<span class="hljs-doctag">@code</span> command&#125; is null  
 */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;  
    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)  
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();  
    <span class="hljs-comment">/*  
     * Proceed in 3 steps:     *     * 1. If fewer than corePoolSize threads are running, try to     * start a new thread with the given command as its first     * task.  The call to addWorker atomically checks runState and     * workerCount, and so prevents false alarms that would add     * threads when it shouldn't, by returning false.     *     * 2. If a task can be successfully queued, then we still need     * to double-check whether we should have added a thread     * (because existing ones died since last checking) or that     * the pool shut down since entry into this method. So we     * recheck state and if necessary roll back the enqueuing if     * stopped, or start a new thread if there are none.     *     * 3. If we cannot queue task, then we try to add a new     * thread.  If it fails, we know we are shut down or saturated     * and so reject the task.     */</span>    
    <span class="hljs-keyword">int</span> c = ctl.get();  
    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;  
        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))  
            <span class="hljs-keyword">return</span>;  
        c = ctl.get();  
    &#125;  
    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;  
        <span class="hljs-keyword">int</span> recheck = ctl.get();  
        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))  
            reject(command);  
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)  
            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);  
    &#125;  
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))  
        reject(command);  
&#125;
</code></pre>
<p><a href="https://www.throwx.cn/2020/08/23/java-concurrency-thread-pool-executor/">硬核干货：4W字从源码上分析JUC线程池ThreadPoolExecutor的实现原理 | Throwable (throwx.cn)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/03/04/Java/Java(3)%EF%BC%9A%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/04/Java/Java(3)%EF%BC%9A%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-04 10:11:52" itemprop="dateCreated datePublished" datetime="2024-03-04T10:11:52+08:00">2024-03-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-22 11:02:50" itemprop="dateModified" datetime="2024-09-22T11:02:50+08:00">2024-09-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ArrayList： 动态数组，实现了List接口，支持动态增长。<br />
LinkedList： 双向链表，也实现了List接口，支持快速的插入和删除操作。<br />
HashMap： 基于哈希表的Map实现，存储键值对，通过键快速查找值。<br />
HashSet： 基于HashMap实现的Set集合，用于存储唯一元素。<br />
TreeMap： 基于红黑树实现的有序Map集合，可以按照键的顺序进行排序。<br />
LinkedHashMap： 基于哈希表和双向链表实现的Map集合，保持插入顺序或访问顺序。<br />
PriorityQueue： 优先队列，可以按照比较器或元素的自然顺序进行排序。</p>
<p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 、 <code>Queue</code>。<br />
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405281131352.png" alt="image.png" /></p>
<ul>
<li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
<li><code>Set</code>(注重独一无二的性质): 存储的元素不可重复的。</li>
<li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，“x” 代表 key，“y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<table>
<thead>
<tr>
<th>集合</th>
<th>实现</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>List</td>
<td>ArrayList</td>
<td></td>
</tr>
<tr>
<td></td>
<td>vector</td>
<td><mark>线程安全</mark></td>
</tr>
<tr>
<td></td>
<td>LinkedList</td>
<td></td>
</tr>
<tr>
<td>Set</td>
<td>HashSet</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LinkedHashSet</td>
<td></td>
</tr>
<tr>
<td></td>
<td>TreeSet</td>
<td></td>
</tr>
<tr>
<td>Map</td>
<td>HashMap</td>
<td>线程不安全，key、value都可为null</td>
</tr>
<tr>
<td></td>
<td>LinkedHashMap</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HashTable</td>
<td><mark>线程安全</mark>，数组+链表组成的，数组是 HashTable 的主体，链表则是主要为了解决哈希冲突而存在的。HashTable 的加锁方法是给每个方法加上synchronized 关键字，不支持null键和值</td>
</tr>
<tr>
<td></td>
<td>TreeMap</td>
<td>红黑树</td>
</tr>
<tr>
<td></td>
<td>ConcurrentHashMap</td>
<td>Node数组+链表+红黑树实现，线程安全的（jdk1.8以前Segment锁，1.8以后volatile + CAS 或者 synchronized）</td>
</tr>
</tbody>
</table>
<p>Queue</p>
<ul>
<li>PriorityQueue</li>
<li>DelayQueue</li>
<li>ArrayDeque</li>
</ul>
<p><code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。</p>
<h1 id="1-list"><a class="markdownIt-Anchor" href="#1-list"></a> 1 List</h1>
<h2 id="11-arraylist和linkedlist区别"><a class="markdownIt-Anchor" href="#11-arraylist和linkedlist区别"></a> 1.1 ArrayList和LinkedList区别</h2>
<ol>
<li>
<p><strong>底层数据结构：</strong></p>
<ul>
<li><code>ArrayList</code>使用<em>动态数组</em>实现。它的内部是一个数组，当数组容量不足时，会自动进行扩容。</li>
<li><code>LinkedList</code>使用<em>双向链表</em>实现。每个元素都包含一个指向前一个元素和一个指向后一个元素的引用。</li>
</ul>
</li>
<li>
<p><strong>随机访问性能：</strong></p>
<ul>
<li><code>ArrayList</code>支持快速的随机访问，因为它是基于数组的，可以通过索引直接访问元素。</li>
<li><code>LinkedList</code>在随机访问时性能较差，因为必须从链表的头部或尾部开始遍历，直到找到目标元素。</li>
</ul>
</li>
<li>
<p><strong>插入和删除操作性能：</strong></p>
<ul>
<li><code>ArrayList</code>在中间插入或删除元素时性能较差，因为需要移动数组中的元素。</li>
<li><code>LinkedList</code>在插入和删除元素时性能较好，因为只需要改变相邻元素的引用。</li>
</ul>
</li>
<li>
<p><strong>空间复杂度：</strong></p>
<ul>
<li><code>ArrayList</code>相对较省空间，因为它只需要存储元素值和数组容量。</li>
<li><code>LinkedList</code>相对较耗费空间，因为每个元素都需要额外的两个引用字段。</li>
</ul>
</li>
<li>
<p><strong>迭代器性能：</strong></p>
<ul>
<li><code>ArrayList</code>上的迭代器性能较好，因为它可以通过索引直接访问元素。</li>
<li><code>LinkedList</code>上的迭代器性能较差，因为必须沿着链表一个一个地移动。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>如果需要频繁进行随机访问，使用<code>ArrayList</code>更为合适。</li>
<li>如果需要频繁进行插入和删除操作，特别是在集合的中间位置，使用<code>LinkedList</code>更为合适。</li>
</ul>
</li>
</ol>
<h1 id="2-set"><a class="markdownIt-Anchor" href="#2-set"></a> 2 Set</h1>
<h2 id="21-comparable和comparator"><a class="markdownIt-Anchor" href="#21-comparable和comparator"></a> 2.1 Comparable和Comparator</h2>
<p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p>
<ul>
<li><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<h2 id="22-hashset-linkedhashset-treeset"><a class="markdownIt-Anchor" href="#22-hashset-linkedhashset-treeset"></a> 2.2 Hashset、LinkedHashSet、TreeSet</h2>
<ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
<h1 id="3-map"><a class="markdownIt-Anchor" href="#3-map"></a> 3 Map</h1>
<h2 id="31-hashmap和treemap"><a class="markdownIt-Anchor" href="#31-hashmap和treemap"></a> 3.1 HashMap和TreeMap</h2>
<p><strong>相比于<code>HashMap</code>来说， <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>
<h2 id="32-hashmap"><a class="markdownIt-Anchor" href="#32-hashmap"></a> 3.2 HashMap</h2>
<blockquote>
<p>[!note]<br />
JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突），JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间</p>
</blockquote>
<p>在 JDK 1.7 版本之前， HashMap 数据结构是数组和链表，HashMap通过哈希算法将元素的键（Key）映射到数组中的槽位（Bucket）。如果多个键映射到同一个槽位，它们会以链表的形式存储在同一个槽位上，因为链表的查询时间是O(n)，所以冲突很严重，一个索引上的链表非常长，效率就很低了。</p>
<h3 id="321-哈希冲突解决方式"><a class="markdownIt-Anchor" href="#321-哈希冲突解决方式"></a> 3.2.1 哈希冲突解决方式</h3>
<ul>
<li>链接法：使用链表或其他数据结构来存储冲突的键值对，将它们链接在同一个哈希桶中。</li>
<li>开放寻址法：在哈希表中找到另一个可用的位置来存储冲突的键值对，而不是存储在链表中。常见的开放寻址方法包括线性探测、二次探测和双重散列。</li>
<li>再哈希法（Rehashing）：当发生冲突时，使用另一个哈希函数再次计算键的哈希值，直到找到一个空槽来存储键值对。</li>
<li>哈希桶扩容：当哈希冲突过多时，可以动态地扩大哈希桶的数量，重新分配键值对，以减少冲突的概率。</li>
</ul>
<h3 id="322-hashcode和equals"><a class="markdownIt-Anchor" href="#322-hashcode和equals"></a> 3.2.2 hashcode和equals</h3>
<p>equals相等的两个对象，hashCode一定相等。hashCode相等的两个对象，equals不一定相等</p>
<h3 id="323-扩容机制"><a class="markdownIt-Anchor" href="#323-扩容机制"></a> 3.2.3 扩容机制</h3>
<ol>
<li>
<p><strong>初始容量和负载因子：</strong></p>
<ul>
<li><code>HashMap</code> 有一个初始容量和一个负载因子。初始容量是哈希表在创建时的容量，默认为 16。负载因子是一个在哈希表大小超过其容量乘以负载因子时，哈希表将进行扩容的阈值，默认为 0.75。</li>
</ul>
</li>
<li>
<p><strong>扩容操作：</strong></p>
<ul>
<li>当哈希表的元素个数达到了负载因子所定义的阈值，<code>HashMap</code> 将进行扩容操作。</li>
<li>扩容操作包括创建一个新的哈希表，其容量为原容量的两倍，然后将所有元素重新分配到新的哈希表中。<br />
<a href="https://zhuanlan.zhihu.com/p/114363420">HashMap的扩容机制 - 知乎 (zhihu.com)</a><br />
<a href="https://blog.csdn.net/qq_49217297/article/details/126304736">HashMap实现原理， 扩容机制，面试题和总结_hashmap扩容机制面试-CSDN博客</a></li>
</ul>
</li>
</ol>
<h3 id="324-hashmap多线程导致死循环"><a class="markdownIt-Anchor" href="#324-hashmap多线程导致死循环"></a> 3.2.4 HashMap多线程导致死循环</h3>
<p>当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，<code>头插法</code>可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。<br />
为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。</p>
<p><a href="https://coolshell.cn/articles/9606.html">疫苗：Java HashMap的死循环 | 酷 壳 - CoolShell</a></p>
<h3 id="325-hashmap为什么线程不安全"><a class="markdownIt-Anchor" href="#325-hashmap为什么线程不安全"></a> 3.2.5 HashMap为什么线程不安全</h3>
<p>多线程环境下，<code>HashMap</code> 扩容时会造成<code>死循环</code> 和<code>数据丢失</code>的问题。<br />
在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对<code>HashMap</code>的put操作会导致线程不安全，可能产生数据覆盖.<br />
数据不一致</p>
<h4 id="3231-同时检测到桶位置为空插入元素"><a class="markdownIt-Anchor" href="#3231-同时检测到桶位置为空插入元素"></a> 3.2.3.1 同时检测到桶位置为空，插入元素</h4>
<ul>
<li>两个线程同时进行put操作，并且存在哈希冲突</li>
<li>由于线程首先都执行完了hash碰撞的判断，桶为空</li>
<li>每个线程再向空桶中插入元素</li>
</ul>
<pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;
    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,
                   <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// 判断是否出现 hash 碰撞</span>
    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>
    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)
        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);
    <span class="hljs-comment">// 桶中已经存在元素（处理hash冲突）</span>
    <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">// ...</span>
&#125;
</code></pre>
<h4 id="3232-多个线程同时put操作导致size不正确"><a class="markdownIt-Anchor" href="#3232-多个线程同时put操作导致size不正确"></a> 3.2.3.2 多个线程同时put操作导致size不正确</h4>
<ul>
<li>两个线程都先获取size，在++size</li>
<li>添加两次元素，而size只增加1</li>
</ul>
<pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;
    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,
                   <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// 实际大小大于阈值则扩容</span>
    <span class="hljs-keyword">if</span> (++size &gt; threshold)
        resize();
    <span class="hljs-comment">// 插入后回调</span>
    afterNodeInsertion(evict);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;

</code></pre>
<p><a href="https://zhuanlan.zhihu.com/p/484653028">基于JDK8的HashMap实现(万字详解) - 知乎 (zhihu.com)</a></p>
<h3 id="326-底层实现"><a class="markdownIt-Anchor" href="#326-底层实现"></a> 3.2.6 底层实现</h3>
<p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当<mark>链表长度大于阈值（默认为 8）</mark>（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<h3 id="327-put添加元素过程"><a class="markdownIt-Anchor" href="#327-put添加元素过程"></a> 3.2.7 put添加元素过程</h3>
<ol>
<li>
<p><strong>计算哈希码（Hash Code）：</strong></p>
<ul>
<li>当你向 <code>HashSet</code> 中添加一个元素时，首先会调用该元素的 <code>hashCode()</code> 方法，得到元素的哈希码。</li>
<li>如果元素为 <code>null</code>，则它的哈希码为 0。</li>
</ul>
</li>
<li>
<p><strong>映射到桶位置（Bucket Position）：</strong></p>
<ul>
<li>哈希码经过一系列的变换和运算，被映射到哈希表中的一个桶位置（bucket position）。</li>
<li>桶位置是一个数组索引，表示存储元素的位置。</li>
</ul>
</li>
<li>
<p><strong>处理哈希冲突：</strong></p>
<ul>
<li>哈希表可能存在冲突，即不同元素映射到相同的桶位置。为了解决冲突，<code>HashSet</code> 使用链表或红黑树（在JDK 8之后）来存储相同桶位置上的元素。</li>
<li>如果桶位置上已经有一个元素，新元素会被添加到链表或红黑树的末尾。</li>
</ul>
</li>
<li>
<p><strong>检查元素唯一性：</strong></p>
<ul>
<li>在添加元素的过程中，<code>HashSet</code> 会通过调用元素的 <code>equals()</code> 方法来检查元素的唯一性。</li>
<li>如果已经存在相同的元素（根据 <code>equals()</code> 判断），新元素不会被加入。</li>
</ul>
</li>
</ol>
<h3 id="328-如何做到让hashmap线程安全"><a class="markdownIt-Anchor" href="#328-如何做到让hashmap线程安全"></a> 3.2.8 如何做到让HashMap线程安全</h3>
<ol>
<li>
<p><strong>使用<code>Collections.synchronizedMap</code>方法：</strong><br />
Map&lt;K, V&gt; synchronizedMap = Collections.synchronizedMap(new HashMap&lt;K, V&gt;());</p>
<p>这将返回一个线程安全的<code>Map</code>，它在每个方法上都使用同步机制来确保线程安全。但请注意，虽然这确保了每个方法的原子性，但在多个操作之间，仍然可能需要额外的同步。</p>
</li>
<li>
<p><strong>使用<code>ConcurrentHashMap</code>：</strong> <code>ConcurrentHashMap</code>是Java提供的线程安全的<code>Map</code>实现。它使用分段锁机制，每个段相当于一个小的<code>HashMap</code>，不同的段之间互不影响，这样可以提高并发性能。</p>
<p>Map&lt;K, V&gt; concurrentMap = new ConcurrentHashMap&lt;K, V&gt;();</p>
</li>
</ol>
<h2 id="33-concurrenthashmap"><a class="markdownIt-Anchor" href="#33-concurrenthashmap"></a> 3.3 ConcurrentHashMap</h2>
<blockquote>
<p>[!note]<br />
ConcurrentHashMap：Node数组+链表+红黑树实现，线程安全的（jdk1.8以前Segment锁，1.8以后volatile + CAS 或者 synchronized）</p>
</blockquote>
<h3 id="331-jdk-17"><a class="markdownIt-Anchor" href="#331-jdk-17"></a> 3.3.1 JDK 1.7</h3>
<blockquote>
<p>Segment数组，通过分段锁（Segmentation）实现线程安全。它将整个哈希表分成多个段（Segment），每个段都是一个小的哈希表，并且拥有自己的锁。这样，多个线程可以并发地访问不同的段，从而减少了锁的竞争，提高了并发性能。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404012148392.png" alt="image.png" /></p>
<h3 id="332-jdk-18"><a class="markdownIt-Anchor" href="#332-jdk-18"></a> 3.3.2 JDK 1.8</h3>
<p>在 JDK 1.7 中它使用的是数组加链表的形式实现的，而数组又分为：大数组 Segment 和小数组 HashEntry。 Segment 是一种可重入锁（ReentrantLock），在 ConcurrentHashMap 里扮演锁的角色；HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素。</p>
<p>直接在table元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率。</p>
<ul>
<li>对于put操作，如果Key对应的数组元素为null，则通过CAS操作（Compare and Swap）将其设置为当前值。</li>
<li>如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，则对该元素使用 synchronized 关键字申请锁，然后进行操作。</li>
<li>如果该 put 操作使得当前链表长度超过一定阈值，则将该链表转换为红黑树，从而提高寻址效率。</li>
</ul>
<blockquote>
<p>使用了一种更细粒度的锁策略，结合CAS（Compare-and-Swap）无锁算法来实现线程安全。在JDK 1.8中，ConcurrentHashMap将整个哈希表看作一个整体，不再进行分段。而是通过<mark>Node数组+链表+红黑树</mark>的结构来存储数据，并使用Synchronized和CAS来协调并发访问。</p>
</blockquote>
<p>锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。<br />
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404012149783.png" alt="image.png" /></p>
<h3 id="333-jdk-17-和-jdk-18-的-concurrenthashmap-实现有什么不同"><a class="markdownIt-Anchor" href="#333-jdk-17-和-jdk-18-的-concurrenthashmap-实现有什么不同"></a> 3.3.3 JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h3>
<ul>
<li><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li>
<li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</li>
<li><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li>
</ul>
<p><a href="https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html#_4-get">ConcurrentHashMap 源码分析 | JavaGuide</a><br />
<a href="https://zhuanlan.zhihu.com/p/94976168">一文彻底搞懂CAS实现原理 &amp; 深入到CPU指令 - 知乎 (zhihu.com)</a><br />
<a href="https://javaguide.cn/java/collection/java-collection-questions-02.html#map-%E9%87%8D%E8%A6%81">Java集合常见面试题总结(下) | JavaGuide</a></p>
<h1 id="4-atomic"><a class="markdownIt-Anchor" href="#4-atomic"></a> 4 Atomic</h1>
<p><code>java.util.concurrent.atomic</code> 包提供了一组用于在多线程环境中进行原子操作的类。这些类通过使用硬件级别的原子性操作或者利用 <code>sun.misc.Unsafe</code> 提供的 CAS（Compare-And-Swap）操作来确保对变量的操作是原子的。这些类大多数都是基于原始数据类型的，例如 <code>int</code>、<code>long</code>，还有一些是引用类型。</p>
<p>以下是 <code>java.util.concurrent.atomic</code> 包中一些主要的类以及它们的用途：</p>
<ol>
<li>
<p><strong>AtomicInteger：</strong> 用于对整数进行原子操作，支持原子的自增（<code>incrementAndGet()</code>）、自减（<code>decrementAndGet()</code>）等操作。</p>
</li>
<li>
<p><strong>AtomicLong：</strong> 用于对长整型进行原子操作，同样支持原子的自增、自减等操作。</p>
</li>
<li>
<p><strong>AtomicBoolean：</strong> 用于对布尔类型进行原子操作，支持原子的设置和获取操作。</p>
</li>
<li>
<p><strong>AtomicReference：</strong> 用于对引用类型进行原子操作，支持原子的获取和设置引用对象。</p>
</li>
<li>
<p><strong>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray：</strong> 用于对数组中的元素进行原子操作，提供了一些原子性的数组操作。</p>
</li>
<li>
<p><strong>AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater：</strong> 用于对类的字段进行原子更新，允许在并发环境中对对象的字段进行原子性操作。</p>
</li>
</ol>
<p>这些原子类提供了一种比使用 <code>synchronized</code> 关键字更轻量级的线程安全机制，特别适用于一些简单的计数器、状态标志等场景。在需要进行原子操作而又不需要全局的锁的情况下，这些类可以提供更好的性能。</p>
<p>虽然这些类提供了原子性的操作，但并不是所有的操作都可以用原子方式完成，因此在使用时仍然需要注意保证原子性的操作是否符合预期。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/02/28/%E6%A1%86%E6%9E%B6/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91(1)%EF%BC%9A%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/28/%E6%A1%86%E6%9E%B6/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91(1)%EF%BC%9A%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">Java：并发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-28 00:00:00" itemprop="dateCreated datePublished" datetime="2024-02-28T00:00:00+08:00">2024-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-22 00:03:24" itemprop="dateModified" datetime="2024-09-22T00:03:24+08:00">2024-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>线程、锁、条件变量</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/02/28/%E6%A1%86%E6%9E%B6/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91(1)%EF%BC%9A%E5%B9%B6%E5%8F%91/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/02/22/%E9%A1%B9%E7%9B%AE/MIT6.824%20Lab3%20KVraft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/22/%E9%A1%B9%E7%9B%AE/MIT6.824%20Lab3%20KVraft/" class="post-title-link" itemprop="url">MIT6.824 Lab3 KVraft</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-22 16:28:21" itemprop="dateCreated datePublished" datetime="2024-02-22T16:28:21+08:00">2024-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-02 21:28:29" itemprop="dateModified" datetime="2024-03-02T21:28:29+08:00">2024-03-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="bug"><a class="markdownIt-Anchor" href="#bug"></a> Bug</h1>
<h3 id="1-panic-close-of-closed-channel"><a class="markdownIt-Anchor" href="#1-panic-close-of-closed-channel"></a> 1. <code>panic: close of closed channel</code></h3>
<p>在server中，只使用了一个全局的管道来接收命令应用结果，PutAppend和Get共享一个管道，两个分别打开管道，随后一个关闭，另一个在关闭时出现问题</p>
<ul>
<li>给两个操作加锁，只有操作执行完（成功执行，超时）才解锁</li>
<li>对Start返回的index，每一个添加一个管道</li>
</ul>
<h2 id="2-command被复制到半数以上服务器但是还没有在状态机上执行然后选举出新的leader新的leader具有添加的命令"><a class="markdownIt-Anchor" href="#2-command被复制到半数以上服务器但是还没有在状态机上执行然后选举出新的leader新的leader具有添加的命令"></a> 2. command被复制到半数以上服务器，但是还没有在状态机上执行，然后选举出新的leader，新的leader具有添加的命令</h2>
<p>在Lab2就想到的问题，一直考虑已经被添加的command如何被再次添加，发现在raft层无法解决这个问题。</p>
<p>在Lab3中遇到了此问题，考虑在server中记录client已经添加的命令（命令可能未执行成功），在收到更小的command时，则不调用Start添加到leader。这需要启用新的server作为leader时，快速将已有的命令执行完毕（在添加任何新命令之前），这一步难以实现。</p>
<p>因此考虑在command中添加client的命令标志，重传的命令也可以被添加到log中，但是在执行时会发现该命令已经执行过</p>
<p>命令没有被执行 TestManyPartitionsManyClients3A</p>
<pre class="highlight"><code class="">=== RUN   TestManyPartitionsManyClients3A
Test: partitions, many clients (3A) ...

</code></pre>
<p>命令结果有额外部分（多执行了？）TestConcurrent3A</p>
<pre class="highlight"><code class="">Test: unreliable net, restarts, partitions, random keys, many clients (3A) ...
info: wrote history visualization to /tmp/1021001197.html
    test_test.go:382: history is not linearizable
--- FAIL: TestPersistPartitionUnreliableLinearizable3A (30.13s)
</code></pre>
<h2 id="3-并发读写map"><a class="markdownIt-Anchor" href="#3-并发读写map"></a> 3. 并发读写map</h2>
<p><code>fatal error: concurrent map read and map write</code></p>
<pre class="highlight"><code class="go">replyCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> ApplierResult, <span class="hljs-number">1</span>)
kv.appliedCh[index] = replyCh
<span class="hljs-comment">//kv.appliedCh[index] = make(chan ApplierResult, 1)</span>
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/02/20/%E6%A1%86%E6%9E%B6/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/20/%E6%A1%86%E6%9E%B6/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-20 23:12:29" itemprop="dateCreated datePublished" datetime="2024-02-20T23:12:29+08:00">2024-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-26 23:34:50" itemprop="dateModified" datetime="2024-08-26T23:34:50+08:00">2024-08-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</strong></p>
</blockquote>
<h1 id="1-cap理论"><a class="markdownIt-Anchor" href="#1-cap理论"></a> 1 CAP理论</h1>
<p><strong>CAP</strong> 也就是 <strong>Consistency（一致性）</strong>、<strong>Availability（可用性）</strong>、<strong>Partition Tolerance（分区容错性）</strong></p>
<ul>
<li><strong>一致性（Consistency）</strong> : 所有节点访问同一份最新的数据副本</li>
<li><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li>
<li><strong>分区容错性（Partition Tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li>
</ul>
<p>Quorum机制（法定人数机制<br />
<strong>分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。</strong> 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p>
<h1 id="2-数据一致性"><a class="markdownIt-Anchor" href="#2-数据一致性"></a> 2 数据一致性</h1>
<p>一些分布式系统通过复制数据来提高系统的可靠性和容错性，并且将数据的不同的副本存放在不同的机器，由于维护数据副本的一致性代价高，因此许多系统<strong>采用弱一致性来提高性能</strong>，一些不同的一致性模型也相继被提出。</p>
<ul>
<li><strong>强一致性</strong>： 要求无论更新操作实在哪一个副本执行，之后所有的读操作都要能获得最新的数据。</li>
<li><strong>弱一致性</strong>：用户读到某一操作对系统特定数据的更新需要一段时间，我们称这段时间为“不一致性窗口”。</li>
<li><strong>最终一致性</strong>：是弱一致性的一种特例，保证用户**最终（即窗口尽量长）**能够读取到某操作对系统特定数据的更新。</li>
</ul>
<blockquote>
<p>[!question] 分布式一致性(缓存与数据库一致性)</p>
<ol>
<li>分布式事务：两段提交</li>
<li>分布式锁</li>
<li>消息队列、消息持久化、重试、幂等操作</li>
<li>Raft / Paxos 等一致性算法</li>
</ol>
</blockquote>
<h1 id="3-base理论"><a class="markdownIt-Anchor" href="#3-base理论"></a> 3 BASE理论</h1>
<p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong>、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。</p>
<h2 id="31-基本可用"><a class="markdownIt-Anchor" href="#31-基本可用"></a> 3.1 基本可用</h2>
<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p>
<p><strong>什么叫允许损失部分可用性呢？</strong></p>
<ul>
<li><strong>响应时间上的损失</strong>: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li>
<li><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li>
</ul>
<h2 id="32-软状态"><a class="markdownIt-Anchor" href="#32-软状态"></a> 3.2 <a href="#%E8%BD%AF%E7%8A%B6%E6%80%81">软状态</a></h2>
<p>软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<h2 id="33-最终一致性"><a class="markdownIt-Anchor" href="#33-最终一致性"></a> 3.3 <a href="#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7">最终一致性</a></h2>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<blockquote>
<p>分布式一致性的 3 种级别：</p>
<ol>
<li><strong>强一致性</strong>：系统写入了什么，读出来的就是什么。</li>
<li><strong>弱一致性</strong>：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</li>
<li><strong>最终一致性</strong>：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li>
</ol>
<p><strong>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</strong></p>
</blockquote>
<h1 id="4-共识算法"><a class="markdownIt-Anchor" href="#4-共识算法"></a> 4 共识算法</h1>
<blockquote>
<p>共识算法的作用是让分布式系统中的多个节点之间对某个提案（Proposal）达成一致的看法。提案的含义在分布式系统中十分宽泛，像哪一个节点是 Leader 节点、多个事件发生的顺序等等都可以是一个提案。</p>
</blockquote>
<p>共识是可容错系统中的一个基本问题：即使面对故障，服务器也可以在共享状态上达成一致。</p>
<p>共识算法允许一组节点像一个整体一样一起工作，即使其中的一些节点出现故障也能够继续工作下去，其正确性主要是源于复制状态机的性质：一组<code>Server</code>的状态机计算相同状态的副本，即使有一部分的<code>Server</code>宕机了它们仍然能够继续运行。<br />
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402232043613.png" alt="image.png" /></p>
<p><a href="https://javaguide.cn/distributed-system/protocol/raft-algorithm.html">https://javaguide.cn/distributed-system/protocol/raft-algorithm.html</a></p>
<h1 id="5-basic-paxos-算法"><a class="markdownIt-Anchor" href="#5-basic-paxos-算法"></a> 5 Basic Paxos 算法</h1>
<ul>
<li><strong>提议者（Proposer）</strong>：也可以叫做协调者（coordinator），提议者负责接受客户端的请求并发起提案。提案信息通常包括提案编号 (Proposal ID) 和提议的值 (Value)。</li>
<li><strong>接受者（Acceptor）</strong>：也可以叫做投票员（voter），负责对提议者的提案进行投票，同时需要记住自己的投票历史；</li>
<li><strong>学习者（Learner）</strong>：如果有超过半数接受者就某个提议达成了共识，那么学习者就需要接受这个提议，并就该提议作出运算，然后将运算结果返回给客户端。<br />
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405211456396.png" alt="image.png|450" /></li>
</ul>
<h1 id="6-raft"><a class="markdownIt-Anchor" href="#6-raft"></a> 6 Raft</h1>
<h2 id="61-基础"><a class="markdownIt-Anchor" href="#61-基础"></a> 6.1 基础</h2>
<h3 id="611-节点类型"><a class="markdownIt-Anchor" href="#611-节点类型"></a> 6.1.1 节点类型</h3>
<ul>
<li><code>Leader</code>：负责发起心跳，响应客户端，创建日志，同步日志。</li>
<li><code>Candidate</code>：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。</li>
<li><code>Follower</code>：接受 Leader 的心跳和日志同步数据，投票给 Candidate。</li>
</ul>
<h3 id="612-任期"><a class="markdownIt-Anchor" href="#612-任期"></a> 6.1.2 任期</h3>
<h3 id="613-日志"><a class="markdownIt-Anchor" href="#613-日志"></a> 6.1.3 日志</h3>
<h2 id="62-领导人选举"><a class="markdownIt-Anchor" href="#62-领导人选举"></a> 6.2 领导人选举</h2>
<p>raft 使用心跳机制来触发 Leader 的选举。</p>
<p>如果一台服务器能够收到来自 Leader 或者 Candidate 的有效信息，那么它会一直保持为 Follower 状态，并且刷新自己的 electionElapsed，重新计时。</p>
<p>Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。如果一个 Follower 在一个周期内没有收到心跳信息，就叫做选举超时，然后它就会认为此时没有可用的 Leader，并且开始进行一次选举以选出一个新的 Leader。</p>
<h2 id="63-日志复制"><a class="markdownIt-Anchor" href="#63-日志复制"></a> 6.3 日志复制</h2>
<p>一旦选出了 Leader，它就开始接受客户端的请求。每一个客户端的请求都包含一条需要被复制状态机（<code>Replicated State Machine</code>）执行的命令。</p>
<p>Leader 收到客户端请求后，会生成一个 entry，包含<code>&lt;index,term,cmd&gt;</code>，再将这个 entry 添加到自己的日志末尾后，向所有的节点广播该 entry，要求其他服务器复制这条 entry。</p>
<p>如果 Follower 接受该 entry，则会将 entry 添加到自己的日志后面，同时返回给 Leader 同意。</p>
<p>如果 Leader 收到了多数的成功响应，Leader 会将这个 entry 应用到自己的状态机中，之后可以称这个 entry 是 committed 的，并且向客户端返回执行结果。</p>
<p>raft 保证以下两个性质：</p>
<ul>
<li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd</li>
<li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同</li>
</ul>
<h1 id="7-主从-集群-分布式的区别"><a class="markdownIt-Anchor" href="#7-主从-集群-分布式的区别"></a> 7 主从、集群、分布式的区别</h1>
<ul>
<li>分布式：多个系统协同合作完成一个特定任务的系统。分布式是解决中心化管理的问题，把所有的任务叠加到一个节点处理，太慢了。所以把一个大的问题拆分为多个小的问题，并分别解决，最终协同合作。分布式的主要工作是分解任务，将职能拆解。</li>
<li>集群：集群主要的使用场景是为了分担请求的压力，也就是在几个服务器上部署相同的应用程序，来分担客户端请求。当压力进一步增大的时候，可能在需要存储的部分，mysql 无法面对很多的写压力。因为在 mysql 做成集群之后，主要的写压力还是在 master 的机器上面，其他 slave 机器无法分担写压力，从而这个时候，也就引出来分布式。</li>
</ul>
<p><strong>将一套系统拆分成不同子系统部署在不同服务器上（这叫分布式），</strong></p>
<p><strong>然后部署多个相同的子系统在不同的服务器上（这叫集群），部署在不同服务器上的同一个子系统应做负载均衡。</strong></p>
<p><strong>分布式：一个业务拆分为多个子业务，部署在多个服务器上 。</strong></p>
<p><strong>集群：同一个业务，部署在多个服务器上 。</strong></p>
<p>主从、集群和分布式是计算机系统中常见的架构模式，它们有不同的特点和用途：</p>
<ol>
<li>主从（Master-Slave）：
<ul>
<li>主从架构是一种单点控制的架构，其中有一个主节点和一个或多个从节点。</li>
<li>主节点通常负责处理所有的请求和决策，而从节点用于执行主节点分派的任务或保存数据的备份副本。</li>
<li>主从架构通常用于提高系统的可用性和容错性。如果主节点失败，可以将其中一个从节点提升为主节点，以保持系统的运行。</li>
<li>主从架构适用于那些需要单一决策权和数据同步的应用，如数据库复制、负载均衡等。</li>
</ul>
</li>
<li>集群（Cluster）：
<ul>
<li><strong>集群是由多个节点组成的计算机系统</strong>，这些节点共同协作以提供某种服务或功能。</li>
<li>集群节点通常是对等的，它们可以相互协作，共同处理请求，以提高性能和容错性。</li>
<li>集群可以用于各种用途，包括负载均衡、高可用性、并行计算等。</li>
<li>集群可以是对称的（每个节点都具有相同的角色和功能）或非对称的（某些节点具有特殊的角色，如主节点）。</li>
</ul>
</li>
<li>分布式（Distributed）：
<ul>
<li>分布式架构是指系统的组件分布在多个地理位置或计算节点上，它们通过网络通信协同工作。</li>
<li>分布式系统的目标是提高性能、扩展性和可用性，允许系统在多个节点上并行执行任务。</li>
<li>分布式系统可以包括多个集群，每个集群可能都有自己的主从结构，以满足系统的需求。</li>
<li>分布式系统通常需要处理分布式计算、数据同步、一致性和容错性等复杂问题。</li>
</ul>
</li>
</ol>
<p>总之，主从是一种单点控制的架构，集群是多个节点共同协作的架构，分布式是多个节点分布在不同地方并通过网络通信协同工作的架构。这些不同的架构模式在不同的应用场景中有不同的优点和局限性。选择哪种架构取决于应用的需求和目标。</p>
<p>集群是个物理形态，分布式是个工作方式。分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务数来提升效率。<br />
分布式：一个业务分拆多个子业务，部署在不同的服务器上。<br />
集群：同一个业务，部署在多个服务器上</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/02/01/%E9%A1%B9%E7%9B%AE/MIT6.824%20Lab2%20Raft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/01/%E9%A1%B9%E7%9B%AE/MIT6.824%20Lab2%20Raft/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-01 14:23:48" itemprop="dateCreated datePublished" datetime="2024-02-01T14:23:48+08:00">2024-02-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-24 15:21:52" itemprop="dateModified" datetime="2024-05-24T15:21:52+08:00">2024-05-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>term(任期)</p>
<p>Leader发出heartbeat(AppendEntries RPC不带有log entries)</p>
<blockquote>
<p>Raft is a consensus algorithm that is designed to be easy to understand. It’s equivalent to Paxos in fault-tolerance and performance.</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402052155568.jpg" alt="QQ图片20240205215524.jpg" /></p>
<h1 id="2a-leader-election领导人选举"><a class="markdownIt-Anchor" href="#2a-leader-election领导人选举"></a> 2A Leader election(领导人选举)</h1>
<ul>
<li>网络延迟、分区、包丢失、复制和重新排序。</li>
</ul>
<blockquote>
<p>This election term will continue until a follower stops receiving heartbeats and becomes a candidate.</p>
</blockquote>
<p>导致Follower进行选举的原因</p>
<ul>
<li>网络延迟或者包丢失没有在选举超时前收到心跳</li>
<li>网络分区而导致收不到心跳（disconnect）</li>
<li>Leader宕机、崩溃（crash）</li>
</ul>
<h2 id="1-节点类型"><a class="markdownIt-Anchor" href="#1-节点类型"></a> 1. 节点类型</h2>
<ul>
<li><code>Leader</code>：负责发起心跳，响应客户端，创建日志，同步日志。</li>
<li><code>Candidate</code>：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。</li>
<li><code>Follower</code>：接受 Leader 的心跳和日志同步数据，投票给 Candidate。态转换</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402031102578.png" alt="image-20240203110252535" /></p>
<ul>
<li>Follower<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>Candidate（超时：一段时间内未收到heartbeat）</li>
</ul>
<p>Leader(AppendEntries RPC)</p>
<ul>
<li>term过时：
<ul>
<li>发送心跳发现Server的term号大于自身的term号（已经选出新的Leader，将自己状态变为Follower）</li>
<li>收到RequestVote发现更高term号</li>
</ul>
</li>
</ul>
<p>Candidate(RequestVote RPC)</p>
<ul>
<li>term过时
<ul>
<li>收到新的Leader的心跳，请求投票时发现大于自身的term号</li>
<li>收到RequestVote RPC的response，返回的term号更大</li>
</ul>
</li>
</ul>
<p>Follower：被动的，对来自Leader和Candidate的请求进行相应</p>
<ul>
<li>收到Leader的心跳，且term号大于自身term号（更新自身term号）</li>
<li>收到Candidate请求</li>
</ul>
<p>Server：</p>
<ul>
<li>拒绝过时term的请求</li>
</ul>
<h2 id="选举超时时间和心跳时间"><a class="markdownIt-Anchor" href="#选举超时时间和心跳时间"></a> 选举超时时间和心跳时间</h2>
<ul>
<li>
<p>心跳间隔时间(heartbeat timeout)：Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。</p>
</li>
<li>
<p>选举超时时间(election timeout)：如果一个 Follower 在一个周期内没有收到心跳信息或者请求投票信息，就叫做选举超时，并开始一次新的选举。</p>
</li>
</ul>
<p>这两个时间需要保持一定的关系，网络无故障时，在选举超时前应该收到心跳，以保持Leader不变。选举超时时间至少需要大于AppendEntries RPC发送到server所需的最长时间。</p>
<h3 id="选举超时时间更新"><a class="markdownIt-Anchor" href="#选举超时时间更新"></a> 选举超时时间更新</h3>
<ul>
<li>candidate成为leader</li>
<li>candidate收到RequestVote response并变为follower</li>
<li>server收到AppendEntries</li>
<li>server收到RequestVote</li>
<li>leader收到AppendEntries response发现更高term号</li>
</ul>
<h3 id="超时选举实现"><a class="markdownIt-Anchor" href="#超时选举实现"></a> 超时选举实现</h3>
<p>在raft结构体中定义laskAcktime，在收到leader的heartbeat或者candidate的投票请求时，要更新选举超时时间<br />
这里没有通过定时器在到达选举超时时间后触发选举操作，而是首先记录下当前时间，然后让ticker协程sleep一段时间。当再次唤醒后，如果laskAcktime在startTime之后，说明在选举超时前收到了相关信号。<br />
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402272153075.png" alt="image.png" /></p>
<h2 id="注意点"><a class="markdownIt-Anchor" href="#注意点"></a> 注意点</h2>
<h3 id="sendappendentries没有启用新的协程"><a class="markdownIt-Anchor" href="#sendappendentries没有启用新的协程"></a> <code>sendAppendEntries</code>没有启用新的协程</h3>
<p>在<code>sendHeartbeat</code>中，异步发送<code>sendAppendEntries</code>，向所有server发送heartbeat，无需等待RPC完成。因为leader可能无法与其他server通信，或者server不可达，由于等待rpc返回，造成超时重新选举</p>
<p>异步发送<code>RequestVote</code>，并且收到超过半数选票后就成为Leader，发送心跳</p>
<p><code>go test -race -run 2A</code></p>
<h1 id="2b-log-replication日志复制"><a class="markdownIt-Anchor" href="#2b-log-replication日志复制"></a> 2B Log replication(日志复制)</h1>
<blockquote>
<p><mark><strong>Leader Completeness</strong></mark>: if a log entry is committed in a given term, then that entry will be present in the logs of the leaders for all higher-numbered terms. §5.4<br />
<mark><strong>State Machine Safety</strong></mark>: if a server has applied a log entry at a given index to its state machine, no other server will ever apply a different log entry for the same index. §5.4.3</p>
</blockquote>
<ul>
<li>leader收到client请求，将entry添加到log</li>
<li>leader将添加的entry复制到其他server</li>
<li>如果大多数server成功复制entry，则该entry已经committed</li>
<li></li>
<li>已经committed的entry需要应用到机器上，lastApplied代表已经执行的命令</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402061214812.png" alt="Raft-第 1 页.png" /></p>
<h2 id="election-restriction541"><a class="markdownIt-Anchor" href="#election-restriction541"></a> Election restriction(5.4.1)</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402041429181.png" alt="Raft-第 2 页.png" /></p>
<p>log backtracking</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402061305538.png" alt="Raft-加速log回溯" /></p>
<p>S1首先成为leader，成功发送了第一个entry</p>
<p>S1和S2与其他服务器断开后重连</p>
<h2 id="注意点-2"><a class="markdownIt-Anchor" href="#注意点-2"></a> 注意点</h2>
<blockquote>
<p>遇到的bug</p>
</blockquote>
<p>s1断联，添加了一系列entry</p>
<p>重连后，新的leader通过heartbeat更新了s1的commitindex，而此时s1的log还未更新</p>
<h1 id="2c"><a class="markdownIt-Anchor" href="#2c"></a> 2C</h1>
<pre class="highlight"><code class="go">persist
<span class="hljs-comment">// Your code here (2C).</span>
<span class="hljs-comment">// Example:</span>
<span class="hljs-comment">// w := new(bytes.Buffer)</span>
<span class="hljs-comment">// e := labgob.NewEncoder(w)</span>
<span class="hljs-comment">// e.Encode(rf.xxx)</span>
<span class="hljs-comment">// e.Encode(rf.yyy)</span>
<span class="hljs-comment">// data := w.Bytes()</span>
<span class="hljs-comment">// rf.persister.SaveRaftState(data)</span>
readPersist
<span class="hljs-comment">// Your code here (2C).</span>
<span class="hljs-comment">// Example:</span>
<span class="hljs-comment">// r := bytes.NewBuffer(data)</span>
<span class="hljs-comment">// d := labgob.NewDecoder(r)</span>
<span class="hljs-comment">// var xxx</span>
<span class="hljs-comment">// var yyy</span>
<span class="hljs-comment">// if d.Decode(&amp;xxx) != nil ||</span>
<span class="hljs-comment">//    d.Decode(&amp;yyy) != nil &#123;</span>
<span class="hljs-comment">//   error...</span>
<span class="hljs-comment">// &#125; else &#123;</span>
<span class="hljs-comment">//   rf.xxx = xxx</span>
<span class="hljs-comment">//   rf.yyy = yyy</span>
<span class="hljs-comment">// &#125;</span>
</code></pre>
<h2 id="bug"><a class="markdownIt-Anchor" href="#bug"></a> Bug</h2>
<p>同一任期选出两个leader</p>
<p>乱序收到RPC response</p>
<p>AppendEntries的RPC response与当前term不一致</p>
<p>在变成follower时都重置了election time</p>
<h1 id="2d"><a class="markdownIt-Anchor" href="#2d"></a> 2D</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402151207733.png" alt="image-20240215120732611" /></p>
<h2 id="bug-2"><a class="markdownIt-Anchor" href="#bug-2"></a> bug</h2>
<ol>
<li>
<p>每10条command创建一个快照，快照会调用rf.mu这个互斥锁，当存在新的提交命令时，通过applyCh管道进行发送，而测试程序调用snapshot需要获取互斥锁，无法读取管道中的数据，则会产生死锁</p>
</li>
<li>
<p><code>apply error: server 2 apply out of order, expected index 10, got 18</code></p>
<p>当snapshot存在未commit的命令时，snapshot和log分别放入applyCh，应当一次性放入applyCh</p>
</li>
<li></li>
</ol>
<table>
<thead>
<tr>
<th>result</th>
<th>the time that the test took in seconds</th>
<th>the number of Raft peers</th>
<th>the number of RPCs sent during the test</th>
<th>the total number of bytes in the RPC messages</th>
<th>the number of log entries that Raft reports were committed</th>
</tr>
</thead>
<tbody>
<tr>
<td>PASSED</td>
<td>3.9</td>
<td>3</td>
<td>490</td>
<td>154736</td>
<td>207</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1>
<h2 id="raft"><a class="markdownIt-Anchor" href="#raft"></a> raft</h2>
<p>raft是分布式一致性算法，基于复制状态机的思想，对于初始状态一样的节点，在他们上运行同样的命令，还会保持一致性的状态。raft主要包括领导者选举、日志复制、持久化以及快照等。</p>
<h2 id="raft应用场景"><a class="markdownIt-Anchor" href="#raft应用场景"></a> raft应用场景</h2>
<p>Raft 是一种共识算法，通常用于构建分布式系统中的可靠复制日志。它可以应用于各种分布式系统的场景，包括但不限于：</p>
<ol>
<li>
<p><strong>分布式数据库系统</strong>：Raft 可以用于构建分布式数据库系统，确保数据的一致性和可靠性，比如 etcd、Consul 等。</p>
</li>
<li>
<p><strong>分布式文件系统</strong>：在分布式文件系统中，Raft 可以确保各个节点之间的文件操作的一致性，比如 HDFS、Ceph 等。</p>
</li>
<li>
<p><strong>分布式消息队列</strong>：Raft 可以确保消息队列中的消息传递和处理的一致性，比如 Kafka 等。</p>
</li>
<li>
<p><strong>分布式计算</strong>：在分布式计算中，Raft 可以确保各个节点之间的任务调度和执行的一致性，比如 Spark、MapReduce 等。</p>
</li>
<li>
<p><strong>分布式存储系统</strong>：Raft 可以确保分布式存储系统中数据的可靠性和一致性，比如分布式缓存系统如 Redis、分布式块存储系统如 Ceph 等。</p>
</li>
</ol>
<p>总的来说，任何需要在分布式环境中保证一致性和可靠性的系统都可以考虑使用 Raft 算法来实现。</p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<p><a href="https://raft.github.io/">Raft Consensus Algorithm 官网介绍</a></p>
<p><a href="http://thesecretlivesofdata.com/raft/">Raft (thesecretlivesofdata.com)</a>（Raft图示）</p>
<p><a href="https://raw.githubusercontent.com/ongardie/dissertation/master/book.pdf">Raft作者博士论文</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//thesquareplanet.com/blog/instructors-guide-to-raft/">Instructors’ Guide to Raft</a>[4]</p>
<p><a href="https://link.zhihu.com/?target=https%3A//thesquareplanet.com/blog/students-guide-to-raft/">Students’ Guide to Raft</a>[5]</p>
<p><a href="https://link.zhihu.com/?target=https%3A//thesquareplanet.com/blog/raft-qa/">Raft Q&amp;A</a>[6]</p>
<p>paxos 2015版的lab</p>
<p><a href="https://github.com/hashicorp/raft">hashicorp/raft: Golang implementation of the Raft consensus protocol (github.com)</a></p>
<p><a href="https://www.zhihu.com/question/29597104">如何的才能更好地学习 MIT6.824 分布式系统课程？ - 知乎 (zhihu.com)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Destiny</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
