<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"destiny0118.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="凡是过去，皆为序章。">
<meta property="og:type" content="website">
<meta property="og:title" content="我的个人博客">
<meta property="og:url" content="https://destiny0118.github.io/page/5/index.html">
<meta property="og:site_name" content="我的个人博客">
<meta property="og:description" content="凡是过去，皆为序章。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Destiny">
<meta property="article:tag" content="算法，工具">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://destiny0118.github.io/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>我的个人博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">我的个人博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">What past is prolgue.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-项目"><a href="/categories/project/" rel="section"><i class="fa fa-tasks fa-fw"></i>项目</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Destiny</p>
  <div class="site-description" itemprop="description">凡是过去，皆为序章。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">122</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/destiny0118" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;destiny0118" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuyg163@163.com" title="E-Mail → mailto:yuyg163@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/19273732/destiny" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;19273732&#x2F;destiny" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/04/01/%E6%A1%86%E6%9E%B6/Kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/01/%E6%A1%86%E6%9E%B6/Kafka/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-01 22:58:25" itemprop="dateCreated datePublished" datetime="2024-04-01T22:58:25+08:00">2024-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-21 20:10:22" itemprop="dateModified" datetime="2024-04-21T20:10:22+08:00">2024-04-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="为什么Redis-Pub-x2F-Sub比Kafka更快一些？二者之间如何选取？"><a href="#为什么Redis-Pub-x2F-Sub比Kafka更快一些？二者之间如何选取？" class="headerlink" title="为什么Redis Pub&#x2F;Sub比Kafka更快一些？二者之间如何选取？"></a>为什么Redis Pub&#x2F;Sub比Kafka更快一些？二者之间如何选取？</h2><blockquote>
<p><strong>为什么Redis Pub&#x2F;Sub比Kafka更快一些？</strong> Redis是一个内存数据库，其Pub&#x2F;Sub功能将消息保存在内存中。由于内存访问速度通常远快于磁盘访问速度，因此Redis在处理实时性较高的消息推送时具有优势。此外，Redis的Pub&#x2F;Sub模型相对简单，使得它在处理发布和订阅操作时的开销较小。 然而，Kafka是一个完整的系统，提供了高吞吐量、分布式的提交日志。它旨在处理大规模数据流，具有强大的持久化能力和容错性。Kafka的分布式架构和分区机制使得它能够在多个消费者之间实现负载均衡，从而提高整体处理能力。</p>
</blockquote>
<blockquote>
<p><strong>二者之间如何选取？</strong></p>
<p><strong>Redis PUB&#x2F;SUB使用场景：</strong></p>
<ol>
<li>消息持久性需求不高</li>
<li>吞吐量要求不高</li>
<li>可以忍受数据丢失</li>
<li>数据量不大</li>
</ol>
<p><strong>Kafka使用场景：</strong>(上面以外的其他场景)</p>
<ol>
<li>高可靠性</li>
<li>高吞吐量</li>
<li>持久性高</li>
<li>多样化的消费处理模型</li>
</ol>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-01 21:02:51" itemprop="dateCreated datePublished" datetime="2024-04-01T21:02:51+08:00">2024-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-20 21:51:07" itemprop="dateModified" datetime="2024-05-20T21:51:07+08:00">2024-05-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><ul>
<li>chmod：更改文件或目录的权限。</li>
<li>cat：查看文件内容</li>
<li>top：inux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况.该命令可以提供实时的对系统处理器的状态监视，它会显示系统中CPU最“敏感”的任务列表，并且可以按CPU使用、内存使用和执行时间对任务进行排序</li>
</ul>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><blockquote>
<p>分析一行信息</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-v</td>
<td>排除选项</td>
</tr>
<tr>
<td>grep -v ‘^$’ filename</td>
<td>^：行首，$：行尾，去掉空行</td>
</tr>
<tr>
<td>grep -v ‘^#|^$’ filename</td>
<td>^#：以#开头，去掉空行和以#开头的行</td>
</tr>
</tbody></table>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">压缩命令</span><br><span class="line">tar：该命令用于将多个文件或目录打包成一个文件，也可以同时对其进行压缩。常用的参数有：</span><br><span class="line"><span class="deletion">-c：创建新的压缩文件。</span></span><br><span class="line"><span class="deletion">-v：显示详细的压缩过程。</span></span><br><span class="line"><span class="deletion">-f：指定压缩文件的名称。</span></span><br><span class="line"><span class="deletion">-z：使用gzip压缩算法进行压缩。</span></span><br><span class="line"><span class="deletion">-j：使用bzip2压缩算法进行压缩。</span></span><br><span class="line"><span class="deletion">-J：使用xz压缩算法进行压缩。</span></span><br><span class="line"></span><br><span class="line">解压命令：</span><br><span class="line">tar：该命令不仅可以用于压缩，也可以用于解压。解压时常用的参数有：</span><br><span class="line"><span class="deletion">-x：从压缩文件中提取文件或目录。</span></span><br><span class="line"><span class="deletion">-v：显示详细的解压过程。</span></span><br><span class="line"><span class="deletion">-f：指定要解压的压缩文件名称。</span></span><br><span class="line"><span class="deletion">-z：解压使用gzip压缩算法的文件。</span></span><br><span class="line"><span class="deletion">-j：解压使用bzip2压缩算法的文件。</span></span><br><span class="line"><span class="deletion">-J：解压使用xz压缩算法的文件。</span></span><br><span class="line">例如，要解压doc.tar.gz到当前目录，可以使用命令tar -xzvf doc.tar.gz。</span><br></pre></td></tr></table></figure>


<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况</p>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>ps命令用于报告当前系统的进程状态。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。</p>
<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>free命令可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。</p>
<p><a href="https://www.jianshu.com/p/4bca8fe8a878">面试官常考的 21 条 Linux 命令 - 简书 (jianshu.com)</a></p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="6-Linux相关：文件的概念？文件有哪些类型？各自的作用是什么？"><a href="#6-Linux相关：文件的概念？文件有哪些类型？各自的作用是什么？" class="headerlink" title="6. Linux相关：文件的概念？文件有哪些类型？各自的作用是什么？"></a>6. Linux相关：文件的概念？文件有哪些类型？各自的作用是什么？</h2><p><strong>解析：</strong>： 文件类型很多，能回答几种常见的就行，例如普通文件，目录文件，块设备文件，套接字文件。 <strong>参考回答：</strong></p>
<blockquote>
<p>1.普通文件（-）：这是最常见的文件类型，包括纯文本文件、二进制文件、数据文件等。它们不包含文件系统的结构信息，只是用户所接触到的文件。例如，.c文件、可执行的二进制文件等都是普通文件。</p>
<p>2.目录文件（d）：目录文件是用于存放文件名及其相关信息的文件。它们可以包含下一级文件目录或普通文件，是内核组织文件系统的基本节点。通过目录文件，用户可以轻松地浏览和管理文件系统。</p>
<p>3.字符设备文件（c）：这类文件提供了对设备不带缓冲区的访问，每次访问长度可变。它们通常用于表示系统中的字符设备，如控制台、串口等。</p>
<p>4.块设备文件（b）：块设备文件提供对设备（如磁盘）带缓冲的访问，每次访问以固定的长度单位进行。它们用于表示系统中的块设备，如硬盘、U盘等。</p>
<p>5.FIFO（p）：FIFO文件也称为命名管道，用于进程间的通信。它们允许一个进程向另一个进程发送数据，而不需要通过中间的文件或网络连接。</p>
<p>6.套接字（s）：套接字文件用于进程间的网络通信。它们提供了一种在不同进程之间传输数据的方式，通常用于实现网络服务和客户端之间的通信。</p>
<p>7.链接文件（l）：链接文件是指向另一个文件的指针。它们可以分为硬链接和符号链接两种。硬链接指向文件的inode节点，而符号链接则指向另一个文件的路径名。通过链接文件，用户可以方便地访问其他文件或目录。</p>
<p>除了以上七种常见的文件类型外，Linux系统中还有其他一些特殊的文件类型，如特殊文件、门文件等，但这些类型在日常使用中相对较少见。</p>
</blockquote>
<p><strong>学习指引：</strong> <a href="https://gw-c.nowcoder.com/api/sparta/jump/link?link=https://xiaolincoding.com/os/6_file_system/file_system.html%23%25E6%2596%2587%25E4%25BB%25B6%25E7%25B3%25BB%25E7%25BB%259F%25E7%259A%2584%25E5%259F%25BA%25E6%259C%25AC%25E7%25BB%2584%25E6%2588%2590">推荐学习：小林 coding|图解系统｜文件系统</a></p>
<h2 id="7-Linux相关：inode的作用？inode包含哪些内容？给出一个文件名，Linux是如何根据该文件名打开文件的？（文件名-gt-inode-gt-block）文件的访问时间是如何记录的？"><a href="#7-Linux相关：inode的作用？inode包含哪些内容？给出一个文件名，Linux是如何根据该文件名打开文件的？（文件名-gt-inode-gt-block）文件的访问时间是如何记录的？" class="headerlink" title="7. Linux相关：inode的作用？inode包含哪些内容？给出一个文件名，Linux是如何根据该文件名打开文件的？（文件名-&gt;inode-&gt;block）文件的访问时间是如何记录的？"></a>7. Linux相关：inode的作用？inode包含哪些内容？给出一个文件名，Linux是如何根据该文件名打开文件的？（文件名-&gt;inode-&gt;block）文件的访问时间是如何记录的？</h2><p><strong>解析：</strong>： 考察linux文件系统相关问题，比较细，推荐大家系统学习后理解掌握 <strong>参考回答：</strong></p>
<blockquote>
<p><strong>1.inode的作用？：</strong> inode，即索引节点，在Linux文件系统中用于存储文件或目录的元数据信息。它是文件系统的一个基本组成部分，允许系统通过inode号而非完整的文件路径快速访问到文件数据。</p>
<p><strong>2.inode包含哪些内容？：</strong> inode包含文件的元数据信息，如文件大小、文件所有者、文件权限、文件类型、文件的创建&#x2F;访问&#x2F;修改时间等。此外，inode还包含指向文件数据块的指针，这些指针指示了文件内容在磁盘上的实际存储位置。</p>
<p>&#x3D;&#x3D;<strong>3.给出一个文件名，Linux是如何根据该文件名打开文件的？</strong> <strong>（文件名-&gt;inode-&gt;block）</strong>&#x3D;&#x3D;： 当给出一个文件名时，Linux首先会根据文件路径在目录结构中查找该文件对应的&#x3D;&#x3D;目录项&#x3D;&#x3D;。目录项中包含了文件的inode号。然后，系统会使用这个inode号在文件系统中找到对应的inode结构。一旦找到inode，系统就可以通过inode中的指针找到文件数据所在的磁盘块（block）。最后，系统将这些磁盘块加载到内存中，从而打开并访问文件。</p>
<p><strong>4.文件的访问时间是如何记录的</strong>？： 文件的访问时间是通过inode中的访问时间戳（atime）来记录的。每当文件被读取时，其inode中的atime就会被更新为当前时间。这个机制允许系统跟踪文件的访问历史，以便进行各种管理和维护操作。需要注意的是，为了优化性能，某些文件系统可能会延迟更新atime或仅在文件内容实际被读取时更新它。</p>
</blockquote>
<p><a href="https://www.nowcoder.com/discuss/590576768491216896?sourceSSR=users">阿里云 实习面经（已OC） 一面面经｜讲解_牛客网 (nowcoder.com)</a></p>
<h2 id="8-零拷贝是什么？用来解决什么问题？有哪些应用场景？实现方式有哪些？"><a href="#8-零拷贝是什么？用来解决什么问题？有哪些应用场景？实现方式有哪些？" class="headerlink" title="8. 零拷贝是什么？用来解决什么问题？有哪些应用场景？实现方式有哪些？"></a>8. 零拷贝是什么？用来解决什么问题？有哪些应用场景？实现方式有哪些？</h2><p><strong>解析：</strong>：</p>
<p><strong>参考回答：</strong></p>
<blockquote>
<p><strong>1.是什么？</strong>：零拷贝是一种IO操作优化技术，旨在减少数据在内核空间和用户空间之间的冗余拷贝，从而解放CPU、减少上下文切换并降低系统资源消耗。它主要用来解决传统IO操作中不必要的数据拷贝问题，提高数据传输效率。</p>
<p><strong>2.应用场景</strong>：零拷贝技术广泛应用于需要高性能数据传输的场景，如网络传输、文件传输、数据库操作等。在这些场景中，大量的数据需要在内核空间和用户空间之间传输，传统的IO操作会导致不必要的数据拷贝和性能损失。</p>
<p><strong>3.实现方式有哪些？</strong>：实现零拷贝的方式主要有mmap、sendfile、splice和tee等。其中，mmap通过内存映射将内核缓冲区与用户空间共享，避免了数据拷贝；sendfile直接将数据从内核缓冲区发送到网络缓冲区，减少了CPU拷贝；splice和tee则在内核空间内实现数据的传输和复制，避免了用户空间的参与。这些技术根据具体的应用场景和需求选择使用，可以有效地提高数据传输效率和系统性能。</p>
</blockquote>
<p><strong>学习指引：</strong> <a href="https://gw-c.nowcoder.com/api/sparta/jump/link?link=https://xiaolincoding.com/os/8_network_system/zero_copy.html">图解系统：什么是零拷贝？如何实现零拷贝？</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">数据库优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-26 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-26T00:00:00+08:00">2024-03-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-29 11:10:07" itemprop="dateModified" datetime="2024-05-29T11:10:07+08:00">2024-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1. 读写分离
2. 分库分表
3. 数据库查询优化</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/03/11/%E9%A1%B9%E7%9B%AE/Lottery/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/11/%E9%A1%B9%E7%9B%AE/Lottery/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-11 21:34:46" itemprop="dateCreated datePublished" datetime="2024-03-11T21:34:46+08:00">2024-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-20 21:31:36" itemprop="dateModified" datetime="2024-05-20T21:31:36+08:00">2024-05-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h1><ul>
<li><p>活动表：是一个用于配置抽奖活动的总表，用于存放活动信息，包括：ID、名称、描述、时间、库存、参与次数等。</p>
</li>
<li><p>奖品表</p>
</li>
<li><p>策略表</p>
</li>
<li><p>规则表</p>
</li>
<li><p>用户参与表</p>
</li>
<li><p>中奖信息表</p>
</li>
<li><p>抽奖活动配置（活动ID、活动名称、活动描述、活动库存、每人可参与次数、活动状态）</p>
</li>
<li><p>奖品策略配置（策略ID、策略描述、策略方式、发放奖品方式）</p>
</li>
<li><p>奖品策略明细配置（&#x3D;&#x3D;策略ID、奖品ID&#x3D;&#x3D;、奖品描述、奖品库存、奖品剩余库存、中奖概率）</p>
</li>
<li><p>奖品信息配置（奖品ID、奖品类型、奖品名称、奖品内容）</p>
</li>
<li><p>用户活动参与次数（用户ID、活动ID、可参与次数、已参与次数）</p>
</li>
</ul>
<p>首先要有活动信息表，记录活动可参与次数等信息；其次，对于每个抽奖活动配置抽奖策略。抽奖策略有具体明细，可以抽取的奖品。最后，抽奖明细中可以抽取到哪些奖品。</p>
<ul>
<li>活动配置，activity：提供活动的基本配置</li>
<li>策略配置，strategy：用于配置抽奖策略，概率、玩法、库存、奖品</li>
<li>策略明细，strategy_detail：抽奖策略的具体明细配置</li>
<li>奖品配置，award：用于配置具体可以得到的奖品</li>
<li>用户参与活动记录表，user_take_activity：每个用户参与活动都会记录下他的参与信息，时间、次数</li>
<li>用户活动参与次数表，user_take_activity_count：用于记录当前参与了多少次</li>
<li>用户策略计算结果表，user_strategy_export_001~004：最终策略结果的一个记录，也就是奖品中奖信息的内容</li>
</ul>
<h1 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h1><h2 id="lottery-rpc"><a href="#lottery-rpc" class="headerlink" title="lottery-rpc"></a>lottery-rpc</h2><ul>
<li>DTO</li>
<li>req</li>
<li>res</li>
<li>服务接口<br>rpc提供接口，供外界调用，在req中封装请求对象，res封装请求结果（将查询的结果DTO对象也封装其中）</li>
</ul>
<h2 id="lottery-interfaces"><a href="#lottery-interfaces" class="headerlink" title="lottery-interfaces"></a>lottery-interfaces</h2><ul>
<li>interfaces</li>
<li>LotteryApplication</li>
<li>resources<ul>
<li>mybatis<ul>
<li>config</li>
<li>mapper</li>
</ul>
</li>
<li>application.yml</li>
</ul>
</li>
</ul>
<p>在interfaces下实现rpc层定义的接口，调用infrastructure层提供的仓储服务进行查询</p>
<h2 id="lottery-domain"><a href="#lottery-domain" class="headerlink" title="lottery-domain"></a>lottery-domain</h2><p>定义仓储接口</p>
<h2 id="lottery-infrastructure"><a href="#lottery-infrastructure" class="headerlink" title="lottery-infrastructure"></a>lottery-infrastructure</h2><ul>
<li>dao：访问数据库，封装数据库操作</li>
<li>po</li>
</ul>
<p>实现仓储接口</p>
<h1 id="抽奖策略领域（策略模式、模板模式）"><a href="#抽奖策略领域（策略模式、模板模式）" class="headerlink" title="抽奖策略领域（策略模式、模板模式）"></a>抽奖策略领域（策略模式、模板模式）</h1><blockquote>
<p>抽奖策略使用了策略模式，即提供一个接口，供抽奖调用，同时不同策略方式分别实现该接口</p>
</blockquote>
<p>两种抽奖算法描述，场景A20%、B30%、C50%</p>
<ul>
<li><strong>总体概率</strong>：如果A奖品抽空后，B和C奖品的概率按照 <code>3:5</code> 均分，相当于B奖品中奖概率由 <code>0.3</code> 升为 <code>0.375</code></li>
<li><strong>单项概率</strong>：如果A奖品抽空后，B和C保持目前中奖概率，用户抽奖扔有20%中为A，因A库存抽空则结果展示为未中奖。(将奖品依据抽奖概率分配到长度为100的字符数组中，每一个位置可能对应多个奖品，只要该位置奖品没抽完，即算抽中。可以通过哈希散列的方式，将奖品信息分散到数组中去)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403112313092.png" alt="image.png"></p>
<ul>
<li>domain<ul>
<li>strategy<ul>
<li>model：用于提供vo、req、res 和 aggregates 聚合对象。</li>
<li>repository：提供仓储服务，其实也就是对Mysql、Redis等数据的统一包装。</li>
<li>service：是具体的业务领域逻辑实现层<ul>
<li>algorithm<ul>
<li>impl<ul>
<li>SingleRateRandomDrawAlgorithm</li>
<li>EntiretyRateRandomDrawAlgorithm</li>
</ul>
</li>
<li>IDrawAlgorithm</li>
</ul>
</li>
<li>draw<ul>
<li>impl<ul>
<li>DrawExecImpl</li>
</ul>
</li>
<li>AbstractDrawBase（模板模式定义抽象抽奖过程，涉及到具体差异实现的则在impl下实现）</li>
<li>DrawConfig（策略配置，哈希表映射到IDrawAlgorithm的具体实现类）</li>
<li>DrawStrategySupport（提供抽奖策略数据支持，便于查询策略配置、奖品信息。）</li>
<li>IDrawExel（接口，暴漏抽奖方法接口给外界使用）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在draw下处理抽奖流程</p>
<ul>
<li>DrawConfig：配置抽奖策略，SingleRateRandomDrawAlgorithm、EntiretyRateRandomDrawAlgorithm</li>
<li>DrawStrategySupport：提供抽奖策略数据支持，便于查询策略配置、奖品信息。通过这样的方式隔离职责。</li>
<li>AbstractDrawBase：抽象类定义模板方法流程，在抽象类的 <code>doDrawExec</code> 方法中，处理整个抽奖流程，并提供在流程中需要使用到的抽象方法，由 <code>DrawExecImpl</code> 服务逻辑中做具体实现。</li>
<li>IDrawExec#doDrawExec<ul>
<li><code>获取抽奖策略</code>、<code>校验抽奖策略是否已经初始化到内存</code>、<code>获取不在抽奖范围内的列表，包括：奖品库存为空、风控策略、临时调整等</code>、<code>执行抽奖算法</code>、<code>包装中奖结果</code><br><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403121148213.png" alt="Lottery-Draw抽奖流程.png"></li>
</ul>
</li>
</ul>
<h1 id="搭建发奖领域（简单工厂设计模式）"><a href="#搭建发奖领域（简单工厂设计模式）" class="headerlink" title="搭建发奖领域（简单工厂设计模式）"></a>搭建发奖领域（简单工厂设计模式）</h1><blockquote>
<p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<p>利用工厂模式+接口封装奖品，让每一块功能都更加清晰易于扩展和维护。</p>
<p>简单工厂模式避免创建者与具体的产品逻辑耦合、满足单一职责，每一个业务逻辑实现都在所属自己的类中完成、满足开闭原则，无需更改使用调用方就可以在程序中引入新的产品类型。但这样也会带来一些问题，比如有非常多的奖品类型，那么实现的子类会极速扩张，对于这样的场景就需要在引入其他设计手段进行处理，例如抽象通用的发奖子领域，自动化配置奖品发奖。</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">└── domain</span><br><span class="line">	└──award</span><br><span class="line">		├── model</span><br><span class="line">		├── repository</span><br><span class="line">		│   ├── impl</span><br><span class="line">		│   │   └── AwardRepository</span><br><span class="line">		│   └── IAwardRepository</span><br><span class="line">		└── service</span><br><span class="line">			├── factory</span><br><span class="line">			│   ├── <span class="module-access"><span class="module"><span class="identifier">DistributionGoodsFactory</span>.</span></span>java（通过提供的奖品类型获取具体的奖品实现类）</span><br><span class="line">			│   └── <span class="module-access"><span class="module"><span class="identifier">GoodsConfig</span>.</span></span>java（配置文件，通过map将奖品类型映射到具体实现类）</span><br><span class="line">			└── goods</span><br><span class="line">				├── impl</span><br><span class="line">				│   ├── <span class="module-access"><span class="module"><span class="identifier">CouponGoods</span>.</span></span>java</span><br><span class="line">				│   ├── <span class="module-access"><span class="module"><span class="identifier">DescGoods</span>.</span></span>java</span><br><span class="line">				│   ├── <span class="module-access"><span class="module"><span class="identifier">PhysicalGoods</span>.</span></span>java</span><br><span class="line">				│   └── <span class="module-access"><span class="module"><span class="identifier">RedeemCodeGoods</span>.</span></span>java</span><br><span class="line">				├── <span class="module-access"><span class="module"><span class="identifier">DistributionBase</span>.</span></span>java（发奖涉及到的对数据仓储的修改）</span><br><span class="line">				└── <span class="module-access"><span class="module"><span class="identifier">IDistributionGoodsc</span>.</span></span>java(接口类，奖品配送接口)</span><br></pre></td></tr></table></figure>

<h1 id="活动领域的配置与状态"><a href="#活动领域的配置与状态" class="headerlink" title="活动领域的配置与状态"></a>活动领域的配置与状态</h1><h2 id="活动创建"><a href="#活动创建" class="headerlink" title="活动创建"></a>活动创建</h2><p>活动的创建操作主要包括：添加活动配置、添加奖品配置、添加策略配置、添加策略明细配置</p>
<h2 id="状态变更（设计模式：状态模式）"><a href="#状态变更（设计模式：状态模式）" class="headerlink" title="状态变更（设计模式：状态模式）"></a>状态变更（设计模式：状态模式）</h2><blockquote>
<p>状态模式：类的行为是基于它的状态改变的，这种类型的设计模式属于行为型模式。它描述的是一个行为下的多种状态变更，比如我们最常见的一个网站的页面，在你登录与不登录下展示的内容是略有差异的(不登录不能展示个人信息)，而这种登录与不登录就是我们通过改变状态，而让整个行为发生了变化。</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">domain.activity</span><br><span class="line">├── model</span><br><span class="line">├── repository</span><br><span class="line">│   └── IActivityRepository</span><br><span class="line">└── service</span><br><span class="line">	├── deploy</span><br><span class="line">	├── partake <span class="literal">[待开发]</span></span><br><span class="line">	└── stateflow</span><br><span class="line">		├── event（都实现了AbstractState接口，当前状态在相应事件下的响应）</span><br><span class="line">		│   ├── <span class="module-access"><span class="module"><span class="identifier">ArraignmentState</span>.</span></span>java</span><br><span class="line">		│   ├── <span class="module-access"><span class="module"><span class="identifier">CloseState</span>.</span></span>java</span><br><span class="line">		│   ├── <span class="module-access"><span class="module"><span class="identifier">DoingState</span>.</span></span>java</span><br><span class="line">		│   ├── <span class="module-access"><span class="module"><span class="identifier">EditingState</span>.</span></span>java</span><br><span class="line">		│   ├── <span class="module-access"><span class="module"><span class="identifier">OpenState</span>.</span></span>java</span><br><span class="line">		│   ├── <span class="module-access"><span class="module"><span class="identifier">PassState</span>.</span></span>java</span><br><span class="line">		│   └── <span class="module-access"><span class="module"><span class="identifier">RefuseState</span>.</span></span>java</span><br><span class="line">		├── impl</span><br><span class="line">		│   └── <span class="module-access"><span class="module"><span class="identifier">StateHandlerImpl</span>.</span></span>java（实现类，获取当前状态的实现类，调用相应事件操作）</span><br><span class="line">		├── <span class="module-access"><span class="module"><span class="identifier">AbstractState</span>.</span></span>java（接口，提供了各项状态之间流转服务的接口，即一个状态到另一个状态的事件）</span><br><span class="line">		├── <span class="module-access"><span class="module"><span class="identifier">IStateHandler</span>.</span></span>java（接口，暴露给外界可用于改变状态的事件操作）</span><br><span class="line">		└── <span class="module-access"><span class="module"><span class="identifier">StateConfig</span>.</span></span>java（提供map，整形到具体event下状态实现类的映射）</span><br></pre></td></tr></table></figure>





<h1 id="ID生成策略（策略模式）"><a href="#ID生成策略（策略模式）" class="headerlink" title="ID生成策略（策略模式）"></a>ID生成策略（策略模式）</h1><blockquote>
<p>策略模式是行为模式的一种：外部的调用方会需要根据不同的场景来选择出适合的ID生成策略</p>
</blockquote>
<ul>
<li>订单号：唯一、大量、订单创建时使用、分库分表</li>
<li>活动号：唯一、少量、活动创建时使用、单库单表</li>
<li>策略号：唯一、少量、活动创建时使用、单库单表<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">domain<span class="selector-class">.support</span><span class="selector-class">.ids</span></span><br><span class="line">├── policy（IIdGenerator具体实现类）</span><br><span class="line">│   ├── RandomNumeric<span class="selector-class">.java</span></span><br><span class="line">│   ├── ShortCode<span class="selector-class">.java</span></span><br><span class="line">│   └── SnowFlake<span class="selector-class">.java</span></span><br><span class="line">├── IdContext.java（map，记录枚举类型到ID生成具体实现类的映射）</span><br><span class="line">└── IIdGenerator<span class="selector-class">.java</span>(接口类，定义生成ID的策略接口，供外界调用)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><p>由于业务体量较大，数据增长较快，所以需要把用户数据拆分到不同的库表中去，减轻数据库压力。</p>
<p>分库分表操作主要有垂直拆分和水平拆分：</p>
<ul>
<li>垂直拆分：指按照业务将表进行分类，分布到不同的数据库上，这样也就将数据的压力分担到不同的库上面。最终一个数据库由很多表的构成，每个表对应着不同的业务，也就是专库专用。</li>
<li>水平拆分：如果垂直拆分后遇到单机瓶颈，可以使用水平拆分。相对于垂直拆分的区别是：垂直拆分是把不同的表拆到不同的数据库中，而本章节需要实现的水平拆分，是把同一个表拆到不同的数据库中。如：user_001、user_002</li>
</ul>
<p>数据库路由设计</p>
<ul>
<li>是关于 AOP 切面拦截的使用，这是因为需要给使用数据库路由的方法做上标记，便于处理分库分表逻辑。</li>
<li>数据源的切换操作，既然有分库那么就会涉及在多个数据源间进行链接切换，以便把数据分配给不同的数据库。</li>
<li>数据库表寻址操作，一条数据分配到哪个数据库，哪张表，都需要进行索引计算。在方法调用的过程中最终通过 ThreadLocal 记录。</li>
<li>为了能让数据均匀的分配到不同的库表中去，还需要考虑如何进行数据散列的操作，不能分库分表后，让数据都集中在某个库的某个表，这样就失去了分库分表的意义。</li>
<li>Mybatis 拦截器处理分表 SQL</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202403142000474.png" alt="router.png"></p>
<h1 id="领取活动（模板模式）"><a href="#领取活动（模板模式）" class="headerlink" title="领取活动（模板模式）"></a>领取活动（模板模式）</h1><blockquote>
<p>用于领取活动领域功能开发中用户领取活动信息，在一个事务下记录多张表数据。<br>领取活动的流程作为模板实现，具体调用的方法在实现类实现。</p>
</blockquote>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">domain.activity.service.partake</span><br><span class="line">|<span class="string">-impl</span></span><br><span class="line"><span class="string"></span>|<span class="string">	</span>|<span class="string">-ActivityPartakeImpl</span></span><br><span class="line"><span class="string"></span>|<span class="string">-ActivityPartakeSupport：根据uid,activityID查询活动信息和用户领取信息</span></span><br><span class="line"><span class="string"></span>|<span class="string">-BaseActivityPartake：doPartake处理活动领取，调用抽象方法在实现类进行具体实现</span></span><br><span class="line"><span class="string"></span>|<span class="string">-IActivityPartake</span></span><br></pre></td></tr></table></figure>

<p>领取活动流程：</p>
<ul>
<li>根据uid、activityId查询活动账单</li>
<li>活动信息校验处理（抽象方法）</li>
<li>扣减活动库存(activity表，可优化为Redis扣减)</li>
<li>领取活动（个人用户把活动信息写入到用户表）（扣减user_take_activity_count剩余可领取次数，将领取活动信息插入user_take_activity）</li>
<li>返回策略ID，用于后续抽奖步骤</li>
</ul>
<h1 id="应用层：抽奖过程"><a href="#应用层：抽奖过程" class="headerlink" title="应用层：抽奖过程"></a>应用层：抽奖过程</h1><p>在 application 应用层调用领域服务功能，编排抽奖过程，包括：领取活动、执行抽奖、落库结果</p>
<p>分别在两个分库的表 lottery_01.user_take_activity、lottery_02.user_take_activity 中添加 state<code>【活动单使用状态 0未使用、1已使用】</code> 状态字段，这个状态字段用于写入中奖信息到 user_strategy_export_000~003 表中时候，两个表可以做一个幂等性的事务。</p>
<p>同时还需要加入 strategy_id 策略ID字段，用于处理领取了活动单但执行抽奖失败时，可以继续获取到此抽奖单继续执行抽奖，而不需要重新领取活动。<em>其实领取活动就像是一种活动镜像信息，可以在控制幂等反复使用</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404152300246.png" alt="image.png"></p>
<ul>
<li>抽奖整个活动过程的流程编排，主要包括：对活动的领取、对抽奖的操作、对中奖结果的存放，以及如何处理发奖，对于发奖流程我们设计为MQ触发，后续再补全这部分内容。</li>
<li>对于每一个流程节点编排的内容，都是在领域层开发完成的，而应用层只是做最为简单的且很薄的一层。<em>其实这块也很符合目前很多低代码的使用场景，通过界面可视化控制流程编排，生成代码</em></li>
</ul>
<p>抽奖过程：</p>
<ul>
<li>用户请求抽奖(doPartake)（uId, activityId），领取活动<ul>
<li><code>查询是否存在未执行抽奖领取活动单【user_take_activity 存在 state = 0，领取了但抽奖过程失败的，可以直接返回领取结果继续抽奖】</code></li>
</ul>
</li>
<li>执行抽奖（<code>doDrawExec</code>）（uId, strategyId, takeId）</li>
<li>结果落库（uId, activityId，strategyId, takeId）</li>
<li>发送MQ，触发发奖流程</li>
<li>返回结果</li>
</ul>
<h1 id="量化人群参与活动（规则引擎、组合模式）"><a href="#量化人群参与活动（规则引擎、组合模式）" class="headerlink" title="量化人群参与活动（规则引擎、组合模式）"></a>量化人群参与活动（规则引擎、组合模式）</h1><blockquote>
<p>使用组合模式搭建用于量化人群的规则引擎，用于用户参与活动之前，通过规则引擎过滤性别、年龄、首单消费、消费金额、忠实用户等各类身份来量化出具体可参与的抽奖活动。通过这样的方式控制运营成本和精细化运营。</p>
</blockquote>
<p>组合模式的特点就像是搭建出一棵二叉树，而库表中则需要把这样一颗二叉树存放进去，那么这里就需要包括：树根、树茎、子叶、果实。在具体的逻辑实现中则需要通过子叶判断走哪个树茎以及最终筛选出一个果实来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404161042433.png" alt="image.png"></p>
<ul>
<li>基于量化决策引擎，筛选用户身份标签，找到符合参与的活动号。拿到活动号后，就可以参与到具体的抽奖活动中了。</li>
<li>通常量化决策引擎也是一种用于差异化人群的规则过滤器，不只是可以过滤出活动，也可以用于活动唯独的过滤，判断是否可以参与到这个抽奖活动中。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404161057494.png" alt="image.png"></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">Lottery</span><br><span class="line">└── <span class="attribute">src</span></span><br><span class="line">    └── <span class="selector-tag">main</span></span><br><span class="line">       └── java</span><br><span class="line">          └── cn<span class="selector-class">.itedus</span><span class="selector-class">.lottery</span><span class="selector-class">.domain</span><span class="selector-class">.rule</span></span><br><span class="line">              ├── model</span><br><span class="line">              │   ├── aggregates</span><br><span class="line">              │   │   └── TreeRich<span class="selector-class">.java</span></span><br><span class="line">              │   ├── req</span><br><span class="line">              │   │   └── DecisionMatterReq<span class="selector-class">.java</span></span><br><span class="line">              │   ├── res</span><br><span class="line">              │   │   └── EngineResult<span class="selector-class">.java</span></span><br><span class="line">              │   └── vo</span><br><span class="line">              │       ├── TreeNodeLineVO<span class="selector-class">.java</span></span><br><span class="line">              │       ├── TreeNodeVO<span class="selector-class">.java</span></span><br><span class="line">              │       └── TreeRootVO<span class="selector-class">.java</span>	</span><br><span class="line">              └── service</span><br><span class="line">                  ├── engine</span><br><span class="line">                  │   ├── impl	</span><br><span class="line">                  │   │   └── TreeEngineHandle.java（实现类，先查询树对应的所有节点以及节点间的连线）</span><br><span class="line">                  │   ├── EngineBase<span class="selector-class">.java</span> （engineDecisionMaker，根据过滤条件筛选出叶子节点）</span><br><span class="line">                  │   ├── EngineConfig.java（配置不同条件使用的过滤器）</span><br><span class="line">                  │   └── IEngine<span class="selector-class">.java</span>	（暴露process接口，调用参数：treeRootId，过滤条件）</span><br><span class="line">                  └── logic</span><br><span class="line">                      ├── impl	</span><br><span class="line">                      │   ├── UserAgeFilter<span class="selector-class">.java</span></span><br><span class="line">                      │   └── UserGenderFilter<span class="selector-class">.java</span></span><br><span class="line">                      ├── BaseLogic.java（根据决策值，对所有连线进行判断）</span><br><span class="line">                      └── LogicFilter.java（暴露接口）</span><br></pre></td></tr></table></figure>



<h1 id="MQ：抽奖发货流程"><a href="#MQ：抽奖发货流程" class="headerlink" title="MQ：抽奖发货流程"></a>MQ：抽奖发货流程</h1><p>使用MQ消息的特性，把用户抽奖到发货到流程进行解耦。这个过程中包括了消息的发送、库表中状态的更新、消息的接收消费、发奖状态的处理等。</p>
<p>在数据库表 <code>user_strategy_export</code> 添加字段 <code>mq_state</code> 这个字段用于发送 MQ 成功更新库表状态，如果 MQ 消息发送失败则需要通过定时任务补偿 MQ 消息。PS：你可以使用本章节分支下的 sql 更新自己的库表。<br><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404172253392.png" alt="image.png"></p>
<pre><code> // 1. 领取活动
// 2. 执行抽奖
// 3. 结果落库
// 4. 发送MQ，触发发奖流程
    发奖（消费者收到消息进行发奖）
`// 4.1 MQ 消息发送完成，更新数据库表 user_strategy_export.mq_state = 1`
`// 4.2 MQ 消息发送失败，更新数据库表 user_strategy_export.mq_state = 2 【等待定时任务扫码补偿MQ消息】`
</code></pre>
<p>消息发送完毕后进行回调处理，更新数据库中 MQ 发送的状态，如果有 MQ 发送失败则更新数据库 mq_state &#x3D; 2 <strong>这里还有可能在更新库表状态的时候失败</strong>，但没关系这些都会被 worker 补偿处理掉，一种是发送 MQ 失败，另外一种是 MQ 状态为 0 但很久都没有发送 MQ 那么也可以触发发送。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/03/05/%E8%AF%AD%E6%B3%95/Java/Java%E5%B9%B6%E5%8F%91(4)%EF%BC%9AThreadPoolExecutor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/05/%E8%AF%AD%E6%B3%95/Java/Java%E5%B9%B6%E5%8F%91(4)%EF%BC%9AThreadPoolExecutor/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-03-05 20:42:29 / 修改时间：21:21:44" itemprop="dateCreated datePublished" datetime="2024-03-05T20:42:29+08:00">2024-03-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Executes the given task sometime in the future.  The task * may execute in a new thread or in an existing pooled thread. * * If the task cannot be submitted for execution, either because this * executor has been shutdown or because its capacity has been reached, * the task is handled by the current &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;.  </span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@param</span> command the task to execute  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException at discretion of  </span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;, if the task  </span></span><br><span class="line"><span class="comment"> *         cannot be accepted for execution * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> command&#125; is null  </span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();  </span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:     *     * 1. If fewer than corePoolSize threads are running, try to     * start a new thread with the given command as its first     * task.  The call to addWorker atomically checks runState and     * workerCount, and so prevents false alarms that would add     * threads when it shouldn&#x27;t, by returning false.     *     * 2. If a task can be successfully queued, then we still need     * to double-check whether we should have added a thread     * (because existing ones died since last checking) or that     * the pool shut down since entry into this method. So we     * recheck state and if necessary roll back the enqueuing if     * stopped, or start a new thread if there are none.     *     * 3. If we cannot queue task, then we try to add a new     * thread.  If it fails, we know we are shut down or saturated     * and so reject the task.     */</span>    </span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();  </span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        c = ctl.get();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();  </span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))  </span><br><span class="line">            reject(command);  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)  </span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))  </span><br><span class="line">        reject(command);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.throwx.cn/2020/08/23/java-concurrency-thread-pool-executor/">硬核干货：4W字从源码上分析JUC线程池ThreadPoolExecutor的实现原理 | Throwable (throwx.cn)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/03/04/%E8%AF%AD%E6%B3%95/Java/Java(3)%EF%BC%9A%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/04/%E8%AF%AD%E6%B3%95/Java/Java(3)%EF%BC%9A%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-04 10:11:52" itemprop="dateCreated datePublished" datetime="2024-03-04T10:11:52+08:00">2024-03-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-29 11:47:00" itemprop="dateModified" datetime="2024-05-29T11:47:00+08:00">2024-05-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 、 <code>Queue</code>。<br><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405281131352.png" alt="image.png"></p>
<ul>
<li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
<li><code>Set</code>(注重独一无二的性质): 存储的元素不可重复的。</li>
<li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<table>
<thead>
<tr>
<th>集合</th>
<th>实现</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>List</td>
<td>ArrayList</td>
<td></td>
</tr>
<tr>
<td></td>
<td>vector</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LinkedList</td>
<td></td>
</tr>
<tr>
<td>Set</td>
<td>HashSet</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LinkedHashSet</td>
<td></td>
</tr>
<tr>
<td></td>
<td>TreeSet</td>
<td></td>
</tr>
<tr>
<td>Map</td>
<td>HashMap</td>
<td>线程不安全，key、value都可为null</td>
</tr>
<tr>
<td></td>
<td>LinkedHashMap</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HashTable</td>
<td>线程安全</td>
</tr>
<tr>
<td></td>
<td>TreeMap</td>
<td></td>
</tr>
</tbody></table>
<p>Queue</p>
<ul>
<li>PriorityQueue</li>
<li>DelayQueue</li>
<li>ArrayDeque</li>
</ul>
<p><code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。</p>
<h1 id="1-List"><a href="#1-List" class="headerlink" title="1 List"></a>1 List</h1><h2 id="1-1-ArrayList和LinkedList区别"><a href="#1-1-ArrayList和LinkedList区别" class="headerlink" title="1.1 ArrayList和LinkedList区别"></a>1.1 ArrayList和LinkedList区别</h2><ol>
<li><p><strong>底层数据结构：</strong></p>
<ul>
<li><code>ArrayList</code>使用<em>动态数组</em>实现。它的内部是一个数组，当数组容量不足时，会自动进行扩容。</li>
<li><code>LinkedList</code>使用<em>双向链表</em>实现。每个元素都包含一个指向前一个元素和一个指向后一个元素的引用。</li>
</ul>
</li>
<li><p><strong>随机访问性能：</strong></p>
<ul>
<li><code>ArrayList</code>支持快速的随机访问，因为它是基于数组的，可以通过索引直接访问元素。</li>
<li><code>LinkedList</code>在随机访问时性能较差，因为必须从链表的头部或尾部开始遍历，直到找到目标元素。</li>
</ul>
</li>
<li><p><strong>插入和删除操作性能：</strong></p>
<ul>
<li><code>ArrayList</code>在中间插入或删除元素时性能较差，因为需要移动数组中的元素。</li>
<li><code>LinkedList</code>在插入和删除元素时性能较好，因为只需要改变相邻元素的引用。</li>
</ul>
</li>
<li><p><strong>空间复杂度：</strong></p>
<ul>
<li><code>ArrayList</code>相对较省空间，因为它只需要存储元素值和数组容量。</li>
<li><code>LinkedList</code>相对较耗费空间，因为每个元素都需要额外的两个引用字段。</li>
</ul>
</li>
<li><p><strong>迭代器性能：</strong></p>
<ul>
<li><code>ArrayList</code>上的迭代器性能较好，因为它可以通过索引直接访问元素。</li>
<li><code>LinkedList</code>上的迭代器性能较差，因为必须沿着链表一个一个地移动。</li>
</ul>
</li>
<li><p><strong>适用场景：</strong></p>
<ul>
<li>如果需要频繁进行随机访问，使用<code>ArrayList</code>更为合适。</li>
<li>如果需要频繁进行插入和删除操作，特别是在集合的中间位置，使用<code>LinkedList</code>更为合适。</li>
</ul>
</li>
</ol>
<h1 id="2-Set"><a href="#2-Set" class="headerlink" title="2 Set"></a>2 Set</h1><h2 id="2-1-Comparable和Comparator"><a href="#2-1-Comparable和Comparator" class="headerlink" title="2.1 Comparable和Comparator"></a>2.1 Comparable和Comparator</h2><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p>
<ul>
<li><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<h2 id="2-2-Hashset、LinkedHashSet、TreeSet"><a href="#2-2-Hashset、LinkedHashSet、TreeSet" class="headerlink" title="2.2 Hashset、LinkedHashSet、TreeSet"></a>2.2 Hashset、LinkedHashSet、TreeSet</h2><ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
<h1 id="3-Map"><a href="#3-Map" class="headerlink" title="3 Map"></a>3 Map</h1><h2 id="3-1-HashMap和TreeMap"><a href="#3-1-HashMap和TreeMap" class="headerlink" title="3.1 HashMap和TreeMap"></a>3.1 HashMap和TreeMap</h2><p><strong>相比于<code>HashMap</code>来说， <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>
<h2 id="3-2-HashMap"><a href="#3-2-HashMap" class="headerlink" title="3.2 HashMap"></a>3.2 HashMap</h2><h3 id="3-2-1-扩容机制"><a href="#3-2-1-扩容机制" class="headerlink" title="3.2.1 扩容机制"></a>3.2.1 扩容机制</h3><ol>
<li><p><strong>初始容量和负载因子：</strong></p>
<ul>
<li><code>HashMap</code> 有一个初始容量和一个负载因子。初始容量是哈希表在创建时的容量，默认为 16。负载因子是一个在哈希表大小超过其容量乘以负载因子时，哈希表将进行扩容的阈值，默认为 0.75。</li>
</ul>
</li>
<li><p><strong>扩容操作：</strong></p>
<ul>
<li>当哈希表的元素个数达到了负载因子所定义的阈值，<code>HashMap</code> 将进行扩容操作。</li>
<li>扩容操作包括创建一个新的哈希表，其容量为原容量的两倍，然后将所有元素重新分配到新的哈希表中。<br><a href="https://zhuanlan.zhihu.com/p/114363420">HashMap的扩容机制 - 知乎 (zhihu.com)</a><br><a href="https://blog.csdn.net/qq_49217297/article/details/126304736">HashMap实现原理， 扩容机制，面试题和总结_hashmap扩容机制面试-CSDN博客</a></li>
</ul>
</li>
</ol>
<h3 id="3-2-2-HashMap多线程导致死循环"><a href="#3-2-2-HashMap多线程导致死循环" class="headerlink" title="3.2.2 HashMap多线程导致死循环"></a>3.2.2 HashMap多线程导致死循环</h3><p>当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，<code>头插法</code>可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。<br>为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。</p>
<p><a href="https://coolshell.cn/articles/9606.html">疫苗：Java HashMap的死循环 | 酷 壳 - CoolShell</a></p>
<h3 id="3-2-3-HashMap为什么线程不安全"><a href="#3-2-3-HashMap为什么线程不安全" class="headerlink" title="3.2.3 HashMap为什么线程不安全"></a>3.2.3 HashMap为什么线程不安全</h3><p>多线程环境下，<code>HashMap</code> 扩容时会造成<code>死循环</code> 和<code>数据丢失</code>的问题。<br>在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对<code>HashMap</code>的put操作会导致线程不安全，可能产生数据覆盖.</p>
<h4 id="3-2-3-1-同时检测到桶位置为空，插入元素"><a href="#3-2-3-1-同时检测到桶位置为空，插入元素" class="headerlink" title="3.2.3.1 同时检测到桶位置为空，插入元素"></a>3.2.3.1 同时检测到桶位置为空，插入元素</h4><ul>
<li>两个线程同时进行put操作，并且存在哈希冲突</li>
<li>由于线程首先都执行完了hash碰撞的判断，桶为空</li>
<li>每个线程再向空桶中插入元素<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 判断是否出现 hash 碰撞</span></span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素（处理hash冲突）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-2-3-2-多个线程同时put操作导致size不正确"><a href="#3-2-3-2-多个线程同时put操作导致size不正确" class="headerlink" title="3.2.3.2 多个线程同时put操作导致size不正确"></a>3.2.3.2 多个线程同时put操作导致size不正确</h4><ul>
<li>两个线程都先获取size，在++size</li>
<li>添加两次元素，而size只增加1<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/484653028">基于JDK8的HashMap实现(万字详解) - 知乎 (zhihu.com)</a></p>
<h3 id="3-2-4-底层实现"><a href="#3-2-4-底层实现" class="headerlink" title="3.2.4 底层实现"></a>3.2.4 底层实现</h3><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<h3 id="3-2-5-put添加元素过程"><a href="#3-2-5-put添加元素过程" class="headerlink" title="3.2.5 put添加元素过程"></a>3.2.5 put添加元素过程</h3><ol>
<li><p><strong>计算哈希码（Hash Code）：</strong></p>
<ul>
<li>当你向 <code>HashSet</code> 中添加一个元素时，首先会调用该元素的 <code>hashCode()</code> 方法，得到元素的哈希码。</li>
<li>如果元素为 <code>null</code>，则它的哈希码为 0。</li>
</ul>
</li>
<li><p><strong>映射到桶位置（Bucket Position）：</strong></p>
<ul>
<li>哈希码经过一系列的变换和运算，被映射到哈希表中的一个桶位置（bucket position）。</li>
<li>桶位置是一个数组索引，表示存储元素的位置。</li>
</ul>
</li>
<li><p><strong>处理哈希冲突：</strong></p>
<ul>
<li>哈希表可能存在冲突，即不同元素映射到相同的桶位置。为了解决冲突，<code>HashSet</code> 使用链表或红黑树（在JDK 8之后）来存储相同桶位置上的元素。</li>
<li>如果桶位置上已经有一个元素，新元素会被添加到链表或红黑树的末尾。</li>
</ul>
</li>
<li><p><strong>检查元素唯一性：</strong></p>
<ul>
<li>在添加元素的过程中，<code>HashSet</code> 会通过调用元素的 <code>equals()</code> 方法来检查元素的唯一性。</li>
<li>如果已经存在相同的元素（根据 <code>equals()</code> 判断），新元素不会被加入。</li>
</ul>
</li>
</ol>
<h3 id="3-2-6-如何做到让HashMap线程安全"><a href="#3-2-6-如何做到让HashMap线程安全" class="headerlink" title="3.2.6 如何做到让HashMap线程安全"></a>3.2.6 如何做到让HashMap线程安全</h3><ol>
<li><p><strong>使用<code>Collections.synchronizedMap</code>方法：</strong><br> Map&lt;K, V&gt; synchronizedMap &#x3D; Collections.synchronizedMap(new HashMap&lt;K, V&gt;());</p>
<p> 这将返回一个线程安全的<code>Map</code>，它在每个方法上都使用同步机制来确保线程安全。但请注意，虽然这确保了每个方法的原子性，但在多个操作之间，仍然可能需要额外的同步。</p>
</li>
<li><p><strong>使用<code>ConcurrentHashMap</code>：</strong> <code>ConcurrentHashMap</code>是Java提供的线程安全的<code>Map</code>实现。它使用分段锁机制，每个段相当于一个小的<code>HashMap</code>，不同的段之间互不影响，这样可以提高并发性能。</p>
<p> Map&lt;K, V&gt; concurrentMap &#x3D; new ConcurrentHashMap&lt;K, V&gt;();</p>
</li>
</ol>
<h2 id="3-3-ConcurrentHashMap"><a href="#3-3-ConcurrentHashMap" class="headerlink" title="3.3 ConcurrentHashMap"></a>3.3 ConcurrentHashMap</h2><h3 id="3-3-1-1-7"><a href="#3-3-1-1-7" class="headerlink" title="3.3.1 1.7"></a>3.3.1 1.7</h3><blockquote>
<p>通过分段锁（Segmentation）实现线程安全。它将整个哈希表分成多个段（Segment），每个段都是一个小的哈希表，并且拥有自己的锁。这样，多个线程可以并发地访问不同的段，从而减少了锁的竞争，提高了并发性能。 </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404012148392.png" alt="image.png"></p>
<h3 id="3-3-2-1-8"><a href="#3-3-2-1-8" class="headerlink" title="3.3.2 1.8"></a>3.3.2 1.8</h3><blockquote>
<p>使用了一种更细粒度的锁策略，结合CAS（Compare-and-Swap）无锁算法来实现线程安全。在JDK 1.8中，ConcurrentHashMap将整个哈希表看作一个整体，不再进行分段。而是通过Node数组+链表+红黑树的结构来存储数据，并使用Synchronized和CAS来协调并发访问。  </p>
</blockquote>
<p>锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。<br><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404012149783.png" alt="image.png"></p>
<h3 id="3-3-3-JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？"><a href="#3-3-3-JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？" class="headerlink" title="3.3.3 JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？"></a>3.3.3 JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h3><ul>
<li><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li>
<li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</li>
<li><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li>
</ul>
<p><a href="https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html#_4-get">ConcurrentHashMap 源码分析 | JavaGuide</a><br><a href="https://zhuanlan.zhihu.com/p/94976168">一文彻底搞懂CAS实现原理 &amp; 深入到CPU指令 - 知乎 (zhihu.com)</a><br><a href="https://javaguide.cn/java/collection/java-collection-questions-02.html#map-%E9%87%8D%E8%A6%81">Java集合常见面试题总结(下) | JavaGuide</a></p>
<h1 id="4-Atomic"><a href="#4-Atomic" class="headerlink" title="4 Atomic"></a>4 Atomic</h1><p><code>java.util.concurrent.atomic</code> 包提供了一组用于在多线程环境中进行原子操作的类。这些类通过使用硬件级别的原子性操作或者利用 <code>sun.misc.Unsafe</code> 提供的 CAS（Compare-And-Swap）操作来确保对变量的操作是原子的。这些类大多数都是基于原始数据类型的，例如 <code>int</code>、<code>long</code>，还有一些是引用类型。</p>
<p>以下是 <code>java.util.concurrent.atomic</code> 包中一些主要的类以及它们的用途：</p>
<ol>
<li><p><strong>AtomicInteger：</strong> 用于对整数进行原子操作，支持原子的自增（<code>incrementAndGet()</code>）、自减（<code>decrementAndGet()</code>）等操作。</p>
</li>
<li><p><strong>AtomicLong：</strong> 用于对长整型进行原子操作，同样支持原子的自增、自减等操作。</p>
</li>
<li><p><strong>AtomicBoolean：</strong> 用于对布尔类型进行原子操作，支持原子的设置和获取操作。</p>
</li>
<li><p><strong>AtomicReference：</strong> 用于对引用类型进行原子操作，支持原子的获取和设置引用对象。</p>
</li>
<li><p><strong>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray：</strong> 用于对数组中的元素进行原子操作，提供了一些原子性的数组操作。</p>
</li>
<li><p><strong>AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater：</strong> 用于对类的字段进行原子更新，允许在并发环境中对对象的字段进行原子性操作。</p>
</li>
</ol>
<p>这些原子类提供了一种比使用 <code>synchronized</code> 关键字更轻量级的线程安全机制，特别适用于一些简单的计数器、状态标志等场景。在需要进行原子操作而又不需要全局的锁的情况下，这些类可以提供更好的性能。</p>
<p>虽然这些类提供了原子性的操作，但并不是所有的操作都可以用原子方式完成，因此在使用时仍然需要注意保证原子性的操作是否符合预期。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/02/28/%E8%AF%AD%E6%B3%95/Java/Java%E5%B9%B6%E5%8F%91(1)%EF%BC%9A%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/28/%E8%AF%AD%E6%B3%95/Java/Java%E5%B9%B6%E5%8F%91(1)%EF%BC%9A%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">Java：并发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-28 00:00:00" itemprop="dateCreated datePublished" datetime="2024-02-28T00:00:00+08:00">2024-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-26 21:46:42" itemprop="dateModified" datetime="2024-05-26T21:46:42+08:00">2024-05-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>线程、锁、条件变量</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/02/28/%E8%AF%AD%E6%B3%95/Java/Java%E5%B9%B6%E5%8F%91(1)%EF%BC%9A%E5%B9%B6%E5%8F%91/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/02/22/%E9%A1%B9%E7%9B%AE/MIT6.824%20Lab3%20KVraft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/22/%E9%A1%B9%E7%9B%AE/MIT6.824%20Lab3%20KVraft/" class="post-title-link" itemprop="url">MIT6.824 Lab3 KVraft</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-22 16:28:21" itemprop="dateCreated datePublished" datetime="2024-02-22T16:28:21+08:00">2024-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-02 21:28:29" itemprop="dateModified" datetime="2024-03-02T21:28:29+08:00">2024-03-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h1><h3 id="1-panic-close-of-closed-channel"><a href="#1-panic-close-of-closed-channel" class="headerlink" title="1. panic: close of closed channel"></a>1. <code>panic: close of closed channel</code></h3><p>在server中，只使用了一个全局的管道来接收命令应用结果，PutAppend和Get共享一个管道，两个分别打开管道，随后一个关闭，另一个在关闭时出现问题</p>
<ul>
<li>给两个操作加锁，只有操作执行完（成功执行，超时）才解锁</li>
<li>对Start返回的index，每一个添加一个管道</li>
</ul>
<h2 id="2-command被复制到半数以上服务器，但是还没有在状态机上执行，然后选举出新的leader，新的leader具有添加的命令"><a href="#2-command被复制到半数以上服务器，但是还没有在状态机上执行，然后选举出新的leader，新的leader具有添加的命令" class="headerlink" title="2. command被复制到半数以上服务器，但是还没有在状态机上执行，然后选举出新的leader，新的leader具有添加的命令"></a>2. command被复制到半数以上服务器，但是还没有在状态机上执行，然后选举出新的leader，新的leader具有添加的命令</h2><p>在Lab2就想到的问题，一直考虑已经被添加的command如何被再次添加，发现在raft层无法解决这个问题。</p>
<p>在Lab3中遇到了此问题，考虑在server中记录client已经添加的命令（命令可能未执行成功），在收到更小的command时，则不调用Start添加到leader。这需要启用新的server作为leader时，快速将已有的命令执行完毕（在添加任何新命令之前），这一步难以实现。</p>
<p>因此考虑在command中添加client的命令标志，重传的命令也可以被添加到log中，但是在执行时会发现该命令已经执行过</p>
<p>命令没有被执行 TestManyPartitionsManyClients3A</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="section">=== RUN   TestManyPartitionsManyClients3A</span></span><br><span class="line">Test: partitions, many clients (3A) ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>命令结果有额外部分（多执行了？）TestConcurrent3A</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Test: </span>unreliable net, restarts, partitions, random keys, many clients (3A) ...</span><br><span class="line">info: wrote history visualization to /tmp/1021001197.html</span><br><span class="line">    test_test.go:382: history is not linearizable</span><br><span class="line">--- FAIL: TestPersistPartitionUnreliableLinearizable3A (30.13s)</span><br></pre></td></tr></table></figure>

<h2 id="3-并发读写map"><a href="#3-并发读写map" class="headerlink" title="3. 并发读写map"></a>3. 并发读写map</h2><p><code>fatal error: concurrent map read and map write</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">replyCh := <span class="built_in">make</span>(<span class="keyword">chan</span> ApplierResult, <span class="number">1</span>)</span><br><span class="line">kv.appliedCh[index] = replyCh</span><br><span class="line"><span class="comment">//kv.appliedCh[index] = make(chan ApplierResult, 1)</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%AB%98%E6%80%A7%E8%83%BD&%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%88%86%E5%B8%83%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E9%AB%98%E6%80%A7%E8%83%BD&%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%88%86%E5%B8%83%E5%BC%8F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-20 23:12:29" itemprop="dateCreated datePublished" datetime="2024-02-20T23:12:29+08:00">2024-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-21 15:05:46" itemprop="dateModified" datetime="2024-05-21T15:05:46+08:00">2024-05-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</strong></p>
</blockquote>
<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p><strong>CAP</strong> 也就是 <strong>Consistency（一致性）</strong>、<strong>Availability（可用性）</strong>、<strong>Partition Tolerance（分区容错性）</strong></p>
<ul>
<li><strong>一致性（Consistency）</strong> : 所有节点访问同一份最新的数据副本</li>
<li><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li>
<li><strong>分区容错性（Partition Tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li>
</ul>
<p>Quorum机制（法定人数机制<br><strong>分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。</strong> 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p>
<h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong>、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。</p>
<h2 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h2><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p>
<p><strong>什么叫允许损失部分可用性呢？</strong></p>
<ul>
<li><strong>响应时间上的损失</strong>: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li>
<li><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li>
</ul>
<h2 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a><a href="#%E8%BD%AF%E7%8A%B6%E6%80%81">软状态</a></h2><p>软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a><a href="#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7">最终一致性</a></h2><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<blockquote>
<p>分布式一致性的 3 种级别：</p>
<ol>
<li><strong>强一致性</strong>：系统写入了什么，读出来的就是什么。</li>
<li><strong>弱一致性</strong>：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</li>
<li><strong>最终一致性</strong>：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li>
</ol>
<p><strong>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</strong></p>
</blockquote>
<h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><blockquote>
<p>共识算法的作用是让分布式系统中的多个节点之间对某个提案（Proposal）达成一致的看法。提案的含义在分布式系统中十分宽泛，像哪一个节点是 Leader 节点、多个事件发生的顺序等等都可以是一个提案。</p>
</blockquote>
<p>共识是可容错系统中的一个基本问题：即使面对故障，服务器也可以在共享状态上达成一致。</p>
<p>共识算法允许一组节点像一个整体一样一起工作，即使其中的一些节点出现故障也能够继续工作下去，其正确性主要是源于复制状态机的性质：一组<code>Server</code>的状态机计算相同状态的副本，即使有一部分的<code>Server</code>宕机了它们仍然能够继续运行。<br><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402232043613.png" alt="image.png"></p>
<p><a href="https://javaguide.cn/distributed-system/protocol/raft-algorithm.html">https://javaguide.cn/distributed-system/protocol/raft-algorithm.html</a></p>
<h1 id="Basic-Paxos-算法"><a href="#Basic-Paxos-算法" class="headerlink" title="Basic Paxos 算法"></a>Basic Paxos 算法</h1><ul>
<li><strong>提议者（Proposer）</strong>：也可以叫做协调者（coordinator），提议者负责接受客户端的请求并发起提案。提案信息通常包括提案编号 (Proposal ID) 和提议的值 (Value)。</li>
<li><strong>接受者（Acceptor）</strong>：也可以叫做投票员（voter），负责对提议者的提案进行投票，同时需要记住自己的投票历史；</li>
<li><strong>学习者（Learner）</strong>：如果有超过半数接受者就某个提议达成了共识，那么学习者就需要接受这个提议，并就该提议作出运算，然后将运算结果返回给客户端。<br><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405211456396.png" alt="image.png|450"></li>
</ul>
<h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><ul>
<li><code>Leader</code>：负责发起心跳，响应客户端，创建日志，同步日志。</li>
<li><code>Candidate</code>：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。</li>
<li><code>Follower</code>：接受 Leader 的心跳和日志同步数据，投票给 Candidate。</li>
</ul>
<h3 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h3><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h2 id="领导人选举"><a href="#领导人选举" class="headerlink" title="领导人选举"></a>领导人选举</h2><p>raft 使用心跳机制来触发 Leader 的选举。</p>
<p>如果一台服务器能够收到来自 Leader 或者 Candidate 的有效信息，那么它会一直保持为 Follower 状态，并且刷新自己的 electionElapsed，重新计时。</p>
<p>Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。如果一个 Follower 在一个周期内没有收到心跳信息，就叫做选举超时，然后它就会认为此时没有可用的 Leader，并且开始进行一次选举以选出一个新的 Leader。</p>
<h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>一旦选出了 Leader，它就开始接受客户端的请求。每一个客户端的请求都包含一条需要被复制状态机（<code>Replicated State Machine</code>）执行的命令。</p>
<p>Leader 收到客户端请求后，会生成一个 entry，包含<code>&lt;index,term,cmd&gt;</code>，再将这个 entry 添加到自己的日志末尾后，向所有的节点广播该 entry，要求其他服务器复制这条 entry。</p>
<p>如果 Follower 接受该 entry，则会将 entry 添加到自己的日志后面，同时返回给 Leader 同意。</p>
<p>如果 Leader 收到了多数的成功响应，Leader 会将这个 entry 应用到自己的状态机中，之后可以称这个 entry 是 committed 的，并且向客户端返回执行结果。</p>
<p>raft 保证以下两个性质：</p>
<ul>
<li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd</li>
<li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同</li>
</ul>
<hr>
<p>著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：<a href="https://javaguide.cn/distributed-system/protocol/raft-algorithm.html">https://javaguide.cn/distributed-system/protocol/raft-algorithm.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/02/01/%E9%A1%B9%E7%9B%AE/MIT6.824%20Lab2%20Raft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/01/%E9%A1%B9%E7%9B%AE/MIT6.824%20Lab2%20Raft/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-01 14:23:48" itemprop="dateCreated datePublished" datetime="2024-02-01T14:23:48+08:00">2024-02-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-24 15:21:52" itemprop="dateModified" datetime="2024-05-24T15:21:52+08:00">2024-05-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>term(任期)</p>
<p>Leader发出heartbeat(AppendEntries RPC不带有log entries)</p>
<blockquote>
<p>Raft is a consensus algorithm that is designed to be easy to understand. It’s equivalent to Paxos in fault-tolerance and performance.</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402052155568.jpg" alt="QQ图片20240205215524.jpg"></p>
<h1 id="2A-Leader-election-领导人选举"><a href="#2A-Leader-election-领导人选举" class="headerlink" title="2A Leader election(领导人选举)"></a>2A Leader election(领导人选举)</h1><ul>
<li>网络延迟、分区、包丢失、复制和重新排序。</li>
</ul>
<blockquote>
<p>This election term will continue until a follower stops receiving heartbeats and becomes a candidate.</p>
</blockquote>
<p>导致Follower进行选举的原因</p>
<ul>
<li>网络延迟或者包丢失没有在选举超时前收到心跳</li>
<li>网络分区而导致收不到心跳（disconnect）</li>
<li>Leader宕机、崩溃（crash）</li>
</ul>
<h2 id="1-节点类型"><a href="#1-节点类型" class="headerlink" title="1. 节点类型"></a>1. 节点类型</h2><ul>
<li><code>Leader</code>：负责发起心跳，响应客户端，创建日志，同步日志。</li>
<li><code>Candidate</code>：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。</li>
<li><code>Follower</code>：接受 Leader 的心跳和日志同步数据，投票给 Candidate。态转换</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402031102578.png" alt="image-20240203110252535"></p>
<ul>
<li>Follower$\rightarrow$Candidate（超时：一段时间内未收到heartbeat）</li>
</ul>
<p>Leader(AppendEntries RPC)</p>
<ul>
<li>term过时：<ul>
<li>发送心跳发现Server的term号大于自身的term号（已经选出新的Leader，将自己状态变为Follower）</li>
<li>收到RequestVote发现更高term号</li>
</ul>
</li>
</ul>
<p>Candidate(RequestVote RPC)</p>
<ul>
<li>term过时<ul>
<li>收到新的Leader的心跳，请求投票时发现大于自身的term号</li>
<li>收到RequestVote RPC的response，返回的term号更大</li>
</ul>
</li>
</ul>
<p>Follower：被动的，对来自Leader和Candidate的请求进行相应</p>
<ul>
<li>收到Leader的心跳，且term号大于自身term号（更新自身term号）</li>
<li>收到Candidate请求</li>
</ul>
<p>Server：</p>
<ul>
<li>拒绝过时term的请求</li>
</ul>
<h2 id="选举超时时间和心跳时间"><a href="#选举超时时间和心跳时间" class="headerlink" title="选举超时时间和心跳时间"></a>选举超时时间和心跳时间</h2><ul>
<li><p>心跳间隔时间(heartbeat timeout)：Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。</p>
</li>
<li><p>选举超时时间(election timeout)：如果一个 Follower 在一个周期内没有收到心跳信息或者请求投票信息，就叫做选举超时，并开始一次新的选举。</p>
</li>
</ul>
<p>这两个时间需要保持一定的关系，网络无故障时，在选举超时前应该收到心跳，以保持Leader不变。选举超时时间至少需要大于AppendEntries RPC发送到server所需的最长时间。</p>
<h3 id="选举超时时间更新"><a href="#选举超时时间更新" class="headerlink" title="选举超时时间更新"></a>选举超时时间更新</h3><ul>
<li>candidate成为leader</li>
<li>candidate收到RequestVote response并变为follower</li>
<li>server收到AppendEntries</li>
<li>server收到RequestVote</li>
<li>leader收到AppendEntries response发现更高term号</li>
</ul>
<h3 id="超时选举实现"><a href="#超时选举实现" class="headerlink" title="超时选举实现"></a>超时选举实现</h3><p>在raft结构体中定义laskAcktime，在收到leader的heartbeat或者candidate的投票请求时，要更新选举超时时间<br>这里没有通过定时器在到达选举超时时间后触发选举操作，而是首先记录下当前时间，然后让ticker协程sleep一段时间。当再次唤醒后，如果laskAcktime在startTime之后，说明在选举超时前收到了相关信号。<br><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402272153075.png" alt="image.png"></p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="sendAppendEntries没有启用新的协程"><a href="#sendAppendEntries没有启用新的协程" class="headerlink" title="sendAppendEntries没有启用新的协程"></a><code>sendAppendEntries</code>没有启用新的协程</h3><p>在<code>sendHeartbeat</code>中，异步发送<code>sendAppendEntries</code>，向所有server发送heartbeat，无需等待RPC完成。因为leader可能无法与其他server通信，或者server不可达，由于等待rpc返回，造成超时重新选举</p>
<p>异步发送<code>RequestVote</code>，并且收到超过半数选票后就成为Leader，发送心跳</p>
<p><code> go test -race -run 2A</code></p>
<h1 id="2B-Log-replication-日志复制"><a href="#2B-Log-replication-日志复制" class="headerlink" title="2B Log replication(日志复制)"></a>2B Log replication(日志复制)</h1><blockquote>
<p>&#x3D;&#x3D;<strong>Leader Completeness</strong>&#x3D;&#x3D;: if a log entry is committed in a given term, then that entry will be present in the logs of the leaders for all higher-numbered terms. §5.4<br>&#x3D;&#x3D;<strong>State Machine Safety</strong>&#x3D;&#x3D;: if a server has applied a log entry at a given index to its state machine, no other server will ever apply a different log entry for the same index. §5.4.3</p>
</blockquote>
<ul>
<li>leader收到client请求，将entry添加到log</li>
<li>leader将添加的entry复制到其他server</li>
<li>如果大多数server成功复制entry，则该entry已经committed</li>
<li></li>
<li>已经committed的entry需要应用到机器上，lastApplied代表已经执行的命令</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402061214812.png" alt="Raft-第 1 页.png"></p>
<h2 id="Election-restriction-5-4-1"><a href="#Election-restriction-5-4-1" class="headerlink" title="Election restriction(5.4.1)"></a>Election restriction(5.4.1)</h2><p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402041429181.png" alt="Raft-第 2 页.png"></p>
<p>log backtracking</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402061305538.png" alt="Raft-加速log回溯"></p>
<p>S1首先成为leader，成功发送了第一个entry</p>
<p>S1和S2与其他服务器断开后重连</p>
<h2 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h2><blockquote>
<p>遇到的bug</p>
</blockquote>
<p>s1断联，添加了一系列entry</p>
<p>重连后，新的leader通过heartbeat更新了s1的commitindex，而此时s1的log还未更新</p>
<h1 id="2C"><a href="#2C" class="headerlink" title="2C"></a>2C</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">persist</span><br><span class="line"><span class="comment">// Your code here (2C).</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">// w := new(bytes.Buffer)</span></span><br><span class="line"><span class="comment">// e := labgob.NewEncoder(w)</span></span><br><span class="line"><span class="comment">// e.Encode(rf.xxx)</span></span><br><span class="line"><span class="comment">// e.Encode(rf.yyy)</span></span><br><span class="line"><span class="comment">// data := w.Bytes()</span></span><br><span class="line"><span class="comment">// rf.persister.SaveRaftState(data)</span></span><br><span class="line">readPersist</span><br><span class="line"><span class="comment">// Your code here (2C).</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">// r := bytes.NewBuffer(data)</span></span><br><span class="line"><span class="comment">// d := labgob.NewDecoder(r)</span></span><br><span class="line"><span class="comment">// var xxx</span></span><br><span class="line"><span class="comment">// var yyy</span></span><br><span class="line"><span class="comment">// if d.Decode(&amp;xxx) != nil ||</span></span><br><span class="line"><span class="comment">//    d.Decode(&amp;yyy) != nil &#123;</span></span><br><span class="line"><span class="comment">//   error...</span></span><br><span class="line"><span class="comment">// &#125; else &#123;</span></span><br><span class="line"><span class="comment">//   rf.xxx = xxx</span></span><br><span class="line"><span class="comment">//   rf.yyy = yyy</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h2><p>同一任期选出两个leader</p>
<p>乱序收到RPC response</p>
<p>AppendEntries的RPC response与当前term不一致</p>
<p>在变成follower时都重置了election time</p>
<h1 id="2D"><a href="#2D" class="headerlink" title="2D"></a>2D</h1><p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202402151207733.png" alt="image-20240215120732611"></p>
<h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><ol>
<li><p>每10条command创建一个快照，快照会调用rf.mu这个互斥锁，当存在新的提交命令时，通过applyCh管道进行发送，而测试程序调用snapshot需要获取互斥锁，无法读取管道中的数据，则会产生死锁</p>
</li>
<li><p><code>apply error: server 2 apply out of order, expected index 10, got 18</code></p>
<p>当snapshot存在未commit的命令时，snapshot和log分别放入applyCh，应当一次性放入applyCh</p>
</li>
<li></li>
</ol>
<table>
<thead>
<tr>
<th>result</th>
<th>the time that the test took in seconds</th>
<th>the number of Raft peers</th>
<th>the number of RPCs sent during the test</th>
<th>the total number of bytes in the RPC messages</th>
<th>the number of log entries that Raft reports were committed</th>
</tr>
</thead>
<tbody><tr>
<td>PASSED</td>
<td>3.9</td>
<td>3</td>
<td>490</td>
<td>154736</td>
<td>207</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="raft"><a href="#raft" class="headerlink" title="raft"></a>raft</h2><p>raft是分布式一致性算法，基于复制状态机的思想，对于初始状态一样的节点，在他们上运行同样的命令，还会保持一致性的状态。raft主要包括领导者选举、日志复制、持久化以及快照等。</p>
<h2 id="raft应用场景"><a href="#raft应用场景" class="headerlink" title="raft应用场景"></a>raft应用场景</h2><p>Raft 是一种共识算法，通常用于构建分布式系统中的可靠复制日志。它可以应用于各种分布式系统的场景，包括但不限于：</p>
<ol>
<li><p><strong>分布式数据库系统</strong>：Raft 可以用于构建分布式数据库系统，确保数据的一致性和可靠性，比如 etcd、Consul 等。</p>
</li>
<li><p><strong>分布式文件系统</strong>：在分布式文件系统中，Raft 可以确保各个节点之间的文件操作的一致性，比如 HDFS、Ceph 等。</p>
</li>
<li><p><strong>分布式消息队列</strong>：Raft 可以确保消息队列中的消息传递和处理的一致性，比如 Kafka 等。</p>
</li>
<li><p><strong>分布式计算</strong>：在分布式计算中，Raft 可以确保各个节点之间的任务调度和执行的一致性，比如 Spark、MapReduce 等。</p>
</li>
<li><p><strong>分布式存储系统</strong>：Raft 可以确保分布式存储系统中数据的可靠性和一致性，比如分布式缓存系统如 Redis、分布式块存储系统如 Ceph 等。</p>
</li>
</ol>
<p>总的来说，任何需要在分布式环境中保证一致性和可靠性的系统都可以考虑使用 Raft 算法来实现。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://raft.github.io/">Raft Consensus Algorithm 官网介绍</a></p>
<p><a href="http://thesecretlivesofdata.com/raft/">Raft (thesecretlivesofdata.com)</a>（Raft图示）</p>
<p><a href="https://raw.githubusercontent.com/ongardie/dissertation/master/book.pdf">Raft作者博士论文</a></p>
<p><a href="https://link.zhihu.com/?target=https://thesquareplanet.com/blog/instructors-guide-to-raft/">Instructors’ Guide to Raft</a>[4]</p>
<p><a href="https://link.zhihu.com/?target=https://thesquareplanet.com/blog/students-guide-to-raft/">Students’ Guide to Raft</a>[5]</p>
<p><a href="https://link.zhihu.com/?target=https://thesquareplanet.com/blog/raft-qa/">Raft Q&amp;A</a>[6]</p>
<p>paxos 2015版的lab</p>
<p><a href="https://github.com/hashicorp/raft">hashicorp&#x2F;raft: Golang implementation of the Raft consensus protocol (github.com)</a></p>
<p><a href="https://www.zhihu.com/question/29597104">如何的才能更好地学习 MIT6.824 分布式系统课程？ - 知乎 (zhihu.com)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Destiny</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
