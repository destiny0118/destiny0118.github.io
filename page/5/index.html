<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"destiny0118.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="凡是过去，皆为序章。">
<meta property="og:type" content="website">
<meta property="og:title" content="我的个人博客">
<meta property="og:url" content="https://destiny0118.github.io/page/5/index.html">
<meta property="og:site_name" content="我的个人博客">
<meta property="og:description" content="凡是过去，皆为序章。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Destiny">
<meta property="article:tag" content="算法，工具">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://destiny0118.github.io/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>我的个人博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">我的个人博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">What past is prolgue.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-项目"><a href="/categories/project/" rel="section"><i class="fa fa-tasks fa-fw"></i>项目</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Destiny</p>
  <div class="site-description" itemprop="description">凡是过去，皆为序章。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">124</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/destiny0118" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;destiny0118" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuyg163@163.com" title="E-Mail → mailto:yuyg163@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/19273732/destiny" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;19273732&#x2F;destiny" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/04/10/%E6%A1%86%E6%9E%B6/JVM/JVM%20(3)%EF%BC%9AJDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/10/%E6%A1%86%E6%9E%B6/JVM/JVM%20(3)%EF%BC%9AJDK%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-10 21:40:22" itemprop="dateCreated datePublished" datetime="2024-04-10T21:40:22+08:00">2024-04-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-06 15:26:02" itemprop="dateModified" datetime="2024-06-06T15:26:02+08:00">2024-06-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>jps</code></strong> (JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</p>
</li>
<li class="lvl-2">
<p><strong><code>jstat</code></strong>（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;</p>
</li>
<li class="lvl-2">
<p><strong><code>jinfo</code></strong> (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;</p>
</li>
<li class="lvl-2">
<p><strong><code>jmap</code></strong> (Memory Map for Java) : 生成堆转储快照;</p>
</li>
<li class="lvl-2">
<p><strong><code>jhat</code></strong> (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;</p>
</li>
<li class="lvl-2">
<p><strong><code>jstack</code></strong> (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</p>
</li>
</ul>
<h1>1 JVM参数</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404102245741.png" alt="image.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404112053964.png" alt="image.png"></p>
<h2 id="1-1-堆参数">1.1 堆参数</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">初始堆(memory start)大小、最大堆大小</span><br><span class="line">-Xms&lt;heap size&gt;[unit]</span><br><span class="line">-Xmx&lt;heap size&gt;[unit]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">年轻代大小</span><br><span class="line">-XX:NewSize=n </span><br><span class="line">-XX:NewRatio=n  年轻代和年老代比值为1:n</span><br><span class="line">-XX:SurvivorRatio=n 年轻代中Eden区与两个Survivor区的比值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">格式：-XX:[+-]&lt;name&gt; 表示启用或者禁用name属性。</span><br><span class="line">例子：-XX:+UseG1GC（表示启用G1垃圾收集器）</span><br></pre></td></tr></table></figure>
<h1>2 jstack :生成虚拟机当前时刻的线程快照</h1>
<p><code>jstack</code>（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.</p>
<p>生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过<code>jstack</code>来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。</p>
<h1>3 OOM排查</h1>
<blockquote>
<p>OOM 全称 “Out Of Memory”，表示内存耗尽。当 JVM 因为没有足够的内存来为对象分配空间，并且垃圾回收器也已经没有空间可回收时，就会抛出这个错误。产生原因：</p>
<ol>
<li class="lvl-3">分配过少：JVM 初始化内存小，业务使用了大量内存；或者不同 JVM 区域分配内存不合理</li>
<li class="lvl-3">代码漏洞：某一个对象被频繁申请，不用了之后却没有被释放，导致内存耗尽</li>
</ol>
</blockquote>
<p><strong>内存泄漏</strong>：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了。因为申请者不用了，而又不能被虚拟机分配给别人用</p>
<p><strong>内存溢出</strong>：申请的内存超出了 JVM 能提供的内存大小，此时称之为溢出</p>
<h2 id="3-1-OOM类型">3.1 OOM类型</h2>
<p><strong>java.lang.OutOfMemoryError: PermGen space</strong></p>
<p>Java7 永久代（方法区）溢出，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。每当一个类初次加载的时候，元数据都会存放到永久代</p>
<p>一般出现于大量 Class 对象或者 JSP 页面，或者采用 CgLib 动态代理技术导致</p>
<p>我们可以通过 <code>-XX：PermSize</code> 和 <code>-XX：MaxPermSize</code> 修改方法区大小</p>
<blockquote>
<p>Java8 将永久代变更为元空间，报错：java.lang.OutOfMemoryError: Metadata space，元空间内存不足默认进行动态扩展</p>
</blockquote>
<p><strong>java.lang.StackOverflowError</strong></p>
<p><strong>虚拟机栈溢出</strong>，一般是由于程序中存在 <strong>死循环或者深度递归调用</strong> 造成的。如果栈大小设置过小也会出现溢出，可以通过 <code>-Xss</code> 设置栈的大小</p>
<p>虚拟机抛出栈溢出错误，可以在日志中定位到错误的类、方法</p>
<p><strong>java.lang.OutOfMemoryError: Java heap space</strong></p>
<p><strong>Java 堆内存溢出</strong>，溢出的原因一般由于 JVM 堆内存设置不合理或者内存泄漏导致</p>
<p>如果是内存泄漏，可以通过工具查看泄漏对象到 GC Roots 的引用链。掌握了泄漏对象的类型信息以及 GC Roots 引用链信息，就可以精准地定位出泄漏代码的位置</p>
<p>如果不存在内存泄漏，就是内存中的对象确实都还必须存活着，那就应该检查虚拟机的堆参数（-Xmx 与 -Xms），查看是否可以将虚拟机的内存调大些</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tasklist | findstr &quot;java&quot;</span><br><span class="line"></span><br><span class="line">查看内存堆栈信息  </span><br><span class="line">//查看jvm内存分布</span><br><span class="line">jmap -heap pid</span><br><span class="line">jhsdb jmap --heap --pid 16279  </span><br><span class="line">(对于jdk8之后的版本，不能再使用jmap -heap pid的命令了，需要使用上面的命令)。</span><br><span class="line"></span><br><span class="line">- 查看gc情况  </span><br><span class="line">    jstat -gc pid 刷新时间  </span><br><span class="line">    例如：jstat -gc 1289 5000 表示每5秒查看一次pid为1289的gc时间。</span><br><span class="line">- 查看内存对象实例数量  </span><br><span class="line">    jmap -histo:live 16279 &gt; c.jmap  </span><br><span class="line">    将结果导入到c.jmap的文件中，这个是自定义的文件。</span><br></pre></td></tr></table></figure>
<h2 id="3-2-案例1（Xmn-Xmx，老年代内存为0）">3.2 案例1（Xmn=Xmx，老年代内存为0）</h2>
<p><code>Heap Space Size = Young Space Size + Old Space Size</code>，而<code>-Xmn</code>参数控制的正是 Young 区的大小，当堆区被 Young Gen 完全挤占，又有对象想要升代到 Old Gen 时，发现 Old 区空间不足，于是触发 Full GC，触发 Full GC 以后呢，通常又会面临两种情况：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Young 区又刚好腾出来一点空间，对象又不用放到 Old 区里面了，皆大欢喜</p>
</li>
<li class="lvl-2">
<p>Young 区空间还是不够，对象还是得放到 Old 区，Old 区空间不够，卒，喜提<code>OOM</code></p>
</li>
<li class="lvl-2">
<p>诶，就是奔着 Old 区去的，管你 Young 不 Young，Old 区空间不够，卒，喜提<code>OOM</code></p>
</li>
</ul>
<p>这个就解释了为什么系统刚刚启动时，会有一个短时间正常工作的现象，随后，当某段程序触发 Old Gen 升代时，就会发生随机的<code>OOM</code>错误。那么什么时候对象会进入老年代呢？这里也很有意思，不妨结合日志里面出现<code>OOM</code>的地方，对号入座：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>经历足够多次数 GC 依然存活的对象</p>
</li>
<li class="lvl-2">
<p>申请一个大对象（比如超过 Eden 区一半大小）</p>
</li>
<li class="lvl-2">
<p>GC 后 Eden 区对象大小超过 S 区之和</p>
</li>
<li class="lvl-2">
<p>Eden 区 + S0 区 GC 后，S1 区放不下</p>
</li>
</ul>
<p>换言之，正常情况下，<code>-Xmn</code>参数总是应当小于<code>-Xmx</code>参数，否则就会触发<code>OOM</code>错误。</p>
<h1>4 CPU占用过高，排查和处理</h1>
<p>在Linux环境下，项目出现CPU占用过高的情况时，可以按照以下步骤进行排查和处理：</p>
<ol>
<li class="lvl-3">
<p><strong>定位高CPU占用的进程</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">使用<code>top</code>命令查看系统中CPU占用率最高的进程。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>分析进程中的线程</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">如果发现某个进程的CPU占用率特别高，可以使用<code>top -H -p [PID]</code>来查看该进程中各个线程的CPU占用情况。</li>
<li class="lvl-6">找出占用CPU最高的线程ID。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>转换线程ID为16进制</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">使用<code>printf &quot;%x\n&quot; [线程ID]</code>命令将线程ID转换为16进制格式。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>获取线程堆栈信息</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">使用<code>jstack [进程PID] | grep [线程ID的16进制] -A 30</code>命令获取该线程的Java堆栈信息（如果是Java进程）。这可以帮助定位到具体的代码行或方法调用。</li>
<li class="lvl-6">如果不是Java进程，可以使用<code>gdb</code>或其他相应的调试工具来获取线程的堆栈信息。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>分析代码和日志</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">根据堆栈信息，检查相关的代码逻辑，看是否有死循环、资源泄露、复杂计算等导致CPU占用过高的问题。</li>
<li class="lvl-6">同时检查应用程序的日志，看是否有异常或错误信息与高CPU占用相关。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>处理措施</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">如果是代码问题，修复相应的bug或优化算法。</li>
<li class="lvl-6">如果是配置问题，调整系统或应用程序的配置参数。</li>
<li class="lvl-6">如果是资源不足，考虑增加硬件资源或优化资源分配。</li>
<li class="lvl-6">如果是外部攻击，加强系统的安全防护措施。<a href="https://blog.csdn.net/baiye_xing/article/details/90483169">线上Java 高CPU占用、高内存占用排查思路_java程序,在线metaspace使用高-CSDN博客</a><a href="https://zhuanlan.zhihu.com/p/312276166">助你了解jvm命令，查找JVM堆栈信息，分析性能问题 - 知乎 (zhihu.com)</a></li>
</ul>
</li>
</ol>
<h1>5 参考</h1>
<p>JVM参数<a href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html">最重要的JVM参数总结 | JavaGuide</a><br>
<a href="https://blog.csdn.net/o9109003234/article/details/119951151">美团面试：熟悉哪些JVM调优参数，幸好我准备过！-CSDN博客</a></p>
<p><a href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html">JDK监控和故障处理工具总结 | JavaGuide</a><br>
<a href="https://www.cnblogs.com/mylibs/p/production-accident-0002.html">生产事故-记一次特殊的OOM排查 - 程语有云 - 博客园 (cnblogs.com)</a><br>
<a href="https://heapdump.cn/article/1661497">YGC问题排查，又让我涨姿势了！ | HeapDump性能社区</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/04/08/%E6%A1%86%E6%9E%B6/JVM/JVM%20(2)%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/08/%E6%A1%86%E6%9E%B6/JVM/JVM%20(2)%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="post-title-link" itemprop="url">JVM (2)：垃圾回收</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-08 00:00:00" itemprop="dateCreated datePublished" datetime="2024-04-08T00:00:00+08:00">2024-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-06 15:18:17" itemprop="dateModified" datetime="2024-06-06T15:18:17+08:00">2024-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1. GC触发时机
2. 死亡对象判断方法
3. 垃圾收集算法
4. 垃圾收集器</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/08/%E6%A1%86%E6%9E%B6/JVM/JVM%20(2)%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/04/02/%E8%AF%AD%E6%B3%95/Java/Java(2)%EF%BC%9A%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/02/%E8%AF%AD%E6%B3%95/Java/Java(2)%EF%BC%9A%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-02 17:02:50" itemprop="dateCreated datePublished" datetime="2024-04-02T17:02:50+08:00">2024-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-13 20:32:03" itemprop="dateModified" datetime="2024-05-13T20:32:03+08:00">2024-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>异常</h1>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405132023043.png" alt="image.png|500"></p>
<h2 id="Exception和Error">Exception和Error</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</p>
</li>
<li class="lvl-2">
<p><strong><code>Error</code></strong>：<code>Error</code> 属于程序无法处理的错误</p>
</li>
</ul>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>NullPointerException</code>(空指针错误)</p>
</li>
<li class="lvl-2">
<p><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</p>
</li>
<li class="lvl-2">
<p><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类，s包含非数字字符，或者为null）</p>
</li>
<li class="lvl-2">
<p><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</p>
</li>
<li class="lvl-2">
<p><code>ClassCastException</code>（类型转换错误）</p>
</li>
<li class="lvl-2">
<p><code>ArithmeticException</code>（算术错误）</p>
</li>
<li class="lvl-2">
<p><code>SecurityException</code> （安全错误比如权限不够）</p>
</li>
<li class="lvl-2">
<p><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</p>
</li>
</ul>
<h3 id="如何使用-try-with-resources-代替try-catch-finally？">如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>泛型</h1>
<blockquote>
<p>在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code></p>
</blockquote>
<p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/04/01/%E6%A1%86%E6%9E%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%80%89%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/01/%E6%A1%86%E6%9E%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%80%89%E5%9E%8B/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-01 22:58:25" itemprop="dateCreated datePublished" datetime="2024-04-01T22:58:25+08:00">2024-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-05 16:12:06" itemprop="dateModified" datetime="2024-06-05T16:12:06+08:00">2024-06-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>1 Kafka</h1>
<p>Kafka 将生产者发布的消息发送到 <strong>Topic（主题）</strong> 中，需要这些消息的消费者可以订阅这些 <strong>Topic（主题）</strong>。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202406051118494.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2"><strong>Producer（生产者）</strong> : 产生消息的一方。</li>
<li class="lvl-2"><strong>Consumer（消费者）</strong> : 消费消息的一方。</li>
<li class="lvl-2"><strong>Broker（代理）</strong> : 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。</li>
<li class="lvl-2"><strong>Topic（主题）</strong> : Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</li>
<li class="lvl-2"><strong>Partition（分区）</strong> : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。这正如我上面所画的图一样</li>
</ul>
<blockquote>
<p>同一topic下不同partition中存储的是完整消息流的一部分，所有partition中数据相加是完整的消息流数据，partition中的数据是不一致的。分区存储在不同的broker提升并发处理能力</p>
</blockquote>
<h2 id="1-1-多副本机制">1.1 多副本机制</h2>
<p>Kafka为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间有一个leader， 其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与leader副本交互，其他副本是leader副本的拷贝，它们的存在是为了保证消息存储的安全性。</p>
<h2 id="1-2-多分区-Partition-以及多副本-Replica">1.2 多分区(Partition)以及多副本(Replica)</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力（负载均衡）。</p>
</li>
<li class="lvl-2">
<p>Partition 可以指定对应的 Replica 数, 这也极大地提高了<code>消息存储的安全性</code>, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</p>
</li>
</ul>
<h2 id="1-3-为什么Redis-Pub-Sub比Kafka更快一些？二者之间如何选取？">1.3 为什么Redis Pub/Sub比Kafka更快一些？二者之间如何选取？</h2>
<blockquote>
<p><strong>为什么Redis Pub/Sub比Kafka更快一些？</strong> Redis是一个内存数据库，其Pub/Sub功能将消息保存在内存中。由于内存访问速度通常远快于磁盘访问速度，因此Redis在处理实时性较高的消息推送时具有优势。此外，Redis的Pub/Sub模型相对简单，使得它在处理发布和订阅操作时的开销较小。 然而，Kafka是一个完整的系统，提供了高吞吐量、分布式的提交日志。它旨在处理大规模数据流，具有强大的持久化能力和容错性。Kafka的分布式架构和分区机制使得它能够在多个消费者之间实现负载均衡，从而提高整体处理能力。</p>
</blockquote>
<blockquote>
<p><strong>二者之间如何选取？</strong></p>
<p><strong>Redis PUB/SUB使用场景：</strong></p>
<ol>
<li class="lvl-3">
<p>消息持久性需求不高</p>
</li>
<li class="lvl-3">
<p>吞吐量要求不高</p>
</li>
<li class="lvl-3">
<p>可以忍受数据丢失</p>
</li>
<li class="lvl-3">
<p>数据量不大</p>
</li>
</ol>
<p><strong>Kafka使用场景：</strong>(上面以外的其他场景)</p>
<ol>
<li class="lvl-3">
<p>高可靠性</p>
</li>
<li class="lvl-3">
<p>高吞吐量</p>
</li>
<li class="lvl-3">
<p>持久性高</p>
</li>
<li class="lvl-3">
<p>多样化的消费处理模型</p>
</li>
</ol>
</blockquote>
<h2 id="1-4-kafaka消费顺序、消息丢失、重复消费">1.4 kafaka消费顺序、消息丢失、重复消费</h2>
<h3 id="1-4-1-消费顺序">1.4.1 消费顺序</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>1个Topic只对应一个Partition</p>
</li>
<li class="lvl-2">
<p>发送消息的时候指定key或Partition</p>
</li>
</ul>
<p>Kafka 中发送 1 条消息的时候，可以指定<code> topic, partition, key,data（数据）</code> 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表/对象的 id 来作为 key 。</p>
<h3 id="1-4-2-消息丢失">1.4.2 消息丢失</h3>
<h4 id="生产者丢失消息">生产者丢失消息</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>确认机制</p>
</li>
<li class="lvl-2">
<p>失败重试机制</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SendResult&lt;String, Object&gt; sendResult = kafkaTemplate.send(topic, o).get();</span><br><span class="line"><span class="keyword">if</span> (sendResult.getRecordMetadata() != <span class="literal">null</span>) &#123;</span><br><span class="line">  logger.info(<span class="string">&quot;生产者成功发送消息到&quot;</span> + sendResult.getProducerRecord().topic() + <span class="string">&quot;-&gt; &quot;</span> + sendRe</span><br><span class="line">              sult.getProducerRecord().value().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = kafkaTemplate.send(topic, o);</span><br><span class="line">future.addCallback(result -&gt; logger.info(<span class="string">&quot;生产者成功发送消息到topic:&#123;&#125; partition:&#123;&#125;的消息&quot;</span>, result.getRecordMetadata().topic(), result.getRecordMetadata().partition()),</span><br><span class="line">                ex -&gt; logger.error(<span class="string">&quot;生产者发送消失败，原因：&#123;&#125;&quot;</span>, ex.getMessage()));</span><br></pre></td></tr></table></figure>
<h4 id="消费者丢失消息">消费者丢失消息</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>消费前提交offset（丢失消息）</p>
</li>
<li class="lvl-2">
<p>消费后提交offset（提交offset失败，重复消费）</p>
</li>
</ul>
<h4 id="Kafka丢失消息">Kafka丢失消息</h4>
<blockquote>
<p>leader中的数据还有一些没有被follower副本同步的话，会造成消息丢失</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置acks=all<br>
acks 的默认值即为 1，代表我们的消息被 leader 副本接收之后就算被成功发送。当我们配置 <strong>acks = all</strong> 表示只有所有 ISR 列表的副本全部收到消息时，生产者才会接收到来自服务器的响应</p>
</li>
<li class="lvl-2">
<p><strong>设置 replication.factor &gt;= 3</strong>：保证每个分区有3个副本</p>
</li>
<li class="lvl-2">
<p><strong>设置 min.insync.replicas &gt; 1（ISR）</strong>：消息至少写入2个副本才算发送成功</p>
</li>
</ul>
<h3 id="1-4-3-重复消费">1.4.3 重复消费</h3>
<p><strong>kafka 出现消息重复消费的原因：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>服务端侧已经消费的数据没有成功提交 offset（根本原因）。</p>
</li>
<li class="lvl-2">
<p>Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了<code>分区 rebalance</code>。</p>
</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>消费消息服务做幂等校验</code>，比如 Redis 的 set、MySQL 的主键等天然的幂等功能。这种方法最有效。</p>
</li>
<li class="lvl-2">
<p>将 enable.auto.commit 参数设置为 false，<code>关闭自动提交</code>，开发者在代码中手动提交 offset。那么这里会有个问题：什么时候提交 offset 合适？</p>
<ul class="lvl-2">
<li class="lvl-6">处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li>
<li class="lvl-6">拉取到消息即提交：会有<strong>消息丢失</strong>的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li>
</ul>
</li>
</ul>
<p><a href="https://cloud.tencent.com/developer/article/1665700">Kafka常见的导致重复消费原因和解决方案-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<h2 id="1-5-分区rebalance">1.5 分区rebalance</h2>
<p><a href="https://cloud.tencent.com/developer/article/1852157">一文理解Kafka的选举机制与Rebalance机制-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<h2 id="1-6-Kafka重试机制">1.6 Kafka重试机制</h2>
<h3 id="1-6-1-重试失败后的数据如何再次处理">1.6.1 重试失败后的数据如何再次处理</h3>
<p>死信队列（Dead Letter Queue，简称 DLQ） 是消息中间件中的一种特殊队列。它主要用于处理无法被消费者正确处理的消息，通常是因为消息格式错误、处理失败、消费超时等情况导致的消息被&quot;丢弃&quot;或&quot;死亡&quot;的情况。当消息进入队列后，消费者会尝试处理它。如果处理失败，或者超过一定的重试次数仍无法被成功处理，消息可以发送到死信队列中，而不是被永久性地丢弃。在死信队列中，可以进一步分析、处理这些无法正常消费的消息，以便定位问题、修复错误，并采取适当的措施。</p>
<h2 id="1-7-Kafka消息丢失">1.7 Kafka消息丢失</h2>
<p><a href="https://blog.csdn.net/jam_yin/article/details/131979567">Kafka消息丢失：原因、解决方案和零丢失的配置-CSDN博客</a></p>
<h2 id="1-8-Kafka中ISR">1.8 Kafka中ISR</h2>
<p>首先，ISR 的全称叫做：In-Sync Replicas （同步副本集）, 我们可以理解为和 leader 保持同步的所有副本的集合。</p>
<p>一个分区的所有副本集合叫做 AR（ Assigned Repllicas ） ，与 leader-replica 未能保持同步的副本集叫做 OSR（ Out-Sync Relipcas ）。</p>
<p>因此我们就能得到这么一个表示：AR = ISR + OSR，翻译一下就是一个分区的副本集分为同步集合和非同步集合两部分。</p>
<p>ISR 的作用：是通过副本机制实现消息高可靠，服务高可用时，不可缺少的一环</p>
<p><a href="https://cloud.tencent.com/developer/article/2231968">说一说你对 Kafka 中 ISR 的理解-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<h1>2 RocketMQ</h1>
<p><a href="https://blog.csdn.net/ctwctw/article/details/107188474">RocketMQ的核心概念以及架构图_rocketmq架构图-CSDN博客</a></p>
<h1>3 消息队列比较</h1>
<table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th><code>RocketMQ</code></th>
<th><code>kafka</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>开发语言</td>
<td>java</td>
<td>erlang</td>
<td>java</td>
<td>scala</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>万级</td>
<td>万级</td>
<td>10万级</td>
<td>10万级，吞吐量高。一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>时效性</td>
<td>ms级</td>
<td>us级，这是rabbitmq的一大特点，延迟是最低的</td>
<td>ms级</td>
<td>ms级</td>
</tr>
<tr>
<td>可用性</td>
<td>高（主从架构）</td>
<td>高（主从架构）</td>
<td>非常高（分布式架构）</td>
<td>非常高（分布式架构），kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>优劣势总结</td>
<td>非常成熟，功能强大，在业内大量的公司以及项目中都有应用偶尔会有较低概率丢失消息，主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用</td>
<td>erlang语言开发，性能极其好，延时很低；吞吐量到万级，MQ功能比较完备而且开源提供的管理界面非常棒</td>
<td></td>
<td>提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展同时kafka最好是支撑较少的topic数量即可，保证其<strong>超高吞吐量</strong>而且kafka唯一的一点劣势是有可能<strong>消息重复消费</strong>，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合<strong>大数据实时计算以及日志收集</strong><br></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>消费推拉模式</strong><br>
客户端消费者获取消息的方式，Kafka和RocketMQ是通过长轮询Pull的方式拉取消息，RabbitMQ、Pulsar、NSQ都是通过Push的方式。</p>
<p>pull类型的消息队列更适合高吞吐量的场景，允许消费者自己进行流量控制，根据消费者实际的消费能力去获取消息。而push类型的消息队列，实时性更好，但需要有一套良好的流控策略（backpressure）当消费者消费能力不足时，减少push的消费数量，避免压垮消费端。</p>
</li>
<li class="lvl-2">
<p><strong>延迟队列</strong><br>
延迟消息的使用场景比如异常检测重试，订单超时取消等，例如：</p>
<ul class="lvl-2">
<li class="lvl-6">服务请求异常，需要将异常请求放到单独的队列，隔5分钟后进行重试；</li>
<li class="lvl-6">用户购买商品，但一直处于未支付状态，需要定期提醒用户支付，超时则关闭订单；</li>
<li class="lvl-6">面试或者会议预约，在面试或者会议开始前半小时，发送通知再次提醒。<br>
Kafka不支持延迟消息，RocketMQ开源版本延迟消息临时存储在一个内部主题中，不支持任意时间精度，支持特定的level，例如定时5s，10s，1m等。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>死信队列</strong><br>
Kafka、RocketMQ、Pulsar、NSQ不支持优先级队列，可以通过不同的队列来实现消息优先级。<br>
RabbitMQ支持优先级消息。</p>
</li>
<li class="lvl-2">
<p><strong>优先级队列</strong></p>
</li>
<li class="lvl-2">
</li>
</ul>
<h1>4 消息队列选择建议</h1>
<p><strong>1.Kafka</strong><br>
Kafka主要特点是基于Pull的模式来处理消息消费，追求<strong>高吞吐量</strong>，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。</p>
<p>大型公司建议可以选用，如果有日志采集功能，肯定是首选kafka了。</p>
<p><strong>2.RocketMQ</strong><br>
天生为<strong>金融互联网领域</strong>而生，对于<strong>高可靠性</strong>的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。</p>
<p>RoketMQ在稳定性上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择RocketMQ。</p>
<p><strong>3.RabbitMQ</strong><br>
RabbitMQ :结合erlang语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护。不过，RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug。</p>
<p>如果你的数据量没有那么大，小公司优先选择功能比较完备的RabbitMQ。</p>
<p><a href="https://cloud.tencent.com/developer/article/1944357">10分钟搞懂！消息队列选型全方位对比-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a href="https://blog.csdn.net/z_344791576/article/details/137820230">一文详解七大主流消息队列（MQ）：特性、应用场景与对比分析_常见的mq消息队列-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_44240587/article/details/104630567">MQ消息队列详解、四大MQ的优缺点分析_四大消息队列的优缺点-CSDN博客</a><a href="https://blog.csdn.net/z_344791576/article/details/137820230">一文详解七大主流消息队列（MQ）：特性、应用场景与对比分析_常见的mq消息队列-CSDN博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-01 21:02:51" itemprop="dateCreated datePublished" datetime="2024-04-01T21:02:51+08:00">2024-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-20 21:51:07" itemprop="dateModified" datetime="2024-05-20T21:51:07+08:00">2024-05-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>Linux常用命令</h1>
<ul class="lvl-0">
<li class="lvl-2">chmod：更改文件或目录的权限。</li>
<li class="lvl-2">cat：查看文件内容</li>
<li class="lvl-2">top：inux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况.该命令可以提供实时的对系统处理器的状态监视，它会显示系统中CPU最“敏感”的任务列表，并且可以按CPU使用、内存使用和执行时间对任务进行排序</li>
</ul>
<h2 id="grep">grep</h2>
<blockquote>
<p>分析一行信息</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v</td>
<td>排除选项</td>
</tr>
<tr>
<td>grep -v ‘^$’ filename</td>
<td>^：行首，$：行尾，去掉空行</td>
</tr>
<tr>
<td>grep -v ‘<sup>#|</sup>$’ filename</td>
<td>^#：以#开头，去掉空行和以#开头的行</td>
</tr>
</tbody>
</table>
<h2 id="tar">tar</h2>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">压缩命令</span><br><span class="line">tar：该命令用于将多个文件或目录打包成一个文件，也可以同时对其进行压缩。常用的参数有：</span><br><span class="line"><span class="deletion">-c：创建新的压缩文件。</span></span><br><span class="line"><span class="deletion">-v：显示详细的压缩过程。</span></span><br><span class="line"><span class="deletion">-f：指定压缩文件的名称。</span></span><br><span class="line"><span class="deletion">-z：使用gzip压缩算法进行压缩。</span></span><br><span class="line"><span class="deletion">-j：使用bzip2压缩算法进行压缩。</span></span><br><span class="line"><span class="deletion">-J：使用xz压缩算法进行压缩。</span></span><br><span class="line"></span><br><span class="line">解压命令：</span><br><span class="line">tar：该命令不仅可以用于压缩，也可以用于解压。解压时常用的参数有：</span><br><span class="line"><span class="deletion">-x：从压缩文件中提取文件或目录。</span></span><br><span class="line"><span class="deletion">-v：显示详细的解压过程。</span></span><br><span class="line"><span class="deletion">-f：指定要解压的压缩文件名称。</span></span><br><span class="line"><span class="deletion">-z：解压使用gzip压缩算法的文件。</span></span><br><span class="line"><span class="deletion">-j：解压使用bzip2压缩算法的文件。</span></span><br><span class="line"><span class="deletion">-J：解压使用xz压缩算法的文件。</span></span><br><span class="line">例如，要解压doc.tar.gz到当前目录，可以使用命令tar -xzvf doc.tar.gz。</span><br></pre></td></tr></table></figure>
<h2 id="top">top</h2>
<p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况</p>
<h2 id="ps">ps</h2>
<p>ps命令用于报告当前系统的进程状态。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。</p>
<h2 id="free">free</h2>
<p>free命令可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。</p>
<p><a href="https://www.jianshu.com/p/4bca8fe8a878">面试官常考的 21 条 Linux 命令 - 简书 (jianshu.com)</a></p>
<h1>文件系统</h1>
<h2 id="6-Linux相关：文件的概念？文件有哪些类型？各自的作用是什么？">6. Linux相关：文件的概念？文件有哪些类型？各自的作用是什么？</h2>
<p><strong>解析：</strong>： 文件类型很多，能回答几种常见的就行，例如普通文件，目录文件，块设备文件，套接字文件。 <strong>参考回答：</strong></p>
<blockquote>
<p>1.普通文件（-）：这是最常见的文件类型，包括纯文本文件、二进制文件、数据文件等。它们不包含文件系统的结构信息，只是用户所接触到的文件。例如，.c文件、可执行的二进制文件等都是普通文件。</p>
<p>2.目录文件（d）：目录文件是用于存放文件名及其相关信息的文件。它们可以包含下一级文件目录或普通文件，是内核组织文件系统的基本节点。通过目录文件，用户可以轻松地浏览和管理文件系统。</p>
<p>3.字符设备文件（c）：这类文件提供了对设备不带缓冲区的访问，每次访问长度可变。它们通常用于表示系统中的字符设备，如控制台、串口等。</p>
<p>4.块设备文件（b）：块设备文件提供对设备（如磁盘）带缓冲的访问，每次访问以固定的长度单位进行。它们用于表示系统中的块设备，如硬盘、U盘等。</p>
<p>5.FIFO（p）：FIFO文件也称为命名管道，用于进程间的通信。它们允许一个进程向另一个进程发送数据，而不需要通过中间的文件或网络连接。</p>
<p>6.套接字（s）：套接字文件用于进程间的网络通信。它们提供了一种在不同进程之间传输数据的方式，通常用于实现网络服务和客户端之间的通信。</p>
<p>7.链接文件（l）：链接文件是指向另一个文件的指针。它们可以分为硬链接和符号链接两种。硬链接指向文件的inode节点，而符号链接则指向另一个文件的路径名。通过链接文件，用户可以方便地访问其他文件或目录。</p>
<p>除了以上七种常见的文件类型外，Linux系统中还有其他一些特殊的文件类型，如特殊文件、门文件等，但这些类型在日常使用中相对较少见。</p>
</blockquote>
<p><strong>学习指引：</strong> <a href="https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fos%2F6_file_system%2Ffile_system.html%23%25E6%2596%2587%25E4%25BB%25B6%25E7%25B3%25BB%25E7%25BB%259F%25E7%259A%2584%25E5%259F%25BA%25E6%259C%25AC%25E7%25BB%2584%25E6%2588%2590">推荐学习：小林 coding|图解系统｜文件系统</a></p>
<h2 id="7-Linux相关：inode的作用？inode包含哪些内容？给出一个文件名，Linux是如何根据该文件名打开文件的？（文件名-inode-block）文件的访问时间是如何记录的？">7. Linux相关：inode的作用？inode包含哪些内容？给出一个文件名，Linux是如何根据该文件名打开文件的？（文件名-&gt;inode-&gt;block）文件的访问时间是如何记录的？</h2>
<p><strong>解析：</strong>： 考察linux文件系统相关问题，比较细，推荐大家系统学习后理解掌握 <strong>参考回答：</strong></p>
<blockquote>
<p><strong>1.inode的作用？：</strong> inode，即索引节点，在Linux文件系统中用于存储文件或目录的元数据信息。它是文件系统的一个基本组成部分，允许系统通过inode号而非完整的文件路径快速访问到文件数据。</p>
<p><strong>2.inode包含哪些内容？：</strong> inode包含文件的元数据信息，如文件大小、文件所有者、文件权限、文件类型、文件的创建/访问/修改时间等。此外，inode还包含指向文件数据块的指针，这些指针指示了文件内容在磁盘上的实际存储位置。</p>
<p><mark><strong>3.给出一个文件名，Linux是如何根据该文件名打开文件的？</strong> <strong>（文件名-&gt;inode-&gt;block）</strong></mark>： 当给出一个文件名时，Linux首先会根据文件路径在目录结构中查找该文件对应的<mark>目录项</mark>。目录项中包含了文件的inode号。然后，系统会使用这个inode号在文件系统中找到对应的inode结构。一旦找到inode，系统就可以通过inode中的指针找到文件数据所在的磁盘块（block）。最后，系统将这些磁盘块加载到内存中，从而打开并访问文件。</p>
<p><strong>4.文件的访问时间是如何记录的</strong>？： 文件的访问时间是通过inode中的访问时间戳（atime）来记录的。每当文件被读取时，其inode中的atime就会被更新为当前时间。这个机制允许系统跟踪文件的访问历史，以便进行各种管理和维护操作。需要注意的是，为了优化性能，某些文件系统可能会延迟更新atime或仅在文件内容实际被读取时更新它。</p>
</blockquote>
<p><a href="https://www.nowcoder.com/discuss/590576768491216896?sourceSSR=users">阿里云 实习面经（已OC） 一面面经｜讲解_牛客网 (nowcoder.com)</a></p>
<h2 id="8-零拷贝是什么？用来解决什么问题？有哪些应用场景？实现方式有哪些？">8. 零拷贝是什么？用来解决什么问题？有哪些应用场景？实现方式有哪些？</h2>
<p><strong>解析：</strong>：</p>
<p><strong>参考回答：</strong></p>
<blockquote>
<p><strong>1.是什么？</strong>：零拷贝是一种IO操作优化技术，旨在减少数据在内核空间和用户空间之间的冗余拷贝，从而解放CPU、减少上下文切换并降低系统资源消耗。它主要用来解决传统IO操作中不必要的数据拷贝问题，提高数据传输效率。</p>
<p><strong>2.应用场景</strong>：零拷贝技术广泛应用于需要高性能数据传输的场景，如网络传输、文件传输、数据库操作等。在这些场景中，大量的数据需要在内核空间和用户空间之间传输，传统的IO操作会导致不必要的数据拷贝和性能损失。</p>
<p><strong>3.实现方式有哪些？</strong>：实现零拷贝的方式主要有mmap、sendfile、splice和tee等。其中，mmap通过内存映射将内核缓冲区与用户空间共享，避免了数据拷贝；sendfile直接将数据从内核缓冲区发送到网络缓冲区，减少了CPU拷贝；splice和tee则在内核空间内实现数据的传输和复制，避免了用户空间的参与。这些技术根据具体的应用场景和需求选择使用，可以有效地提高数据传输效率和系统性能。</p>
</blockquote>
<p><strong>学习指引：</strong> <a href="https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fos%2F8_network_system%2Fzero_copy.html">图解系统：什么是零拷贝？如何实现零拷贝？</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">数据库优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-26 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-26T00:00:00+08:00">2024-03-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-29 21:46:33" itemprop="dateModified" datetime="2024-05-29T21:46:33+08:00">2024-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1. 读写分离
2. 分库分表
3. 数据库查询优化</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/03/05/%E8%AF%AD%E6%B3%95/Java/Java%E5%B9%B6%E5%8F%91(4)%EF%BC%9AThreadPoolExecutor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/05/%E8%AF%AD%E6%B3%95/Java/Java%E5%B9%B6%E5%8F%91(4)%EF%BC%9AThreadPoolExecutor/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-03-05 20:42:29 / 修改时间：21:21:44" itemprop="dateCreated datePublished" datetime="2024-03-05T20:42:29+08:00">2024-03-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Executes the given task sometime in the future.  The task * may execute in a new thread or in an existing pooled thread. * * If the task cannot be submitted for execution, either because this * executor has been shutdown or because its capacity has been reached, * the task is handled by the current &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;.  </span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@param</span> command the task to execute  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException at discretion of  </span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;, if the task  </span></span><br><span class="line"><span class="comment"> *         cannot be accepted for execution * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> command&#125; is null  </span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();  </span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:     *     * 1. If fewer than corePoolSize threads are running, try to     * start a new thread with the given command as its first     * task.  The call to addWorker atomically checks runState and     * workerCount, and so prevents false alarms that would add     * threads when it shouldn&#x27;t, by returning false.     *     * 2. If a task can be successfully queued, then we still need     * to double-check whether we should have added a thread     * (because existing ones died since last checking) or that     * the pool shut down since entry into this method. So we     * recheck state and if necessary roll back the enqueuing if     * stopped, or start a new thread if there are none.     *     * 3. If we cannot queue task, then we try to add a new     * thread.  If it fails, we know we are shut down or saturated     * and so reject the task.     */</span>    </span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();  </span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        c = ctl.get();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();  </span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))  </span><br><span class="line">            reject(command);  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)  </span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))  </span><br><span class="line">        reject(command);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.throwx.cn/2020/08/23/java-concurrency-thread-pool-executor/">硬核干货：4W字从源码上分析JUC线程池ThreadPoolExecutor的实现原理 | Throwable (throwx.cn)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/03/04/%E8%AF%AD%E6%B3%95/Java/Java(3)%EF%BC%9A%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/04/%E8%AF%AD%E6%B3%95/Java/Java(3)%EF%BC%9A%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-04 10:11:52" itemprop="dateCreated datePublished" datetime="2024-03-04T10:11:52+08:00">2024-03-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-29 11:47:00" itemprop="dateModified" datetime="2024-05-29T11:47:00+08:00">2024-05-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 、 <code>Queue</code>。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405281131352.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2"><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
<li class="lvl-2"><code>Set</code>(注重独一无二的性质): 存储的元素不可重复的。</li>
<li class="lvl-2"><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li class="lvl-2"><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，“x” 代表 key，“y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<table>
<thead>
<tr>
<th>集合</th>
<th>实现</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>List</td>
<td>ArrayList</td>
<td></td>
</tr>
<tr>
<td></td>
<td>vector</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LinkedList</td>
<td></td>
</tr>
<tr>
<td>Set</td>
<td>HashSet</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LinkedHashSet</td>
<td></td>
</tr>
<tr>
<td></td>
<td>TreeSet</td>
<td></td>
</tr>
<tr>
<td>Map</td>
<td>HashMap</td>
<td>线程不安全，key、value都可为null</td>
</tr>
<tr>
<td></td>
<td>LinkedHashMap</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HashTable</td>
<td>线程安全</td>
</tr>
<tr>
<td></td>
<td>TreeMap</td>
<td></td>
</tr>
</tbody>
</table>
<p>Queue</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>PriorityQueue</p>
</li>
<li class="lvl-2">
<p>DelayQueue</p>
</li>
<li class="lvl-2">
<p>ArrayDeque</p>
</li>
</ul>
<p><code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。</p>
<h1>1 List</h1>
<h2 id="1-1-ArrayList和LinkedList区别">1.1 ArrayList和LinkedList区别</h2>
<ol>
<li class="lvl-3">
<p><strong>底层数据结构：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>ArrayList</code>使用<em>动态数组</em>实现。它的内部是一个数组，当数组容量不足时，会自动进行扩容。</li>
<li class="lvl-6"><code>LinkedList</code>使用<em>双向链表</em>实现。每个元素都包含一个指向前一个元素和一个指向后一个元素的引用。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>随机访问性能：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>ArrayList</code>支持快速的随机访问，因为它是基于数组的，可以通过索引直接访问元素。</li>
<li class="lvl-6"><code>LinkedList</code>在随机访问时性能较差，因为必须从链表的头部或尾部开始遍历，直到找到目标元素。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>插入和删除操作性能：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>ArrayList</code>在中间插入或删除元素时性能较差，因为需要移动数组中的元素。</li>
<li class="lvl-6"><code>LinkedList</code>在插入和删除元素时性能较好，因为只需要改变相邻元素的引用。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>空间复杂度：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>ArrayList</code>相对较省空间，因为它只需要存储元素值和数组容量。</li>
<li class="lvl-6"><code>LinkedList</code>相对较耗费空间，因为每个元素都需要额外的两个引用字段。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>迭代器性能：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>ArrayList</code>上的迭代器性能较好，因为它可以通过索引直接访问元素。</li>
<li class="lvl-6"><code>LinkedList</code>上的迭代器性能较差，因为必须沿着链表一个一个地移动。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>适用场景：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">如果需要频繁进行随机访问，使用<code>ArrayList</code>更为合适。</li>
<li class="lvl-6">如果需要频繁进行插入和删除操作，特别是在集合的中间位置，使用<code>LinkedList</code>更为合适。</li>
</ul>
</li>
</ol>
<h1>2 Set</h1>
<h2 id="2-1-Comparable和Comparator">2.1 Comparable和Comparator</h2>
<p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</p>
</li>
<li class="lvl-2">
<p><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</p>
</li>
</ul>
<h2 id="2-2-Hashset、LinkedHashSet、TreeSet">2.2 Hashset、LinkedHashSet、TreeSet</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</p>
</li>
<li class="lvl-2">
<p>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</p>
</li>
</ul>
<h1>3 Map</h1>
<h2 id="3-1-HashMap和TreeMap">3.1 HashMap和TreeMap</h2>
<p><strong>相比于<code>HashMap</code>来说， <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>
<h2 id="3-2-HashMap">3.2 HashMap</h2>
<h3 id="3-2-1-扩容机制">3.2.1 扩容机制</h3>
<ol>
<li class="lvl-3">
<p><strong>初始容量和负载因子：</strong></p>
<ul class="lvl-2">
<li class="lvl-6"><code>HashMap</code> 有一个初始容量和一个负载因子。初始容量是哈希表在创建时的容量，默认为 16。负载因子是一个在哈希表大小超过其容量乘以负载因子时，哈希表将进行扩容的阈值，默认为 0.75。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>扩容操作：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">当哈希表的元素个数达到了负载因子所定义的阈值，<code>HashMap</code> 将进行扩容操作。</li>
<li class="lvl-6">扩容操作包括创建一个新的哈希表，其容量为原容量的两倍，然后将所有元素重新分配到新的哈希表中。<br>
<a href="https://zhuanlan.zhihu.com/p/114363420">HashMap的扩容机制 - 知乎 (zhihu.com)</a><br>
<a href="https://blog.csdn.net/qq_49217297/article/details/126304736">HashMap实现原理， 扩容机制，面试题和总结_hashmap扩容机制面试-CSDN博客</a></li>
</ul>
</li>
</ol>
<h3 id="3-2-2-HashMap多线程导致死循环">3.2.2 HashMap多线程导致死循环</h3>
<p>当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，<code>头插法</code>可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。</p>
<p><a href="https://coolshell.cn/articles/9606.html">疫苗：Java HashMap的死循环 | 酷 壳 - CoolShell</a></p>
<h3 id="3-2-3-HashMap为什么线程不安全">3.2.3 HashMap为什么线程不安全</h3>
<p>多线程环境下，<code>HashMap</code> 扩容时会造成<code>死循环</code> 和<code>数据丢失</code>的问题。在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对<code>HashMap</code>的put操作会导致线程不安全，可能产生数据覆盖.</p>
<h4 id="3-2-3-1-同时检测到桶位置为空，插入元素">3.2.3.1 同时检测到桶位置为空，插入元素</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>两个线程同时进行put操作，并且存在哈希冲突</p>
</li>
<li class="lvl-2">
<p>由于线程首先都执行完了hash碰撞的判断，桶为空</p>
</li>
<li class="lvl-2">
<p>每个线程再向空桶中插入元素</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 判断是否出现 hash 碰撞</span></span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素（处理hash冲突）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-3-2-多个线程同时put操作导致size不正确">3.2.3.2 多个线程同时put操作导致size不正确</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>两个线程都先获取size，在++size</p>
</li>
<li class="lvl-2">
<p>添加两次元素，而size只增加1</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://zhuanlan.zhihu.com/p/484653028">基于JDK8的HashMap实现(万字详解) - 知乎 (zhihu.com)</a></p>
<h3 id="3-2-4-底层实现">3.2.4 底层实现</h3>
<p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<h3 id="3-2-5-put添加元素过程">3.2.5 put添加元素过程</h3>
<ol>
<li class="lvl-3">
<p><strong>计算哈希码（Hash Code）：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">当你向 <code>HashSet</code> 中添加一个元素时，首先会调用该元素的 <code>hashCode()</code> 方法，得到元素的哈希码。</li>
<li class="lvl-6">如果元素为 <code>null</code>，则它的哈希码为 0。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>映射到桶位置（Bucket Position）：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">哈希码经过一系列的变换和运算，被映射到哈希表中的一个桶位置（bucket position）。</li>
<li class="lvl-6">桶位置是一个数组索引，表示存储元素的位置。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>处理哈希冲突：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">哈希表可能存在冲突，即不同元素映射到相同的桶位置。为了解决冲突，<code>HashSet</code> 使用链表或红黑树（在JDK 8之后）来存储相同桶位置上的元素。</li>
<li class="lvl-6">如果桶位置上已经有一个元素，新元素会被添加到链表或红黑树的末尾。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>检查元素唯一性：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">在添加元素的过程中，<code>HashSet</code> 会通过调用元素的 <code>equals()</code> 方法来检查元素的唯一性。</li>
<li class="lvl-6">如果已经存在相同的元素（根据 <code>equals()</code> 判断），新元素不会被加入。</li>
</ul>
</li>
</ol>
<h3 id="3-2-6-如何做到让HashMap线程安全">3.2.6 如何做到让HashMap线程安全</h3>
<ol>
<li class="lvl-3">
<p><strong>使用<code>Collections.synchronizedMap</code>方法：</strong><br>
Map&lt;K, V&gt; synchronizedMap = Collections.synchronizedMap(new HashMap&lt;K, V&gt;());</p>
<p>这将返回一个线程安全的<code>Map</code>，它在每个方法上都使用同步机制来确保线程安全。但请注意，虽然这确保了每个方法的原子性，但在多个操作之间，仍然可能需要额外的同步。</p>
</li>
<li class="lvl-3">
<p><strong>使用<code>ConcurrentHashMap</code>：</strong> <code>ConcurrentHashMap</code>是Java提供的线程安全的<code>Map</code>实现。它使用分段锁机制，每个段相当于一个小的<code>HashMap</code>，不同的段之间互不影响，这样可以提高并发性能。</p>
<p>Map&lt;K, V&gt; concurrentMap = new ConcurrentHashMap&lt;K, V&gt;();</p>
</li>
</ol>
<h2 id="3-3-ConcurrentHashMap">3.3 ConcurrentHashMap</h2>
<h3 id="3-3-1-1-7">3.3.1 1.7</h3>
<blockquote>
<p>通过分段锁（Segmentation）实现线程安全。它将整个哈希表分成多个段（Segment），每个段都是一个小的哈希表，并且拥有自己的锁。这样，多个线程可以并发地访问不同的段，从而减少了锁的竞争，提高了并发性能。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404012148392.png" alt="image.png"></p>
<h3 id="3-3-2-1-8">3.3.2 1.8</h3>
<blockquote>
<p>使用了一种更细粒度的锁策略，结合CAS（Compare-and-Swap）无锁算法来实现线程安全。在JDK 1.8中，ConcurrentHashMap将整个哈希表看作一个整体，不再进行分段。而是通过Node数组+链表+红黑树的结构来存储数据，并使用Synchronized和CAS来协调并发访问。</p>
</blockquote>
<p>锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404012149783.png" alt="image.png"></p>
<h3 id="3-3-3-JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？">3.3.3 JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p>
</li>
<li class="lvl-2">
<p><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</p>
</li>
<li class="lvl-2">
<p><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</p>
</li>
</ul>
<p><a href="https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html#_4-get">ConcurrentHashMap 源码分析 | JavaGuide</a><br>
<a href="https://zhuanlan.zhihu.com/p/94976168">一文彻底搞懂CAS实现原理 &amp; 深入到CPU指令 - 知乎 (zhihu.com)</a><br>
<a href="https://javaguide.cn/java/collection/java-collection-questions-02.html#map-%E9%87%8D%E8%A6%81">Java集合常见面试题总结(下) | JavaGuide</a></p>
<h1>4 Atomic</h1>
<p><code>java.util.concurrent.atomic</code> 包提供了一组用于在多线程环境中进行原子操作的类。这些类通过使用硬件级别的原子性操作或者利用 <code>sun.misc.Unsafe</code> 提供的 CAS（Compare-And-Swap）操作来确保对变量的操作是原子的。这些类大多数都是基于原始数据类型的，例如 <code>int</code>、<code>long</code>，还有一些是引用类型。</p>
<p>以下是 <code>java.util.concurrent.atomic</code> 包中一些主要的类以及它们的用途：</p>
<ol>
<li class="lvl-3">
<p><strong>AtomicInteger：</strong> 用于对整数进行原子操作，支持原子的自增（<code>incrementAndGet()</code>）、自减（<code>decrementAndGet()</code>）等操作。</p>
</li>
<li class="lvl-3">
<p><strong>AtomicLong：</strong> 用于对长整型进行原子操作，同样支持原子的自增、自减等操作。</p>
</li>
<li class="lvl-3">
<p><strong>AtomicBoolean：</strong> 用于对布尔类型进行原子操作，支持原子的设置和获取操作。</p>
</li>
<li class="lvl-3">
<p><strong>AtomicReference：</strong> 用于对引用类型进行原子操作，支持原子的获取和设置引用对象。</p>
</li>
<li class="lvl-3">
<p><strong>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray：</strong> 用于对数组中的元素进行原子操作，提供了一些原子性的数组操作。</p>
</li>
<li class="lvl-3">
<p><strong>AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater：</strong> 用于对类的字段进行原子更新，允许在并发环境中对对象的字段进行原子性操作。</p>
</li>
</ol>
<p>这些原子类提供了一种比使用 <code>synchronized</code> 关键字更轻量级的线程安全机制，特别适用于一些简单的计数器、状态标志等场景。在需要进行原子操作而又不需要全局的锁的情况下，这些类可以提供更好的性能。</p>
<p>虽然这些类提供了原子性的操作，但并不是所有的操作都可以用原子方式完成，因此在使用时仍然需要注意保证原子性的操作是否符合预期。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/02/28/%E8%AF%AD%E6%B3%95/Java/Java%E5%B9%B6%E5%8F%91(1)%EF%BC%9A%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/28/%E8%AF%AD%E6%B3%95/Java/Java%E5%B9%B6%E5%8F%91(1)%EF%BC%9A%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">Java：并发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-28 00:00:00" itemprop="dateCreated datePublished" datetime="2024-02-28T00:00:00+08:00">2024-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-06 15:31:11" itemprop="dateModified" datetime="2024-06-06T15:31:11+08:00">2024-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>线程、锁、条件变量</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/02/28/%E8%AF%AD%E6%B3%95/Java/Java%E5%B9%B6%E5%8F%91(1)%EF%BC%9A%E5%B9%B6%E5%8F%91/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2024/02/22/%E9%A1%B9%E7%9B%AE/MIT6.824%20Lab3%20KVraft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 我的个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/22/%E9%A1%B9%E7%9B%AE/MIT6.824%20Lab3%20KVraft/" class="post-title-link" itemprop="url">MIT6.824 Lab3 KVraft</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-22 16:28:21" itemprop="dateCreated datePublished" datetime="2024-02-22T16:28:21+08:00">2024-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-02 21:28:29" itemprop="dateModified" datetime="2024-03-02T21:28:29+08:00">2024-03-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1>Bug</h1>
<h3 id="1-panic-close-of-closed-channel">1. <code>panic: close of closed channel</code></h3>
<p>在server中，只使用了一个全局的管道来接收命令应用结果，PutAppend和Get共享一个管道，两个分别打开管道，随后一个关闭，另一个在关闭时出现问题</p>
<ul class="lvl-0">
<li class="lvl-2">给两个操作加锁，只有操作执行完（成功执行，超时）才解锁</li>
<li class="lvl-2">对Start返回的index，每一个添加一个管道</li>
</ul>
<h2 id="2-command被复制到半数以上服务器，但是还没有在状态机上执行，然后选举出新的leader，新的leader具有添加的命令">2. command被复制到半数以上服务器，但是还没有在状态机上执行，然后选举出新的leader，新的leader具有添加的命令</h2>
<p>在Lab2就想到的问题，一直考虑已经被添加的command如何被再次添加，发现在raft层无法解决这个问题。</p>
<p>在Lab3中遇到了此问题，考虑在server中记录client已经添加的命令（命令可能未执行成功），在收到更小的command时，则不调用Start添加到leader。这需要启用新的server作为leader时，快速将已有的命令执行完毕（在添加任何新命令之前），这一步难以实现。</p>
<p>因此考虑在command中添加client的命令标志，重传的命令也可以被添加到log中，但是在执行时会发现该命令已经执行过</p>
<p>命令没有被执行 TestManyPartitionsManyClients3A</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="section">=== RUN   TestManyPartitionsManyClients3A</span></span><br><span class="line">Test: partitions, many clients (3A) ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>命令结果有额外部分（多执行了？）TestConcurrent3A</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Test: </span>unreliable net, restarts, partitions, random keys, many clients (3A) ...</span><br><span class="line">info: wrote history visualization to /tmp/1021001197.html</span><br><span class="line">    test_test.go:382: history is not linearizable</span><br><span class="line">--- FAIL: TestPersistPartitionUnreliableLinearizable3A (30.13s)</span><br></pre></td></tr></table></figure>
<h2 id="3-并发读写map">3. 并发读写map</h2>
<p><code>fatal error: concurrent map read and map write</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">replyCh := <span class="built_in">make</span>(<span class="keyword">chan</span> ApplierResult, <span class="number">1</span>)</span><br><span class="line">kv.appliedCh[index] = replyCh</span><br><span class="line"><span class="comment">//kv.appliedCh[index] = make(chan ApplierResult, 1)</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Destiny</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
