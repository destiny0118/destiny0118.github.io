<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"destiny0118.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":false,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="DFS: 寻找有效的划分方案  记忆化搜索: 将结果记录下来避免重复搜索(DP)">
<meta property="og:type" content="article">
<meta property="og:title" content="DFS、BFS">
<meta property="og:url" content="https://destiny0118.github.io/2023/02/28/%E7%AE%97%E6%B3%95/%E5%9B%BE%EF%BC%9A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E3%80%81DFS%E3%80%81BFS/index.html">
<meta property="og:site_name" content="我的个人博客">
<meta property="og:description" content="DFS: 寻找有效的划分方案  记忆化搜索: 将结果记录下来避免重复搜索(DP)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202305251704677.png">
<meta property="article:published_time" content="2023-02-28T12:24:17.627Z">
<meta property="article:modified_time" content="2024-03-01T02:12:38.457Z">
<meta property="article:author" content="Destiny">
<meta property="article:tag" content="搜索算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202305251704677.png">


<link rel="canonical" href="https://destiny0118.github.io/2023/02/28/%E7%AE%97%E6%B3%95/%E5%9B%BE%EF%BC%9A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E3%80%81DFS%E3%80%81BFS/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://destiny0118.github.io/2023/02/28/%E7%AE%97%E6%B3%95/%E5%9B%BE%EF%BC%9A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E3%80%81DFS%E3%80%81BFS/","path":"2023/02/28/算法/图：拓扑排序、DFS、BFS/","title":"DFS、BFS"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>DFS、BFS | 我的个人博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">我的个人博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">What past is prolgue.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.</span> <span class="nav-text"> 图的遍历</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-number">2.</span> <span class="nav-text"> 图的存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-number">2.0.0.1.</span> <span class="nav-text"> 邻接矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-number">2.0.0.2.</span> <span class="nav-text"> 邻接表</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text"> 拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.1.</span> <span class="nav-text"> 算法步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#210-%E8%AF%BE%E7%A8%8B%E8%A1%A8-ii"><span class="nav-number">3.1.0.1.</span> <span class="nav-text"> 210. 课程表 II</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">4.</span> <span class="nav-text"> 深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="nav-number">4.0.1.</span> <span class="nav-text"> 695. 岛屿的最大面积</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">5.</span> <span class="nav-text"> 广度优先搜索</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF"><span class="nav-number">6.</span> <span class="nav-text"> 回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#47-%E5%85%A8%E6%8E%92%E5%88%97-ii"><span class="nav-number">6.0.0.1.</span> <span class="nav-text"> 47. 全排列 II</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="nav-number">6.1.</span> <span class="nav-text"> 934. 最短的桥</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="nav-number">6.2.</span> <span class="nav-text"> 130. 被围绕的区域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tip1"><span class="nav-number">6.2.1.</span> <span class="nav-text"> tip1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tip2"><span class="nav-number">6.3.</span> <span class="nav-text"> tip2</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Destiny</p>
  <div class="site-description" itemprop="description">凡是过去，皆为序章。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2023/02/28/%E7%AE%97%E6%B3%95/%E5%9B%BE%EF%BC%9A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E3%80%81DFS%E3%80%81BFS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="DFS、BFS | 我的个人博客">
      <meta itemprop="description" content="DFS: 寻找有效的划分方案  记忆化搜索: 将结果记录下来避免重复搜索(DP)">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          DFS、BFS
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-28 20:24:17" itemprop="dateCreated datePublished" datetime="2023-02-28T20:24:17+08:00">2023-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-01 10:12:38" itemprop="dateModified" datetime="2024-03-01T10:12:38+08:00">2024-03-01</time>
    </span>

  
</div>

            <div class="post-description">DFS: 寻找有效的划分方案  记忆化搜索: 将结果记录下来避免重复搜索(DP)</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p>数据结构：二叉树，图，二维矩阵</p>
</blockquote>
<h1 id="图的遍历"><a class="markdownIt-Anchor" href="#图的遍历"></a> 图的遍历</h1>
<ul>
<li>
<p>深度优先搜索（DFS）</p>
<p>检查图的连通性和无环性、<mark>关节点</mark></p>
</li>
<li>
<p>广度优先搜索（BFS）</p>
<p>检查图的连通性和无环性、求两个给定顶点间 <mark>边的数量</mark> 最少的路径</p>
</li>
</ul>
<h1 id="图的存储"><a class="markdownIt-Anchor" href="#图的存储"></a> 图的存储</h1>
<h4 id="邻接矩阵"><a class="markdownIt-Anchor" href="#邻接矩阵"></a> 邻接矩阵</h4>
<p>适合于边稠密图</p>
<h4 id="邻接表"><a class="markdownIt-Anchor" href="#邻接表"></a> 邻接表</h4>
<p>适用于边数较少的稀疏图</p>
<h1 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h1>
<blockquote>
<p>有向无环图（DAG，directed acyclic graph）</p>
<p>拓扑排序：对于图 <em>G</em> 中的任意一条有向边 (<em>u</em>,<em>v</em>)，<em>u</em> 在排列中都出现在 <em>v</em> 的前面。</p>
<p>m个顶点，n条边，时间复杂度O(m+n)<br />
邻接矩阵<br />
邻接表：时间复杂度O(n+e)</p>
</blockquote>
<h2 id="算法步骤"><a class="markdownIt-Anchor" href="#算法步骤"></a> 算法步骤</h2>
<blockquote>
<ul>
<li>搜索入度为零的顶点，加入队列</li>
<li>当队列不空时
<ul>
<li>取队首元素u，加入答案</li>
<li>将u的相邻顶点入度减1，若减为0，加入队列</li>
</ul>
</li>
<li>若答案包括n个顶点，得到拓扑排序，否则有环</li>
</ul>
</blockquote>
<h4 id="210-课程表-ii"><a class="markdownIt-Anchor" href="#210-课程表-ii"></a> <a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a></h4>
<blockquote>
<p>现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。</p>
<p>例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。<br />
返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。</p>
</blockquote>
<pre class="highlight"><code class="c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// 存储有向图</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges;
    <span class="hljs-comment">// 存储每个节点的入度</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; indeg;
    <span class="hljs-comment">// 存储答案</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;

<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;
        edges.resize(numCourses);
        indeg.resize(numCourses);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info: prerequisites) &#123;
            edges[info[<span class="hljs-number">1</span>]].push_back(info[<span class="hljs-number">0</span>]);
            ++indeg[info[<span class="hljs-number">0</span>]];
        &#125;

        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;
        <span class="hljs-comment">// 将所有入度为 0 的节点放入队列中</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; ++i) &#123;
            <span class="hljs-keyword">if</span> (indeg[i] == <span class="hljs-number">0</span>) &#123;
                q.push(i);
            &#125;
        &#125;

        <span class="hljs-keyword">while</span> (!q.empty()) &#123;
            <span class="hljs-comment">// 从队首取出一个节点</span>
            <span class="hljs-keyword">int</span> u = q.front();
            q.pop();
            <span class="hljs-comment">// 放入答案中</span>
            result.push_back(u);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v: edges[u]) &#123;
                --indeg[v];
                <span class="hljs-comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span>
                <span class="hljs-keyword">if</span> (indeg[v] == <span class="hljs-number">0</span>) &#123;
                    q.push(v);
                &#125;
            &#125;
        &#125;

        <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() != numCourses) &#123;
            <span class="hljs-keyword">return</span> &#123;&#125;;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;
</code></pre>
<p>访问标记设置：可以通过额外的访问标记数组进行记录，或者通过修改原数组数值表明已经访问过</p>
<h1 id="深度优先搜索"><a class="markdownIt-Anchor" href="#深度优先搜索"></a> 深度优先搜索</h1>
<blockquote>
<p>深度优先搜索（depth-first search, DFS）在搜索到一个新的节点时，立即堆该新节点进行遍历；深度优先搜索用<mark>先入后出的栈</mark>来实现，也可以通过递归实现。</p>
</blockquote>
<pre class="highlight"><code class="c++"><span class="hljs-comment">//采用邻接表存储，递归实现</span>
DFS(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; g,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&amp; visited,<span class="hljs-keyword">int</span> cur)&#123;
    <span class="hljs-keyword">if</span>(visited[cur])&#123;
        <span class="hljs-keyword">return</span>;
    &#125;
    visited[cur]=<span class="hljs-literal">true</span>;
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> &amp;next:g[cur])&#123;
        DFS(g,visited,next);
    &#125;
&#125;
</code></pre>
<h3 id="695-岛屿的最大面积"><a class="markdownIt-Anchor" href="#695-岛屿的最大面积"></a> <a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h3>
<p>递归写法：先判断是否满足条件，再进行递归，可以在访问节点时设置访问标记</p>
<pre class="highlight"><code class="c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> area=<span class="hljs-number">0</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; direction=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;
    <span class="hljs-keyword">int</span> m,n;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;
        <span class="hljs-keyword">this</span>-&gt;m=grid.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">this</span>-&gt;n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;
                <span class="hljs-keyword">if</span>(grid[i][j])&#123;
                    area=<span class="hljs-built_in">max</span>(area,DFS(grid,i,j));
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> area;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;
        grid[i][j]=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;
            <span class="hljs-keyword">int</span> x=i+direction[k],y=j+direction[k+<span class="hljs-number">1</span>];
            <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;m&amp;&amp;y&gt;=<span class="hljs-number">0</span>&amp;&amp;y&lt;n&amp;&amp;grid[x][y]==<span class="hljs-number">1</span>)&#123;          
                cnt+=DFS(grid,x,y);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> cnt;
    &#125;
&#125;;
</code></pre>
<p>栈实现</p>
<blockquote>
<p>在入队时设置访问标记，如果出队时设置访问标记，可能导致多次入队，2、3出队列时分别导致4进入队列。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/destiny0118/picgo/master/pic2023/202305251704677.png" alt="image-20230525170426579" /></p>
<pre class="highlight"><code class="c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> area=<span class="hljs-number">0</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; direction=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;
    <span class="hljs-keyword">int</span> m,n;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;
        <span class="hljs-keyword">this</span>-&gt;m=grid.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">this</span>-&gt;n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;
                <span class="hljs-keyword">if</span>(grid[i][j])&#123;
                    <span class="hljs-keyword">int</span> local=<span class="hljs-number">1</span>;
                    <span class="hljs-built_in">queue</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; qu;
                    grid[i][j]=<span class="hljs-number">0</span>;
                    qu.push(&#123;i,j&#125;);

                    <span class="hljs-keyword">while</span>(!qu.empty())&#123;
                        <span class="hljs-keyword">auto</span> [x,y]=qu.front();
                        <span class="hljs-comment">// grid[x][y]=0;</span>
                        qu.pop();
                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;
                            <span class="hljs-keyword">int</span> r=x+direction[k],c=y+direction[k+<span class="hljs-number">1</span>];
                            <span class="hljs-keyword">if</span>(r&gt;=<span class="hljs-number">0</span>&amp;&amp;r&lt;m&amp;&amp;c&gt;=<span class="hljs-number">0</span>&amp;&amp;c&lt;n&amp;&amp;grid[r][c]==<span class="hljs-number">1</span>)&#123;
                                ++local;
                                grid[r][c]=<span class="hljs-number">0</span>;
                                qu.push(&#123;r,c&#125;);
                            &#125;
                        &#125;
                    &#125;
                    area=<span class="hljs-built_in">max</span>(area,local);
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> area;
    &#125;
&#125;;
</code></pre>
<h1 id="广度优先搜索"><a class="markdownIt-Anchor" href="#广度优先搜索"></a> 广度优先搜索</h1>
<blockquote>
<p>广度优先搜索(breadth-first search,BFS)逐层进行遍历，使用<mark>先入先出的队列</mark>进行遍历。可用于处理<mark>无权最短路径</mark>。</p>
</blockquote>
<blockquote>
<ul>
<li>初始化：根元素入队，设置访问标记</li>
<li>当队列不为空的时候
<ul>
<li>求队列长度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>从队列中取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>个元素，进行下一轮扩展
<ul>
<li>节点未被访问过，节点入队，设置访问标记</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<pre class="highlight"><code class="c++"><span class="hljs-comment">//邻接表存储</span>
BFS(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; g)&#123;
    <span class="hljs-keyword">int</span> n=g.<span class="hljs-built_in">size</span>();
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n)</span></span>;
    
    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; qu;
    qu.push(<span class="hljs-number">0</span>);
    visited[<span class="hljs-number">0</span>]=<span class="hljs-literal">true</span>;
    
    <span class="hljs-keyword">while</span>(!qu.empty())&#123;
        <span class="hljs-keyword">int</span> cur=qu.front();
        qu.pop();
        
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> next:g[cur])&#123;
            <span class="hljs-keyword">if</span>(!visited[next])&#123;
                visited[next]=<span class="hljs-literal">true</span>;
                qu.push(next);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">复</mi><mi mathvariant="normal">杂</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">：</mi><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mi mathvariant="normal">，</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">中</mi><mi>n</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">，</mi><mi>m</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">边</mi><mi mathvariant="normal">数</mi><mspace linebreak="newline"></mspace><mi mathvariant="normal">空</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">复</mi><mi mathvariant="normal">杂</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">：</mi><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">，</mi><mi mathvariant="normal">队</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">开</mi><mi mathvariant="normal">销</mi></mrow><annotation encoding="application/x-tex">时间复杂度：O(n+m)，其中n为定点数，m为边数\\
空间复杂度：O(n)，队列开销
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">复</span><span class="mord cjk_fallback">杂</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">：</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">m</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">数</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">空</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">复</span><span class="mord cjk_fallback">杂</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">：</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">队</span><span class="mord cjk_fallback">列</span><span class="mord cjk_fallback">开</span><span class="mord cjk_fallback">销</span></span></span></span></span></p>
<h1 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> 回溯</h1>
<blockquote>
<p>回溯法(backtracking)是优先搜索的一种特殊情况，常用于需要记录节点状态的深度优先搜索。排列、组合、选择类问题使用回溯法。回溯法可以对图的总状态进行修改，而非每次遍历时新建一个图来储存状态。</p>
<p>深度优先搜索：[修改当前节点状态]-&gt;[递归子节点]</p>
<p>回溯：[修改当前节点状态]-&gt;[递归子节点]-&gt;[回改当前节点状态]</p>
<ul>
<li>选择k个数字构成一个排列</li>
<li>选择若干数字组成一个目标和target</li>
<li>对全部数字进行排列</li>
</ul>
</blockquote>
<p><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></p>
<p>方法一：回溯</p>
<pre class="highlight"><code class="c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">subsets</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; subset;
        backtrack(nums,subset,<span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> ans;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;subset, <span class="hljs-keyword">int</span> start)</span></span>&#123;
        <span class="hljs-keyword">if</span>(start==nums.<span class="hljs-built_in">size</span>())&#123;
            ans.push_back(subset);
            <span class="hljs-keyword">return</span>;
        &#125;
        subset.push_back(nums[start]);
        backtrack(nums,subset,start+<span class="hljs-number">1</span>);
        subset.pop_back();

        backtrack(nums,subset,start+<span class="hljs-number">1</span>);

        <span class="hljs-comment">//当前是否必须要选择一个数</span>
        <span class="hljs-comment">// for(int i=start;i&lt;nums.size();i++)&#123;</span>
        <span class="hljs-comment">//     subset.push_back(nums[i]);</span>
        <span class="hljs-comment">//     backtrack(nums,subset,i+1);</span>
        <span class="hljs-comment">//     subset.pop_back();</span>
        <span class="hljs-comment">// &#125;</span>
    &#125;

&#125;;
</code></pre>
<p>方法二：位枚举</p>
<pre class="highlight"><code class="c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">subsets</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-keyword">int</span> n=nums.<span class="hljs-built_in">size</span>();
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tmp;

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)&#123;
            tmp.<span class="hljs-built_in">clear</span>();
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;pos&lt;n;pos++)&#123;
                <span class="hljs-keyword">if</span>((i&gt;&gt;pos)&amp;<span class="hljs-number">1</span>)
                    tmp.push_back(nums[pos]);
            &#125;
            ans.push_back(tmp);
        &#125;
        <span class="hljs-keyword">return</span> ans;
    &#125;
&#125;;
</code></pre>
<h4 id="47-全排列-ii"><a class="markdownIt-Anchor" href="#47-全排列-ii"></a> <a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h4>
<blockquote>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p>
</blockquote>
<pre class="highlight"><code class="markdown">对于重复的数字要保证在结果中的相对位置一致
<span class="hljs-section"># 对于降重的处理</span>
!visited[i-1]
在寻找index位置数字时，因为回溯会把visited[i-1]修改为0
visited[i]便不会被填到index的位置
而在寻找index+1位置时，由于visited[i-1]为1，则索引为i的数字被填到这一位置
寻找顺序位置，前一个相同数字填入过，则继续填入
<span class="hljs-section">## visited[i]</span>
寻找逆序位置，前一个相同数字没有填入过，则继续填入
</code></pre>
<pre class="highlight"><code class="c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ret;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; visited;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">permuteUnique</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;
        visited.resize(nums.<span class="hljs-built_in">size</span>(),<span class="hljs-literal">false</span>);
        sort(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tmp;
        backtracking(<span class="hljs-number">0</span>,tmp,nums);
        <span class="hljs-keyword">return</span> ret;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;tmp,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums)</span></span>&#123;
        <span class="hljs-keyword">if</span>(index==nums.<span class="hljs-built_in">size</span>())&#123;
            ret.push_back(tmp);
            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"****"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;
            <span class="hljs-keyword">return</span>;
        &#125;

        <span class="hljs-comment">// 寻找可以填入下标Index的数字</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span>(visited[i]||(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>]&amp;&amp;!visited[i<span class="hljs-number">-1</span>]))
                <span class="hljs-keyword">continue</span>;
            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"index:"</span>&lt;&lt;index&lt;&lt;<span class="hljs-string">" i:"</span>&lt;&lt;i&lt;&lt;<span class="hljs-built_in">endl</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> vis:visited)
                <span class="hljs-built_in">cout</span>&lt;&lt;vis&lt;&lt;<span class="hljs-string">" "</span>;
            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;
            visited[i]=<span class="hljs-literal">true</span>;
            tmp.push_back(nums[i]);
            backtracking(index+<span class="hljs-number">1</span>,tmp,nums);
            tmp.pop_back();
            visited[i]=<span class="hljs-literal">false</span>;
        &#125;
    &#125;
&#125;;
</code></pre>
<h2 id="934-最短的桥"><a class="markdownIt-Anchor" href="#934-最短的桥"></a> <a href="https://leetcode.cn/problems/shortest-bridge/">934. 最短的桥</a></h2>
<blockquote>
<p>在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）</p>
<p>现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。</p>
<p>返回必须翻转的 0 的最小数目。（可以保证答案至少是 1 。）</p>
</blockquote>
<p>广度优先搜索从一个岛屿出发不断扩展一圈，何时可以找到另外一个岛屿。前提如何保障找到扩展相应第一步时的相应初始位置。</p>
<p>初始时找到一个岛屿的一个点，不断向外扩展，每一层可以找到从这一点向外n步时可以到达的位置。</p>
<pre class="highlight"><code class="c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
<span class="hljs-keyword">int</span> m;
<span class="hljs-keyword">int</span> n;
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; direction=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shortestBridge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;
        m=grid.<span class="hljs-built_in">size</span>();
        n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        <span class="hljs-built_in">queue</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; q;
        <span class="hljs-keyword">bool</span> flag=<span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;
            <span class="hljs-keyword">if</span>(flag)
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;
                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)&#123;
                    DFS(grid,q,i,j);
                    flag=<span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">break</span>;
                &#125;
            &#125;
        &#125;

        <span class="hljs-keyword">int</span> layer=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(!q.empty())&#123;
            layer++;
            <span class="hljs-keyword">int</span> cnt=q.<span class="hljs-built_in">size</span>();
            <span class="hljs-comment">// cout&lt;&lt;"cnt:"&lt;&lt;cnt&lt;&lt;endl;</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;
                <span class="hljs-keyword">auto</span> [x,y]=q.front();
                <span class="hljs-comment">// cout&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;endl;</span>
                q.pop();
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;
                    <span class="hljs-keyword">int</span> a=x+direction[k],b=y+direction[k+<span class="hljs-number">1</span>];
                    <span class="hljs-keyword">if</span>(a&gt;=<span class="hljs-number">0</span>&amp;&amp;a&lt;m&amp;&amp;b&gt;=<span class="hljs-number">0</span>&amp;&amp;b&lt;n)&#123;
                        <span class="hljs-keyword">if</span>(grid[a][b]==<span class="hljs-number">2</span>)
                            <span class="hljs-keyword">continue</span>;
                    <span class="hljs-keyword">if</span>(grid[a][b]==<span class="hljs-number">1</span>)&#123;
                            <span class="hljs-comment">// cout&lt;&lt;"*******"&lt;&lt;endl;</span>
                             <span class="hljs-keyword">return</span> layer;
                        &#125;
                            grid[a][b]=<span class="hljs-number">2</span>;
                            q.push(&#123;a,b&#125;);
                           
                        
                    &#125;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;grid,<span class="hljs-built_in">queue</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; &amp;q,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;
        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||x&gt;=m||y&lt;<span class="hljs-number">0</span>||y&gt;=n||grid[x][y]==<span class="hljs-number">2</span>)
            <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span>(grid[x][y]==<span class="hljs-number">0</span>)&#123;
            q.push(&#123;x,y&#125;);
            <span class="hljs-keyword">return</span>;
        &#125;
        grid[x][y]=<span class="hljs-number">2</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;
            <span class="hljs-keyword">int</span> i=x+direction[k],j=y+direction[k+<span class="hljs-number">1</span>];
            DFS(grid,q,i,j);
        &#125;
    &#125;
&#125;;
</code></pre>
<h2 id="130-被围绕的区域"><a class="markdownIt-Anchor" href="#130-被围绕的区域"></a> <a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h2>
<p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>'X'</code> 和 <code>'O'</code> ，找到所有被 <code>'X'</code> 围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code> 填充。</p>
<h3 id="tip1"><a class="markdownIt-Anchor" href="#tip1"></a> tip1</h3>
<blockquote>
<p>me: 用一个状态记录四周的O可以连接到的位置</p>
<p>在遍历所有位置，不能被四周连接到的改为‘X’</p>
<p>深度优先搜索</p>
</blockquote>
<pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; &amp;board, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; &amp;status, <span class="hljs-keyword">int</span> r,
         <span class="hljs-keyword">int</span> c)</span></span>;
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; direction = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; &amp;board)</span> </span>&#123;
    <span class="hljs-keyword">int</span> m = board.<span class="hljs-built_in">size</span>(), n = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">status</span><span class="hljs-params">(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n, <span class="hljs-literal">true</span>))</span></span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
        <span class="hljs-keyword">if</span> (board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">'O'</span>)
            dfs(board, status, i, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">if</span> (board[i][n - <span class="hljs-number">1</span>] == <span class="hljs-string">'O'</span>)
            dfs(board, status, i, n - <span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;
        <span class="hljs-keyword">if</span> (board[<span class="hljs-number">0</span>][j] == <span class="hljs-string">'O'</span>)
            dfs(board, status, <span class="hljs-number">0</span>, j);
        <span class="hljs-keyword">if</span> (board[m - <span class="hljs-number">1</span>][j] == <span class="hljs-string">'O'</span>)
            dfs(board, status, m - <span class="hljs-number">1</span>, j);
    &#125;

    <span class="hljs-comment">// for (const auto &amp;ele : status) &#123;</span>
    <span class="hljs-comment">//     for (const auto &amp;t : ele)</span>
    <span class="hljs-comment">//         cout &lt;&lt; t &lt;&lt; " ";</span>
    <span class="hljs-comment">//     cout &lt;&lt; endl;</span>
    <span class="hljs-comment">// &#125;</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;
            <span class="hljs-keyword">if</span> (status[i][j] == <span class="hljs-literal">true</span> &amp;&amp; board[i][j] == <span class="hljs-string">'O'</span>) &#123;
                <span class="hljs-comment">// cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl;</span>
                board[i][j] = <span class="hljs-string">'X'</span>;
            &#125;
        &#125;
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; &amp;board, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; &amp;status, <span class="hljs-keyword">int</span> r,
         <span class="hljs-keyword">int</span> c)</span> </span>&#123;
    status[r][c] = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">int</span> x, y;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;
        x = r + direction[k];
        y = c + direction[k + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; board.<span class="hljs-built_in">size</span>() &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp;
            board[x][y] == <span class="hljs-string">'O'</span> &amp;&amp; status[x][y] == <span class="hljs-literal">true</span>) &#123;
            <span class="hljs-comment">// status[x][y] = false;</span>
            <span class="hljs-comment">// cout &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; endl;</span>
            dfs(board, status, x, y);
        &#125;
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; board = &lt;!--swig￼<span class="hljs-number">0</span>--&gt;;
    solve(board);
    system(<span class="hljs-string">"pause"</span>);
&#125;
</code></pre>
<h2 id="tip2"><a class="markdownIt-Anchor" href="#tip2"></a> tip2</h2>
<p>优化？？？</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/" rel="tag"># 搜索算法</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/02/28/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="prev" title="位运算">
                  <i class="fa fa-angle-left"></i> 位运算
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/02/28/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8/" rel="next" title="线性表">
                  线性表 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Destiny</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
