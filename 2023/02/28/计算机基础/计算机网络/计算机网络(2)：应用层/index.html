<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"destiny0118.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="HTTP协议">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络：应用层">
<meta property="og:url" content="https://destiny0118.github.io/2023/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(2)%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/index.html">
<meta property="og:site_name" content="我的个人博客">
<meta property="og:description" content="HTTP协议">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405201718666.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202409081559068.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404262014331.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic/20210717222801.PNG">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404261056667.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202409081621021.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202408232251539.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202409081626747.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202409212351325.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202410062251845.png">
<meta property="article:published_time" content="2023-02-28T12:24:17.556Z">
<meta property="article:modified_time" content="2024-10-06T15:00:35.662Z">
<meta property="article:author" content="Destiny">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405201718666.png">


<link rel="canonical" href="https://destiny0118.github.io/2023/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(2)%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://destiny0118.github.io/2023/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(2)%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/","path":"2023/02/28/计算机基础/计算机网络/计算机网络(2)：应用层/","title":"计算机网络：应用层"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>计算机网络：应用层 | 我的个人博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">我的个人博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">What past is prolgue.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-project"><a href="/categories/project/" rel="section"><i class="fa fa-tasks fa-fw"></i>项目</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">1 HTTP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%B8%B8%E7%94%A8%E5%AD%97%E6%AE%B5"><span class="nav-text">1.1 常用字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-HTTP%E5%B1%82%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B"><span class="nav-text">1.2 HTTP层请求类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-HTTP%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="nav-text">1.3 HTTP缓存技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-HTTP-1-1%E3%80%81HTTP-2%E3%80%81HTTP-3"><span class="nav-text">1.4 HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-HTTP-1-1"><span class="nav-text">1.4.1 HTTP&#x2F;1.1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-HTTP-1-0-%E5%92%8C-HTTP-1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">1.5 HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-HTTP-1-1-%E5%92%8C-HTTP-2-0-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">1.6 HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-HTTP-2-0-%E5%92%8C-HTTP-3-0-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">1.7 HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="nav-text">1.8 队头阻塞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9-Cookie%E5%92%8CSession"><span class="nav-text">1.9 Cookie和Session</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-1-session%E5%85%B1%E4%BA%AB"><span class="nav-text">1.9.1 session共享</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-10-SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB"><span class="nav-text">1.10 SQL注入攻击</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-11-get%E5%92%8Cpost"><span class="nav-text">1.11 get和post</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-12-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-text">1.12 响应报文状态码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">2 HTTP和HTTPS区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-HTTPS%E9%98%B2%E8%8C%83%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="nav-text">2.1 HTTPS防范中间人攻击</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-HTTPS%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">2.2 HTTPS运行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-text">2.2.1 TCP三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-TLS%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-text">2.2.2 TLS四次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TLS%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9Aclient-server-Client-Hello"><span class="nav-text">TLS第一次握手：client -&gt; server  (Client Hello)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLS%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9Aserver-client-1-Server-Hello-2-Certificate-Server-key-Exchange-Server-Hello-Done"><span class="nav-text">TLS第二次握手：server -&gt; client (1.Server Hello; 2.Certificate,Server key Exchange,Server Hello Done)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLS%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8Bclient-server-Client-Key-Exchange-Change-Cipher-Spec-Encrypted-Handshake-Message"><span class="nav-text">TLS第三次握手client -&gt; server (Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Client-Key-Exchange"><span class="nav-text">Client Key Exchange</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Change-Cipher-Spec"><span class="nav-text">Change Cipher Spec</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Encrypted-Handshake-Message"><span class="nav-text">Encrypted Handshake Message</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLS-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8Bserver-client-Change-Cipher-Spec-Encrypted-Handshake-Message"><span class="nav-text">TLS 第四次握手server -&gt; client (Change Cipher Spec,Encrypted Handshake Message)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-%E7%A7%98%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-text">2.2.3 秘钥交换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-HTTPS%E4%B8%80%E5%AE%9A%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E5%90%97"><span class="nav-text">2.2.4 HTTPS一定安全可靠吗</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">3 HTTP和RPC区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">4 DNS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-DNS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-text">4.1 DNS负载均衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-DNS%E5%8A%AB%E6%8C%81"><span class="nav-text">4.2 DNS劫持</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">5 Nginx负载均衡算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">6 参考</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-HTTP"><span class="nav-text">6.1 HTTP</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Destiny</p>
  <div class="site-description" itemprop="description">凡是过去，皆为序章。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">129</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/destiny0118" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;destiny0118" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuyg163@163.com" title="E-Mail → mailto:yuyg163@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/19273732/destiny" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;19273732&#x2F;destiny" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2023/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(2)%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="计算机网络：应用层 | 我的个人博客">
      <meta itemprop="description" content="HTTP协议">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络：应用层<a href="https://github.com/destiny0118/Hexo/edit/master/Destiny/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(2)%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-28 20:24:17" itemprop="dateCreated datePublished" datetime="2023-02-28T20:24:17+08:00">2023-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">HTTP协议</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405201718666.png" alt="image.png"></p>
<p>HTTP、HTTPS、CDN、DNS、FTP 都是应用层协议</p>
<table>
<thead>
<tr>
<th style="text-align:center">协议</th>
<th style="text-align:center">网络应用</th>
<th style="text-align:center">应用层协议</th>
<th style="text-align:center">支撑的运输协议</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">应用程序体系结构</th>
<th style="text-align:left">端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">HTTP</td>
<td style="text-align:center">Web</td>
<td style="text-align:center">超文本传输协议(HyperText Transfer Protocol, HTTP)</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center">无状态协议<br />Web文档的请求与响应</td>
<td style="text-align:center">客户-服务器</td>
<td style="text-align:left">Web服务器：80</td>
</tr>
<tr>
<td style="text-align:center">SMTP</td>
<td style="text-align:center">电子邮件</td>
<td style="text-align:center">简单邮件传输协议(Simple Mail Transfer Protocol, SMTP)<br />邮件访问协议：POP3</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center">电子邮件报文的传输</td>
<td style="text-align:center">SMTP：客户-服务器</td>
<td style="text-align:left">SMTP：25<br/>POP：110</td>
</tr>
<tr>
<td style="text-align:center">DNS</td>
<td style="text-align:center">因特网的目录服务</td>
<td style="text-align:center">域名系统(Domain Name System，DNS)</td>
<td style="text-align:center">UDP</td>
<td style="text-align:center">域名空间、域名服务器、域名解析过程<br/>主机名到IP地址转换的目录服务</td>
<td style="text-align:center">客户-服务器模型</td>
<td style="text-align:left">53</td>
</tr>
<tr>
<td style="text-align:center">FTP</td>
<td style="text-align:center">文件传输</td>
<td style="text-align:center">文件传输协议(FTP)</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
<td style="text-align:center">客户-服务器模型</td>
<td style="text-align:left">控制连接：21<br />数据连接：20</td>
</tr>
<tr>
<td style="text-align:center">Telnet</td>
<td style="text-align:center">远程登陆协议</td>
<td style="text-align:center">Telnet</td>
<td style="text-align:center">TCP</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">SSH</td>
<td style="text-align:center">安全的网路传输协议</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left">22</td>
</tr>
</tbody>
</table>
<h1>1 HTTP协议</h1>
<blockquote>
<p>HTTP 是一种不保存状态，即<strong>无状态（stateless）协议</strong>。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。服务器不维护任何有关客户端过去所发请求的消息。<br>
HTTP 使用客户端-服务器模型，客户端向服务器发送 HTTP Request（请求），服务器响应请求并返回 HTTP Response（响应）</p>
</blockquote>
<h2 id="1-1-常用字段">1.1 常用字段</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>Host字段：有了 <code>Host</code> 字段，就可以将请求发往「同一台」服务器上的不同网站。</p>
</li>
<li class="lvl-2">
<p><mark>Content-Length</mark>字段：请求正文的字节数</p>
</li>
<li class="lvl-2">
<p>Connection：<code>Keep-Alive</code>（使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，这个方法称为 <mark>HTTP 长连接</mark>。）</p>
</li>
</ul>
<h2 id="1-2-HTTP层请求类型">1.2 HTTP层请求类型</h2>
<p>GET：用于请求获取指定资源，通常用于获取数据。 POST：用于向服务器提交数据，通常用于提交表单数据或进行资源的创建。 PUT：用于向服务器更新指定资源，通常用于更新已存在的资源。 DELETE：用于请求服务器删除指定资源。 HEAD：类似于GET请求，但只返回资源的头部信息，用于获取资源的元数据而不获取实际内容。</p>
<h2 id="1-3-HTTP缓存技术">1.3 HTTP缓存技术</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>强制缓存</p>
</li>
<li class="lvl-2">
<p>协商缓存<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202409081559068.png" alt="image.png"></p>
</li>
</ul>
<h2 id="1-4-HTTP-1-1、HTTP-2、HTTP-3">1.4 HTTP/1.1、HTTP/2、HTTP/3</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404262014331.png" alt="image.png"></p>
<h3 id="1-4-1-HTTP-1-1">1.4.1 HTTP/1.1</h3>
<p>HTTP/1.1 是请求响应模型，如果第一个发送的请求，未收到对应的响应，那么后续的请求就不会发送（PS：HTTP/1.1 管道模式是默认不使用的，所以讨论 HTTP/1.1 的队头阻塞问题，是不考虑管道模式的）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是<strong>没有解决响应的队头阻塞</strong>，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</p>
</li>
<li class="lvl-2">
<p>HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</p>
</li>
</ul>
<h2 id="1-5-HTTP-1-0-和-HTTP-1-1-有什么区别？">1.5 HTTP/1.0 和 HTTP/1.1 有什么区别？</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>连接方式</strong> : HTTP/1.0 为<mark>短连接，HTTP/1.1 支持长连接</mark>。HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</p>
</li>
<li class="lvl-2">
<p><strong>状态响应码</strong> : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</p>
</li>
<li class="lvl-2">
<p><strong>缓存机制</strong> : 在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</p>
</li>
<li class="lvl-2">
<p><strong>带宽</strong>：<mark>范围请求</mark>，HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
</li>
<li class="lvl-2">
<p><strong>Host 头（Host Header）处理</strong> :HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持<mark>虚拟主机</mark>的功能。而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。</p>
</li>
<li class="lvl-2">
<p><mark>管道网路传输</mark>：HTTP/1.0串行请求，HTTP/1.1在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></p>
</li>
</ul>
<blockquote>
<p>[!note]<br>
<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>，如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为==「队头堵塞」==。所以，<strong>HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p>
</blockquote>
<blockquote>
<p>[!note] Host头处理</p>
</blockquote>
<p>域名系统（DNS）允许多个主机名绑定到同一个 IP 地址上，但是 HTTP/1.0 并没有考虑这个问题，假设我们有一个资源 URL 是<code>http://example1.org/home.html</code>，HTTP/1.0的请求报文中，将会请求的是<code>GET /home.html HTTP/1.0</code>.也就是不会加入主机名。这样的报文送到服务器端，服务器是理解不了客户端想请求的真正网址。</p>
<p>因此，HTTP/1.1 在请求头中加入了<code>Host</code>字段。加入<code>Host</code>字段的报文头部将会是:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/home.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example1.org</span><br></pre></td></tr></table></figure>
<p>这样，服务器端就可以确定客户端想要请求的真正的网址了。</p>
<h2 id="1-6-HTTP-1-1-和-HTTP-2-0-有什么区别？">1.6 HTTP/1.1 和 HTTP/2.0 有什么区别？</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>多路复用（Multiplexing）</strong>：HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本），互不干扰。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有 6-8 个 TCP 连接都限制。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。<mark>HTTP/2.0 的多路复用使得不同的请求可以共用一个 TCP 连接</mark>，避免建立多个连接带来不必要的额外开销，而 HTTP/1.1 中的每个请求都会建立一个单独的连接</p>
</li>
<li class="lvl-2">
<p><strong>二进制帧（Binary Frames）</strong>：HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。</p>
</li>
<li class="lvl-2">
<p><strong>头部压缩（Header Compression）</strong>：HTTP/1.1 支持<code>Body</code>压缩，<code>Header</code>不支持压缩。HTTP/2.0 支持对<code>Header</code>压缩，使用了专门为<code>Header</code>压缩而设计的 HPACK 算法，减少了网络开销。</p>
</li>
<li class="lvl-2">
<p><strong>服务器推送（Server Push）</strong>：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。</p>
</li>
</ul>
<h2 id="1-7-HTTP-2-0-和-HTTP-3-0-有什么区别？">1.7 HTTP/2.0 和 HTTP/3.0 有什么区别？</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>传输协议</strong>：HTTP/2.0 是基于 TCP 协议实现的，HTTP/3.0 新增了<code> QUIC（Quick UDP Internet Connections）</code> 协议来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。你可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP/3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。</p>
</li>
<li class="lvl-2">
<p><strong>连接建立</strong>：HTTP/2.0 需要经过经典的 TCP 三次握手过程（由于安全的 HTTPS 连接建立还需要 TLS 握手，共需要大约 3 个 RTT）。由于 QUIC 协议的特性（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。</p>
</li>
<li class="lvl-2">
<p><strong>队头阻塞</strong>：HTTP/2.0 多请求复用一个 TCP 连接，一旦发生<mark>丢包</mark>，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP/3.0 在一定程度上解决了==队头阻塞（Head-of-Line blocking, 简写：HOL blocking）==问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。</p>
</li>
<li class="lvl-2">
<p><strong>错误恢复</strong>：HTTP/3.0 具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而 HTTP/2.0 则需要依赖于 TCP 的错误恢复机制。</p>
</li>
<li class="lvl-2">
<p><strong>安全性</strong>：HTTP/2.0 和 HTTP/3.0 在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。HTTP/2.0 使用 TLS 协议进行加密，而 HTTP/3.0 基于 QUIC 协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。</p>
</li>
</ul>
<blockquote>
<p>[! Note] 队头阻塞</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>HTTP/1.1 中的管道（ pipeline）虽然解决了<mark>请求的队头阻塞</mark>，但是没有解决<mark>响应的队头阻塞</mark>，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</p>
</li>
<li class="lvl-2">
<p>HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是一旦发生<mark>丢包</mark>，就会阻塞住所有的 HTTP 请求，这属于 <mark>TCP 层队头阻塞</mark>。</p>
</li>
<li class="lvl-2">
<p>HTTP/2 队头阻塞的问题是因为 TCP，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p>
</li>
</ul>
<h2 id="1-8-队头阻塞">1.8 队头阻塞</h2>
<p>队头阻塞是指在 HTTP/2.0 中，多个 HTTP 请求和响应共享一个 TCP 连接，如果其中一个请求或响应因为网络拥塞或丢包而被阻塞，那么后续的请求或响应也无法发送，导致整个连接的效率降低。这是由于 HTTP/2.0 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。HTTP/3.0 在一定程度上解决了队头阻塞问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。</p>
<p>当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了,会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」</p>
<h2 id="1-9-Cookie和Session">1.9 Cookie和Session</h2>
<p>HTTP协议是无状态的，而登录、购物车等需要知道用户状态。</p>
<p><strong>cookie</strong>： cookie是服务器传给客户端并保存在客户端的一段信息。cookie保存在了客户端，当我们去请求一个URL时，浏览器会根据这个URL路径将符合条件的Cookie放在请求头中传给服务器。</p>
<p><strong>session</strong>：<strong>Session是基于Cookie来工作</strong>，同一个客户端每次访问服务器时，只要当浏览器在第一次访问服务器时，服务器设置一个id并保存一些信息(例如登陆就保存用户信息，视具体情况)，并把这个id通过Cookie存到客户端，客户端每次和服务器交互时只传这个id，就可以实现维持浏览器和服务器的状态，而这个ID通常是NAME为JSESSIONID的一个Cookie。</p>
<p>Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p>
<p><code>Cookie</code> 数据保存在客户端(浏览器端)，<code>Session</code> 数据保存在服务器端。相对来说 <code>Session</code> 安全性更高。如果使用 <code>Cookie</code> 的一些敏感信息不要写入 <code>Cookie</code> 中，最好能将 <code>Cookie</code> 信息加密然后使用到的时候再去服务器端解密。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<blockquote>
<p>[!note] Cookie用途</p>
<ul class="lvl-1">
<li class="lvl-2">会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li class="lvl-2">个性化设置（如用户自定义设置、主题等）</li>
<li class="lvl-2">浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
</blockquote>
<blockquote>
<p>[!question] 主要区别</p>
</blockquote>
<ol>
<li class="lvl-3">
<p><strong>存储位置</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>Cookie的数据存储在客户端的浏览器中</p>
</li>
<li class="lvl-2">
<p>Session的数据则存放在服务器上</p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p><strong>存储容量与类型</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>Cookie的存储容量相对较小，通常限制在4KB以内，并且只能存储字符串类型的数据。</p>
</li>
<li class="lvl-2">
<p>Session的存储容量没有明确的限制（但考虑到服务器性能，通常不建议存放过多数据），并且它可以存储任意类型的数据。</p>
</li>
</ul>
<ol start="3">
<li class="lvl-3">
<p><strong>有效期与生命周期</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>Cookie的有效期可以在设置时指定，只要不超过设置的过期时间，它可以长期保存在客户端。</p>
</li>
<li class="lvl-2">
<p>Session的生命周期则通常较短，它会在一定的操作时间（如30分钟）后失效，并且在用户关闭浏览器或会话结束时，Session数据会被清除。</p>
</li>
</ul>
<ol start="4">
<li class="lvl-3">
<p><strong>安全性</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>由于Cookie存储在客户端，存在被第三方截获或篡改的风险，因此安全性相对较低。攻击者可以通过分析或伪造Cookie来欺骗系统。</p>
</li>
<li class="lvl-2">
<p>Session数据存储在服务器上，相对更加安全，不容易被攻击者直接获取或修改。</p>
</li>
</ul>
<ol start="5">
<li class="lvl-3">
<p><strong>跨域支持</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>Cookie支持跨域名访问，即可以在不同的域名之间共享。</p>
</li>
<li class="lvl-2">
<p>Session则通常与特定的客户端和服务器端关联，不支持跨域访问。</p>
</li>
</ul>
<ol start="6">
<li class="lvl-3">
<p><strong>对服务器压力</strong>：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>Cookie不占用服务器资源，因为数据存储在客户端。</p>
</li>
<li class="lvl-2">
<p>Session则需要在服务器上存储数据，因此对服务器的资源占用和性能有一定影响。</p>
</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/90750522">一文彻底搞懂cookie和session - 知乎 (zhihu.com)</a><br>
<a href="https://zhuanlan.zhihu.com/p/631349844"> 一文彻底搞清session、cookie、token的区别</a></p>
<h3 id="1-9-1-session共享">1.9.1 session共享</h3>
<ol>
<li class="lvl-3">
<p><strong>数据库存储</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">将session数据存储在数据库中，而不是仅仅存储在内存中。这样，无论请求发送到哪个服务器，都可以通过查询数据库来获取session数据。</li>
<li class="lvl-6">这种方法需要设计好数据库表结构，并编写相应的存储和检索逻辑。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>缓存系统</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">使用像Redis或Memcached这样的缓存系统来存储session数据。每个服务器都可以访问这个共享的缓存系统来获取和更新session数据。</li>
<li class="lvl-6">这种方法通常比数据库访问更快，并且能更好地处理大量并发请求。</li>
</ul>
</li>
</ol>
<h2 id="1-10-SQL注入攻击">1.10 SQL注入攻击</h2>
<p>攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。 用户登录，输入用户名 lianggzone，密码 ‘ or ‘1’=’1 ，如果此时使用参数构造的方式，就会出现 select * from user where name = ‘lianggzone’ and password = ‘’ or ‘1’=‘1’ 不管用户名和密码是什么内容，使查询出来的用户列表不为空。</p>
<p>如何防范SQL注入攻击使用预编译的PrepareStatement是必须的，但是一般我们会从两个方面同时入手。<br>
Web端 1）有效性检验。 2）限制字符串输入的长度。服务端 1）不用拼接SQL字符串。 2）使用预编译的PrepareStatement。 3）有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求) 4）过滤SQL需要的参数中的特殊字符。比如单引号、双引号。</p>
<h2 id="1-11-get和post">1.11 get和post</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>语义（主要区别）：GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。</p>
</li>
<li class="lvl-2">
<p><mark>幂等</mark>：GET 请求是幂等的，即多次重复执行不会改变资源的状态，而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。（<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求）</strong>，<strong>也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。）</p>
</li>
<li class="lvl-2">
<p>格式：GET 请求的参数通常放在 URL 中，形成查询字符串（querystring），而 POST 请求的参数通常放在请求体（body）中，可以有多种编码格式，如 application/x-www-form-urlencoded、multipart/form-data、application/json 等。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的 body 大小则没有明确的限制。不过，实际上 GET 请求也可以用 body 传输数据，只是并不推荐这样做，因为这样可能会导致一些兼容性或者语义上的问题。</p>
</li>
<li class="lvl-2">
<p>缓存：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。而 POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。</p>
</li>
<li class="lvl-2">
<p>安全性：GET 请求和 POST 请求如果使用 HTTP 协议的话，那都不安全，因为 HTTP 协议本身是<mark>明文</mark>传输的，必须使用 HTTPS 协议来加密传输数据。另外，GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中。post更安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中）</p>
</li>
</ul>
<p><a href="https://www.runoob.com/http/http-tutorial.html">HTTP协议（HyperText Transfer Protocol，超文本传输协议）</a></p>
<p><a href="https://www.runoob.com/html/html-url.html">url(统一资源定位器 Uniform Resource Locators)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/128000072">万字长文，一文搞懂TCP、IP和HTTP、HTTPS</a></p>
<h2 id="1-12-响应报文状态码">1.12 响应报文状态码</h2>
  <img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic/20210717222801.PNG" alt="IMG_2748(20210717-195049)"  />
200：请求成功； 301：永久重定向；302：临时重定向； 404：无法找到此页面；405：请求的方法类型不支持； 500：服务器内部出错。
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202404261056667.png" alt="image.png"></p>
<p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p>
<p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</p>
</li>
<li class="lvl-2">
<p>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</p>
</li>
<li class="lvl-2">
<p>「<mark>206 Partial Content</mark>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。部分内容返回成功，这是范围请求的状态码，表示服务器返回了所请求的部分内容。</p>
</li>
</ul>
<p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</p>
</li>
<li class="lvl-2">
<p>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p>
</li>
</ul>
<p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</p>
</li>
</ul>
<p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</p>
</li>
<li class="lvl-2">
<p>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</p>
</li>
<li class="lvl-2">
<p>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p>
</li>
</ul>
<p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</p>
</li>
<li class="lvl-2">
<p>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</p>
</li>
<li class="lvl-2">
<p>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</p>
</li>
<li class="lvl-2">
<p>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</p>
</li>
</ul>
<h1>2 HTTP和HTTPS区别</h1>
<blockquote>
<p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</p>
</li>
<li class="lvl-2">
<p><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但<code>对称加密的密钥用服务器方的证书进行了非对称加密</code>。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p>
</li>
<li class="lvl-2">
<p><strong>SEO（搜索引擎优化）</strong>：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。</p>
</li>
<li class="lvl-2">
<p>使用 SSL/TLS 协议用作加密和安全认证；非对称加密交换密钥，对称加密传输消息</p>
</li>
<li class="lvl-3">
<p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p>
</li>
</ul>
<p>区别主要有以下四点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</p>
</li>
<li class="lvl-2">
<p>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</p>
</li>
<li class="lvl-2">
<p>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</p>
</li>
<li class="lvl-2">
<p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p>
</li>
</ul>
<blockquote>
<p>[!note]<br>
SSL/TLS协议作用：认证用户和服务，加密数据，维护数据的完整性的应用层协议加密和解密需要两个不同的密钥，故被称为非对称加密；加密和解密都使用同一个密钥的</p>
</blockquote>
<p>为了公钥传输的信赖性问题，第三方机构应运而生——<mark>证书颁发机构</mark>（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的<strong>电子签名</strong>。</p>
<p>数字签名要解决的问题，是防止证书被伪造。第三方信赖机构 CA 之所以能被信赖，就是 <strong>靠数字签名技术</strong> 。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202409081621021.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>非对称加密（公钥加密、私钥解密）</p>
</li>
<li class="lvl-2">
<p>对称加密</p>
</li>
<li class="lvl-2">
<p>证书颁发机构（CA，Certificate Authority）——数字签名技术</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202408232251539.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>可以通过哈希算法来保证消息的完整性；</p>
</li>
<li class="lvl-2">
<p>可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202409081626747.png" alt="image.png"></p>
</li>
</ul>
<h2 id="2-1-HTTPS防范中间人攻击">2.1 HTTPS防范中间人攻击</h2>
<p>加密：https 握手期间会通过非对称加密的方式来协商出对称加密密钥。身份校验：服务器会向证书颁发机构申请数字证书，证书中包含了服务器的公钥和其他相关信息。当客户端与服务器建立连接时，服务器会将证书发送给客户端。客户端会验证证书的合法性，包括检查证书的有效期、颁发机构的信任等。如果验证通过，客户端会使用证书中的公钥来加密通信数据，并将加密后的数据发送给服务器，然后由服务端用私钥解密</p>
<h2 id="2-2-HTTPS运行流程">2.2 HTTPS运行流程</h2>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202409212351325.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>用户在浏览器里输入一个https网址，然后连接到server的443端口。</p>
</li>
<li class="lvl-2">
<p>服务器必须要有一套<strong>数字证书</strong>，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过。这套证书其实就是一对公钥和私钥。</p>
</li>
<li class="lvl-2">
<p>服务器将自己的<mark>数字证书</mark>（含有公钥）发送给客户端。</p>
</li>
<li class="lvl-2">
<p>客户端收到服务器端的数字证书之后，会对其进行检查，如果不通过，则弹出警告框。如果证书没问题，则<mark>生成一个密钥（对称加密）</mark>，用证书的公钥对它加密。</p>
</li>
<li class="lvl-2">
<p>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</p>
</li>
<li class="lvl-2">
<p>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后得到客户端密钥，然后用客户端密钥对返回数据进行对称加密，这样数据就变成了密文。</p>
</li>
<li class="lvl-2">
<p>服务器将加密后的密文返回给客户端。</p>
</li>
<li class="lvl-2">
<p>客户端收到服务器发返回的密文，用自己的密钥（客户端密钥）对其进行对称解密，得到服务器返回的数据</p>
</li>
</ul>
<h3 id="2-2-1-TCP三次握手">2.2.1 TCP三次握手</h3>
<h3 id="2-2-2-TLS四次握手">2.2.2 TLS四次握手</h3>
<h4 id="TLS第一次握手：client-server-Client-Hello">TLS第一次握手：client -&gt; server  (Client Hello)</h4>
<p>客户端向服务端发送：</p>
<ol>
<li class="lvl-3">
<p>客户端支持的协议；</p>
</li>
<li class="lvl-3">
<p>已经使用的TLS版本；</p>
</li>
<li class="lvl-3">
<p>随机数Random（Client Random）</p>
</li>
<li class="lvl-3">
<p>支持的密码套件。</p>
</li>
</ol>
<p>客户端发送完「Client Hello」，服务端向客户端发送的ACK确认消息，代表上面的「Client Hello」已经收到。这里也可以看出服务端是通过普通的TCP 的ACK消息去应答「Client Hello」。</p>
<h4 id="TLS第二次握手：server-client-1-Server-Hello-2-Certificate-Server-key-Exchange-Server-Hello-Done">TLS第二次握手：server -&gt; client (1.Server Hello; 2.Certificate,Server key Exchange,Server Hello Done)</h4>
<ol>
<li class="lvl-3">
<p><strong>Server Hello</strong>：</p>
<ul class="lvl-2">
<li class="lvl-6">服务端支持的协议；</li>
<li class="lvl-6">使用的TLS版本；</li>
<li class="lvl-6">随机数Random==（Server Random）==</li>
<li class="lvl-6">服务端选用的密码套件。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Certificate</strong>：服务端为了证明自己的身份，会发送「Server Certificate」给客户端，这个消息里含有数字证书；</p>
</li>
<li class="lvl-3">
<p><strong>Server key Exchange,Server Hello Done</strong>：目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。</p>
</li>
</ol>
<p>::: note<br>
<em>数字证书签发和验证流程</em><br>
:::</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202410062251845.png" alt="image.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>CA(证书认证机构)对公钥等信息进行Hash计算，并通过私钥加密，对证书进行签名</p>
</li>
<li class="lvl-2">
<p>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1</p>
</li>
<li class="lvl-2">
<p>浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个Hash值H2</p>
</li>
</ul>
<h4 id="TLS第三次握手client-server-Client-Key-Exchange-Change-Cipher-Spec-Encrypted-Handshake-Message">TLS第三次握手client -&gt; server (Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message)</h4>
<h5 id="Client-Key-Exchange">Client Key Exchange</h5>
<p>客户端收到了服务端的证书及「Server Hello Done」消息后，首先通过浏览器或者操作系统中的CA公钥<mark>校验证书</mark>，校验通过后会将Client Params数据传递给服务端，其中包含自身生成的椭圆曲线公钥（Pubkey）</p>
<p>接着，客户端就会生成一个新的<strong>随机数 (pre-master)</strong>，用服务器的 RSA 公钥加密该随机数，通过「<strong>Client Key Exchange</strong>」消息传给服务端。</p>
<h5 id="Change-Cipher-Spec">Change Cipher Spec</h5>
<p>加密通信算法改变通知，「Change Cipher Spec」消息表示客户端已经生成密钥，并<mark>切换到对称加密模式</mark>。</p>
<h5 id="Encrypted-Handshake-Message">Encrypted Handshake Message</h5>
<ol>
<li class="lvl-3">
<p>告诉服务端，客户端在握手的过程中收到和发送的数据做一个摘要并用会话密钥加密发送给服务端做校验，保证TSL握手过程中报文没有被修改过；</p>
</li>
<li class="lvl-3">
<p>如果服务端收到这个消息并能解密成功，就能说明对称密钥是正确的。</p>
</li>
</ol>
<p>「Encrypted Handshake Message」消息其实不只是客户端会发送，之后服务端也会发送一个。</p>
<h4 id="TLS-第四次握手server-client-Change-Cipher-Spec-Encrypted-Handshake-Message">TLS 第四次握手server -&gt; client (Change Cipher Spec,Encrypted Handshake Message)</h4>
<p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>
（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p>
<p><a href="https://javaguide.cn/cs-basics/network/http-vs-https.html">HTTP vs HTTPS（应用层） | JavaGuide</a></p>
<p><a href="https://mp.weixin.qq.com/s/nzT3idzmhe7rJg-EikLWvA">字节校招一面：聊聊https 原理</a></p>
<h3 id="2-2-3-秘钥交换算法">2.2.3 秘钥交换算法</h3>
<p><a href="https://xiaolincoding.com/network/2_http/https_rsa.html">RSA 算法</a>和 <a href="https://xiaolincoding.com/network/2_http/https_ecdhe.html">ECDHE 算法</a></p>
<h3 id="2-2-4-HTTPS一定安全可靠吗">2.2.4 HTTPS一定安全可靠吗</h3>
<p>客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。</p>
<p>发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。 中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p>
<h1>3 HTTP和RPC区别</h1>
<p><strong>RPC（即Remote Procedure Call，远程过程调用）和HTTP（HyperText Transfer Protocol，超文本传输协议）</strong>，两者前者是一种方法，后者则是一种协议。两者都常用于实现服务，在这个层面最本质的区别是RPC服务主要工作在TCP协议之上（也可以在HTTP协议），而HTTP服务工作在HTTP协议之上。由于HTTP协议基于TCP协议，所以RPC服务天然比HTTP更轻量，效率更胜一筹。</p>
<p><a href="https://cloud.tencent.com/developer/article/1979507">HTTP和RPC的区别-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a href="https://xiaolincoding.com/network/2_http/http_rpc.html#%E4%BB%8E-tcp-%E8%81%8A%E8%B5%B7">3.8 既然有 HTTP 协议，为什么还要有 RPC？ | 小林coding (xiaolincoding.com)</a></p>
<h1>4 DNS</h1>
<p>DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是<strong>域名和 IP 地址的映射问题</strong>。</p>
<blockquote>
<p>[!note]<br>
浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。一、主机向本地域名服务器的查询一般都是采用递归查询。二、本地域名服务器向根域名服务器的查询的迭代查询。</p>
</blockquote>
<blockquote>
<p>DNS：递归（通过其他服务器解析）、迭代（自己处理解析过程）<br>
<strong>迭代</strong>查询对于客户端来说比较复杂，需要自行处理多次查询和跳转。 迭代查询可以减少DNS服务器的负载，因为客户端自行进行多次查询可以分散服务器的压力。 在实际应用中，递归查询和迭代查询各有优缺点。 递归查询可以减少客户端的复杂度，但需要DNS服务器具备较高的处理能力和带宽资源。 而迭代查询可以减轻DNS服务器的压力，但需要客户端自行进行多次查询和跳转。</p>
</blockquote>
<h2 id="4-1-DNS负载均衡">4.1 DNS负载均衡</h2>
<p>当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会崩掉。处理办法就是用DNS负载均衡技术，它的原理是在<mark>DNS服务器中为同一个主机名配置多个IP地址</mark>,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p>
<h2 id="4-2-DNS劫持">4.2 DNS劫持</h2>
<p>DNS 劫持是一种网络攻击，它通过修改 DNS 服务器的解析结果，使用户访问的域名指向错误的 IP 地址，从而导致用户无法访问正常的网站，或者被引导到恶意的网站。DNS 劫持有时也被称为 DNS 重定向、DNS 欺骗或 DNS 污染。</p>
<h1>5 Nginx负载均衡算法</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>轮询：按照顺序依次将请求分配给后端服务器。这种算法最简单，但是也无法处理某个节点变慢或者客户端操作有连续性的情况。</p>
</li>
<li class="lvl-2">
<p>IP哈希：根据客户端IP地址的哈希值来确定分配请求的后端服务器。适用于需要保持同一客户端的请求始终发送到同一台后端服务器的场景，如会话保持。</p>
</li>
<li class="lvl-2">
<p>URL哈希：按访问的URL的哈希结果来分配请求，使每个URL定向到一台后端服务器，可以进一步提高后端缓存服务器的效率。</p>
</li>
<li class="lvl-2">
<p>最短响应时间：按照后端服务器的响应时间来分配请求，响应时间短的优先分配。适用于后端服务器性能不均的场景，能够将请求发送到响应时间快的服务器，实现负载均衡。</p>
</li>
<li class="lvl-2">
<p>加权轮询：按照权重分配请求给后端服务器，权重越高的服务器获得更多的请求。适用于后端服务器性能不同的场景，可以根据服务器权重分配请求，提高高性能服务器的利用率。</p>
</li>
</ul>
<h1>6 参考</h1>
<h2 id="6-1-HTTP">6.1 HTTP</h2>
<p><a href="https://mp.weixin.qq.com/s/HtqRUKYxidXFCa2-z9M8ew">重磅！图文详解HTTPS协议通信全过程，结合抓包实战分析，带你一次看透HTTPS！ (qq.com)</a><br>
<a href="https://xiaolincoding.com/network/2_http/https_rsa.html#tls-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">3.3 HTTPS RSA 握手解析 | 小林coding (xiaolincoding.com)</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/02/28/%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%EF%BC%9A%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84(Binary-Indexed-Tree,-BIT)/" rel="prev" title="树状数组(Binary Indexed Tree, BIT)">
                  <i class="fa fa-chevron-left"></i> 树状数组(Binary Indexed Tree, BIT)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/02/28/%E7%AE%97%E6%B3%95/%E6%A0%88%E3%80%81%E5%8D%95%E8%B0%83%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97/" rel="next" title="栈">
                  栈 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Destiny</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
