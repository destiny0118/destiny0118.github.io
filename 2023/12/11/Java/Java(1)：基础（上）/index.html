<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"destiny0118.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="(封装、继承、多态)；深拷贝、浅拷贝；接口、抽象类">
<meta property="og:type" content="article">
<meta property="og:title" content="Java(1)：基础（上）">
<meta property="og:url" content="https://destiny0118.github.io/2023/12/11/Java/Java(1)%EF%BC%9A%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8A%EF%BC%89/index.html">
<meta property="og:site_name" content="我的个人博客">
<meta property="og:description" content="(封装、继承、多态)；深拷贝、浅拷贝；接口、抽象类">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202312110953812.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405291046978.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202312122359896.png">
<meta property="article:published_time" content="2023-12-11T01:50:34.263Z">
<meta property="article:modified_time" content="2024-09-23T08:26:55.402Z">
<meta property="article:author" content="Destiny">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202312110953812.png">


<link rel="canonical" href="https://destiny0118.github.io/2023/12/11/Java/Java(1)%EF%BC%9A%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8A%EF%BC%89/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://destiny0118.github.io/2023/12/11/Java/Java(1)%EF%BC%9A%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8A%EF%BC%89/","path":"2023/12/11/Java/Java(1)：基础（上）/","title":"Java(1)：基础（上）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java(1)：基础（上） | 我的个人博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">我的个人博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">What past is prolgue.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-project"><a href="/categories/project/" rel="section"><i class="fa fa-tasks fa-fw"></i>项目</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">1 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">1.1 基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-primitive-vs-reference"><span class="nav-text">1.1.1 primitive vs reference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="nav-text">1.1.2 自动装箱与拆箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3-%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1"><span class="nav-text">1.1.3 浮点数运算的精度丢失</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E5%8F%98%E9%87%8F"><span class="nav-text">1.2 变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">1.2.1 成员变量与局部变量的区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">1.3 关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E6%96%B9%E6%B3%95"><span class="nav-text">1.4 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">1.4.1 静态方法为什么不能调用非静态成员?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-overload-%E9%87%8D%E8%BD%BD-%E5%92%8Coverride-%E9%87%8D%E5%86%99"><span class="nav-text">1.4.2 overload(重载)和override(重写)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD"><span class="nav-text">重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99"><span class="nav-text">重写</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">2 面向对象基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">2.1.1 面向对象和面向过程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E7%AD%89%E5%92%8C%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">2.1.2 对象的相等和引用相等的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">2.2 构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-text">2.3 面向对象三大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-%E5%B0%81%E8%A3%85"><span class="nav-text">2.3.1 封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-%E7%BB%A7%E6%89%BF"><span class="nav-text">2.3.2 继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-%E5%A4%9A%E6%80%81"><span class="nav-text">2.3.3 多态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">2.4 接口和抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-text">2.5 深拷贝和浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-Object%E7%B1%BB"><span class="nav-text">2.6 Object类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-String"><span class="nav-text">2.7 String</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-1-String%E3%80%81StringBuffer-%E7%BA%BF%E7%A8%8B%E5%AE%8C%E5%85%A8-%E3%80%81StringBuilder-%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">2.7.1 String、StringBuffer(线程完全)、StringBuilder(非线程安全)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-2-String%E4%B8%8D%E5%8F%AF%E6%94%B9%E5%8F%98"><span class="nav-text">2.7.2 String不可改变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5-StringBuilder"><span class="nav-text">2.7.3 字符串拼接(+ StringBuilder)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-text">2.7.4 字符串常量池</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Destiny</p>
  <div class="site-description" itemprop="description">凡是过去，皆为序章。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">129</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/destiny0118" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;destiny0118" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuyg163@163.com" title="E-Mail → mailto:yuyg163@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/19273732/destiny" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;19273732&#x2F;destiny" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://destiny0118.github.io/2023/12/11/Java/Java(1)%EF%BC%9A%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8A%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Destiny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
      <meta itemprop="description" content="凡是过去，皆为序章。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java(1)：基础（上） | 我的个人博客">
      <meta itemprop="description" content="(封装、继承、多态)；深拷贝、浅拷贝；接口、抽象类">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java(1)：基础（上）<a href="https://github.com/destiny0118/Hexo/edit/master/Destiny/source/_posts/Java/Java(1)%EF%BC%9A%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8A%EF%BC%89.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-11 09:50:34" itemprop="dateCreated datePublished" datetime="2023-12-11T09:50:34+08:00">2023-12-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">(封装、继承、多态)；深拷贝、浅拷贝；接口、抽象类</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用的，能够创建和编译 Java 程序。他包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p>
<p>JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202312110953812.png" alt="image.png|425"></p>
<p>Java程序先通过编译生成字节码，在通过Java解释器解释执行。</p>
<h1>1 基础</h1>
<h2 id="1-1-基本数据类型">1.1 基本数据类型</h2>
<h3 id="1-1-1-primitive-vs-reference">1.1.1 primitive vs reference</h3>
<p>原语变量和引用变量</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>6 种数字类型：</p>
<ul class="lvl-2">
<li class="lvl-6">4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li class="lvl-6">2 种浮点型：<code>float</code>、<code>double</code></li>
</ul>
</li>
<li class="lvl-2">
<p>1 种字符类型：<code>char</code></p>
</li>
<li class="lvl-2">
<p>1 种布尔型：<code>boolean</code>。</p>
</li>
</ul>
<p>基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。</p>
<h3 id="1-1-2-自动装箱与拆箱">1.1.2 自动装箱与拆箱</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p>
</li>
<li class="lvl-2">
<p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> 等价于 <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>)</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i 等价于 <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i.intValue();</span><br></pre></td></tr></table></figure>
<h3 id="1-1-3-浮点数运算的精度丢失">1.1.3 浮点数运算的精度丢失</h3>
<p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。<br>
<a href="https://javaguide.cn/java/basis/bigdecimal.html">BigDecimal 详解</a></p>
<h2 id="1-2-变量">1.2 变量</h2>
<h3 id="1-2-1-成员变量与局部变量的区别？">1.2.1 成员变量与局部变量的区别？</h3>
<p><img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202405291046978.png" alt="image.png"></p>
<p>成员变量 vs 局部变量</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p>
</li>
<li class="lvl-2">
<p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p>
</li>
<li class="lvl-2">
<p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</p>
</li>
<li class="lvl-2">
<p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p>
</li>
</ul>
<h2 id="1-3-关键字">1.3 关键字</h2>
<p>被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。</p>
<h2 id="1-4-方法">1.4 方法</h2>
<h3 id="1-4-1-静态方法为什么不能调用非静态成员">1.4.1 静态方法为什么不能调用非静态成员?</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p>
</li>
<li class="lvl-2">
<p>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作</p>
</li>
</ul>
<h3 id="1-4-2-overload-重载-和override-重写">1.4.2 overload(重载)和override(重写)</h3>
<p><a href="https://www.runoob.com/java/java-override-overload.html">Java 重写(Override)与重载(Overload) | 菜鸟教程 (runoob.com)</a></p>
<blockquote>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
</blockquote>
<h4 id="重载">重载</h4>
<p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>
<p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>
<h4 id="重写">重写</h4>
<p>重写（Override）是指子类定义了一个与其父类中具有相同名称、参数列表和返回类型的方法，并且子类方法的实现覆盖了父类方法的实现。 <strong>即外壳不变，核心重写！</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>参数列表与被重写方法的参数列表必须完全相同。</p>
</li>
<li class="lvl-2">
<p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p>
</li>
</ul>
<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li class="lvl-3">
<p>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p>
</li>
<li class="lvl-3">
<p>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</p>
</li>
<li class="lvl-3">
<p>构造方法无法被重写</p>
</li>
</ol>
<p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody>
</table>
<h1>2 面向对象基础</h1>
<h3 id="2-1-1-面向对象和面向过程的区别">2.1.1 面向对象和面向过程的区别</h3>
<p>两者的主要区别在于解决问题的方式不同：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</p>
</li>
<li class="lvl-2">
<p>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</p>
</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<h3 id="2-1-2-对象的相等和引用相等的区别">2.1.2 对象的相等和引用相等的区别</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>对象的相等一般比较的是内存中存放的内容是否相等。</p>
</li>
<li class="lvl-2">
<p>引用相等一般比较的是他们指向的内存地址是否相等。</p>
</li>
</ul>
<h2 id="2-2-构造方法">2.2 构造方法</h2>
<blockquote>
<p>如果一个类没有声明构造方法，会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。</p>
</blockquote>
<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h2 id="2-3-面向对象三大特性">2.3 面向对象三大特性</h2>
<h3 id="2-3-1-封装">2.3.1 封装</h3>
<p>encapsulation：实例变量(instance variable)不能直接访问修改</p>
<blockquote>
<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
</blockquote>
<h3 id="2-3-2-继承">2.3.2 继承</h3>
<blockquote>
<p>Java 的类不可以多继承，但是接口可以多继承。</p>
</blockquote>
<p>inheritance：IS-A</p>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<ol>
<li class="lvl-4">
<p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</p>
</li>
<li class="lvl-3">
<p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
</li>
<li class="lvl-3">
<p>子类可以用自己的方式实现父类的方法。</p>
</li>
</ol>
<h3 id="2-3-3-多态">2.3.3 多态</h3>
<blockquote>
<p>概念：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。简单的说:就是用基类的引用指向子类的对象。</p>
</blockquote>
<p>polymorphism：父类引用变量引用子类，让不同的子类进行相同的行为</p>
<blockquote>
<p>一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
</blockquote>
<p><strong>多态的特点:</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</p>
</li>
<li class="lvl-2">
<p>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</p>
</li>
<li class="lvl-2">
<p>多态不能调用“只在子类存在但在父类不存在”的方法；</p>
</li>
<li class="lvl-2">
<p>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</p>
</li>
</ul>
<blockquote>
<p>多态的目的是为了提高程序的可扩展性，解决项目中紧耦合的问题，提高代码的复用性。多态可以让程序员针对抽象而不是具体实现来编程，这样的代码会有更好的可扩展性。通过使用多态，可以将具体的实现细节隐藏在抽象的接口或基类中，使得代码更加高层次和抽象化2。这种解耦合的设计可以提高代码的可读性和可维护性2。</p>
</blockquote>
<ol>
<li class="lvl-3">
<p><strong>封装（Encapsulation）：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">封装是面向对象编程的基本原则之一。它将类的实现细节隐藏起来，只向外部暴露必要的接口和数据。通过封装，对象内部的实现细节对外部是不可见的，这提高了代码的安全性和可维护性。封装可以通过访问修饰符（如private、protected、public）来实现，同时提供公共的方法来访问或修改私有属性。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>继承（Inheritance）：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">继承是一种通过重用现有类的属性和方法来创建新类的机制。子类继承父类的特性，可以使用父类中的方法和属性，同时可以在子类中扩展或修改这些方法和属性。继承实现了代码的重用，提高了代码的可维护性。Java中通过关键字<code>extends</code>来实现继承关系。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>多态（Polymorphism）：</strong></p>
<ul class="lvl-2">
<li class="lvl-6">多态是指同一个操作作用于不同的对象可以有不同的行为。多态提高了代码的灵活性和可扩展性。Java中有两种类型的多态：编译时多态（静态多态）和运行时多态（动态多态）。运行时多态是通过方法的重写（Override）和接口来实现的。编译时多态是通过方法的重载（Overload）来实现的。多态是面向对象编程中一个非常重要的概念，它使得程序更容易扩展和维护。</li>
</ul>
</li>
</ol>
<p><a href="https://www.cnblogs.com/hai-ping/articles/2807750.html">什么是多态?为什么用多态?有什么好处?多态在什么地方用？ - 技术_菜鸟 - 博客园 (cnblogs.com)</a></p>
<h2 id="2-4-接口和抽象类">2.4 接口和抽象类</h2>
<p><strong>共同点</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>都不能被实例化。</p>
</li>
<li class="lvl-2">
<p>都可以包含抽象方法。</p>
</li>
<li class="lvl-2">
<p>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</p>
</li>
</ul>
<p><strong>区别</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</p>
</li>
<li class="lvl-2">
<p>一个类只能继承一个类，但是可以实现多个接口。</p>
</li>
<li class="lvl-2">
<p>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类可以有抽象方法和普通方法，但抽象方法不能有body</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WoWo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/Doreamonx/article/details/125673494">抽象类和接口的区别（通俗易理解）-CSDN博客</a></p>
<h2 id="2-5-深拷贝和浅拷贝">2.5 深拷贝和浅拷贝</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象<mark>共用同一个内部对象</mark>。</p>
</li>
<li class="lvl-2">
<p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
</li>
<li class="lvl-2">
<p>引用拷贝：两个不同的引用指向同一个对象。<br>
<img src="https://cdn.jsdelivr.net/gh/destiny0118/picgo/pic2023/202312122359896.png" alt="image.png"></p>
</li>
</ul>
<h2 id="2-6-Object类">2.6 Object类</h2>
<p>==和equals</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于基本数据类型来说，<code>==</code> 比较的是值。</p>
</li>
<li class="lvl-2">
<p>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-7-String">2.7 String</h2>
<h3 id="2-7-1-String、StringBuffer-线程完全-、StringBuilder-非线程安全">2.7.1 String、StringBuffer(线程完全)、StringBuilder(非线程安全)</h3>
<blockquote>
<p>源码阅读</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可变性</strong><br>
<code>String</code>是不可变的，<code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<p><strong>线程安全性</strong><br>
<code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全</strong>的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是<strong>非线程安全</strong>的。</p>
<p><strong>性能</strong><br>
每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li class="lvl-3">
<p>操作少量的数据: 适用 <code>String</code></p>
</li>
<li class="lvl-3">
<p>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></p>
</li>
<li class="lvl-3">
<p>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code>（线程安全）</p>
</li>
</ol>
<h3 id="2-7-2-String不可改变">2.7.2 String不可改变</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li class="lvl-4">
<p>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法</p>
</li>
<li class="lvl-3">
<p><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</p>
</li>
</ol>
</blockquote>
<h3 id="2-7-3-字符串拼接-StringBuilder">2.7.3 字符串拼接(+ StringBuilder)</h3>
<p><a href="https://juejin.cn/post/7182872058743750715">还在无脑用 StringBuilder？来重温一下字符串拼接吧 - 掘金 (juejin.cn)</a></p>
<h3 id="2-7-4-字符串常量池">2.7.4 字符串常量池</h3>
<p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag"># 基础</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/12/10/Java/Java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/" rel="prev" title="">
                  <i class="fa fa-chevron-left"></i> 
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/12/14/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/bug/" rel="next" title="">
                   <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Destiny</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
